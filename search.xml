<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>4 激活函数</title>
      <link href="/Deep-Learning/DL_04_activation_func.html"/>
      <url>/Deep-Learning/DL_04_activation_func.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1">  <p><a href="https://teeyohuang.github.io/Deep-Learning/DL_00_introduction.html">深度学习系列博文目录一览</a><br>————————————————</p><h1 id="4-激活函数"><a href="#4-激活函数" class="headerlink" title="4 激活函数"></a>4 激活函数</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p>激活函数也就是一些<b>非线性单元</b>，如果不用激活函数，每一层输出都是上层输入的线性函数，无论神经网络有多少层，输出都是输入的线性组合。如果使用激活函数的话，<b>激活函数给神经元引入了非线性因素，使得神经网络可以任意逼近任何非线性函数，这样神经网络就可以应用到众多的非线性模型中</b>。 </p><p>对于激活函数的使用，可以追溯到多层感知机解决异或(XOR)问题。</p><p>参考资料：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/25110450">知乎</a></li></ol><h2 id="4-1-sigmoid"><a href="#4-1-sigmoid" class="headerlink" title="4.1 sigmoid"></a>4.1 sigmoid</h2><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/4_1.webp" width="90%">  </p><p><b>sigmoid作激活函数的优点</b>:</p><ul><li><p>梯度计算较为方便  </p><p>  <img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/4_1_1.webp" width="90%">  </p></li><li><p>能够控制数值的幅度</p><p>  （即能压缩数据，在深层网络中可以保持数据幅度不会出现大的变化，保证数据幅度不会有问题）  </p></li></ul><p><b>sigmoid缺点</b>：</p><ul><li><p><b>容易出现梯度消失（gradient  vanishing）的现象</b>：<br>  当激活函数的输入值接近饱和区（两边)时，变化太缓慢，导数接近0；</p><p>  根据反向传播的数学依据是微积分求导的链式法则，当前导数需要之前各层导数的乘积，几个比较小的数相乘，导数结果很接近0，从而无法完成深层网络的训练。</p></li><li><p><b>Sigmoid的输出不是0均值（zero-centered）的</b>：<br>  <b><font color="red">输出值恒大于0，这会导致模型训练的收敛速度变慢</font></b>。比如上一级 经过 sigmoid之后，输出的一定是个正数x，那么希望更新这一级的参数的时候，wx+b，w的梯度是x，但是x恒为正，那么我这一级的w（w是个向量，里面会有很多分量）的所有分量都只能往正向移动，不能各个分量朝不同的方向移动，所以收敛速度变慢。 </p></li><li><p><b>幂运算相对来讲比较耗时。</b>  </p></li></ul><h2 id="4-2-tanh"><a href="#4-2-tanh" class="headerlink" title="4.2 tanh"></a>4.2 tanh</h2><p>tanh读作 Hyperbolic Tangent  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/4_2.webp" width="90%">  </p><p>它的输出是0均值的了，解决了上面sigmoid的（2问题），但是梯度消失 和 幂运算费时的问题依然存在。</p><h2 id="4-3-ReLU"><a href="#4-3-ReLU" class="headerlink" title="4.3 ReLU"></a>4.3 ReLU</h2><p>ReLU（Rectified Linear Unit）：整流线性单元</p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/4_3.webp" width="90%">  </p><p>ReLU函数其实就是一个取最大值函数，注意这并不是全区间可导的(0点不连续)，但是我们可以取sub-gradient，如上图所示。ReLU虽然简单，但却是近几年的重要成果，有以下几大优点：  </p><ul><li>解决了gradient vanishing问题 (在正区间)</li><li>计算速度非常快，只需要判断输入是否大于0</li><li>收敛速度远快于sigmoid和tanh</li></ul><p>ReLU也有几个需要特别注意的问题：</p><ul><li><p>ReLU的输出不是zero-centered  </p></li><li><p>Dead ReLU Problem<br>  <b><font color="red">指的是某些神经元可能永远不会被激活，导致相应的参数永远不能被更新</font></b>。有两个主要原因可能导致这种情况产生:<br>   (1) 非常不幸的参数初始化，这种情况比较少见 ；  </p><p>  (2) <b>learning rate太高导致在训练过程中<font color="red"> 参数更新太大</font></b>，使得<b>输入发生巨大变化</b>后越过0界，则前向传播为0，相当于这个单元被关闭了，反向传播的时候也为0 ，这个关掉的单元就跳不出来了。解决方法是<b>可以采用Xavier初始化方法，以及避免将learning rate设置太大或使用adagrad等自动调节learning rate的算法</b>。</p></li></ul><p>尽管存在这两个问题，ReLU目前仍是最常用的activation function，在搭建人工神经网络的时候推荐优先尝试！</p><h2 id="4-4-Leaky-ReLU"><a href="#4-4-Leaky-ReLU" class="headerlink" title="4.4 Leaky ReLU"></a>4.4 Leaky ReLU</h2><p>中文称作：渗漏整流线性单元  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/4_4.webp" width="90%"> </p><p>为了解决Dead ReLU Problem，提出了将ReLU的前半段设为0.01x而非0. </p><h2 id="4-5-ELU"><a href="#4-5-ELU" class="headerlink" title="4.5 ELU"></a>4.5 ELU</h2><p>ELU (Exponential Linear Units)：指数化线性单元</p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/4_5.webp" width="90%">  </p><p>ELU也是为解决ReLU存在的问题而提出，显然，ELU有ReLU的基本所有优点，以及：</p><p>（1）不会有Dead ReLU问题</p><p>（2）输出的均值接近0，zero-centered</p><p>它的一个小问题在于计算量稍大。类似于Leaky ReLU，理论上虽然好于ReLU，但在实际使用中目前并没有好的证据ELU总是优于ReLU。</p><h2 id="4-6-PReLU"><a href="#4-6-PReLU" class="headerlink" title="4.6 PReLU"></a>4.6 PReLU</h2><p>PReLU ( Parameterized ReLU） 参数整流线性单元</p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/4_6.webp" width="40%"></p><p>从形式上看，很像Leaky ReLU，但是区别在于将 PReLU 输入为负半轴部分映射为 <b>一个可学习参数 α </b>和输入的乘积; Leaky ReLU 而负半轴的参数是一个固定值。</p><p>.</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5 随机失活</title>
      <link href="/Deep-Learning/DL_05_dropout.html"/>
      <url>/Deep-Learning/DL_05_dropout.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1">  <p><a href="https://teeyohuang.github.io/Deep-Learning/DL_00_introduction.html">深度学习系列博文目录一览</a><br>————————————————</p><h1 id="5-随机失活"><a href="#5-随机失活" class="headerlink" title="5 随机失活"></a>5 随机失活</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="5-1-模型平均"><a href="#5-1-模型平均" class="headerlink" title="5.1 模型平均"></a>5.1 模型平均</h2><p>如果对传统机器学习有所了解的话，会知道有一种称之为集成学习的方法。<br>而神经网络中的<b>随机失活-dropout</b>其实就是借鉴了集成学习的思想，更具体地，是<b>集成学习中的bagging</b>方法，<b>即模型平均思想</b>的一种运用。  </p><p>因为模型平均要对训练集有放回的采样，得到多个不同的训练集，再训练多个不同的模型，<br>在测试阶段由多个不同的模型投票表决或者平均 来做出最终预测。<br>但是对于深度神经网络而言，<b>训练多个不同的模型 可能不切实际，会耗费大量时间和计算力。</b></p><h2 id="5-2-dropout作用关于模型平均的解释"><a href="#5-2-dropout作用关于模型平均的解释" class="headerlink" title="5.2 dropout作用关于模型平均的解释"></a>5.2 dropout作用关于模型平均的解释</h2><p>dropout 对<b>神经元随机失活</b>，也就是说<b><font color="red">前传的过程中可能这个神经元以及它后面的路径并不会被使用，相当于前传的路径只是整个大神经网络的一个子网络。</font></b>&lt;/font&gt;<br>所以训练的时候，相当于是在并行训练很多个子网络（模型）；<br>预测的时候，随机失活不产生作用，这样使用 的就是整个大网络模型，得到的结果相当于是综合考虑子网络得到的平均结果。<br>这样就相当于实现了bagging训练。</p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/5_1.webp" width="70%">   </p><p>Dropout训练与Bagging训练的一些区别。</p><ul><li>①<br> 在Bagging的情况下，所有模型都是独立；<br> 在Dropout的情况下，所有模型共享参数，其中每个模型继承父神经网络参数的不同子集。其中每个参数共享使得在有限可用的内存下表示指数级数量的模型变得可能。</li></ul><ul><li><p>②<br> 在Bagging的情况下，每一个模型在其相应训练集上训练到收敛。</p><p> 在Dropout的情况下，通常大部分模型都没有显式地被训练，因为通常父神经网络会很大，以致于到宇宙毁灭都不可能采样完所有的子网络。取而代之的是，在单个步骤中我们训练一小部分的子网络，参数共享会使得剩余的子网络也能有好的参数设定。</p></li></ul><p>这些是仅有的区别。除了这些，Dropout与Bagging算法一样。</p><p>每一个随机失活的单元都可以设置一个失活概率P，是超参数，控制前向传播的时候，dropout是否发生作用。</p><h2 id="5-2-dropout作用关于正则化的解释"><a href="#5-2-dropout作用关于正则化的解释" class="headerlink" title="5.2 dropout作用关于正则化的解释"></a>5.2 dropout作用关于正则化的解释</h2><p>在后续的研究中，研究者发现dropout可能不是Hinton认为的那样是类似于bagging训练，也就是说我们上面的解释可能只是Hinton当时的一种初级解释。现在学界普遍认为，dropout是引入了噪音，相当于对网络引入了正则项。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2 卷积与池化</title>
      <link href="/Deep-Learning/DL_02_convolution_and_pool_layer.html"/>
      <url>/Deep-Learning/DL_02_convolution_and_pool_layer.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1">  <p><a href="https://teeyohuang.github.io/Deep-Learning/DL_00_introduction.html">深度学习系列博文目录一览</a><br>————————————————</p><h1 id="2-卷积与池化"><a href="#2-卷积与池化" class="headerlink" title="2 卷积与池化"></a>2 卷积与池化</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p>这里暂时不介绍卷积操作具体是如何进行的，关于这点，很多文章都有介绍。</p><p>本文主要介绍一下 <b>为何会广泛使用卷积操作</b>？</p><p>参考资料：</p><ol><li><p>《Deep Learning》</p></li><li><p><a href="https://mooc.study.163.com/learn/2001281004?tid=2001392030#/learn/content?type=detail&amp;id=2001728690">deeplearning.ai</a></p></li></ol><p>卷积运算 主要通过三个重要的思想来帮助改进机器学习系统：</p><ul><li><p>稀疏交互 sparse interactions</p></li><li><p>参数共享 parameter sharing</p></li><li><p>等变表示 equivariant representations</p></li></ul><h2 id="2-1-稀疏交互"><a href="#2-1-稀疏交互" class="headerlink" title="2.1 稀疏交互"></a>2.1 稀疏交互</h2><p>卷积网络的<b>稀疏交互 - sparse interactions</b>（也叫稀疏连接 或者 稀疏权重），是通过使<b>卷积核的大小远小于输入的大小</b>来达到的。这就区别于全连接层的 矩阵相乘运算，</p><p><b><font color="red">卷积核的话就只接受有限个输入，使得参数量减小。</font></b>&lt;/font&gt;比如3x3大小的卷积核，就只接受9个像素点上的输入。这块儿大小有个更专业的术语，叫做 <b>感受野（receptive field）</b>，或者<b>FOV（field of view）.</b>但是这样说明<b>卷积核主要是在学习局部相关性。</b></p><p>CNN中的卷积操作在对图像进行处理时，主要是为了获得图片局部特征，在计算机视觉里，我们将这样的操作叫做滤波，都是为了获得局部领域的输出。常用的卷积操作本质上就是加权平均，这样的线性运算是获取局部特征最简单的操作，利用BP算法也显得特别直接。  </p><p>CNN同样可以处理时间序列和文本数据，因为CNN利用的就是数据的局部相关性，语音和文本具备局部相关性。</p><h2 id="2-2-参数共享"><a href="#2-2-参数共享" class="headerlink" title="2.2 参数共享"></a>2.2 参数共享</h2><p>参数共享 - parameter sharing ，是指 在一个模型的多个函数中使用相同的参数。卷积网络中，一般情况下一个卷积核会作用在输入的每一个位置，这种参数共享保证了我们只需要学习一个参数集合，而不是对每一个输入位置都需要学习一个单独的参数。</p><p>通俗来讲，就是我们在运用卷积操作时，通常情况（因为也有一些特殊情况）下，是用一个卷积核 从左往右、从上到下  按照步长stride，去遍历完特征图的所有位置。</p><h2 id="2-3-等变表示"><a href="#2-3-等变表示" class="headerlink" title="2.3 等变表示"></a>2.3 等变表示</h2><p>参数共享使得神经网络层对<b>平移</b>具有等变性质。</p><p><b>所谓等变，即对其输入施加的变换也会同样反应在输出上。<br>即如果对输入进行轻微的平移，卷积运算得到的结果在忽略位置的时候，是一样的。</b><br>比如若图像上的一个特征本来位于图像左侧，现在将该区域平移到右侧，卷积网络依然能够检测到该特征，只不过探测到的位置会发生变化而已。更具体一点，如果一个图像上有一只小狗位于左侧，现在将小狗的区域平移到图像右侧去，卷积网络依然能够检测到这个区域的特征，并且判定该特征是一只小狗。</p><p>但是卷积对其他的一些变换并不是天然等变的，例如对于图像的放缩或者旋转变换，需要其他的一些机制来处理这些变换。</p><h2 id="2-4-常规卷积与其他卷积的对比"><a href="#2-4-常规卷积与其他卷积的对比" class="headerlink" title="2.4 常规卷积与其他卷积的对比"></a>2.4 常规卷积与其他卷积的对比</h2><h3 id="①常规卷积"><a href="#①常规卷积" class="headerlink" title="①常规卷积"></a>①常规卷积</h3><p>可以看作只有一个核，且被应用到各个位置。<br>相当于每个位置对应的卷积核的参数都是一样的，这就是前面说到的参数共享。  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/2_1.webp" width="70%">  </p><p><i>图中S为卷积核；x为特征值；每个卷积核接受2个位置的输入，</i></p><p>但是参数a，b一直在重复使用，相当于是同一个卷积核在从左往右遍历&lt;/i&gt;  </p><h3 id="②局部连接"><a href="#②局部连接" class="headerlink" title="②局部连接"></a>②局部连接</h3><p><i><font color="red">注意：有些地方提及的局部连接，是指的本篇博文中的第1点，稀疏交互，<br>本篇博文的名称规则是依据DeepLearning这本花书来的，这里讲的局部连接是指的非共享卷积。</font></i></p><p>局部连接有时候也称为非共享卷积，因为它和具有一个小核的离散卷积运算很像，<b>但并不横跨位置来共享参数，</b>也就是说，并不是一个卷积核 作用于所有的输入位置，而是<b>不同的输入位置所对应的卷积核 拥有不同的参数。</b>  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/2_2.webp" width="70%">  </p><p><i>图中S为卷积核；x为特征值；每个卷积核都有各自的参数。</i>  </p><h3 id="③平铺卷积"><a href="#③平铺卷积" class="headerlink" title="③平铺卷积"></a>③平铺卷积</h3><p>是介于局部卷积 和 标准卷积之间，与局部卷积相同的地方在于，<b>相邻的单元具有不同的参数</b>，与其区别在于， 会有 <b>t</b> 个不同的卷积核循环使用，也就是说<b>相隔为 t 的卷积核，就会共享参数。</b>    </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/2_3.webp" width="70%">   </p><p><i>图中S为卷积核；x为特征值；相邻的卷积核都有各自的参数；</i></p><p>但每隔 t 个（图中 t=2）卷积核，参数就会重复使用。&lt;/i&gt;  </p><h3 id="④全连接层"><a href="#④全连接层" class="headerlink" title="④全连接层"></a>④全连接层</h3><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/2_4.webp" width="70%">  </p><p><i>图中S为卷积核；x为特征值；每条边都有各自的参数，但是它的感受野是全部的x特征，并不是局部的连接。</i></p><h2 id="2-5-池化操作"><a href="#2-5-池化操作" class="headerlink" title="2.5 池化操作"></a>2.5 池化操作</h2><p>池化函数使用<b>某一位置的相邻输出的总体统计特征</b>来代替网络在该位置的输出。比如最大池化、平均池化等等。</p><p>不管采用什么样的池化函数，当输入作出少量平移时，池化能够帮助输入的表示近似不变（invariant）。</p><p><b>对于平移的不变性</b>是指当我们对输入进行<b>少量平移</b>时，经过池化函数后的大多数输出并不会发生改变。</p><p>池化对于不同大小的输入具有重要作用。例如我们想对不同大小的图像进行分类时，分类层的输入必须是固定的大小，而这通常通过调整池化区域的偏置大小来实现，这样分类层总是能接收到相同数量的统计特征。以便于后面的全连接层进行处理</p><h2 id="2-6-卷积与池化作为一种无限强的先验"><a href="#2-6-卷积与池化作为一种无限强的先验" class="headerlink" title="2.6 卷积与池化作为一种无限强的先验"></a>2.6 卷积与池化作为一种无限强的先验</h2><p>可以把卷积的使用当作是对网络中一层的参数引入了一个<b>无限强的先验概率分布</b>。</p><p><b>这个先验说明了该层应该学得的函数只包含局部连接关系并且对平移具有等变性。<br>类似的，使用池化 也是一个无限强的先验：每一个单元都具有对少量平移的不变性</b>。</p><p>.</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1 权重初始化</title>
      <link href="/Deep-Learning/DL_01_weight_init.html"/>
      <url>/Deep-Learning/DL_01_weight_init.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1"> <p><a href="https://teeyohuang.github.io/Deep-Learning/DL_00_introduction.html">深度学习系列博文目录一览</a><br>———————————————— </p><h1 id="1-权重初始化"><a href="#1-权重初始化" class="headerlink" title="1 权重初始化"></a>1 权重初始化</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="1-1-为什么需要权重初始化"><a href="#1-1-为什么需要权重初始化" class="headerlink" title="1.1 为什么需要权重初始化"></a>1.1 为什么需要权重初始化</h2><ul><li><p>① 为了使神经网络在<b>合理的时间内收敛</b>.</p></li><li><p>② 为了尽量避免在深度神经网络的正向（前向）传播过程中层激活函数的<b>输出梯度出现爆炸或消失</b>。  </p></li></ul><h2 id="1-2-如何进行初始化"><a href="#1-2-如何进行初始化" class="headerlink" title="1.2 如何进行初始化"></a>1.2 如何进行初始化</h2><p>① <b>如果将每个隐藏单元的参数都初始化为0.</b></p><p>那么在正向传播时每个隐藏单元将<b>对于相同的输入会计算出相同的值</b>，并传递至输出层。在<b>反向传播中，每个隐藏单元的参数梯度值相等</b>。因此，这些参数在使用基于梯度的优化算法迭代后值依然相等。这样所有隐层的单元都是对称的了，很难学到什么有效的信息，之后的迭代也是如此。</p><p><b><font color="red">所以权重初始化不能将权重参数全部初始化为0，应打破这种对称性。</font></b></p><p>② <b>如果将参数都初始化为0周围极小的值</b></p><p><b>也不好</b>，比如 如果用 sigmoid 做激活函数，它在0周围是近似线性的，如果我们的参数都初始化为0附近，那么可能数据经过神经元之后，输出值也在0附近，这样<b>大部分都落在激活函数线性区，那么激活函数引入非线性的作用将被削减。</b></p><p>③ <b>如果参数都初始化为较大的值，很显然容易使得输出落入饱和区。</b></p><p><b><font color="red">所以合理的初始化时比较重要的，一般采用随机的初始化。</font></b></p><h2 id="1-3-常见的几种初始化方式"><a href="#1-3-常见的几种初始化方式" class="headerlink" title="1.3 常见的几种初始化方式"></a>1.3 常见的几种初始化方式</h2><p>① <b>均匀分布初始化：</b><br>将参数初始化为 <b><font color="red">均匀分布U(a,b) </font></b>上的随机值，pytorch的实现方案：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.uniform_(tensor, a=<span class="number">0</span>, b=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>② <b>高斯初始化：</b><br>将参数初始化为 <b><font color="red">高斯分布N(0,1)</font></b> 上的随机值，pytorch的实现方案：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.normal_(tensor, mean=<span class="number">0</span>, std=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>③ <b>常数初始化：</b><br>将参数初始化为一个 <b><font color="red">固定的常数val</font></b>, pytorch实现方案为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.constant_(tensor, val)</span><br></pre></td></tr></table></figure><p>上面三种初始化方法其实并不是十分理想的初始化方案，因为如果网络层数过深的话，依然会导致 <b>梯度爆炸</b> 或者 <b>梯度弥散</b>的 情况出现，<br>一般在使用中，可能就是神经网络中的某一两层可能会用到上述初始化方案，比如自己写的某几层,并不建议对所有的参数都使用上述初始化方案。<b>对于一些较为普及的模型，比如VGG、ResNet等，往往会加载官方提供的预训练模型的参数值，对大网络进行参数初始化</b>。 </p><h2 id="1-4-Xavier-初始化方案"><a href="#1-4-Xavier-初始化方案" class="headerlink" title="1.4 Xavier 初始化方案"></a>1.4 Xavier 初始化方案</h2><p>Xavier 初始化的基本思想是，若<b><font color="red">对于一层网络的输入和输出的方差尽量不变</font>，这样就可以避免输出趋向于0，从而避免梯度弥散情况。</b>   </p><p>参考资料：<br><a href="https://prateekvjoshi.com/2016/03/29/understanding-xavier-initialization-in-deep-neural-networks/">链接1</a><br><a href="http://proceedings.mlr.press/v9/glorot10a/glorot10a.pdf">链接2</a><br><a href="https://zhuanlan.zhihu.com/p/40175178">链接3</a>  </p><p>对于 $y=wx$ , 根据假设有：</p><script type="math/tex; mode=display">Var(Y) = Var(w_iX) = Var(w_i)*Var(X) + E^2(X)Var(w_i) + E^2(w_i)Var(X);</script><p>当 $X, w_i$ 都符合均值为 0 的正态分布时，其期望 $E(X), E(w_i)$ 均为0, 则上式可以简化为: </p><script type="math/tex; mode=display">Var(Y) = Var(w_i)*Var(X)</script><p>若该层共有$n_i$个神经元，则有：</p><script type="math/tex; mode=display">Var(Y) = n_i * Vaar(w_i) * Var(X)</script><p>要使得$Var(Y) = Var(X)$， 则需要 $n_i * Var(W_i) = 1$, 则 $ Var(w_i) = 1/n_i$;</p><p>同理，当反向传播时, $Var(w_i) = 1/n_{i+1}$  </p><p>因此，综合正向和反向传播考虑，最终取 $Var(w_i) = 1 / \frac{(n_i+n_{i+1})}{2} = 2/(n_i+n_{i+1})$ </p><p>如果使用<b><font color="red">均匀分布U(a,b) </font></b>为基础进行初始化，则：</p><script type="math/tex; mode=display">\begin{aligned} E &= (a+b)/2 = 0  \\\\Var &= (b-a)^2/12 = 2/(n_i+n_{i+1}) \end{aligned}</script><p>解得： $ a= -b = -\sqrt{6/(n_i+n_{i+1})} $  </p><p>即$w_i$ 初始化为 $ U(-\sqrt{\frac{6}{(n_i+n_{i+1})}}, \sqrt{\frac{6}{(n_i+n_{i+1})}}) $  </p><p><b>pytorch的实现方案①, 以均匀分布为基础</b>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.xavier_uniform_(tensor, gain=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>将参数初始化为均匀分布 $U(-\alpha, \alpha) $上的随机值，其中 $\alpha$ 取值为：$ \alpha = gain * \sqrt{\frac{6}{(fan_{in} + fan_{out})}}$  </p><ul><li>fan_in 指输入端神经元的个数， fan_out 指输出端神经元的个数，pytorch它会自己根据网络计算。</li><li>gain 是一个增益， 默认为1；</li></ul><p><b>pytorch的实现方案②, 以高斯分布为基础</b>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.xavier_normal_(tensor, gain=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>将参数初始化为高斯分布 $N(0, std^2)$上的随机值，而 std 的取值是：$std = gain * \sqrt{\frac{2}{(fan_{in} + fan_{out})}}$ </p><h2 id="1-5-Kaiming初始化"><a href="#1-5-Kaiming初始化" class="headerlink" title="1.5 Kaiming初始化"></a>1.5 Kaiming初始化</h2><p>Kaiming初始化基本思想是，当使用<code>ReLU</code>做为激活函数时，<code>Xavier</code>的效果不好。<br>原因在于：<b>当ReLU的输入小于0时，其输出为0，影响了输出的分布模式。也就是激活函数输出均值不为0，我们上面的推导中是有假设E(X)=0的。</b>  </p><p>因此Kaiming He初始化，在Xavier的基础上，<b>假设每层网络有一半的神经元被关闭，于是其分布的方差也会变小。所以提出一个新的假设，那就是前向传播中，如果采用Xiaver，方差会缩小为原来一半</b>。那么为了修正这个缩减，就使得参数初始化的范围比原来扩大一倍。  </p><p><b>pytorch的实现方案①, 以均匀分布为基础</b>：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.kaiming_uniform_(tensor, a=<span class="number">0</span>, mode=<span class="string">&#x27;fan_in&#x27;</span>, nonlinearity=<span class="string">&#x27;leaky_relu&#x27;</span>)</span><br></pre></td></tr></table></figure><p>将参数初始化为均匀分布 $U(-bound, bound)$上的随机值，其中 bound 取值为</p><p> $bound = \sqrt{\frac{6}{(1+\alpha^2)*fan_{in} }}$</p><ul><li>$\alpha$ : 该层后面一层的激活函数中负的斜率 (0 for ReLU by default)</li><li>使用 mode = fan_in 保持 weights 的方差在<b>前向传播</b>中不变；</li><li>使用 mode = fan_out 保持weights 的方差在<b>反向传播</b>中不变。  </li></ul><p><b>pytorch的实现方案②, 以高斯分布为基础</b>：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.kaiming_normal_(tensor, a=<span class="number">0</span>, mode=<span class="string">&#x27;fan_in&#x27;</span>, nonlinearity=<span class="string">&#x27;leaky_relu&#x27;</span>)</span><br></pre></td></tr></table></figure><p>将参数初始化为高斯分布 $N(0, std^2)$上的随机值，而std的取值是：$std = \sqrt{\frac{2}{(1+\alpha^2)*fan_{in} }}$  </p><h2 id="1-6-pytorch常见的-权重初始化-操作方法"><a href="#1-6-pytorch常见的-权重初始化-操作方法" class="headerlink" title="1.6 pytorch常见的 权重初始化 操作方法"></a>1.6 pytorch常见的 权重初始化 操作方法</h2><ul><li>方案一：直接对某层的data进行赋值</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.conv1.weight.data.normal_(<span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">self.conv1.bias.data.zero_()</span><br></pre></td></tr></table></figure><ul><li>方案二：调用nn初始化模块：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.normal_(self.conv1.weight, std=<span class="number">0.01</span>)</span><br><span class="line">torch.nn.init.constant_(self.conv1.bias, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>可搭配for循环使用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> self.children():</span><br><span class="line">    torch.nn.init.normal_(layer.weight, std=<span class="number">0.01</span>)</span><br><span class="line">    torch.nn.init.constant_(layer.bias, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>方案三： 定义一个自己的小函数</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_weight_init</span>(<span class="params">m</span>):</span><br><span class="line">    classname = m.__class__.__name__</span><br><span class="line">    <span class="keyword">if</span> classname.find(<span class="string">&#x27;Conv&#x27;</span>) != -<span class="number">1</span>:</span><br><span class="line">        torch.nn.init.xavier_(m.weight)</span><br><span class="line">        torch.nn.init.xavier_(m.bias)</span><br><span class="line">    <span class="keyword">if</span> classname.find(<span class="string">&#x27;Linear&#x27;</span>) != -<span class="number">1</span>:</span><br><span class="line">        torch.nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line">        torch.nn.init.constant_(m.bias, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#或者不读取下划线，直接看是不是某个类,这种方法相对来说更安全一些</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_weights_init</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, torch.nn.Conv2d):</span><br><span class="line">        torch.nn.xavier_(m.weight)</span><br><span class="line">        torch.nn.xavier_(m.bias)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, torch.nn.Linear):</span><br><span class="line">        torch.nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line">        torch.nn.init.constant_(m.bias, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 然后对某个Net应用：</span></span><br><span class="line">Net.apply(_weight_init)</span><br></pre></td></tr></table></figure><p><b><font color="red">以上三个均为示例，具体使用情况请依据自己的网络和具体的代码，请勿生搬硬套。</font></b>&lt;/font&gt;<br>.</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度学习导论</title>
      <link href="/Deep-Learning/DL_00_introduction.html"/>
      <url>/Deep-Learning/DL_00_introduction.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">    </p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="深度学习导论"><a href="#深度学习导论" class="headerlink" title="深度学习导论"></a>深度学习导论</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p>深度学习算是机器学习的一个子领域，其和机器学习的关系如下图所示:  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/AI_ML_DL.webp" width="40%">   </p><p>本系列文章简要介绍深度学习的一些基础性、常见性知识，内容源于我早期所写<a href="https://blog.csdn.net/Teeyohuang/article/details/104120242">旧博客</a>，或许其中有所纰漏或者过时之处，权当参考而已。</p><h2 id="1-权重初始化"><a href="#1-权重初始化" class="headerlink" title="1 权重初始化"></a><a href="https://teeyohuang.github.io/Deep-Learning/DL_01_weight_init.html">1 权重初始化</a></h2><h2 id="2-卷积网络与池化操作"><a href="#2-卷积网络与池化操作" class="headerlink" title="2 卷积网络与池化操作"></a><a href="https://teeyohuang.github.io/Deep-Learning/DS_02_convolution_and_pool_layer.html">2 卷积网络与池化操作</a></h2><h2 id="3-规范化操作"><a href="#3-规范化操作" class="headerlink" title="3 规范化操作"></a><a href="https://teeyohuang.github.io/Deep-Learning/DS_22_array_exercises.html">3 规范化操作</a></h2><h2 id="4-激活操作"><a href="#4-激活操作" class="headerlink" title="4 激活操作"></a><a href="https://teeyohuang.github.io/Deep-Learning/DL_04_activation_func.html">4 激活操作</a></h2><h2 id="5-随机失活"><a href="#5-随机失活" class="headerlink" title="5 随机失活"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_23_array_double_pointer_exercises.html">5 随机失活</a></h2><h2 id="6-损失函数"><a href="#6-损失函数" class="headerlink" title="6 损失函数"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_23_array_double_pointer_exercises.html">6 损失函数</a></h2><h2 id="7-优化方法"><a href="#7-优化方法" class="headerlink" title="7 优化方法"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_23_array_double_pointer_exercises.html">7 优化方法</a></h2>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8-1 图</title>
      <link href="/Data-Structure/DS_81_graph.html"/>
      <url>/Data-Structure/DS_81_graph.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1"> <h1 id="8-1-图"><a href="#8-1-图" class="headerlink" title="8-1 图"></a>8-1 图</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="8-1-1-图的定义"><a href="#8-1-1-图的定义" class="headerlink" title="8.1.1 图的定义"></a>8.1.1 图的定义</h2><p>前面已经讲了 “一对一” 的线性存储结构、”一对多”的树结构 ， 而图结构（Graph）是一种  “<strong>多对多</strong>“ 的结构；  </p><p>图G由两个集合 V 和 E 组成， 记为 <strong>G=(V, E)</strong> ，  其中:<br> <strong>V</strong> 是 <strong>顶点（Vertex）</strong> 的<b>有穷 非空 集合</b>，而顶点通常就是<b>数据结点</b>；<br> <strong>E</strong> 是指<b>边</b> <strong>（Edge）</strong> 的<b>有穷集合</b>， 边指的是顶点之间的<b>连接关系</b>。 </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/8_1_1.webp" width="50%"> </p><h2 id="8-1-2-图的分类"><a href="#8-1-2-图的分类" class="headerlink" title="8.1.2 图的分类"></a>8.1.2 图的分类</h2><p>图结构可细分两种表现类型，<strong>无向图</strong> （Undirected Graph）和 <strong>有向图</strong>（Directed Graph）。<br>若图G的<strong>边没有表示方向</strong>，则就称为无向图，这样的边用<strong>圆括号</strong>表示 <strong>（Vi, Vj）</strong> ；<br>如果图G中的<strong>每条边都是有方向</strong>的，就称为有向图，边用<strong>尖括号</strong>表示 <strong>&lt; Vi, Vj&gt;</strong> ， 表示从 Vi 指向 Vj。  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/8_1_2.webp" width="70%"> </p><div class="table-container"><table><thead><tr><th>术语</th><th>定义</th></tr></thead><tbody><tr><td><b>邻接点</b></td><td>对于无向图，每条边的两个端点互为邻接点；<br>对于有向图， 有向边的<strong>终点</strong>是 起点的 邻接点，<font color="red">反之不成立！</font><br> 比如 <strong>&lt; u, v&gt;</strong> 表示 u指向v， 所以<strong>v是u的邻接点， 但 u不是v的邻接点!</strong></td></tr><tr><td><b>弧头和弧尾</b></td><td><strong>有向边</strong>也被称为 <strong>弧</strong> ，无箭头一端即<b>“起点”</b>称”<strong>弧尾</strong>“，<br>有箭头一端, 即<b>“端点”</b>或”<strong>弧头</strong>“。</td></tr><tr><td><b>度</b></td><td>常用<b>D(V)</b>来表示，在无向图中，顶点的度 就是 以该顶点为端点的边的条数；<br>在有向图中，指向该顶点的弧的数目 称为 <b>入度ID(V)</b>，  从该顶点出发的 弧 的数目 称为 <b>出度OD(V)</b>。<br>有向图的顶点的度是二者之和 D(V) = ID(V) + OD(V).<br>重要结论： <strong>无论是有向图还是无向图，顶点数n、边数e、和度数之间有关系：所有顶点的度数之和  等于 边数的2倍</strong>。</td></tr><tr><td><b>路径和回路</b></td><td>从一个顶点到另一顶点途径的所有顶点组成的序列（包含这两个顶点），称为一条路径。<br>如果路径中第一个顶点和最后一个顶点相同，则此路径称为”<strong>回路</strong>“（或”<strong>环</strong>“）。<br>若路径 / 回路 中各顶点都不重复，此路径又被称为”简单路径” / “简单回路”</td></tr><tr><td><b>权和网</b></td><td>若图中的每条边（或弧）被赋予一个实数来表示一定的含义，这种与边（或弧）相匹配的实数被称为”权”，而带权的图通常称为网。</td></tr></tbody></table></div><h3 id="8-1-2-1-细分种类"><a href="#8-1-2-1-细分种类" class="headerlink" title="8.1.2.1 细分种类"></a>8.1.2.1 细分种类</h3><p>图又可分为完全图，连通图、稀疏图和稠密图；</p><div class="table-container"><table><thead><tr><th>名称</th><th>定义</th></tr></thead><tbody><tr><td><b>完全图</b></td><td>若图中各个顶点都与除自身外的其他顶点有关系，这样的无向图称为完全图。同时，满足此条件的有向图则称为有向完全图。<br><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/8_1_2_1_n.webp" width="80%"></td></tr><tr><td><b>稀疏图和稠密图</b></td><td>这两种图是相对存在的，即如果图中具有很少的边（或弧），此图就称为”稀疏图”；反之，则称此图为”稠密图”。<br>稀疏和稠密的判断条件是：e &lt; nlogn，其中 e 表示图中边（或弧）的数量，n 表示图中顶点的数量。如果式子成立，则为稀疏图；反之为稠密图。<br><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/8_1_2_2.webp" width="100%"></td></tr><tr><td><b>连通图</b></td><td>在无向图中，若每一对顶点 u和v之间都能找到一条<strong>路径</strong>，则此图称为 连通图；<br>若无向图不是连通图，但图中存储某个子图符合连通图的性质，则称该子图为连通分量。（这里的子图指的是图中”最大”的连通子图）<br>在有向图中，若每一对顶点u和v之间都存在 u到v 以及 从 v到u的<strong>路径</strong>，则成为强连通图。<br>若有向图本身不是<b>强</b>连通图，但其包含的最大连通子图具有强连通图的性质，则称该子图为强连通分量。<br><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/8_1_2_3.webp" width="100%"></td></tr><tr><td><b>加权图</b></td><td>图中的边带有权值：<br><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/8_1_2_4.webp" width="80%"></td></tr></tbody></table></div><h2 id="8-1-3-图的存储结构"><a href="#8-1-3-图的存储结构" class="headerlink" title="8.1.3 图的存储结构"></a>8.1.3 图的存储结构</h2><h3 id="8-1-3-1-邻接矩阵"><a href="#8-1-3-1-邻接矩阵" class="headerlink" title="8.1.3.1 邻接矩阵"></a>8.1.3.1 邻接矩阵</h3><p>图结构的元素之间虽然具有“多对多”的关系，但是同样可以采用<strong>顺序存储</strong>，即使用数组有效地存储图。  </p><p><b>集合V</b>中所有的顶点可以利用一个<b>一维</b>数组存储；<br>而<b>集合E</b>中所有的边可以用一个<b>二维数组</b>来存储，此二维数组就称为 <strong>邻接矩阵</strong>！<br>如下图所示, 点与点之间如果有边存在, 那矩阵中对应位置的值就为 1；反之为 0.  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/8_1_3_1.webp" width="80%"> |</p><p>设 $G=(V,E)$ 是有 n 个（n&gt;=1）顶点的 ==<strong>有向图</strong>== ，则G的邻接矩阵是具有如下性质的 n x n 矩阵： </p><script type="math/tex; mode=display">A[ i, j ] = \begin{cases} 1 & <Vi, Vj> \quad \in E \\0 & <Vi, Vj> \quad \notin E\end{cases}</script><p>设 $G=(V,E)$ 是有n个（n&gt;=1）顶点的 ==<strong>无向图</strong>==，则G的邻接矩阵是具有如下性质的 n x n 矩阵：  </p><script type="math/tex; mode=display">A[ i, j ] = A[j, i] =\begin{cases} 1 & (Vi, Vj) \quad \in E \\0 & (Vi, Vj) \quad \notin E\end{cases}</script><ul><li>对于无向图，邻接矩阵第 i 行（或第 i 列）的元素之和是 顶点 $V_i$ 的度；</li><li>对于有向图，邻接矩阵第 i 行 元素之和为 顶点Vi的<strong>出度</strong>， 邻接矩阵第 i 列 的 元素之和 为顶点 $V_i$ 的<strong>入度</strong>。<br>比如上图的有向图的邻接矩阵中，第3行的和为1：表示顶点3的出度为1；第3列的和为2：表示顶点3的入度为2.</li><li>对于带权图，也就是 <strong>网</strong> 来说， 只需要把上面的 等于 1 的情况改为 权重 $W_{ij}$， 把等于 0 的情况 改为 $ \infty $。  </li><li>容易得出，无向图的邻接矩阵是按矩阵主对角线对称的。</li></ul><h3 id="8-1-3-2-邻接表"><a href="#8-1-3-2-邻接表" class="headerlink" title="8.1.3.2 邻接表"></a>8.1.3.2 邻接表</h3><p>邻接表既适用于存储无向图，也适用于存储有向图。邻接表存储图的实现方式是，给图中的每个顶点独自建立一个链表，第 i 个单链表中的结点包含顶点 i 的所有邻接点。  </p><p>为了便于管理这些链表，通常会将所有链表的头结点存储到数组中（也可以用链表存储）。<br>也正因为各个链表的头结点存储的是各个顶点，因此各链表在存储邻接点数据时，仅需存储该邻接顶点位于数组中的位置下标即可，不用存储完整的顶点数据，降低了空间复杂度；同时知道点的下标，就能以O(1)的时间复杂度从数组中获得顶点数据。  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/8_1_3_2.webp" width="80%"> </p><p>假设该图是 G(n, m) 。这里 G 是图， n 是结点数， m 是图 G 中存在的边的总数 。<br>在无向图的情况下，链表的结点总数将为 <strong>2m</strong> （因为连接是双向的）；使用的总空间为 O(n + 2m)。<br>在有向图的情况下，使用的总空间为 O(n + m)。  </p><p><b><br>对于稀疏图，推荐使用邻接表，因为稀疏矩阵会浪费大量内存；<br>对于稠密图，可以使用邻接矩阵。</b></p><h2 id="8-1-4-图的遍历"><a href="#8-1-4-图的遍历" class="headerlink" title="8.1.4 图的遍历"></a>8.1.4 图的遍历</h2><p>图的遍历可以分为<b>深度优先遍历</b>和<b>广度优先遍历</b>，和树的深度优先遍历和广度优先遍历十分相似。</p><p>我在 BiliBili 上看到一个讲解视频，讲得十分详尽，所以这里直接引用该视频的链接，已获得原视频up主：<a href="https://space.bilibili.com/627875426">码农论坛</a> 的授权，同时原视频地址也备注在下方。</p><h3 id="8-1-4-1-图的深度优先遍历"><a href="#8-1-4-1-图的深度优先遍历" class="headerlink" title="8.1.4.1 图的深度优先遍历"></a>8.1.4.1 图的深度优先遍历</h3><p>原视频地址：<a href="https://www.bilibili.com/video/BV1JU4y1p7Ue?p=2">link</a></p><iframe src="https://player.bilibili.com/player.html?aid=672031208&bvid=BV1JU4y1p7Ue&cid=310040941&page=2&autoplay=0" scrolling="no" width="800px" height="500px" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>  <p>下面用一个例子演示深度优先遍历的 code，假设有图结构如下：</p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/8_1_4_1.webp" width="40%"> </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;上图中的graph用列表表示如下</span></span><br><span class="line"><span class="string">索引代表结点, </span></span><br><span class="line"><span class="string">列表中的子列表代表当前结点的邻接点&#x27;&#x27;&#x27;</span></span><br><span class="line">graph = [</span><br><span class="line">    [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>],</span><br><span class="line">    [<span class="number">2</span>],</span><br><span class="line">    [<span class="number">2</span>,<span class="number">7</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">6</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">4</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 深度优先遍历的code如下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="comment"># 终止条件：当前结点已经被访问过</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">in</span> visited:</span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将当前结点加入结果中</span></span><br><span class="line">    res.append(node)</span><br><span class="line">    <span class="comment"># 同时记录当前结点已经被访问的状态</span></span><br><span class="line">    visited[node] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历当前结点的邻接点</span></span><br><span class="line">    <span class="keyword">for</span> neighbour <span class="keyword">in</span> graph[node]:</span><br><span class="line">        <span class="comment"># 假设这里 graph[node] 存储的是 node 的邻接点</span></span><br><span class="line">        <span class="comment"># 具体的题目中这里的写法可能稍有不同</span></span><br><span class="line">        DFS(neighbour)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">visited = &#123;&#125; <span class="comment"># 记录哪些结点已经被访问的哈希表</span></span><br><span class="line">res = [] <span class="comment"># 存储遍历结果的list</span></span><br><span class="line">DFS(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实<b>图的深度优先遍历，和树的深度优先遍历中的【先序遍历】是很相似的</b>，他们的核心流程基本一致；用伪代码表示如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="comment"># step 1. 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> End_Condition:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step 2. 访问当前结点</span></span><br><span class="line">    visit(node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 3. 利用递归操作，访问当前结点的相关结点</span></span><br><span class="line">    DFS(node_relations)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><p>这里再贴上二叉树的先序遍历的code用于对照理解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 对每棵子树的结构，都先访问根结点的值</span></span><br><span class="line">    res.append(root.val)</span><br><span class="line">    <span class="comment"># 然后递归地分别处理左右子结点</span></span><br><span class="line">    preorder(root.left)</span><br><span class="line">    preorder(root.right)</span><br><span class="line"></span><br><span class="line">res =[]</span><br><span class="line">preorder(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th></th><th>二叉树先序遍历</th><th>图的深度优先遍历</th></tr></thead><tbody><tr><td>step 1</td><td>终止条件为node为空</td><td>当前结点已经被遍历</td></tr><tr><td>step 2</td><td>访问当前结点</td><td>访问当前结点</td></tr><tr><td>step 3</td><td>利用递归, 访问当前结点的子结点</td><td>利用递归，访问当前结点的邻接点</td></tr></tbody></table></div><p><b>需要注意的有几点</b></p><ul><li><p>树的遍历一定是从root结点开始，所以用同一种方法遍历得到的list是唯一确定的；<br>而图的遍历，起始位置不确定，通常可以从任何一个点开始遍历，所以即便用同一种方法，如果选取不同的起始点，得到的遍历结果的顺序也不一样；</p></li><li><p>上面的例子只是比较简单的情况，它是一个连通图；<br>还有非连通的情况，比如两棵不同的树就是一个非连通图，对于每一个连通分量的遍历，依然可以使用上面的code示范的方法，只不过对于不同的连通分量的切换，还需要额外处理，可以自己思考一下，此处不再赘述。</p></li></ul><h3 id="8-1-4-2-图的广度优先遍历"><a href="#8-1-4-2-图的广度优先遍历" class="headerlink" title="8.1.4.2 图的广度优先遍历"></a>8.1.4.2 图的广度优先遍历</h3><p>原视频地址：<a href="https://www.bilibili.com/video/BV1JU4y1p7Ue?p=1">link</a></p><iframe src="https://player.bilibili.com/player.html?aid=672031208&bvid=BV1JU4y1p7Ue&cid=310040937&page=1&autoplay=0" scrolling="no" width="800px" height="500px" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>  <p>下面用一个例子演示深度优先遍历的 code，假设有图结构如下：</p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/8_1_4_1.webp" width="40%"> </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>(<span class="params">graph, node</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(graph) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将初始结点先入队</span></span><br><span class="line">    q, res = [node], []</span><br><span class="line">    <span class="comment"># 凡是入队的结点, 就要标记为访问过</span></span><br><span class="line">    visited = &#123;node:<span class="literal">True</span>&#125;</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        layer = []</span><br><span class="line">        <span class="comment"># 这个 n 其实就是在求要遍历的那一层的宽度</span></span><br><span class="line">        n = <span class="built_in">len</span>(q)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            node = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 队列中弹出的元素直接放入该层的list中</span></span><br><span class="line">            layer.append(node)</span><br><span class="line">            <span class="comment"># 对该结点的邻接点进行入队操作</span></span><br><span class="line">            <span class="keyword">for</span> neighbour <span class="keyword">in</span> graph[node]: </span><br><span class="line">                <span class="comment"># 要判断邻接点是否已经被访问过</span></span><br><span class="line">                <span class="keyword">if</span> neighbour <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="comment"># 没被访问过的邻接点： 入队 + 标记状态</span></span><br><span class="line">                    q.append(neighbour)</span><br><span class="line">                    visited[neighbour] = <span class="literal">True</span></span><br><span class="line">        res.append(layer)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(BFS(graph, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(BFS(graph, <span class="number">9</span>))</span><br></pre></td></tr></table></figure><p>关于层次遍历，<b>其实就是看结点距离起始点的路径有几段</b>，<br>以起始点为9 为例：<br>第一层就是 [9]；<br>第二层就是距离9的路径为1段的 [4]<br>第三层就是距离9的路径为2段的 [1, 3, 8]<br>第四层就是距离9的路径为3段的 [0, 2, 7]<br>第五层就是距离9的路径为4段的 [5, 6]</p><p>图的知识点其实还有很多，但是作为基础的算法结构来讲，了解到图的遍历就基本可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7-2 树相关的题目</title>
      <link href="/Data-Structure/DS_72_tree_exercises.html"/>
      <url>/Data-Structure/DS_72_tree_exercises.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="7-2-树相关的题目"><a href="#7-2-树相关的题目" class="headerlink" title="7-2 树相关的题目"></a>7-2 树相关的题目</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p><span id="7.2.1"></span></p><h2 id="7-2-1-二叉树的遍历"><a href="#7-2-1-二叉树的遍历" class="headerlink" title="7.2.1 二叉树的遍历"></a>7.2.1 二叉树的遍历</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">LeetCode 144.二叉树的前序遍历</a></td><td><a href="#7.2.1.1.1">题解7.2.1.1.1</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">LeetCode 94.二叉树的中序遍历</a></td><td><a href="#7.2.1.1.2">题解7.2.1.1.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">LeetCode 145.二叉树的后序遍历</a></td><td><a href="#7.2.1.1.3">题解7.2.1.1.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">LeetCode 102.二叉树的层序遍历</a></td><td><a href="#7.2.1.2.1">题解7.2.1.2.1</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">LeetCode 107.二叉树的层序遍历 II</a></td><td><a href="#7.2.1.2.2">题解7.2.1.2.2</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">LeetCode 103.二叉树的锯齿形层序遍历</a></td><td><a href="#7.2.1.2.3">题解7.2.1.2.3</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">LeetCode 104.二叉树的最大深度</a></td><td><a href="#7.2.1.3">题解7.2.1.3</a></td></tr><tr><td>⑧</td><td><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">LeetCode 111.二叉树的最小深度</a></td><td><a href="#7.2.1.4">题解7.2.1.4</a></td></tr><tr><td>⑨</td><td><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">LeetCode 662.二叉树最大宽度</a></td><td><a href="#7.2.1.5">题解7.2.1.5</a></td></tr><tr><td>⑩</td><td><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">LeetCode 199.二叉树的右视图</a></td><td><a href="#7.2.1.6">题解7.2.1.6</a></td></tr><tr><td>⑪</td><td><a href="https://leetcode.cn/problems/symmetric-tree/">LeetCode 101.对称二叉树</a></td><td><a href="#7.2.1.7">题解7.2.1.7</a></td></tr><tr><td>⑫</td><td><a href="https://leetcode.cn/problems/invert-binary-tree/">LeetCode 226.翻转二叉树</a></td><td><a href="#7.2.1.8">题解7.2.1.8</a></td></tr><tr><td>⑬</td><td><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">LeetCode 116.填充每个节点的下一个右侧节点指针</a></td><td><a href="#7.2.1.9">题解7.2.1.9</a></td></tr><tr><td>⑭</td><td><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">LeetCode 117.填充每个节点的下一个右侧节点指针 II</a></td><td><a href="#7.2.1.10">题解7.2.1.10</a></td></tr><tr><td>⑮</td><td><a href="https://leetcode.cn/problems/same-tree/">LeetCode 100.相同的树</a></td><td><a href="#7.2.1.11">题解7.2.1.11</a></td></tr></tbody></table></div><h3 id="7-2-1-1-深度优先遍历-DFS"><a href="#7-2-1-1-深度优先遍历-DFS" class="headerlink" title="7.2.1.1 深度优先遍历-DFS"></a>7.2.1.1 深度优先遍历-DFS</h3><p><span id="7.2.1.1.1"></span>  </p><h4 id="7-2-1-1-1-二叉树的前序遍历"><a href="#7-2-1-1-1-二叉树的前序遍历" class="headerlink" title="7.2.1.1.1 二叉树的前序遍历"></a>7.2.1.1.1 二叉树的前序遍历</h4><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">LeetCode 144.二叉树的前序遍历</a> | |<a href="#7.2.1">返回目录7.2.1</a></p><font color="#3399FF">思路：前序遍历就是根结点要先遍历到。中-左-右 的顺序</font>    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.递归方法&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 根结点在最开始处理</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            preorder(root.left)</span><br><span class="line">            preorder(root.right)</span><br><span class="line"></span><br><span class="line">        res =[]</span><br><span class="line">        preorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归方法之一&#x27;&#x27;&#x27;</span></span><br><span class="line">        cur = root</span><br><span class="line">        s, res = [], []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> <span class="built_in">len</span>(s)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 先遍历根结点及其左子树上的每一个子树的根结点</span></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="comment"># 左子树部分遍历完之后就可以遍历右边的子树部分了</span></span><br><span class="line">            cur = s.pop()</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归方法之二&#x27;&#x27;&#x27;</span></span><br><span class="line">        s, res = [], []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            s.append(root)</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span>:</span><br><span class="line">                cur = s.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                <span class="comment"># 注意这里是先将右子结点入栈，再将左子结点入栈</span></span><br><span class="line">                <span class="comment"># 这样出栈的时候，就是左子结点先出栈，右子结点后出栈</span></span><br><span class="line">                <span class="keyword">if</span> cur.right :</span><br><span class="line">                    s.append(cur.right)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    s.append(cur.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="7.2.1.1.2"></span>  </p><h4 id="7-2-1-1-2-二叉树的中序遍历"><a href="#7-2-1-1-2-二叉树的中序遍历" class="headerlink" title="7.2.1.1.2 二叉树的中序遍历"></a>7.2.1.1.2 二叉树的中序遍历</h4><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">LeetCode 94.二叉树的中序遍历</a>| | <a href="#7.2.1">返回目录7.2.1</a></p><font color="#3399FF">思路：前序遍历就是左子结点要先遍历到。左-中-右 的顺序</font>    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.递归方法&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            inorder(root.left)</span><br><span class="line">            <span class="comment"># 根结点在中间处理</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            inorder(root.right)</span><br><span class="line"></span><br><span class="line">        res =[]</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归方法&#x27;&#x27;&#x27;</span></span><br><span class="line">        cur = root</span><br><span class="line">        s, res = [], []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> <span class="built_in">len</span>(s)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="comment"># 先将结点入栈而不是读取值</span></span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.left </span><br><span class="line">            </span><br><span class="line">            cur = s.pop()</span><br><span class="line">            <span class="comment"># 弹出的结点再读取值</span></span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="7.2.1.1.3"></span>  </p><h4 id="7-2-1-1-3-二叉树的后序遍历"><a href="#7-2-1-1-3-二叉树的后序遍历" class="headerlink" title="7.2.1.1.3 二叉树的后序遍历"></a>7.2.1.1.3 二叉树的后序遍历</h4><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">LeetCode 145.二叉树的后序遍历</a> | |<a href="#7.2.1">返回目录7.2.1</a></p><font color="#3399FF">思路：后序就是按照 左-右-中 的顺序</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.递归法&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">posorder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            posorder(root.left)</span><br><span class="line">            posorder(root.right)</span><br><span class="line">            <span class="comment"># 根结点排在最后处理</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        posorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归方法之一&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;按照先序遍历，只不过是右结点先于左结点，构造成：中-右-左，最后逆序：</span></span><br><span class="line"><span class="string">        得到 左-右-中 的顺序&#x27;&#x27;&#x27;</span></span><br><span class="line">        cur = root</span><br><span class="line">        s, res = [], []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> <span class="built_in">len</span>(s)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                s.append(cur)</span><br><span class="line">                <span class="comment"># 这里就是先处理左右当中的右子结点</span></span><br><span class="line">                cur = cur.right</span><br><span class="line">            cur = s.pop()</span><br><span class="line">            <span class="comment"># 后处理左结点</span></span><br><span class="line">            cur = cur.left</span><br><span class="line">        <span class="comment"># 此时res是 中-右-左 的顺序，再逆序即可</span></span><br><span class="line">        res.reverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归方法之二&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;按照先序遍历，只不过是右结点先于左结点，构造成：中-右-左，最后逆序：</span></span><br><span class="line"><span class="string">        得到 左-右-中 的顺序&#x27;&#x27;&#x27;</span></span><br><span class="line">        s, res = [], []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            s.append(root)</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span>:</span><br><span class="line">                cur = s.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                <span class="comment"># 注意这里是先将左子结点入栈，再将右子结点入栈</span></span><br><span class="line">                <span class="comment"># 这样出栈的时候，就是右子结点先出栈，左子结点后出栈</span></span><br><span class="line">                <span class="keyword">if</span> cur.right :</span><br><span class="line">                    s.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    s.append(cur.right)</span><br><span class="line">        res.reverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归方法之三&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;不采用逆序的手段，直接按照需要的顺序求结果&#x27;&#x27;&#x27;</span></span><br><span class="line">        pre, cur = <span class="literal">None</span>, root</span><br><span class="line">        s, res = [], []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> <span class="built_in">len</span>(s)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            </span><br><span class="line">            cur = s.pop()</span><br><span class="line">            <span class="comment"># 如果当前结点没有右子结点，或者其右子结点上一轮已经处理过</span></span><br><span class="line">            <span class="comment"># 就说明应该处理当前结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.right <span class="keyword">or</span> cur.right == pre:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 如果不是，就先将当前结点入栈，先处理其右子结点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="7-2-1-2-广度优先遍历-BFS"><a href="#7-2-1-2-广度优先遍历-BFS" class="headerlink" title="7.2.1.2 广度优先遍历-BFS"></a>7.2.1.2 广度优先遍历-BFS</h3><p><span id="7.2.1.2.1"></span>  </p><h4 id="7-2-1-2-1-二叉树的层序遍历"><a href="#7-2-1-2-1-二叉树的层序遍历" class="headerlink" title="7.2.1.2.1 二叉树的层序遍历"></a>7.2.1.2.1 二叉树的层序遍历</h4><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">LeetCode 102.二叉树的层序遍历</a> | | <a href="#7.2.1">返回目录7.2.1</a></p><font color="#3399FF">思路：一层一层的遍历。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># q作为临时队列</span></span><br><span class="line">        q = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            layer = []</span><br><span class="line">            <span class="comment"># N 实际是当前要遍历的层的结点个数</span></span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="comment"># 模拟队列的处理方法，即先进的先出，</span></span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                layer.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">            res.append(layer)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="7.2.1.2.2"></span>  </p><h4 id="7-2-1-2-2-二叉树的层序遍历-II"><a href="#7-2-1-2-2-二叉树的层序遍历-II" class="headerlink" title="7.2.1.2.2 二叉树的层序遍历 II"></a>7.2.1.2.2 二叉树的层序遍历 II</h4><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">LeetCode 107.二叉树的层序遍历 II</a>| | <a href="#7.2.1">返回目录7.2.1</a></p><font color="#3399FF">思路：普通的层序遍历再逆序。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrderBottom</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># q作为临时队列</span></span><br><span class="line">        q = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            layer = []</span><br><span class="line">            <span class="comment"># N 实际是当前要遍历的层的结点个数</span></span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="comment"># 模拟队列的处理方法，即先进的先出，</span></span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                layer.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">            res.append(layer)</span><br><span class="line">        res.reverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="7.2.1.2.3"></span>  </p><h4 id="7-2-1-2-3-二叉树的锯齿形层序遍历"><a href="#7-2-1-2-3-二叉树的锯齿形层序遍历" class="headerlink" title="7.2.1.2.3 二叉树的锯齿形层序遍历"></a>7.2.1.2.3 二叉树的锯齿形层序遍历</h4><p><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">LeetCode 103.二叉树的锯齿形层序遍历</a> | | <a href="#7.2.1">返回目录7.2.1</a></p><font color="#3399FF">思路：普通的层序遍历,对于特定的层进行逆序。这个逆序操作可以在遍历完一层之后再做，也可以在遍历的时候就调整方向，手法是多种的。题解中选择遍历完一层之后再对整层做逆序，操作起来简单一些。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">zigzagLevelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># q作为临时队列</span></span><br><span class="line">        q = [root]</span><br><span class="line">        res = []</span><br><span class="line">        L = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            layer = []</span><br><span class="line">            <span class="comment"># N 实际是当前要遍历的层的结点个数</span></span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="comment"># 模拟队列的处理方法，即先进的先出，</span></span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                layer.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> L % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                res.append(layer)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(layer[::-<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 处理完当前层之后，层索引加一</span></span><br><span class="line">            L += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="7.2.1.3"></span>  </p><h3 id="7-2-1-3-二叉树的最大深度"><a href="#7-2-1-3-二叉树的最大深度" class="headerlink" title="7.2.1.3 二叉树的最大深度"></a>7.2.1.3 二叉树的最大深度</h3><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">LeetCode 104.二叉树的最大深度</a> | | <a href="#7.2.1">返回目录7.2.1</a></p><font color="#3399FF">思路1：说白了就是求多少层，就可以考虑使用层序遍历的解法。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        q = [root]</span><br><span class="line">        h = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            n = <span class="built_in">len</span>(q)</span><br><span class="line">            h+=<span class="number">1</span> <span class="comment"># 思路很简单，每有一层，就给深度加上1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure><font color="#3399FF">思路2：如果按照有多深这个角度来理解，使用深度优先遍历也是可以的。采用递归的方法，写起来也简单。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            left_height = self.maxDepth(root.left) </span><br><span class="line">            right_height = self.maxDepth(root.right) </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left_height, right_height) + <span class="number">1</span> </span><br></pre></td></tr></table></figure><p><span id="7.2.1.4"></span>  </p><h3 id="7-2-1-4-二叉树的最小深度"><a href="#7-2-1-4-二叉树的最小深度" class="headerlink" title="7.2.1.4 二叉树的最小深度"></a>7.2.1.4 二叉树的最小深度</h3><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">LeetCode 111.二叉树的最小深度</a>| | <a href="#7.2.1">返回目录7.2.1</a></p><font color="#3399FF">思路1：说白了还是在求层数，就可以考虑使用层序遍历的解法，只不过不一定要遍历到最后一层才停止。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        q, h = [root], <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q :</span><br><span class="line">            n = <span class="built_in">len</span>(q)</span><br><span class="line">            h+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 知道终点条件就行，达到此条件，直接可以返回了，不用继续遍历下一层了</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">not</span> cur.left) <span class="keyword">and</span> (<span class="keyword">not</span> cur.right):</span><br><span class="line">                    <span class="keyword">return</span> h</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure><font color="#3399FF">思路2：依然可以使用深度优先遍历的方法。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 递归的结束条件依然是判断当前结点是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        min_depth = <span class="number">10</span>**<span class="number">9</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            min_depth = <span class="built_in">min</span>(self.minDepth(root.left), min_depth)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            min_depth = <span class="built_in">min</span>(self.minDepth(root.right), min_depth)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="7.2.1.5"></span>  </p><h3 id="7-2-1-5-二叉树最大宽度"><a href="#7-2-1-5-二叉树最大宽度" class="headerlink" title="7.2.1.5 二叉树最大宽度"></a>7.2.1.5 二叉树最大宽度</h3><p><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">LeetCode 662.二叉树最大宽度</a> | | <a href="#7.2.1">返回目录7.2.1</a></p><font color="#3399FF">思路1：比较直观的方法是求出每一层的宽度，然后求出最大值，这就可以考虑层次优先遍历。  求每一层的宽度时，因其实就是求最右侧的点到最左侧的点，的宽度是多少，  然而，此时要求将中间的null结点也算作有效的点，干脆就对结点进行编号。  编号方式为，假设其在对应的一个满二叉树中的位置索引编号！</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">widthOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        width = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> width </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化根节点和其序号      </span></span><br><span class="line">        q = [(root,<span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="comment"># 计算该层的最大宽度</span></span><br><span class="line">            width_of_layer = q[-<span class="number">1</span>][<span class="number">1</span>] - q[<span class="number">0</span>][<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 然后更新width</span></span><br><span class="line">            width = <span class="built_in">max</span>(width, width_of_layer)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur, index = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 对比原始的层序遍历，只是将入队的元素改为了(node, index)而已</span></span><br><span class="line">                <span class="comment"># index是对应满二叉树的位置索引</span></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append((cur.left, <span class="number">2</span>*index+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append((cur.right, <span class="number">2</span>*index+<span class="number">2</span>))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> width</span><br></pre></td></tr></table></figure><font color="#3399FF">思路2：也可以使用递归方法采取深度优先的思路，直观上没有层次遍历方法那么容易理解。说白了也是利用递归的时候，每次深入结点，就改变index，同时对每层设置了一个起始节点的index，固定在那里，便于计算宽度。直观上不太好理解</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">widthOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 这个是存储每一层的最左侧结点的index的哈希表</span></span><br><span class="line">        layerMin = &#123;&#125;</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode], depth: <span class="built_in">int</span>, index: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="comment"># 递归结束条件为当前结点为空</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> depth <span class="keyword">not</span> <span class="keyword">in</span> layerMin:</span><br><span class="line">                layerMin[depth] = index  <span class="comment"># 每一层最先访问到的节点会是最左边的节点，即每一层编号的最小值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(index - layerMin[depth] + <span class="number">1</span>,</span><br><span class="line">                       dfs(node.left, depth + <span class="number">1</span>, index * <span class="number">2</span> + <span class="number">1</span>),</span><br><span class="line">                       dfs(node.right, depth + <span class="number">1</span>, index * <span class="number">2</span> + <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><span id="7.2.1.6"></span>  </p><h3 id="7-2-1-6-二叉树的右视图"><a href="#7-2-1-6-二叉树的右视图" class="headerlink" title="7.2.1.6 二叉树的右视图"></a>7.2.1.6 二叉树的右视图</h3><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">LeetCode 199.二叉树的右视图</a> | | <a href="#7.2.1">返回目录7.2.1</a></p><font color="#3399FF">思路1：采用层序遍历，每一层只取最右的结点。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.广度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        q=[root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(q) &gt; <span class="number">0</span>:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> i == N-<span class="number">1</span>:</span><br><span class="line">                    res.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><font color="#3399FF">思路2：采用深度优先遍历，按照先序遍历的基础code进行修改，但是要先遍历右子树上的结点；   并且，我们记住已经遍历过的深度，对于每一深度（层）而言，遍历到这一深度时的第一个结点一定是最右侧的结点。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.深度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每一个元素由[结点, 深度]这样的二元数组构成</span></span><br><span class="line">        cur = [root,<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 用一个哈希表存储已经遍历过的层的序号</span></span><br><span class="line">        hash_d = &#123;&#125;</span><br><span class="line">        s, res = [], []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur[<span class="number">0</span>] <span class="keyword">or</span> s:</span><br><span class="line">            <span class="keyword">while</span> cur[<span class="number">0</span>]:</span><br><span class="line">                cur_node, cur_d = cur[<span class="number">0</span>], cur[<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 如果当前深度还没有遍历，那么该层遇到的第一个结点就一定是最右侧的结点</span></span><br><span class="line">                <span class="keyword">if</span> cur_d <span class="keyword">not</span> <span class="keyword">in</span> hash_d:</span><br><span class="line">                    res.append(cur_node.val)</span><br><span class="line">                    hash_d[cur_d] = cur_node</span><br><span class="line"></span><br><span class="line">                s.append(cur)</span><br><span class="line">                <span class="comment"># 记得往右子树的方向更新cur</span></span><br><span class="line">                cur = [cur_node.right, cur_d+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            cur = s.pop()</span><br><span class="line">            cur = [cur[<span class="number">0</span>].left, cur[<span class="number">1</span>]+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="7.2.1.7"></span>  </p><h3 id="7-2-1-7-对称二叉树"><a href="#7-2-1-7-对称二叉树" class="headerlink" title="7.2.1.7 对称二叉树"></a>7.2.1.7 对称二叉树</h3><p><a href="https://leetcode.cn/problems/symmetric-tree/">LeetCode 101.对称二叉树</a> | | <a href="#7.2.1">返回目录7.2.1</a>  </p><font color="#3399FF">思路1：采用广度优先(层序)遍历，判断各层是否符合对称条件。  注意，这里对称不光是要值相等，还要让位置符合对称的条件</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.采用广度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line"></span><br><span class="line">        h = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 同时将结点，和其对应满二叉树的位置索引保存</span></span><br><span class="line">        q = [(root,<span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            h += <span class="number">1</span></span><br><span class="line">            layer = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                node, idx = cur</span><br><span class="line">                layer.append(cur)</span><br><span class="line">                <span class="comment"># 同时将结点，和其对应满二叉树的位置索引保存</span></span><br><span class="line">                <span class="keyword">if</span> node.left:   </span><br><span class="line">                    q.append((node.left, <span class="number">2</span>*idx+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    q.append((node.right, <span class="number">2</span>*idx+<span class="number">2</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 判断当前layer是否符合对称条件</span></span><br><span class="line">            L, R = <span class="number">0</span>, N-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt;= R:</span><br><span class="line">                left, right = layer[L], layer[R]</span><br><span class="line">                <span class="comment"># 要同时判断值是否相等，以及位置是否满足对称关系</span></span><br><span class="line">                <span class="comment"># 这里先求前几层的结点总数</span></span><br><span class="line">                front_node_cnts = <span class="number">2</span>**(h-<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> left[<span class="number">0</span>].val == right[<span class="number">0</span>].val <span class="keyword">and</span> \</span><br><span class="line">                    left[<span class="number">1</span>]-front_node_cnts  +  right[<span class="number">1</span>]-front_node_cnts == <span class="number">2</span>**(h-<span class="number">1</span>)-<span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 其中 left[1]-front_node_cnts 和 right[1]-front_node_cnts 代表的是当前结点索引，减去前几层的结点数</span></span><br><span class="line">                    <span class="comment"># 2**(h-1) 是假设当前层是满的情况时，应该有多少个结点</span></span><br><span class="line">                    L+=<span class="number">1</span></span><br><span class="line">                    R-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># print(left[0].val,right[0].val,left[1],right[1], front_node_cnts, N-1)</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><font color="#3399FF">思路2：采用深度优先遍历。  注意，这里要注意，判断左右两个结点的值是否相等时，一定要保证这两个结点来自对称的位置，而未必是同一个结点的左右子结点。  </font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.采用深度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 根结点本身为空，返回True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line"></span><br><span class="line">         <span class="comment"># 结点不为空，再来讨论其子树</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">left, right</span>):</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;注意: </span></span><br><span class="line"><span class="string">            DFS传入的两个结点，是对称位置的两个结点，而不一定是同一个结点的左右子结点 </span></span><br><span class="line"><span class="string">            只有对树的根结点而言，对称位置的两个结点，刚好是其左右子结点，再往下就不是左右子结点了！</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="comment"># 如果对称位置的结点都为空，满足对称</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">            <span class="keyword">elif</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="comment"># 如果左侧结点不为空，右侧结点为空，显然不对称</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> left <span class="keyword">and</span> right:</span><br><span class="line">                <span class="comment"># 如果左侧结点为空，右侧结点不为空，显然不对称</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果对称左右位置的结点都不为空，就要讨论两个条件：</span></span><br><span class="line">                <span class="comment"># 1.左右两个结点的值是否相等：</span></span><br><span class="line">                <span class="comment"># 2.左右两个结点下的子树本身是否满足对称条件</span></span><br><span class="line">                <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">                    <span class="comment"># 左右结点（即对称位置）的值不相等，显然不对称</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 一定要注意DFS传入的两个结点，是对称位置的两个结点，而非同一个结点的左右子结点</span></span><br><span class="line">                    <span class="keyword">return</span> DFS(left.left, right.right) <span class="keyword">and</span> DFS(left.right, right.left)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> DFS(root.left, root.right)</span><br></pre></td></tr></table></figure><p><span id="7.2.1.8"></span>  </p><h3 id="7-2-1-8-翻转二叉树"><a href="#7-2-1-8-翻转二叉树" class="headerlink" title="7.2.1.8 翻转二叉树"></a>7.2.1.8 翻转二叉树</h3><p><a href="https://leetcode.cn/problems/invert-binary-tree/">LeetCode 226.翻转二叉树</a> | | <a href="#7.2.1">返回目录7.2.1</a>  </p><font color="#3399FF">思路1：采用深度优先遍历，递归地反转子树。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先递归处理该结点的左右子树，使其左右子树已经完成反转</span></span><br><span class="line">        new_left = self.invertTree(root.left)</span><br><span class="line">        new_right = self.invertTree(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 再将其左右子树交换即可</span></span><br><span class="line">        root.left, root.right = new_right, new_left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><span id="7.2.1.9"></span>  </p><h3 id="7-2-1-9-填充每个节点的下一个右侧节点指针"><a href="#7-2-1-9-填充每个节点的下一个右侧节点指针" class="headerlink" title="7.2.1.9 填充每个节点的下一个右侧节点指针"></a>7.2.1.9 填充每个节点的下一个右侧节点指针</h3><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">LeetCode 116.填充每个节点的下一个右侧节点指针</a> | | <a href="#7.2.1">返回目录7.2.1</a>  </p><font color="#3399FF">思路1：最直接的思路就是采用广度优先遍历，对每一层进行连接即可。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="string">&#x27;Optional[Node]&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root </span><br><span class="line">        </span><br><span class="line">        q = [root]</span><br><span class="line">        cur = root </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N =<span class="built_in">len</span>(q)</span><br><span class="line">            pre = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 层内链接</span></span><br><span class="line">                <span class="keyword">if</span> pre:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur </span><br><span class="line">                pre = cur </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> root </span><br></pre></td></tr></table></figure><font color="#3399FF">思路2：由于题目中说了这是满二叉树，所以每一层都是满的，每个父节点都有两个子节点。所以也可以利用这一特点来做，即对已经建立起来的next链接做横向移动。</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># 从根节点开始</span></span><br><span class="line">        leftmost = root</span><br><span class="line">        <span class="keyword">while</span> leftmost.left:</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 遍历这一层节点组织成的横向链表，为下一层的节点更新 next 指针</span></span><br><span class="line">            head = leftmost</span><br><span class="line">            <span class="keyword">while</span> head:</span><br><span class="line">                <span class="comment"># 1.同一个父节点内的左右子结点链接</span></span><br><span class="line">                head.left.<span class="built_in">next</span> = head.right</span><br><span class="line">                <span class="comment"># 2.将不同父节点之间的下一层右左子结点链接起来</span></span><br><span class="line">                <span class="keyword">if</span> head.<span class="built_in">next</span>:</span><br><span class="line">                    head.right.<span class="built_in">next</span> = head.<span class="built_in">next</span>.left</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 在本层内指针向后移动</span></span><br><span class="line">                head = head.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 去下一层的最左的节点</span></span><br><span class="line">            leftmost = leftmost.left</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root </span><br></pre></td></tr></table></figure><p><span id="7.2.1.10"></span>  </p><h3 id="7-2-1-10-填充每个节点的下一个右侧节点指针II"><a href="#7-2-1-10-填充每个节点的下一个右侧节点指针II" class="headerlink" title="7.2.1.10 填充每个节点的下一个右侧节点指针II"></a>7.2.1.10 填充每个节点的下一个右侧节点指针II</h3><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">LeetCode 117.填充每个节点的下一个右侧节点指针 II</a> | | <a href="#7.2.1">返回目录7.2.1</a>   </p><font color="#3399FF">思路1：这个题和上一题的唯一区别就是，该题没有明确说明树是【完全二叉树】，但是依然能够用上一题的层次遍历的方法来做。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root </span><br><span class="line">        </span><br><span class="line">        q = [root]</span><br><span class="line">        cur = root </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N =<span class="built_in">len</span>(q)</span><br><span class="line">            pre = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> pre:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur </span><br><span class="line">                pre = cur </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> root </span><br></pre></td></tr></table></figure><p><span id="7.2.1.11"></span>  </p><h3 id="7-2-1-11-相同的树"><a href="#7-2-1-11-相同的树" class="headerlink" title="7.2.1.11 相同的树"></a>7.2.1.11 相同的树</h3><p><a href="https://leetcode.cn/problems/same-tree/">LeetCode 100.相同的树</a> | | <a href="#7.2.1">返回目录7.2.1</a>   </p><font color="#3399FF">思路：如果采用深度优先遍历的思路，其实和【[对称二叉树](#7.2.1.7)】那道题的思路几乎一致。都是对比对应位置的结点的值是否相等，只不过一个是在树的左右两侧寻找，一个是在两棵树之间寻找。  code的基本写法也是很相似的。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSameTree</span>(<span class="params">self, p: <span class="type">Optional</span>[TreeNode], q: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;注意：传入的两个结点，是对两个树对应位置的两个结点&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 如果两个结点都是空结点，满足相等</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">        <span class="comment"># 如果一个为空一个不为空，显然不相等</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> p <span class="keyword">and</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        <span class="comment"># 如果一个为空一个不为空，显然不相等</span></span><br><span class="line">        <span class="keyword">elif</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果两个结点都不为空，对比值的大小</span></span><br><span class="line">            <span class="keyword">if</span> p.val != q.val:</span><br><span class="line">                <span class="comment"># 值不想等，显然不符合</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 值相等的话，再看其左右子树是否满足</span></span><br><span class="line">                <span class="comment"># 传入的两个结点，是对两个树对应位置的两个结点</span></span><br><span class="line">                <span class="keyword">return</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br></pre></td></tr></table></figure><p><span id="7.2.2"></span></p><h2 id="7-2-2-二叉树反序列化（还原）"><a href="#7-2-2-二叉树反序列化（还原）" class="headerlink" title="7.2.2 二叉树反序列化（还原）"></a>7.2.2 二叉树反序列化（还原）</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LeetCode 105.从前序与中序遍历序列构造二叉树</a></td><td><a href="#7.2.2.1">题解7.2.2.1</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">LeetCode 106.从中序与后序遍历序列构造二叉树</a></td><td><a href="#7.2.2.2">题解7.2.2.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">LeetCode 889.根据前序和后序遍历构造二叉树</a></td><td><a href="#7.2.2.3">题解7.2.2.3</a></td></tr></tbody></table></div><p><span id="7.2.2.1"></span>  </p><h3 id="7-2-2-1-从前序与中序遍历序列构造二叉树"><a href="#7-2-2-1-从前序与中序遍历序列构造二叉树" class="headerlink" title="7.2.2.1 从前序与中序遍历序列构造二叉树"></a>7.2.2.1 从前序与中序遍历序列构造二叉树</h3><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LeetCode 105.从前序与中序遍历序列构造二叉树</a> | | <a href="#7.2.2">返回目录7.2.2</a></p><font color="#3399FF">思路：核心在于，对于每一棵子树范围的结点，它的先序遍历的第一个元素，一定是该子树的根结点，即[ 根结点-[左子树结点]-[右子树结点] ]。而对于中序遍历,根结点能够将左右子树的结点分开，即[ [左子树结点]-根结点-[右子树结点] ] 。 而且该题强调了无重复元素，所以能够根据这两个遍历方式还原出原始二叉树。</font><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:       </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getNode</span>(<span class="params">preorder_start, preorder_end, inorder_start, inorder_end</span>):</span><br><span class="line">            <span class="comment"># 如果传入的先序序列的开始索引已经大于了结束索引，就可以停止了</span></span><br><span class="line">            <span class="keyword">if</span> preorder_start &gt; preorder_end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当前考察的先序序列的第一个元素一定是根结点</span></span><br><span class="line">            root_val = preorder[preorder_start]</span><br><span class="line">            root_node = TreeNode(root_val)</span><br><span class="line">            <span class="comment"># 求出该元素在中序序列中的索引（题目中已经说了没有重复元素，所以可以直接在哈希表中找）</span></span><br><span class="line">            root_inorder_idx = inorder_index[root_val]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 根据中序遍历根结点的位置，我们可以将【中序】遍历分成左右两半，分别代表左右两个子树的【中序】序列</span></span><br><span class="line">            <span class="comment"># 注意，这里只是写了两个区域的端点索引</span></span><br><span class="line">            left_tree_inorder = [inorder_start, root_inorder_idx-<span class="number">1</span>]</span><br><span class="line">            right_tree_inorder = [root_inorder_idx+<span class="number">1</span>, inorder_end]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 还可以得到左子树的结点个数：</span></span><br><span class="line">            left_tree_node_cnts = root_inorder_idx - inorder_start</span><br><span class="line">            <span class="comment"># 根据这个数目，来求左右子树的【先序】序列的端点索引</span></span><br><span class="line">            left_tree_preorder = [preorder_start+<span class="number">1</span>, preorder_start + left_tree_node_cnts]</span><br><span class="line">            right_tree_preorder = [preorder_start + left_tree_node_cnts + <span class="number">1</span>, preorder_end]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 已经知道左右两个子树的，先序和中序的端点索引了，可以调用递归了</span></span><br><span class="line">            root_node.left = getNode(left_tree_preorder[<span class="number">0</span>], left_tree_preorder[<span class="number">1</span>], left_tree_inorder[<span class="number">0</span>], left_tree_inorder[<span class="number">1</span>])</span><br><span class="line">            root_node.right = getNode(right_tree_preorder[<span class="number">0</span>], right_tree_preorder[<span class="number">1</span>], right_tree_inorder[<span class="number">0</span>], right_tree_inorder[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root_node</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 用哈希表暂时将中序遍历的索引存储</span></span><br><span class="line">        inorder_index = &#123;val:i <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder)&#125;</span><br><span class="line">        N = <span class="built_in">len</span>(preorder)        </span><br><span class="line">        root = getNode(<span class="number">0</span>,N-<span class="number">1</span>, <span class="number">0</span>, N-<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><span id="7.2.2.2"></span>  </p><h3 id="7-2-2-2-从中序与后序遍历序列构造二叉树"><a href="#7-2-2-2-从中序与后序遍历序列构造二叉树" class="headerlink" title="7.2.2.2 从中序与后序遍历序列构造二叉树"></a>7.2.2.2 从中序与后序遍历序列构造二叉树</h3><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">LeetCode 106.从中序与后序遍历序列构造二叉树</a>| | <a href="#7.2.2">返回目录7.2.2</a></p><font color="#3399FF">思路：和上一题的思路是一样的，甚至code都只需要改一点点。改动点是：后序遍历的顺序是根结点在最后一个位置，即[ [左子树结点]-[右子树结点]-根结点 ]</font><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getNode</span>(<span class="params">postorder_start, postorder_end, inorder_start, inorder_end</span>):</span><br><span class="line">            <span class="comment"># 如果传入的后序序列的开始索引已经大于了结束索引，就可以停止了</span></span><br><span class="line">            <span class="keyword">if</span> postorder_start &gt; postorder_end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当前考察的后序序列的【最后一个】元素一定是根结点</span></span><br><span class="line">            root_val = postorder[postorder_end]</span><br><span class="line">            root_node = TreeNode(root_val)</span><br><span class="line">            <span class="comment"># 求出该元素在中序序列中的索引（题目中已经说了没有重复元素，所以可以直接在哈希表中找）</span></span><br><span class="line">            root_inorder_idx = inorder_index[root_val]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 根据中序遍历根结点的位置，我们可以将【中序】遍历分成左右两半，分别代表左右两个子树的【中序】序列</span></span><br><span class="line">            <span class="comment"># 注意，这里只是写了两个区域的端点索引</span></span><br><span class="line">            left_tree_inorder = [inorder_start, root_inorder_idx-<span class="number">1</span>]</span><br><span class="line">            right_tree_inorder = [root_inorder_idx+<span class="number">1</span>, inorder_end]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 还可以得到左子树的结点个数：</span></span><br><span class="line">            left_tree_node_cnts = root_inorder_idx - inorder_start</span><br><span class="line">            <span class="comment"># 根据这个数目，来求左右子树的【后序】序列的端点索引</span></span><br><span class="line">            left_tree_postorder = [postorder_start, postorder_start + left_tree_node_cnts-<span class="number">1</span>]</span><br><span class="line">            right_tree_postorder = [postorder_start + left_tree_node_cnts, postorder_end-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 已经知道左右两个子树的，后序和中序的端点索引了，可以调用递归了</span></span><br><span class="line">            root_node.left = getNode(left_tree_postorder[<span class="number">0</span>], left_tree_postorder[<span class="number">1</span>], left_tree_inorder[<span class="number">0</span>], left_tree_inorder[<span class="number">1</span>])</span><br><span class="line">            root_node.right = getNode(right_tree_postorder[<span class="number">0</span>], right_tree_postorder[<span class="number">1</span>], right_tree_inorder[<span class="number">0</span>], right_tree_inorder[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root_node</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 用哈希表暂时将中序遍历的索引存储</span></span><br><span class="line">        inorder_index = &#123;val:i <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder)&#125;</span><br><span class="line">        N = <span class="built_in">len</span>(postorder)        </span><br><span class="line">        root = getNode(<span class="number">0</span>,N-<span class="number">1</span>, <span class="number">0</span>, N-<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><span id="7.2.2.3"></span>  </p><h3 id="7-2-2-3-根据前序和后序遍历构造二叉树"><a href="#7-2-2-3-根据前序和后序遍历构造二叉树" class="headerlink" title="7.2.2.3 根据前序和后序遍历构造二叉树"></a>7.2.2.3 根据前序和后序遍历构造二叉树</h3><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">LeetCode 889.根据前序和后序遍历构造二叉树</a> | | <a href="#7.2.2">返回目录7.2.2</a></p><font color="#3399FF">思路：实际上，只靠先序遍历和后序遍历的结果，并不能唯一确定地还原二叉树的结构。  但是由于题目中说如果存在多个答案，可以返回任何一个，这样该题才能做。  同样是利用上面二题的思路进行code改写即可。  </font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">constructFromPrePost</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getNode</span>(<span class="params">preorder_start, preorder_end, postorder_start, postorder_end</span>):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> preorder_start &gt; preorder_end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当前考察的先序序列的第一个元素一定是根结点</span></span><br><span class="line">            root_val = preorder[preorder_start]</span><br><span class="line">            root_node = TreeNode(root_val)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 说明没有子树了，只需要返回一个结点即可</span></span><br><span class="line">            <span class="keyword">if</span> preorder_start == preorder_end:</span><br><span class="line">                <span class="keyword">return</span> root_node</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果该条件成立，说明至少存在一个子树</span></span><br><span class="line">            <span class="keyword">if</span> preorder_start + <span class="number">1</span> &lt;= preorder_end:</span><br><span class="line">                <span class="comment"># 如果先序序列的第二个结点，等于后序遍历的倒数第二个结点，又由于结点的值不存在重复的情况</span></span><br><span class="line">                <span class="comment"># 说明只有一棵子树，题目中说如果有多个答案，可以返回其中任何一个，那么就直接将这种情况当作左子树来处理</span></span><br><span class="line">                <span class="keyword">if</span> preorder[preorder_start + <span class="number">1</span>] == postorder[postorder_end-<span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># 求出前序遍历的 左子树的 区间端点索引</span></span><br><span class="line">                    left_tree_preorder = [preorder_start + <span class="number">1</span>, preorder_end]</span><br><span class="line">                    <span class="comment"># 求出后序遍历的 左子树的 区间端点索引</span></span><br><span class="line">                    left_tree_postorder = [postorder_start, postorder_end-<span class="number">1</span>]</span><br><span class="line">                    <span class="comment"># 将端点值传入递归函数</span></span><br><span class="line">                    root_node.left = getNode(left_tree_preorder[<span class="number">0</span>], left_tree_preorder[<span class="number">1</span>], left_tree_postorder[<span class="number">0</span>], left_tree_postorder[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 上面的if如果不成立，说明一定同时存在左右两棵子树</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 左子树的根结点，就是先序遍历序列的第二个元素</span></span><br><span class="line">                    left_root = preorder[preorder_start + <span class="number">1</span>]</span><br><span class="line">                    <span class="comment"># 右子树的根结点，就是后序遍历序列的倒数第二个元素</span></span><br><span class="line">                    right_root = postorder[postorder_end-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                     <span class="comment"># 求出前序遍历的 左子树和右子树的 区间端点索引</span></span><br><span class="line">                    left_tree_preorder = [preorder_start + <span class="number">1</span>, preorder_index[right_root]-<span class="number">1</span>]</span><br><span class="line">                    right_tree_preorder = [preorder_index[right_root], preorder_end]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 求出后序遍历的 左子树和右子树的 区间端点索引</span></span><br><span class="line">                    left_tree_postorder = [postorder_start, postorder_index[left_root]]</span><br><span class="line">                    right_tree_postorder = [postorder_index[left_root]+<span class="number">1</span>, postorder_end-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 将区间端点索引传入递归函数</span></span><br><span class="line">                    root_node.left = getNode(left_tree_preorder[<span class="number">0</span>], left_tree_preorder[<span class="number">1</span>], left_tree_postorder[<span class="number">0</span>], left_tree_postorder[<span class="number">1</span>])</span><br><span class="line">                    root_node.right = getNode(right_tree_preorder[<span class="number">0</span>], right_tree_preorder[<span class="number">1</span>], right_tree_postorder[<span class="number">0</span>], right_tree_postorder[<span class="number">1</span>])</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> root_node</span><br><span class="line"></span><br><span class="line">        preorder_index = &#123;val:i <span class="keyword">for</span> (i,val) <span class="keyword">in</span> <span class="built_in">enumerate</span>(preorder)&#125;</span><br><span class="line">        postorder_index = &#123;val:i <span class="keyword">for</span> (i,val) <span class="keyword">in</span> <span class="built_in">enumerate</span>(postorder)&#125;</span><br><span class="line">        N = <span class="built_in">len</span>(preorder)</span><br><span class="line">        root = getNode(<span class="number">0</span>,N-<span class="number">1</span>, <span class="number">0</span>, N-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><span id="7.2.3"> </span></p><h2 id="7-2-3-路径问题"><a href="#7-2-3-路径问题" class="headerlink" title="7.2.3 路径问题"></a>7.2.3 路径问题</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/path-sum/">LeetCode 112.路径总和</a></td><td><a href="#7.2.3.1">题解7.2.3.1</a></td></tr><tr><td>①</td><td><a href="https://leetcode.cn/problems/path-sum-ii/">LeetCode 113.路径总和 II</a></td><td><a href="#7.2.3.2">题解7.2.3.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">LeetCode 124.二叉树中的最大路径和</a></td><td><a href="#7.2.3.3">题解7.2.3.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">LeetCode 236.二叉树的最近公共祖先</a></td><td><a href="#7.2.3.4">题解7.2.3.4</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/binary-tree-paths/">LeetCode 257.二叉树的所有路径</a></td><td><a href="#7.2.3.5">题解7.2.3.5</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/path-in-zigzag-labelled-binary-tree/">LeetCode 1104.二叉树寻路</a></td><td><a href="#7.2.3.6">题解7.2.3.6</a></td></tr></tbody></table></div><p><span id="7.2.3.1"></span>  </p><h3 id="7-2-3-1-路径总和"><a href="#7-2-3-1-路径总和" class="headerlink" title="7.2.3.1 路径总和"></a>7.2.3.1 路径总和</h3><p><a href="https://leetcode.cn/problems/path-sum/">LeetCode 112.路径总和</a> | | <a href="#7.2.3">返回目录7.2.3</a></p><font color="#3399FF">思路 1：广度优先遍历。每一层的每个结点都计算其累积的路径和，直到计算完最后一层的结点的路径和。  </font><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.广度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#每一个元素是由 (结点, 之前路径上的路径和)</span></span><br><span class="line">        q = [(root, <span class="number">0</span>)]</span><br><span class="line">        cur = (root, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            layer = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                node, pathSum = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment">#layer.append(pathSum + node.val)</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果当前结点已经是叶子结点了，就需要判断一下刚刚它计算得到的路径和</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> pathSum + node.val == targetSum:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果不是叶子结点，就继续添加下一层</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    q.append((node.left, pathSum + node.val))</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    q.append((node.right, pathSum + node.val))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><font color="#3399FF">思路 2：深度优先遍历。每深入一个结点，就减去上面已经遍历过的路径上的结点值的和，相当于值看剩下的结点能否满足剩下的和。  </font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;2.深度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node, restSum</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果本身就是叶子结点,就看剩下的 restSum 是不是等于结点值</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">        <span class="keyword">return</span> restSum == node.val</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果本身不是叶子结点，就继续向下深入</span></span><br><span class="line">    <span class="comment"># 只要左右子结点中有一条路能满足即可</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> DFS(node.left, restSum - node.val) <span class="keyword">or</span> DFS(node.right, restSum - node.val) </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> DFS(root, targetSum)</span><br></pre></td></tr></table></figure><p><span id="7.2.3.2"></span>  </p><h3 id="7-2-3-2-路径总和II"><a href="#7-2-3-2-路径总和II" class="headerlink" title="7.2.3.2 路径总和II"></a>7.2.3.2 路径总和II</h3><p><a href="https://leetcode.cn/problems/path-sum-ii/">LeetCode 113.路径总和 II</a> | | <a href="#7.2.3">返回目录7.2.3</a></p><font color="#3399FF">思路 1：和上一题很类似，只不过上一题只是判断是否存在这样的路径，而该题还要确定出这样的路径，难度稍微提升了一点。  如果我们仍使用广度优先搜索，该如何才能在确定这样的路径存在时，知道前面路径上的所有结点是什么呢？  可以考虑用一个哈希表来记住所有结点的父结点。这样的话就能沿着路径反方向遍历完整条路径。  仅需在上一题的code的基础上做一些修改即可。</font><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.广度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用一个哈希表来存储各个结点的父结点</span></span><br><span class="line">        hash_father = &#123;root:<span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getPath</span>(<span class="params">node</span>):</span><br><span class="line">            path = []</span><br><span class="line">            <span class="comment"># 按照哈希表记录的父结点，一直往上找，并将值添加到path中</span></span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                path.append(node.val)</span><br><span class="line">                node = hash_father[node]</span><br><span class="line">            <span class="comment"># 记得要反转一下path才是从上到下的顺序</span></span><br><span class="line">            path.reverse()</span><br><span class="line">            <span class="keyword">return</span> path</span><br><span class="line"></span><br><span class="line">        <span class="comment">#每一个元素是由 (结点, 之前路径上的路径和)</span></span><br><span class="line">        q = [(root, <span class="number">0</span>)]</span><br><span class="line">        cur = (root, <span class="number">0</span>)</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            layer = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                node, pathSum = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 如果当前结点已经是叶子结点了，就需要判断一下刚刚它计算得到的路径和</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> pathSum + node.val == targetSum:</span><br><span class="line">                    <span class="comment">#return True</span></span><br><span class="line">                    <span class="comment"># 调用getPath向上寻找路径，并添加到结果res中</span></span><br><span class="line">                    res.append(getPath(node))</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果不是叶子结点，就继续添加下一层</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    q.append((node.left, pathSum + node.val))</span><br><span class="line">                    <span class="comment"># 记得更新左子结点的父结点关系</span></span><br><span class="line">                    hash_father[node.left] = node</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    q.append((node.right, pathSum + node.val))</span><br><span class="line">                    <span class="comment"># 记得更新右子结点的父结点关系</span></span><br><span class="line">                    hash_father[node.right] = node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><font color="#3399FF">思路 2：也可以将哈希表的思路与深度优先遍历的code相结合。</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.深度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用一个哈希表来存储各个结点的父结点</span></span><br><span class="line">        hash_father = &#123;root:<span class="literal">None</span>&#125;</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getPath</span>(<span class="params">node</span>):</span><br><span class="line">            path = []</span><br><span class="line">            <span class="comment"># 按照哈希表记录的父结点，一直往上找，并将值添加到path中</span></span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                path.append(node.val)</span><br><span class="line">                node = hash_father[node]</span><br><span class="line">            <span class="comment"># 记得要反转一下path才是从上到下的顺序</span></span><br><span class="line">            path.reverse()</span><br><span class="line">            <span class="keyword">return</span> path</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node, restSum</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="comment"># 如果本身就是叶子结点,就看剩下的restSum是不是等于结点值</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="keyword">if</span> restSum == node.val:</span><br><span class="line">                    res.append(getPath(node))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果本身不是叶子结点，就继续向下深入</span></span><br><span class="line">            <span class="comment"># 只要左右子结点中有一条路能满足即可</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    hash_father[node.left] = node</span><br><span class="line">                    DFS(node.left, restSum - node.val)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    hash_father[node.right] = node</span><br><span class="line">                    DFS(node.right, restSum - node.val) </span><br><span class="line"></span><br><span class="line">        DFS(root, targetSum)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="7.2.3.3"></span>  </p><h3 id="7-2-3-3-二叉树中的最大路径和"><a href="#7-2-3-3-二叉树中的最大路径和" class="headerlink" title="7.2.3.3 二叉树中的最大路径和"></a>7.2.3.3 二叉树中的最大路径和</h3><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">LeetCode 124.二叉树中的最大路径和</a>| | <a href="#7.2.3">返回目录7.2.3</a></p><font color="#3399FF">思路：这里的路径并不一定是指的从根结点出发到叶子结点的路径，而是从一个结点到另一个结点的任意路径。  考察二叉树最小的结构，即1个父结点连着两个子结点的情况：&ensp;father &ensp;/ &emsp;&emsp;\ left &emsp;right  如果我们的路径要经过father结点，那么路径一共就只有以下几种情况：1.这一部分作为更大路径的子路径：a. father;  b. father-left;  c. father-right2.自己这一部分构成一个路径：left-father-right  而至于我们要不要经过 father 结点，那就是看上面这4种情况，能否产生更大的路径和，即：经过father点是否对更大的路径的总和有正向增益？  将这个最小结构放入树当中，这里的左右子结点，可以视为左右子树的总贡献；而father结点的贡献，就视为father结点作为某个子结点时的贡献。</font><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">maxGain</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 递归计算左右子节点的最大贡献值</span></span><br><span class="line">            <span class="comment"># 只有在最大贡献值大于 0 时，才会选取对应子节点</span></span><br><span class="line">            leftGain = <span class="built_in">max</span>(maxGain(node.left), <span class="number">0</span>)</span><br><span class="line">            rightGain = <span class="built_in">max</span>(maxGain(node.right), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 因为结点只能在路径序列中至多出现一次</span></span><br><span class="line">            <span class="comment"># 所以对于任一父结点与其左右子结点能够组成的一个子路径分别为：</span></span><br><span class="line">            <span class="comment"># 1.只取父结点入路径; 2.父结点-左子结点; 3.父结点-右子结点</span></span><br><span class="line">            local_path_gain = <span class="built_in">max</span>(node.val, node.val+leftGain, node.val+rightGain)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 另有一种情况就是 父结点和两个子结点自己组成大路径，不再作为其它大路径的子部分</span></span><br><span class="line">            global_path_gain = node.val + leftGain + rightGain</span><br><span class="line">            <span class="comment"># 如果是这种情况，我们直接将该路径和与总的结果比较，取较大者</span></span><br><span class="line">            res[<span class="number">0</span>] = <span class="built_in">max</span>(res[<span class="number">0</span>], global_path_gain)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果希望将父结点和任一子结点作为一个子路径参与大更大的路径中</span></span><br><span class="line">            <span class="comment"># 我们就把这个子路径的最大路径和返回出去即可</span></span><br><span class="line">            <span class="keyword">return</span> local_path_gain</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 题目中给的条件是 -1000 &lt;= Node.val &lt;= 1000</span></span><br><span class="line">        <span class="comment"># 借用列表来作为全局变量</span></span><br><span class="line">        res =[-<span class="number">1001</span>]</span><br><span class="line">        maxGain(root)</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><span id="7.2.3.4"></span>  </p><h3 id="7-2-3-4-二叉树的最近公共祖先"><a href="#7-2-3-4-二叉树的最近公共祖先" class="headerlink" title="7.2.3.4 二叉树的最近公共祖先"></a>7.2.3.4 二叉树的最近公共祖先</h3><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">LeetCode 236.二叉树的最近公共祖先</a> | | <a href="#7.2.3">返回目录7.2.3</a></p><font color="#3399FF">思路1： 既然是找公共祖先，比较容易想到的是，上面的题目中 [题解7.2.3.2](#7.2.3.2) 为了获取路径，将父结点都存入哈希表中的方法。这里确实可以用。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q: </span><br><span class="line">            <span class="keyword">return</span> root </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置一个哈希表来存储结点的父结点</span></span><br><span class="line">        hash_father = &#123;root:<span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 利用DFS先将各个结点和其父结点都存入hash_father</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node :</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                hash_father[node.left] = node </span><br><span class="line">                DFS(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                hash_father[node.right] = node </span><br><span class="line">                DFS(node.right)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        DFS(root)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这样对于 p, q 两个node，都能够一直往上追溯回树的根结点root</span></span><br><span class="line">        <span class="comment"># 这个问题就可以看成两个无环链表的相交问题了</span></span><br><span class="line">        <span class="comment"># 为了code简便起见，这里又用哈希表方法来解决相交问题</span></span><br><span class="line">        hash_p = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            hash_p[p] = <span class="number">1</span></span><br><span class="line">            p = hash_father[p]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="keyword">if</span> q <span class="keyword">in</span> hash_p:</span><br><span class="line">                <span class="keyword">return</span> q</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q = hash_father[q]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span> </span><br></pre></td></tr></table></figure><font color="#3399FF">思路2：也可以用深度优先遍历，递归的方法找。    注意到题目中提示了，p和q互不相等，且一定位于树中，说明一定有公共祖先！  如果最近祖先是根结点，那么说明p和q一个位于左子树，一个位于右子树；  如果最近公共祖先不是根结点，那么要么位于左子树（说明p和q都位于左子树），要么位于右子树（说明p和q都位于右子树）。  这个概念可以递归推导于任一一个范围的子树。</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q: </span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># left的返回值，要么是None（即p和q都不在左子树中），要么是 p 或者q 或其最近公共祖先</span></span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="comment"># right的返回值，要么是None（即p和q都不在右子树中），要么是 p 或者q 或其最近公共祖先</span></span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left: </span><br><span class="line">            <span class="comment"># 如果left是None，则p和q都不在左子树中，则p和q都在右子树中，答案就是right返回值</span></span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right: </span><br><span class="line">            <span class="comment"># 如果right是None，则p和q都不在右子树中，则p和q都在左子树中，答案就是left 返回值</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 如果上面两个return都没有返回，说明left和right都不为空</span></span><br><span class="line">        <span class="comment"># 那么p和q分别位于 左、右子树中，最近公共祖先就应该是root</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><span id="7.2.3.5"></span>  </p><h3 id="7-2-3-5-二叉树的所有路径"><a href="#7-2-3-5-二叉树的所有路径" class="headerlink" title="7.2.3.5 二叉树的所有路径"></a>7.2.3.5 二叉树的所有路径</h3><p><a href="https://leetcode.cn/problems/binary-tree-paths/">LeetCode 257.二叉树的所有路径</a> | | <a href="#7.2.3">返回目录7.2.3</a></p><font color="#3399FF">思路：采用深度优先遍历，这里的code的写法，也应用到上面的【[7.2.3.2 路径总和II](#7.2.3.2)】同理，该题也可以用上面的那种拿哈希表存储父结点的思路。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node, path</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="comment"># 进入到该结点的处理环节，就先将该结点放入path中</span></span><br><span class="line">            path.append(<span class="built_in">str</span>(node.val))</span><br><span class="line">            <span class="comment"># 是叶子结点,说明已经找到一条路径</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="comment"># 往结果中形成一条路径</span></span><br><span class="line">                res.append(<span class="string">&#x27;-&gt;&#x27;</span>.join(path))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                DFS(node.left, path)</span><br><span class="line">                DFS(node.right, path)</span><br><span class="line">            <span class="comment"># 这一层处理完之后，需要将该结点弹出，不然会继续停留在path中</span></span><br><span class="line">            path.pop()</span><br><span class="line">        </span><br><span class="line">        res, path = [], []</span><br><span class="line">        DFS(root, path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="7.2.3.6"></span>  </p><h3 id="7-2-3-6-二叉树寻路"><a href="#7-2-3-6-二叉树寻路" class="headerlink" title="7.2.3.6 二叉树寻路"></a>7.2.3.6 二叉树寻路</h3><p><a href="https://leetcode.cn/problems/path-in-zigzag-labelled-binary-tree/">LeetCode 1104.二叉树寻路</a>| | <a href="#7.2.3">返回目录7.2.3</a></p><font color="#3399FF">思路：这个题可以采用二叉分裂的方法，就是从根结点到下不断地去寻找子结点，这个寻找的依据是根据label结点在最后一行的位置。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathInZigZagTree</span>(<span class="params">self, label: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> label == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 利用二叉树的性质，先判断出结点应该位于第几层</span></span><br><span class="line">        a, d = label, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> a &gt; <span class="number">1</span>:</span><br><span class="line">            a = a // <span class="number">2</span></span><br><span class="line">            d += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 上面的几层的结点总数</span></span><br><span class="line">        nodes_before = <span class="number">2</span>**(d-<span class="number">1</span>)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_reverse</span>(<span class="params">idx, h</span>):</span><br><span class="line">            <span class="comment"># 由于只有偶数层会逆序,所以这里只考虑 h 是偶数层的情况</span></span><br><span class="line">            <span class="comment"># idx是正常满二叉树在该位置的值</span></span><br><span class="line">            <span class="comment"># 先计算该位置在该层排第几个</span></span><br><span class="line">            k = idx - (<span class="number">2</span>**(h-<span class="number">1</span>)-<span class="number">1</span>) </span><br><span class="line">            <span class="comment"># 生产一个逆序的序号列表 layer</span></span><br><span class="line">            layer = [ i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**h-<span class="number">1</span>, <span class="number">2</span>**(h-<span class="number">1</span>)-<span class="number">1</span>, -<span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">return</span> layer[k-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 求目标label在它那一层是第几个结点</span></span><br><span class="line">        <span class="keyword">if</span> d % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            target_idx = label - nodes_before</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            target_idx = get_reverse(label, d) - nodes_before</span><br><span class="line">        <span class="comment"># print(&quot;target_idx: &quot;, (target_idx))</span></span><br><span class="line">        <span class="comment"># 将最下一层的结点分为左右两部分，并不断地缩小该范围</span></span><br><span class="line">        L,mid,R = <span class="number">1</span>, <span class="number">2</span>**(d-<span class="number">1</span>) / <span class="number">2</span>, <span class="number">2</span>**(d-<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># print(L,mid,R)</span></span><br><span class="line">        <span class="comment"># 由于label==1时已经讨论过，所以这里直接从第二层开始讨论</span></span><br><span class="line">        father, h = <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> h&lt;d:</span><br><span class="line">            <span class="comment"># 位于左半边</span></span><br><span class="line">            <span class="keyword">if</span> target_idx &lt;= mid:</span><br><span class="line">                <span class="comment"># print(&quot;%d &lt;= %d&quot; % (target_idx, mid))</span></span><br><span class="line">                left = <span class="number">2</span>*father</span><br><span class="line">                <span class="keyword">if</span> h % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 奇数层，顺序不变</span></span><br><span class="line">                    res.append(left)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 偶数层</span></span><br><span class="line">                    res.append(get_reverse(left, h))</span><br><span class="line">                father = left</span><br><span class="line">                <span class="comment"># 将之前的左半边细分为两部分</span></span><br><span class="line">                L, mid, R = L, L+(mid-L)//<span class="number">2</span>, mid</span><br><span class="line">                <span class="comment"># print(L,mid,R)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 位于右半边</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># print(&quot;%d &gt; %d&quot; % (target_idx, mid))</span></span><br><span class="line">                right = <span class="number">2</span>*father+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> h % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 奇数层，顺序不变</span></span><br><span class="line">                    res.append(right)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 偶数层，原位置逆序</span></span><br><span class="line">                    res.append(get_reverse(right, h))</span><br><span class="line">                father = right</span><br><span class="line">                <span class="comment"># 将之前的右半边细分为两部分</span></span><br><span class="line">                L, mid, R = mid+<span class="number">1</span>, mid+(R-mid)//<span class="number">2</span>, R</span><br><span class="line">                <span class="comment"># print(L,mid,R)</span></span><br><span class="line">            h+=<span class="number">1</span></span><br><span class="line">        res.append(label)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="7.2.4"></span>  </p><h2 id="7-2-4-验证各种树"><a href="#7-2-4-验证各种树" class="headerlink" title="7.2.4 验证各种树"></a>7.2.4 验证各种树</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/validate-binary-tree-nodes/">LeetCode 1361.验证二叉树</a></td><td><a href="#7.2.4.1">题解7.2.4.1</a></td></tr><tr><td>①</td><td><a href="https://leetcode.cn/problems/validate-binary-search-tree/">LeetCode 98.验证二叉搜索树</a></td><td><a href="#7.2.4.2">题解7.2.4.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">LeetCode 958.二叉树的完全性检验</a></td><td><a href="#7.2.4.3">题解7.2.4.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/balanced-binary-tree/">LeetCode 110.平衡二叉树</a></td><td><a href="#7.2.4.4">题解7.2.4.4</a></td></tr></tbody></table></div><p><span id="7.2.4.1"></span>  </p><h3 id="7-2-4-1-验证二叉树"><a href="#7-2-4-1-验证二叉树" class="headerlink" title="7.2.4.1 验证二叉树"></a>7.2.4.1 验证二叉树</h3><p><a href="https://leetcode.cn/problems/validate-binary-tree-nodes/">LeetCode 1361.验证二叉树</a> | | <a href="#7.2.4">返回目录7.2.4</a></p><font color="#3399FF">思路：这个题乍一看可能不知道在说什么，其实给出的两个列表 leftChild 和 rightChild 的元素指的就是 第 i 个结点的左右指向。  示例1中，i=0的结点，左子结点是leftChild[0]->1，右子结点是rightChild[0]->2;i=1的结点，左子结点是leftChild[1]->-1,表示没有，右子结点是rightChild[1]->-1,表示没有;  i=2的结点，左子结点是leftChild[2]->3，右子结点是rightChild[2]->-1,表示没有;  i=3的结点，左子结点是leftChild[3]->-1,表示没有，右子结点是rightChild[3]->-1,表示没有;  <b>说白了，就是看每个结点的入度（指入的箭头）是否不超过1，且有且只有1个结点入度为0（即根结点），  以及出度（指出的箭头）是否不超过2，（但是此题每个点只会有left和right两个指向，所以这个条件是自然满足的，可以不用考虑）  以及箭头是否为单向的，比如如果 0指向1，但是1也指向0，那明显是不符合的。</b>  比如示例2中，1和2都指向3，导致3的入度为2，就不符合条件了。</font><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validateBinaryTreeNodes</span>(<span class="params">self, n: <span class="built_in">int</span>, leftChild: <span class="type">List</span>[<span class="built_in">int</span>], rightChild: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 先建立一个入度的统计列表</span></span><br><span class="line">        indegree = [<span class="number">0</span>]*n</span><br><span class="line">        <span class="comment"># 将每个结点的入度数目进行统计</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> leftChild[i] != -<span class="number">1</span>: indegree[leftChild[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> rightChild[i] != -<span class="number">1</span>: indegree[rightChild[i]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先判断是否有且只有一个根结点</span></span><br><span class="line">        root = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 统计入度为0的结点的数目</span></span><br><span class="line">            <span class="keyword">if</span> indegree[i] == <span class="number">0</span>: </span><br><span class="line">                root.append(i)</span><br><span class="line">            <span class="comment"># 如果有发现入度超过 1 的结点，直接返回False</span></span><br><span class="line">            <span class="keyword">elif</span> indegree[i] &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 要求有且只有一个根结点，否则就不能满足树的条件！</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(root) != <span class="number">1</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确定存在根结点之后，来判断</span></span><br><span class="line">        <span class="comment"># 这里采用层次遍历的方法</span></span><br><span class="line">        res = []</span><br><span class="line">        q = [root[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            layer = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur_idx = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 检查cur_idx是否已经存在了，</span></span><br><span class="line">                <span class="comment"># 即判断这里cur_idx作为上一层的子结点，是否还指向了上面的层</span></span><br><span class="line">                <span class="keyword">if</span> cur_idx <span class="keyword">in</span> res:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    layer.append(cur_idx)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> leftChild[cur_idx] != -<span class="number">1</span>:</span><br><span class="line">                    q.append(leftChild[cur_idx])</span><br><span class="line">                <span class="keyword">if</span> rightChild[cur_idx] != -<span class="number">1</span>:</span><br><span class="line">                    q.append(rightChild[cur_idx])</span><br><span class="line"></span><br><span class="line">            res.extend(layer)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里的判断是检查连通性，即所有结点都被包含在树中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(res) == n</span><br></pre></td></tr></table></figure><p><span id="7.2.4.2"></span>  </p><h3 id="7-2-4-2-验证二叉搜索树"><a href="#7-2-4-2-验证二叉搜索树" class="headerlink" title="7.2.4.2 验证二叉搜索树"></a>7.2.4.2 验证二叉搜索树</h3><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">LeetCode 98.验证二叉搜索树</a> | | <a href="#7.2.4">返回目录7.2.4</a></p><font color="#3399FF">思路1 ：二叉搜索树的重要特性，就是如果按中序遍历的话，其结果是一个递增数组！  利用这一点，稍微改动中序遍历的code，就能够实现二叉搜索树的判定</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        cur = root</span><br><span class="line">        res, s = [], []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> <span class="built_in">len</span>(s)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                s.append(cur) </span><br><span class="line">                cur = cur.left</span><br><span class="line">            cur = s.pop()</span><br><span class="line">            <span class="comment"># 在原始的中序遍历读值之前，先判断当前值，是否比前一个值大</span></span><br><span class="line">            <span class="comment"># 就多了这么个步骤</span></span><br><span class="line">            <span class="keyword">if</span> res:</span><br><span class="line">                <span class="keyword">if</span> cur.val &lt;= res[-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><font color="#3399FF">思路2 ：二叉搜索树当中的每个子树，也都是二叉搜索树。利用这一点，采用深度优先遍历，递归地判定每个子树都满足二叉搜索的条件，  并将子树部分的最大、最小值往上级传递，就能够实现二叉搜索树的判定</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node</span>)-&gt; (<span class="built_in">bool</span>, <span class="built_in">int</span>, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="comment"># 如果是空树，直接就满足条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>, <span class="literal">None</span>, <span class="literal">None</span>            </span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                <span class="comment"># 如果左子结点不为空，才往下递归</span></span><br><span class="line">                left_tree, left_min, left_max = DFS(node.left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 否则左子树直接就满足二叉搜索的条件,</span></span><br><span class="line">                <span class="comment"># 手动设置为 left_min = node.val，（这样该结点值能作为左部分的最小值向上传递，）</span></span><br><span class="line">                <span class="comment"># left_max = 无穷小，保证该结点值一定满足二叉搜索条件 </span></span><br><span class="line">                left_tree, left_min, left_max = <span class="literal">True</span>, node.val, -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                <span class="comment"># 如果右子结点不为空，才往下递归</span></span><br><span class="line">                right_tree, right_min, right_max = DFS(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 否则右子树直接就满足二叉搜索的条件,</span></span><br><span class="line">                <span class="comment"># 手动设置为 right_max = node.val（这样该结点值能作为右部分的最大值向上传递，）</span></span><br><span class="line">                <span class="comment"># right_min = 无穷大，保证该结点值一定满足二叉搜索条件 </span></span><br><span class="line">                right_tree, right_min, right_max = <span class="literal">True</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), node.val</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断左右子树是否满足二叉搜索条件，以及当前结点是否满足</span></span><br><span class="line">            <span class="keyword">if</span> left_tree <span class="keyword">and</span> right_tree <span class="keyword">and</span> left_max &lt; node.val  <span class="keyword">and</span> node.val &lt; right_min:</span><br><span class="line">                <span class="comment"># 左侧最小数，作为该部分子树最小数的代表：min = left_min</span></span><br><span class="line">                <span class="comment"># 右侧最大数，作为该部分子树最大数的代表：max = right_max</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>, left_min, right_max</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 当返回False的时候，后面两个min max值已经没有意义了，可以随便写</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span>, <span class="literal">None</span>, <span class="literal">None</span> </span><br><span class="line">        <span class="keyword">return</span> DFS(root)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><span id="7.2.4.3"></span>  </p><h3 id="7-2-4-3-二叉树的完全性检验"><a href="#7-2-4-3-二叉树的完全性检验" class="headerlink" title="7.2.4.3 二叉树的完全性检验"></a>7.2.4.3 二叉树的完全性检验</h3><p><a href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">LeetCode 958.二叉树的完全性检验</a> | | <a href="#7.2.4">返回目录7.2.4</a></p><font color="#3399FF">思路：完全二叉树的一个性质就是，对于每一个结点，其序号应当与对应的满二叉树的结点序号对应一致，毕竟满二叉树就是一颗特殊的完全二叉树。  求最大宽度的那个例子里，遍历元素的时候，将其序号取到，而且这个序号，恰巧就是按照满二叉树的排列来取的。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isCompleteTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 将根节点的序号初始化为0</span></span><br><span class="line">        q = [(root,<span class="number">0</span>)]</span><br><span class="line">        i = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur, index = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 每遍历一个结点，就将其数组排列顺序 i 加上1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 比较两个序号是否相等</span></span><br><span class="line">                <span class="keyword">if</span> i != index:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 在队列入队时，同时搭上其在满二叉树中对应位置的序号</span></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append((cur.left, <span class="number">2</span>*index+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append((cur.right, <span class="number">2</span>*index+<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><span id="7.2.4.4"></span>  </p><h3 id="7-2-4-4-平衡二叉树"><a href="#7-2-4-4-平衡二叉树" class="headerlink" title="7.2.4.4 平衡二叉树"></a>7.2.4.4 平衡二叉树</h3><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">LeetCode 110.平衡二叉树</a> | | <a href="#7.2.4">返回目录7.2.4</a></p><font color="#3399FF">思路1：对于每个结点，其左右子树的高度差不大于1。  所以可以用深度优先遍历，递归的检查每个子树是否平衡。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 第一个递归函数是用来求解结点的height</span></span><br><span class="line">    <span class="comment"># 这其实就是【7.2.1.3 二叉树的最大深度】的递归解法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.height(node.left), self.height(node.right)) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 要判断左右两个子树的高度差是否超过1, 以及左右子树是否都平衡</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(self.height(root.left) - self.height(root.right)) &lt;= <span class="number">1</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br></pre></td></tr></table></figure><font color="#3399FF">思路2：上面的方案1思路是对的，但是在递归使用 isBalanced 函数的时候，对于每一个结点，都要调用一次 height 来求一次该结点的深度，实际上浪费了很多重复计算。  如果在递归的时候，能够不断的把结点的深度往上传递，就不用每次都用height函数去计算了。因为父结点的深度 就是 子结点的最大深度+1 </font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node</span>)-&gt;(<span class="built_in">bool</span>, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> (<span class="literal">True</span>, <span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">            left_tree, left_height = DFS(node.left)</span><br><span class="line">            right_tree, right_height = DFS(node.right)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 其实连cur_height 都可以不先急着算，只有在下面的条件为真的时候再算，进一步缩减时间</span></span><br><span class="line">            <span class="comment"># 但我写在这里更便于逻辑上理解</span></span><br><span class="line">            cur_height = <span class="built_in">max</span>(left_height, right_height) + <span class="number">1</span> </span><br><span class="line">            <span class="comment"># 这里只要发现内层中有非平衡的情况，直接就往外传递False, 都不用计算高度差了</span></span><br><span class="line">            <span class="keyword">if</span> left_tree <span class="keyword">and</span> right_tree <span class="keyword">and</span> <span class="built_in">abs</span>(left_height - right_height) &lt;<span class="number">2</span> :</span><br><span class="line">                <span class="keyword">return</span> (<span class="literal">True</span>, cur_height)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> (<span class="literal">False</span>, cur_height)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> DFS(root)[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    其实这中code写法，和上一题7.2.4.3的思路2的解法是一致的，</span></span><br><span class="line"><span class="string">    都是在递归的时候，回传一个需要对比的值</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="7.2.5"></span></p><h2 id="7-2-5-二叉查找树"><a href="#7-2-5-二叉查找树" class="headerlink" title="7.2.5 二叉查找树"></a>7.2.5 二叉查找树</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">LeetCode 700.二叉搜索树中的搜索</a></td><td><a href="#7.2.5.1">题解7.2.5.1</a></td></tr><tr><td>①</td><td><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">LeetCode 701.二叉搜索树中的插入操作</a></td><td><a href="#7.2.5.2">题解7.2.5.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">LeetCode 450.删除二叉搜索树中的节点</a></td><td><a href="#7.2.5.3">题解7.2.5.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">LeetCode 230.二叉搜索树中第K小的元素</a></td><td><a href="#7.2.5.4">题解7.2.5.4</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指Offer 54.二叉搜索树的第k大节点</a></td><td><a href="#7.2.5.5">题解7.2.5.5</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">LeetCode 235.二叉搜索树的最近公共祖先</a></td><td><a href="#7.2.5.6">题解7.2.5.6</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">LeetCode 108.将有序数组转换为二叉搜索树</a></td><td><a href="#7.2.5.7">题解7.2.5.7</a></td></tr></tbody></table></div><p><span id="7.2.5.1"></span>  </p><h3 id="7-2-5-1-二叉搜索树中的搜索"><a href="#7-2-5-1-二叉搜索树中的搜索" class="headerlink" title="7.2.5.1 二叉搜索树中的搜索"></a>7.2.5.1 二叉搜索树中的搜索</h3><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">LeetCode 700.二叉搜索树中的搜索</a> | | <a href="#7.2.5">返回目录7.2.5</a></p><font color="#3399FF">思路：较为简单，按照二叉树的性质：  如果当前结点比val大，就往去左子树找；如果当前结点比val小，就去右子树找。本身就是一种二分查找。</font><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># &#x27;&#x27;&#x27;递归&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># if not root or root.val == val:</span></span><br><span class="line">        <span class="comment">#     return root</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># if val &lt; root.val:</span></span><br><span class="line">        <span class="comment">#     # 在左子树里递归</span></span><br><span class="line">        <span class="comment">#     return self.searchBST(root.left, val)</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     # 在右子树里递归</span></span><br><span class="line">        <span class="comment">#     return self.searchBST(root.right, val) </span></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;迭代&#x27;&#x27;&#x27;</span></span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="keyword">if</span> val == node.val:</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">            <span class="keyword">elif</span>  val &lt; node.val:</span><br><span class="line">                node = node.left </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = node.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><span id="7.2.5.2"></span>  </p><h3 id="7-2-5-2-二叉搜索树中的插入操作"><a href="#7-2-5-2-二叉搜索树中的插入操作" class="headerlink" title="7.2.5.2 二叉搜索树中的插入操作"></a>7.2.5.2 二叉搜索树中的插入操作</h3><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">LeetCode 701.二叉搜索树中的插入操作</a> | | <a href="#7.2.5">返回目录7.2.5</a></p><font color="#3399FF">思路：示例中给了两个满足条件的解决结果，会发现第二个解决方式，是对原有的树的根结点做了修改，这样操作起来可能会有点复杂；  <b>其实可以尽量保持原来的树不动</b>，将新结点尽可能地插入到树的最后一层或者倒数第二层去。这样能保证上面的结点的关系是不变的。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertIntoBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 如果是空树，直接添加</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        </span><br><span class="line">        pos = root</span><br><span class="line">        <span class="comment"># 从根结点开始遍历</span></span><br><span class="line">        <span class="keyword">while</span> pos:</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;因为题目保证输入数据一定与原始二叉树中任一结点的值不同</span></span><br><span class="line"><span class="string">            所以只存在 大于 和 小于 两种情况， 不存在 等于 的情况</span></span><br><span class="line"><span class="string">            这里直接考虑新结点安排在某个叶子结点之后&#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> val &lt; pos.val:</span><br><span class="line">            <span class="comment"># 如果待插入的val, 小于当前结点的val, 就应该往左树上安排</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pos.left:</span><br><span class="line">                <span class="comment"># 如果左子结点为空, 刚好就放在左子结点</span></span><br><span class="line">                    pos.left = TreeNode(val)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果当前结点的左子结点不为空, 就继续向下遍历</span></span><br><span class="line">                    pos = pos.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pos.right:</span><br><span class="line">                    pos.right = TreeNode(val)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pos = pos.right</span><br><span class="line">        <span class="comment"># 可以看到code中一定是要找到某个点的 左/ 右子结点为空才插入，</span></span><br><span class="line">        <span class="comment"># 即不改变原来的结点的关系</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><span id="7.2.5.3"></span>  </p><h3 id="7-2-5-3-删除二叉搜索树中的节点"><a href="#7-2-5-3-删除二叉搜索树中的节点" class="headerlink" title="7.2.5.3 删除二叉搜索树中的节点"></a>7.2.5.3 删除二叉搜索树中的节点</h3><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">LeetCode 450.删除二叉搜索树中的节点</a>| | <a href="#7.2.5">返回目录7.2.5</a></p><font color="#3399FF">思路：该题的每一个输入都会对应好几种不同的合理的输出，这主要取决于如何处理被删除的结点的子树。  这里选用一种比较简单的思路，即用右子树代替原来的子树部分，然后将原来的左子树整体搬迁的右子树的下面去；。  那么哪个位置合适呢？原来右子树的左下角的那个结点，将原来的左子树作为左下角结点的左子树，一定是合适的；这是由BST 左 < 中 < 右 的性质决定的，可以在草稿上画一画。  </font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root    </span><br><span class="line">        <span class="comment">######### 先查找值为 key 的结点 ##############        </span></span><br><span class="line">        node, father, tag = root, <span class="literal">None</span>, <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 在遍历的时候, 同时记录node的父结点, 以便等会儿进行新的链接操作, 如同删除链表结点那般</span></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="keyword">if</span> key == node.val:</span><br><span class="line">                <span class="comment"># 找到该结点, 退出循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span>  key &lt; node.val:</span><br><span class="line">                father = node </span><br><span class="line">                tag = <span class="string">&#x27;left&#x27;</span>    <span class="comment"># tag=left表示node是父结点的左子结点</span></span><br><span class="line">                node = node.left </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                father = node </span><br><span class="line">                tag = <span class="string">&#x27;right&#x27;</span>   <span class="comment"># tag=left表示node是父结点的右子结点</span></span><br><span class="line">                node = node.right</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="comment"># 没找到key相同的结点, 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="comment">######### 找到了值为 key 的结点 ##############</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;这里需要注意，若tag=&#x27;&#x27;，说明一上来就找到了该结点，即要删除的是root结点&#x27;&#x27;&#x27;</span>          </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="comment"># 当前结点没有子结点, 直接将该结点置空</span></span><br><span class="line">            <span class="keyword">if</span> tag == <span class="string">&#x27;&#x27;</span>:        root = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">elif</span> tag == <span class="string">&#x27;left&#x27;</span> : father.left = <span class="literal">None</span> </span><br><span class="line">            <span class="keyword">else</span>:                father.right = <span class="literal">None</span> </span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> node.left:</span><br><span class="line">            <span class="comment"># 当前结点无左子结点, 但有右子结点, 用右子结点替代当前结点即可</span></span><br><span class="line">            <span class="keyword">if</span> tag == <span class="string">&#x27;&#x27;</span>:        root = root.right</span><br><span class="line">            <span class="keyword">elif</span> tag == <span class="string">&#x27;left&#x27;</span> : father.left = node.right </span><br><span class="line">            <span class="keyword">else</span>:                father.right = node.right </span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="comment">#  当前结点无右子结点, 但有左子结点, 用左子结点替代当前结点即可</span></span><br><span class="line">            <span class="keyword">if</span> tag == <span class="string">&#x27;&#x27;</span>:        root = root.left</span><br><span class="line">            <span class="keyword">elif</span> tag == <span class="string">&#x27;left&#x27;</span> : father.left = node.left </span><br><span class="line">            <span class="keyword">else</span>:                father.right = node.left </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="comment"># 当前结点左右子结点都不为空, 就要来细节处理一下了</span></span><br><span class="line">            <span class="comment"># 本次code选择将该结点的左子树部分全部移动到右子树最下方</span></span><br><span class="line">            </span><br><span class="line">            left, right = node.left, node.right</span><br><span class="line">            <span class="comment"># 在右子树里进行遍历, 直到找到右子树里最下层的左侧结点</span></span><br><span class="line">            <span class="keyword">while</span> right.left:</span><br><span class="line">                right = right.left </span><br><span class="line">            <span class="comment"># 根据二叉搜索树的性质, 右子树部分的点的值, 一定是大于左子树部分的点的值</span></span><br><span class="line">            <span class="comment"># 所以这里直接将原来左子树, 接在右侧最下层的左边, 是一定能满足二叉搜索树的性质的</span></span><br><span class="line">            right.left = left </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 用右子树部分替代原有结点</span></span><br><span class="line">            <span class="keyword">if</span> tag == <span class="string">&#x27;&#x27;</span>:        root = root.right</span><br><span class="line">            <span class="keyword">elif</span> tag == <span class="string">&#x27;left&#x27;</span> : father.left = node.right </span><br><span class="line">            <span class="keyword">else</span>:                father.right = node.right </span><br><span class="line">        <span class="keyword">return</span> root </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="7.2.5.4"></span>  </p><h3 id="7-2-5-4-二叉搜索树中第K小的元素"><a href="#7-2-5-4-二叉搜索树中第K小的元素" class="headerlink" title="7.2.5.4 二叉搜索树中第K小的元素"></a>7.2.5.4 二叉搜索树中第K小的元素</h3><p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指Offer 54.二叉搜索树的第k大节点</a>| | <a href="#7.2.5">返回目录7.2.5</a></p><font color="#3399FF">思路：核心思想是 BST 的中序遍历是升序数列。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallest</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.最简单的思路：先求中序遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 1.1 递归</span></span><br><span class="line"><span class="string">        def inorder(node):</span></span><br><span class="line"><span class="string">            if not node:</span></span><br><span class="line"><span class="string">                return</span></span><br><span class="line"><span class="string">            inorder(node.left)</span></span><br><span class="line"><span class="string">            res.append(node.val)</span></span><br><span class="line"><span class="string">            inorder(node.right)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        res = []</span></span><br><span class="line"><span class="string">        inorder(root)</span></span><br><span class="line"><span class="string">        return res[k-1]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 1.2 迭代</span></span><br><span class="line"><span class="string">        s, res = [], [] </span></span><br><span class="line"><span class="string">        cur = root</span></span><br><span class="line"><span class="string">        while cur or s:</span></span><br><span class="line"><span class="string">            while cur:</span></span><br><span class="line"><span class="string">                s.append(cur)</span></span><br><span class="line"><span class="string">                cur = cur.left </span></span><br><span class="line"><span class="string">            cur = s.pop()</span></span><br><span class="line"><span class="string">            res.append(cur.val)</span></span><br><span class="line"><span class="string">            cur = cur.right </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return  res[k-1]</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.不用完成全部中序遍历，而在遍历的过程中计数&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 2.1 递归方案</span></span><br><span class="line"><span class="string">        def inorder(node):</span></span><br><span class="line"><span class="string">            if not node:</span></span><br><span class="line"><span class="string">                return </span></span><br><span class="line"><span class="string">            inorder(node.left)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            res[0] +=1</span></span><br><span class="line"><span class="string">            if res[0] == res[1]:</span></span><br><span class="line"><span class="string">                res.append(node.val)</span></span><br><span class="line"><span class="string">                return </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            inorder(node.right) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 用res[0]存放计数器, 用res[1]存放目标值k</span></span><br><span class="line"><span class="string">        res=[0,k]</span></span><br><span class="line"><span class="string">        inorder(root)</span></span><br><span class="line"><span class="string">        return res[-1]</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 2.2 迭代方案</span></span><br><span class="line">        s, i = [],<span class="number">0</span></span><br><span class="line">        cur = root </span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> s:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.left </span><br><span class="line">            cur= s.pop()</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == k:</span><br><span class="line">                <span class="keyword">return</span> cur.val </span><br><span class="line">            cur = cur.right </span><br></pre></td></tr></table></figure><p><span id="7.2.5.5"></span>  </p><h3 id="7-2-5-5-二叉搜索树的第k大节点"><a href="#7-2-5-5-二叉搜索树的第k大节点" class="headerlink" title="7.2.5.5 二叉搜索树的第k大节点"></a>7.2.5.5 二叉搜索树的第k大节点</h3><p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指Offer 54.二叉搜索树的第k大节点</a>| | <a href="#7.2.5">返回目录7.2.5</a></p><font color="#3399FF">思路：上一题是求第k小，这一题是求第k大，核心原理是一样的：利用BST的中序遍历。  只不过这里要求第k大的话，稍微改一下中序遍历的code， 即改成 右-中-左 的形式。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthLargest</span>(<span class="params">self, root: TreeNode, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.递归方案&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># def DFS(node):</span></span><br><span class="line">        <span class="comment">#     if not node:</span></span><br><span class="line">        <span class="comment">#         return </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#     DFS(node.right)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#     res[0]+=1</span></span><br><span class="line">        <span class="comment">#     if res[0] == res[1]:</span></span><br><span class="line">        <span class="comment">#         res.append(node.val)</span></span><br><span class="line">        <span class="comment">#         return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#     DFS(node.left)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># res = [0, k]</span></span><br><span class="line">        <span class="comment"># DFS(root)</span></span><br><span class="line">        <span class="comment"># return res[-1]</span></span><br><span class="line">            </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.迭代方案&#x27;&#x27;&#x27;</span></span><br><span class="line">        s, i = [], <span class="number">0</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> s:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            cur = s.pop()</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == k:</span><br><span class="line">                <span class="keyword">return</span> cur.val </span><br><span class="line">            cur = cur.left </span><br></pre></td></tr></table></figure><p><span id="7.2.5.6"></span>  </p><h3 id="7-2-5-6-二叉搜索树的最近公共祖先"><a href="#7-2-5-6-二叉搜索树的最近公共祖先" class="headerlink" title="7.2.5.6  二叉搜索树的最近公共祖先"></a>7.2.5.6  二叉搜索树的最近公共祖先</h3><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">LeetCode 235.二叉搜索树的最近公共祖先</a>| | <a href="#7.2.5">返回目录7.2.5</a></p><font color="#3399FF">思路：该题和 【[7.2.3.4 二叉树的最近公共祖先](#7.2.3.4)】其实一样，所以可以直接用那道题的code；  但是一棵树是二叉搜索树BST时，有其特殊性，所以也有更快一点的方案。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 1.直接使用普通二叉树 最近公共祖先的code [236题]</span></span><br><span class="line"><span class="string">        if not root or root == p or root == q: </span></span><br><span class="line"><span class="string">            return root</span></span><br><span class="line"><span class="string">        # left的返回值，要么是None（即p和q都不在左子树中），要么是 p 或者q 或其最近公共祖先</span></span><br><span class="line"><span class="string">        left = self.lowestCommonAncestor(root.left, p, q)</span></span><br><span class="line"><span class="string">        # right的返回值，要么是None（即p和q都不在右子树中），要么是 p 或者q 或其最近公共祖先</span></span><br><span class="line"><span class="string">        right = self.lowestCommonAncestor(root.right, p, q)</span></span><br><span class="line"><span class="string">        if not left: </span></span><br><span class="line"><span class="string">            # 如果left是None，则p和q都不在左子树中，则p和q都在右子树中，答案就是right返回值</span></span><br><span class="line"><span class="string">            return right</span></span><br><span class="line"><span class="string">        if not right: </span></span><br><span class="line"><span class="string">            # 如果right是None，则p和q都不在右子树中，则p和q都在左子树中，答案就是left 返回值</span></span><br><span class="line"><span class="string">            return left</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">        # 如果上面两个return都没有返回，说明left和right都不为空</span></span><br><span class="line"><span class="string">        # 那么p和q分别位于 左、右子树中，最近公共祖先就应该是root</span></span><br><span class="line"><span class="string">        return root</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 依据BST自身的特性来做</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q: </span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># 如果两个点的值, 都比当前结点的值小, 那就去当前结点的左子树中寻找</span></span><br><span class="line">        <span class="keyword">if</span> p.val &lt; root.val <span class="keyword">and</span> q.val &lt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="comment"># 如果两个点的值, 都比当前结点的值大, 那就去当前结点的右子树中寻找</span></span><br><span class="line">        <span class="keyword">elif</span> p.val &gt; root.val <span class="keyword">and</span> q.val &gt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="comment"># 如果当前结点的值在p和q的值的中间, 那说明当前结点就是最近公共祖先</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><span id="7.2.5.7"></span>  </p><h3 id="7-2-5-7-将有序数组转换为二叉搜索树"><a href="#7-2-5-7-将有序数组转换为二叉搜索树" class="headerlink" title="7.2.5.7 将有序数组转换为二叉搜索树"></a>7.2.5.7 将有序数组转换为二叉搜索树</h3><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">LeetCode 108.将有序数组转换为二叉搜索树</a>| | <a href="#7.2.5">返回目录7.2.5</a></p><font color="#3399FF">思路：BST本身就是利用二分查找思想来构建的树，所以这里直接用二分法。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;二分法的步骤&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">Bi</span>(<span class="params">L, R</span>):</span><br><span class="line">            <span class="keyword">if</span> L &gt; R:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            M = L + (R-L)//<span class="number">2</span></span><br><span class="line">            <span class="comment"># 每一次将区间 中间的数 作为当前子树的根结点</span></span><br><span class="line">            node = TreeNode(nums[M])</span><br><span class="line">            <span class="comment"># 中点左侧的数放在左子树处理</span></span><br><span class="line">            node.left = Bi(L,M-<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 中点右侧的数放在右子树处理</span></span><br><span class="line">            node.right = Bi(M+<span class="number">1</span>, R)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Bi(<span class="number">0</span>, N-<span class="number">1</span>) </span><br></pre></td></tr></table></figure><p><span id="7.2.6"></span></p><h2 id="7-2-6-前缀树"><a href="#7-2-6-前缀树" class="headerlink" title="7.2.6 前缀树"></a>7.2.6 前缀树</h2><p>前缀树即<code>Trie</code>树（发音类似 “try”），也被称为字典树，是一种树形结构。广泛应用于统计和排序大量的字符串（但不仅限于字符串）。它是根据树的路径来得到字符串，能节省存储空间，减少字符串比较，尽快地查询到需要的字符串，所以经常被用于文本词频统计。  </p><p>距离说明，现有 await, awake, award, awful, awfully 共5个单词（字符串），据此生成的前缀树如下图所示：  </p><blockquote><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/7_2_6.webp" width="50%"> </p></blockquote><p>可以观察到，对于重叠部分的子串，是可以公用树中的路径的，这样就减少了存储字符串的空间。<br>对于每一个字符串的结尾字母形成的结点，用绿色高亮表示，意味着从根结点出发的这条路径存在一个对应的字符串的，这样也就能提高查询效率。比如最右侧的路径中，第一个L和最后的Y都是高亮表示，说明该条路径存在以第一个L结尾，和Y结尾的单词。  </p><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">LeetCode 208.实现 Trie (前缀树)</a></td><td><a href="#7.2.6.1">题解7.2.6.1</a></td></tr><tr><td>①</td><td><a href="https://leetcode.cn/problems/longest-common-prefix/">LeetCode 14.最长公共前缀</a></td><td><a href="#7.2.6.2">题解7.2.6.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">LeetCode 211.添加与搜索单词 - 数据结构设计</a></td><td><a href="#7.2.6.3">题解7.2.6.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/prefix-and-suffix-search/">LeetCode 745.前缀和后缀搜索</a></td><td><a href="#7.2.6.4">题解7.2.6.4</a></td></tr></tbody></table></div><p><span id="7.2.6.1"></span>  </p><h3 id="7-2-6-1-实现-Trie-前缀树"><a href="#7-2-6-1-实现-Trie-前缀树" class="headerlink" title="7.2.6.1 实现 Trie (前缀树)"></a>7.2.6.1 实现 Trie (前缀树)</h3><p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">LeetCode 208.实现 Trie (前缀树)</a> | | <a href="#7.2.6">返回目录7.2.6</a>  </p><font color="#3399FF">思路 1：利用链表结构来实现树，单独设计出存储字符的结点的结构：TrieNode。  这个结点包含两个基本属性，一个是它的子结点，另一个是它是否是结尾结点；  甚至还可以根据需要，增加结点的属性，比如路径权重，作为结尾的次数等等。  所以这个方法，从直观上来说，容易理解和接受。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 对于每个结点，一定要有子结点</span></span><br><span class="line">        <span class="comment"># 而子结点往往不像二叉树那样一般有左右两个，</span></span><br><span class="line">        <span class="comment"># 所以用一个字典来存储所有子结点</span></span><br><span class="line">        self.children = defaultdict(TrieNode)</span><br><span class="line">        <span class="comment"># 标记当且结点是否是某个字符串的结尾</span></span><br><span class="line">        self.word_tail = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 有多少个子串经过当前结点的路径</span></span><br><span class="line">        <span class="comment"># self.weight = 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 从根结点开始遍历</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="comment"># 按照子结点继续向下延伸路径</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="comment"># 因为children是用的 defaultdict 来构造</span></span><br><span class="line">            <span class="comment"># 所以不用判断cur.children中是否已存在c，如果不存在会默认构造一个TrieNode对象；详细可以参考defaultdict的用法</span></span><br><span class="line">            cur = cur.children[c]</span><br><span class="line">        <span class="comment"># 字符串最后的结点，要记得标记一下结尾</span></span><br><span class="line">        cur.is_word = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 从根结点开始遍历</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="comment"># 从子结点中尝试取得当前字符</span></span><br><span class="line">            cur = cur.children.get(c)</span><br><span class="line">            <span class="comment"># 如果子结点中没有该字符，说明不存在这样的字符串</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 如果前面的路径都存在，就要看最后的字符是否是一个结尾字符</span></span><br><span class="line">        <span class="comment"># 因为该函数是查找是否存在某个单词，而非查找前缀</span></span><br><span class="line">        <span class="comment"># 所以直接返回最后结点的“结尾状态”</span></span><br><span class="line">        <span class="keyword">return</span> cur.is_word</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 从根结点开始遍历</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="comment"># 注意这里是查找前缀，而非查找某个单词</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> prefix:</span><br><span class="line">            cur = cur.children.get(c)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 所以最后不用判断是否存在这样的单词，</span></span><br><span class="line">        <span class="comment"># 而是只要有这样的路径（前缀）即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><font color="#3399FF">思路 2：利用哈希表来实现。  它是通过字典的嵌套来实现，即一个字符作为字典的key，而字典的value是一个新的子字典，里面包含后续的字符作为key的子字典。就是不断地在字典里面新建更深层的字典。  这种方法理解起来没有使用链表那么直观，但是更省内存，速度也更快。</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 初始化就是建立一个空的哈希表/字典</span></span><br><span class="line">        self.root = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word:<span class="built_in">str</span></span>)-&gt;<span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 依然是从根结点开始</span></span><br><span class="line">        <span class="comment"># 这里可以理解为从最外层往里进行深入</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">        <span class="comment"># 对于每一个来自word的字符，查看它是否已经是当前层的字典的一个key</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">            <span class="comment"># 如果当前层还没有ch这个key，那么就需要先建立一个以ch为key的子字典</span></span><br><span class="line">                cur[ch] = &#123;&#125;</span><br><span class="line">            <span class="comment"># 进入ch为key的子字典那一层</span></span><br><span class="line">            cur = cur[ch]</span><br><span class="line">        <span class="comment"># 对于最后一层字典的 &#x27;nd&#x27; 这个key，设置其value为 1，表示是一个word的结尾。</span></span><br><span class="line">        cur[<span class="string">&#x27;end&#x27;</span>] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word:<span class="built_in">str</span></span>)-&gt;<span class="built_in">bool</span>:</span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            cur = cur[ch]</span><br><span class="line">        <span class="comment"># 因为该函数是查找是否有一个word，所以要判断符合条件的路径的最后一层字典</span></span><br><span class="line">        <span class="comment"># 是否包含 end 这个key</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;end&#x27;</span> <span class="keyword">in</span> cur</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            cur  = cur[ch]</span><br><span class="line">        <span class="comment"># 因为该函数只需要判断是否存在这样的路径（前缀），所以只要中途不跳出，就一定存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><span id="7.2.6.2"></span>  </p><h3 id="7-2-6-2-最长公共前缀"><a href="#7-2-6-2-最长公共前缀" class="headerlink" title="7.2.6.2 最长公共前缀"></a>7.2.6.2 最长公共前缀</h3><p><a href="https://leetcode.cn/problems/longest-common-prefix/">LeetCode 14.最长公共前缀</a> | | <a href="#7.2.6">返回目录7.2.6</a></p><font color="#3399FF">思路：找公共前缀，这里比较自然的就想到了前缀树的思路。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;使用前缀树的思路&#x27;&#x27;&#x27;</span></span><br><span class="line">        N = <span class="built_in">len</span>(strs)</span><br><span class="line">        <span class="comment"># 如果只有一个单词，那它本身就是自己的公共前缀</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        Trie = &#123;<span class="string">&quot;root&quot;</span>:&#123;&#125;&#125;</span><br><span class="line">        <span class="comment"># end_flag = &quot;#end&quot; # 该题只是判断前缀，不用查找单词，所以可以不设置结尾标识</span></span><br><span class="line">        </span><br><span class="line">        common_prefix = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> strs:</span><br><span class="line">            cur = Trie[<span class="string">&quot;root&quot;</span>]</span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="comment"># 如果原来没有这样的路径，就需要新建一个</span></span><br><span class="line">                    cur[ch] = &#123;&#125;</span><br><span class="line">                <span class="comment"># 进入ch为key的那一层</span></span><br><span class="line">                cur = cur[ch]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;weight&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="comment"># 如果当前层还没有设置过weight参数，说明是第一次到该层，初始化一下weight参数</span></span><br><span class="line">                    cur[<span class="string">&#x27;weight&#x27;</span>] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果当前层已经设置过weight参数，将ch这一层的路径权重加 1</span></span><br><span class="line">                    cur[<span class="string">&#x27;weight&#x27;</span>] += <span class="number">1</span></span><br><span class="line">                <span class="comment"># print(ch, cur[&#x27;weight&#x27;])</span></span><br><span class="line">                <span class="comment">#然后判断, 路径权重是否等于word的数目，等于的话才一定是所有word的公共路径</span></span><br><span class="line">                <span class="keyword">if</span> cur[<span class="string">&#x27;weight&#x27;</span>] == N:</span><br><span class="line">                    common_prefix += ch</span><br><span class="line">                </span><br><span class="line">            <span class="comment"># cur[end_flag] = True</span></span><br><span class="line">        <span class="keyword">return</span> common_prefix</span><br></pre></td></tr></table></figure><p><span id="7.2.6.3"></span>  </p><h3 id="7-2-6-1-添加与搜索单词-数据结构设计"><a href="#7-2-6-1-添加与搜索单词-数据结构设计" class="headerlink" title="7.2.6.1 添加与搜索单词 - 数据结构设计"></a>7.2.6.1 添加与搜索单词 - 数据结构设计</h3><p><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">LeetCode 211.添加与搜索单词 - 数据结构设计</a> | | <a href="#7.2.6">返回目录7.2.6</a></p><font color="#3399FF">思路：利用前缀树的思路来解决。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = &#123;&#125;</span><br><span class="line">        self.end = <span class="string">&#x27;end&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addWord</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">                cur[ch] = &#123;&#125;</span><br><span class="line">            cur = cur[ch]</span><br><span class="line">        cur[self.end] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="comment"># 因为&#x27;.&#x27;相当于万能符号，所以当&#x27;.&#x27;存在的时候，要对该层的所有key进行向下的查找</span></span><br><span class="line">        <span class="comment"># 所以不是一个单路径的查找过程，故这里写成递归函数的形式，当某一条路径没有找到的时候，还能跳回上级的出发点</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">cur, w, index</span>):</span><br><span class="line">            <span class="comment"># 递归结束的条件</span></span><br><span class="line">            <span class="comment"># 因为索引是从0开始的，即待查找的的字符索引是从 0 ~ N-1,（N表示word长度）</span></span><br><span class="line">            <span class="comment"># index 为 N 的时候表示遍历完了整个待查找的的字符串</span></span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(w):</span><br><span class="line">                <span class="comment"># 如果要求匹配的是前缀, 到这里可以直接返回 True</span></span><br><span class="line">                <span class="comment"># return True</span></span><br><span class="line">                <span class="comment"># 但是由于匹配的是word，即完成的单词，就涉及到要判断当前路径是否是结尾的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> self.end <span class="keyword">not</span> <span class="keyword">in</span> cur <span class="keyword">else</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">            ch = w[index]</span><br><span class="line">            <span class="comment"># 如果不是万能字符，就按照正常处理</span></span><br><span class="line">            <span class="keyword">if</span> ch != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> cur:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">return</span> recursive(cur[ch], w, index+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果当前是万能字符，就需要对该层的每一个key向下进行搜索</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> key <span class="keyword">in</span> cur:</span><br><span class="line">                    <span class="comment"># 这个条件往往容易忽略, 如果 key ==self.end, 说明该条路线上已经没有元素了</span></span><br><span class="line">                    <span class="comment"># 就不用再顺着这条路往里面递归了</span></span><br><span class="line">                    <span class="keyword">if</span> key == self.end:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> recursive(cur[key], w, index+<span class="number">1</span>):</span><br><span class="line">                        <span class="comment"># 如果向下递归的返回值是True, 这里也就返回True</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="comment"># 遍历了当前层的所有key都没有返回True的话，最后就只好返回False了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recursive(cur, word, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><span id="7.2.6.4"></span>  </p><h3 id="7-2-6-1-前缀和后缀搜索"><a href="#7-2-6-1-前缀和后缀搜索" class="headerlink" title="7.2.6.1 前缀和后缀搜索"></a>7.2.6.1 前缀和后缀搜索</h3><p><a href="https://leetcode.cn/problems/prefix-and-suffix-search/">LeetCode 745.前缀和后缀搜索</a> | | <a href="#7.2.6">返回目录7.2.6</a></p><font color="#3399FF">思路：前缀搜索可以用前缀树的思路，那么后缀搜索就是逆序的前缀搜索；所以可以考虑使用两个前缀树，一个进行前缀存储，另一个逆序前缀（即后缀）存储、</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordFilter</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>):</span><br><span class="line">        self.trie_prefix = &#123;&#125;</span><br><span class="line">        self.trie_suff = &#123;&#125;</span><br><span class="line">        self.end = <span class="string">&#x27;end&#x27;</span></span><br><span class="line">        <span class="comment"># 调用 insert_list 函数来从words列表构建前缀树和后缀树</span></span><br><span class="line">        self.insert_list(words)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为该题的测试输入时，会出现那种反复查找重复的 前缀 prefix, 后缀 suff 的情况</span></span><br><span class="line">        <span class="comment"># 所以我这里为了提速，将查找过的结果，以 “prefix#suff” 为key, 索引值index为value，存入record字典中，</span></span><br><span class="line">        <span class="comment"># 这样之后出现重复的测试输入，就不用再去计算了</span></span><br><span class="line">        self.record = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_word</span>(<span class="params">self, root, word, index</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;具体的如何插入每个单词&#x27;&#x27;&#x27;</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="comment"># 对于路径上的每一层，要保存其出现在 words列表 中的index</span></span><br><span class="line">                cur[ch] = &#123;<span class="string">&#x27;index&#x27;</span>:[], &#125;</span><br><span class="line">            cur = cur[ch]</span><br><span class="line">            cur[<span class="string">&#x27;index&#x27;</span>].append(index)</span><br><span class="line">        cur[self.end] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_index</span>(<span class="params">self, root, substr</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;查找具有子串：substr 的单词的索引&#x27;&#x27;&#x27;</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> substr:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            cur = cur[ch]</span><br><span class="line">        <span class="keyword">return</span> cur[<span class="string">&#x27;index&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_list</span>(<span class="params">self, words</span>):        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(words)):</span><br><span class="line">            self.insert_word(self.trie_prefix, words[i], i)</span><br><span class="line">            self.insert_word(self.trie_suff, words[i][::-<span class="number">1</span>], i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self, pref: <span class="built_in">str</span>, suff: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果当前的 prefix 和 suff 的组合，在之前没有查询过，就进行以下的查询</span></span><br><span class="line">        <span class="keyword">if</span> pref + <span class="string">&#x27;#&#x27;</span> + suff <span class="keyword">not</span> <span class="keyword">in</span> self.record:</span><br><span class="line">            <span class="comment"># 在前缀树中查找该前缀的index</span></span><br><span class="line">            prefix_index = self.find_index(self.trie_prefix, pref)</span><br><span class="line">            <span class="comment"># 在后缀树中查找该后缀的index</span></span><br><span class="line">            suff_index = self.find_index(self.trie_suff, suff[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果二者其一没有找到，那就说明该样例不存在</span></span><br><span class="line">            <span class="keyword">if</span> prefix_index == -<span class="number">1</span> <span class="keyword">or</span> suff_index== -<span class="number">1</span>:</span><br><span class="line">                self.record[pref + <span class="string">&#x27;#&#x27;</span> + suff] = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果前后缀都找到各自的 index，那就求它们的交集</span></span><br><span class="line">                join_index = <span class="built_in">set</span>(prefix_index) &amp; <span class="built_in">set</span>(suff_index)</span><br><span class="line">                <span class="comment"># 如果交集大于0， 就存下最大的那个 index</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(join_index) &gt; <span class="number">0</span>:</span><br><span class="line">                    self.record[pref + <span class="string">&#x27;#&#x27;</span> + suff] = <span class="built_in">max</span>(join_index)</span><br><span class="line">                <span class="comment"># 如果不存在交集，说明该样例也不存在，存储 -1 </span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.record[pref + <span class="string">&#x27;#&#x27;</span> + suff] = -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.record[pref + <span class="string">&#x27;#&#x27;</span> + suff]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7-1 树</title>
      <link href="/Data-Structure/DS_71_tree.html"/>
      <url>/Data-Structure/DS_71_tree.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="7-1-树"><a href="#7-1-树" class="headerlink" title="7-1 树"></a>7-1 树</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="7-1-1-树结构"><a href="#7-1-1-树结构" class="headerlink" title="7.1.1 树结构"></a>7.1.1 树结构</h2><h3 id="7-1-1-1-树的概念"><a href="#7-1-1-1-树的概念" class="headerlink" title="7.1.1.1 树的概念"></a>7.1.1.1 树的概念</h3><p>前面讲的都是 <strong>线性存储结构</strong>，而树是一种典型的<strong>非线性存储结构</strong>，一个元素可以有<strong>多个直接后继元素</strong>。  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/7_1_1_1.webp" width="40%">   </p><p>树的一些术语如下所示：<br>|称呼|含义|<br>|—-|—-|<br>|叶子|没有后继结点的 结点称为叶子结点|<br>|子结点|某一个结点的直接后继结点|<br>|父结点|某个子结点的直接前驱结点|<br>|兄弟|具有同一父结点的 一群结点|<br>|祖先|从根结点开始走到该结点的所有上级结点，都是该结点的祖先|<br>|结点的度|直接后继结点的数目（子结点数目）|<br>|结点的层次|根结点为1，其它结点的层次等于它的父结点层次+1|<br>|树的深度|结点的最大层次值|<br>|森林|不同的树的集合；如果一棵树删除了根结点，那么剩下的子树就组成一片森林|</p><h3 id="7-1-1-2-争议问题"><a href="#7-1-1-2-争议问题" class="headerlink" title="7.1.1.2 争议问题"></a>7.1.1.2 争议问题</h3><p>关于树的根结点的数目的问题<br>这个似乎一直以来都有点矛盾，不同的书上可能说的不一样。<br>有的书说，<strong>树有且只有一个根结点</strong>，即根结点数目为1；有的书说，<strong>树的根结点可以为0</strong>，这时候称为<strong>空树</strong>。  </p><p>而且连<strong>网上的各种资料也都存在这两种说法</strong>：<br><strong>维基百科截图如下</strong>：  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/7_1_1_2.webp" width="100%">  </p><p><strong>还是维基百科</strong>：  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/7_1_1_3.webp" width="100%">  </p><p>按照这里的说法: 二叉树结点可以为0，普通树不行；<br>那么，二叉树是不是树？？？二叉树当然是树。所以要说【树的结点】最小可以是1还是0呢？这里感觉说法确实很难自洽。<br>那就看具体情况来回答这个问题吧，也不用过多纠结。 </p><h3 id="7-1-1-3-树的种类"><a href="#7-1-1-3-树的种类" class="headerlink" title="7.1.1.3 树的种类"></a>7.1.1.3 树的种类</h3><p>树依据不同的划分基准可以分为很多种类，这里大致罗列出常见的一些，并不完整，只是作为基本了解：  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/7_1_1_4.webp" width="80%"></p><h2 id="7-1-2-二叉树"><a href="#7-1-2-二叉树" class="headerlink" title="7.1.2 二叉树"></a>7.1.2 二叉树</h2><p>本文简要介绍几种常见的二叉树。简单地理解，满足以下两个条件的树就是二叉树：  </p><p><b>①本身是有序树（区分左右）！！！<br>②树中包含的各个结点的度不能超过 2，即只能是 0、1 或者 2；</b></p><h3 id="7-1-2-1-满二叉树"><a href="#7-1-2-1-满二叉树" class="headerlink" title="7.1.2.1 满二叉树"></a>7.1.2.1 满二叉树</h3><table>    <tr>        <td><b>定义</b></td>        <td>如果二叉树中除了叶子结点，<b>每个结点的度都为 2</b>，则此二叉树称为满二叉树。</td>    </tr>        <tr>        <td rowspan="4"><b>性质</b></td>        <td>①满二叉树中第 k 层的结点数为 <b>2^ (k-1)</b> 个。（假设根结点层数是1）</td>    </tr>    <tr>        <td>②深度为 k 的满二叉树必有 <b>2^k - 1</b> 个结点（等比数列求和公式） ，叶子数为 <b>2^ (k-1)</b>。</td>    </tr>        <tr>        <td>③满二叉树中不存在度为 1 的结点，每一个分支点都有两棵深度相同的子树，且叶子结点都在最底层。</td>    </tr>        <tr>        <td>④具有 n 个结点的满二叉树的深度为 <b>log2(n+1)</b> </td>    </tr></table>  <h3 id="7-1-2-2-完全二叉树"><a href="#7-1-2-2-完全二叉树" class="headerlink" title="7.1.2.2 完全二叉树"></a>7.1.2.2 完全二叉树</h3><table>    <tr>        <td><b>定义</b></td>        <td>二叉树中 除去最后一层结点 为满二叉树，且最后一层的结点依次从左到右有序分布;<br>或者这么理解：一个具有n个结点的二叉树，如果其结点编号 和 一颗满二叉树的1---n个结点的编号完全一致，那这棵树就是完全二叉树。</td>    </tr>        <tr>        <td rowspan="4"><b>性质</b></td>        <td>①N 个结点的完全二叉树的深度为 <b>⌊log2  N⌋+1。</b>（向下取整再加1）</td>    </tr>    <tr>        <td>②如果将含有的结点按照层次从左到右依次标号，对于任意一个结点 i 完全二叉树，有以下几个结论成立：            <br>（首先假设<b>i=0 时，表示的是根结点</b>，无父亲结点；在python中，往往是索引从0开始计数）            <br>a. i>0 时，父亲结点为结点 <b>[(i-1)/2]</b> （向下取整）。<br><i>(在实际python的code中，用int取整即可，如果使用//向下取整，会在-0.5时取到-1,当i=0时使用//无法正确取数，所以用int向靠近0取整，能将i=0也直接统一进来)</i>            <br>b. i 结点的左孩子( 如果有的话 )是结点 2*i +1 。            <br>c. i 结点的右孩子( 如果有的话 )是结点 2*i +2。。</td></tr></table><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/7_1_2_1.webp" width="80%"></p><p>在讲排序部分和优先队列的时候，遇到的大根堆/小根堆，就是属于完全二叉树；<br>大根堆：根结点是整棵树的最大值；并且对于每一棵子树而言，其最大值也都在子树根结点<br>小根堆：根结点是整棵树的最小值；并且对于每一棵子树而言，其最小值也都在子树根结点  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/7_1_2_2.webp" width="80%"></p><h3 id="7-1-2-3-排序二叉树（二叉查找树、二叉搜索树）"><a href="#7-1-2-3-排序二叉树（二叉查找树、二叉搜索树）" class="headerlink" title="7.1.2.3 排序二叉树（二叉查找树、二叉搜索树）"></a>7.1.2.3 排序二叉树（二叉查找树、二叉搜索树）</h3><p>又称二叉查找树（Binary Search Tree - BST），亦称二叉搜索树。<br>定义为：一棵空树，或者是具有下列性质的二叉树：<br>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>（3）左、右子树也分别为二叉排序树。  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/7_1_2_3.webp" width="25%"></p><p>二叉搜索树有着高效的插入、删除、查询操作。<br>平均时间的时间复杂度为 O(log n)，最差情况为 O(n)。<br>二叉搜索树与堆不同，不一定是完全二叉树，底层不容易直接用数组表示，一般是用链表来进行构造的；<br>其实二叉搜索树查找元素的过程，就是在实现“二分查找”。</p><h3 id="7-1-2-4-平衡二叉搜索树"><a href="#7-1-2-4-平衡二叉搜索树" class="headerlink" title="7.1.2.4 平衡二叉搜索树"></a>7.1.2.4 平衡二叉搜索树</h3><p>平衡二叉搜索树又被称为 AVL树，是 Adelson-Velsky and Landis Tree的缩写，分别是两个提出者的名字。<br>其实是对普通二叉搜索树的改进。考虑以下情况：  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/7_1_2_4.webp" width="60%">  </p><p>右侧的情况很显然其查找时间是O(N)，但它确实是一个二叉搜索树，只是形状太极端了。<br>可以将其进行改进为AVL树，定义为一棵空树，或者是具有下列性质的二叉树：：<br>（1）本身是一棵二叉搜索树；<br>（2）<b>每个结点的左右两子树高度差都不超过一；（这就是平衡的含义）</b><br>（3）左、右子树也分别为平衡二叉搜索树。<br>称为平衡二叉搜索树。</p><p>平衡二叉搜索树就不会出现上面图(b)的这种极端情况了。<br>注意：由于维护这种高度平衡所付出的代价比从中获得的效率收益还大,故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树.（下面会提及）<br>如果应用场景中对插入删除不频繁,只是对查找要求较高,还是可以用AVL树，其查找效率是O(logN)。</p><h3 id="7-1-2-4-红黑树"><a href="#7-1-2-4-红黑树" class="headerlink" title="7.1.2.4 红黑树"></a>7.1.2.4 红黑树</h3><p>红黑树（Red Black Tree）算是对AVL树进行的一种改进，但是它的左右子树高差有可能大于 1，所以红黑树不是严格意义上的平衡二叉树（AVL），但 对之进行平衡的代价较低， 其平均统计性能要强于 AVL 。<br>红黑树的得名原因是，其结点有颜色之分，分为红色结点和黑色结点，所以每个结点要增加一个存储位表示结点的颜色，其性质如下： </p><ul><li>每个结点非红即黑.</li><li>根结点是黑的。</li><li>每个叶结点都是黑的.（叶子结点是NULL）</li><li>每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）</li><li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。  </li></ul><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/7_1_2_5_b.webp" width="80%"></p><p>红黑树的一些具体操作不在这里细讲，只需要知道： 它是查找，插入和删除效率都是(logN)。  </p><h2 id="7-1-3-二叉树的存储结构"><a href="#7-1-3-二叉树的存储结构" class="headerlink" title="7.1.3  二叉树的存储结构"></a>7.1.3  二叉树的存储结构</h2><h3 id="7-1-3-1-顺序存储结构"><a href="#7-1-3-1-顺序存储结构" class="headerlink" title="7.1.3.1 顺序存储结构"></a>7.1.3.1 顺序存储结构</h3><p>使用顺序表（数组）存储二叉树。需要注意的是，顺序存储只适用于完全二叉树。<br>完全二叉树的顺序存储，仅需从根结点开始，按照层次依次将树中结点存储到数组即可。<br>如果我们想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树。方法很简单，人为添加一些并不存在的空结点（其元素值为“空”），使之成为一颗完全二叉树的形式。但是这种方式明显会浪费大量内存，这时就应考虑链式存储方式。  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/7_1_3_1.webp" width="40%">  </p><p>从顺序表中还原完全二叉树也很简单。我们知道，完全二叉树具有这样的性质，将树中结点按照层次并从左到右依次标号（0,1,2,3,…），若结点 i 有左右孩子，则其左孩子结点为 2 <em> i + 1，右孩子结点为 2 </em> i+ 2。此性质可用于还原数组中存储的完全二叉树。  </p><h3 id="7-1-3-2-链式存储结构"><a href="#7-1-3-2-链式存储结构" class="headerlink" title="7.1.3.2 链式存储结构"></a>7.1.3.2 链式存储结构</h3><p>只需从树的根结点开始，将各个结点及其左右孩子使用链表存储即可。不必非得是完全二叉树。下面是二叉树的二叉链表示意图：  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/7_1_3_2.webp" width="70%">  </p><p>二叉树的结点：<br>其结点结构由 3 部分构成：<br>指向左孩子结点的指针（Lchild）；结点存储的数据（data）；指向右孩子结点的指针（Rchild）<br>这样的链表结构，通常称为二叉链表。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BiTNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val = <span class="literal">None</span></span>):</span><br><span class="line">        self.data = val; //数据域</span><br><span class="line">        self.lchild = <span class="literal">None</span></span><br><span class="line">        self.rchild = <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-1-4-二叉树的遍历方式"><a href="#7-1-4-二叉树的遍历方式" class="headerlink" title="7.1.4 二叉树的遍历方式"></a>7.1.4 二叉树的遍历方式</h2><h3 id="7-1-4-1-深度优先遍历"><a href="#7-1-4-1-深度优先遍历" class="headerlink" title="7.1.4.1 深度优先遍历"></a>7.1.4.1 深度优先遍历</h3><p><b>深度优先搜索(Depth First Search - DFS)</b>是沿着树的深度遍历树的结点，尽可能深的搜索树的分支。<br>那么深度遍历有重要的三种方法。这三种方式常被用于访问树的结点，它们之间的不同在于访问每个结点的次序不同。这三种遍历分别叫做<b>先序遍历（preorder），中序遍历（inorder）和后序遍历（postorder）</b>。    </p><h4 id="7-1-4-1-1-先序遍历"><a href="#7-1-4-1-1-先序遍历" class="headerlink" title="7.1.4.1.1 先序遍历"></a>7.1.4.1.1 先序遍历</h4><p>在先序遍历中，我们对每一棵子树，都是先访问其根结点，然后访问其左孩子结点，最后访问其又孩子结点。</p><p>路径为：根结点-&gt;左子树-&gt;右子树</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;递归法&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 递归法就是调用系统栈</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 对每棵子树的结构，都先访问根结点的值</span></span><br><span class="line">    res.append(root.val)</span><br><span class="line">    <span class="comment"># 然后递归地分别处理左右子结点</span></span><br><span class="line">    preorder(root.left)</span><br><span class="line">    preorder(root.right)</span><br><span class="line"></span><br><span class="line">res =[]</span><br><span class="line">preorder(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-1-4-1-2-中序遍历"><a href="#7-1-4-1-2-中序遍历" class="headerlink" title="7.1.4.1.2 中序遍历"></a>7.1.4.1.2 中序遍历</h4><p>在先序遍历中，我们对每一棵子树，都是先访问其左子结点，然后访问其根结点，最后访问其右孩子结点。</p><p>路径为：左子树-&gt;根结点-&gt;右子树<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;递归法&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 递归法就是调用系统栈</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    inorder(node.left)</span><br><span class="line">    res.append(node.val)</span><br><span class="line">    inorder(node.right)</span><br><span class="line"></span><br><span class="line">res =[]</span><br><span class="line">preorder(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h4 id="7-1-4-1-3-后序遍历"><a href="#7-1-4-1-3-后序遍历" class="headerlink" title="7.1.4.1.3 后序遍历"></a>7.1.4.1.3 后序遍历</h4><p>在先序遍历中，我们对每一棵子树，都是先访问其左子结点，然后访问其右孩子结点，最后访问其根结点。</p><p>路径为：左子树-&gt;右子树-&gt;根结点<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;递归法&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 递归法就是调用系统栈</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    postorder(node.left)</span><br><span class="line">    postorder(node.right)</span><br><span class="line">    res.append(node.val)</span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line">postorder(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="7-1-4-2-广度优先遍历-层次遍历"><a href="#7-1-4-2-广度优先遍历-层次遍历" class="headerlink" title="7.1.4.2 广度优先遍历(层次遍历)"></a>7.1.4.2 广度优先遍历(层次遍历)</h3><p><b>广度优先遍历(Breath First Search - BFS)</b>是横向遍历，即从上到下，一层一层的遍历结点。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;迭代法&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 宽度优先遍历，是利用的队列的思想，先进先出</span></span><br><span class="line"><span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">q, res = [root], []</span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">    layer =[]</span><br><span class="line">    <span class="comment"># 这个 n 其实就是在求要遍历的那一层的宽度</span></span><br><span class="line">    n = <span class="built_in">len</span>(q)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        node = q.pop(<span class="number">0</span>)</span><br><span class="line">        layer.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            q.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            q.append(node.right)</span><br><span class="line">    <span class="comment"># 根据自己想要的输出格式，选用 append 或者 extend</span></span><br><span class="line">    res.append(layer)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6-2 链表相关题目</title>
      <link href="/Data-Structure/DS_62_link_list_exercises.html"/>
      <url>/Data-Structure/DS_62_link_list_exercises.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="6-2-链表相关题目"><a href="#6-2-链表相关题目" class="headerlink" title="6-2 链表相关题目"></a>6-2 链表相关题目</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p><span id="6.2.1"></span>  </p><h2 id="6-2-1-链表逆序部分"><a href="#6-2-1-链表逆序部分" class="headerlink" title="6.2.1 链表逆序部分"></a>6.2.1 链表逆序部分</h2><div class="table-container"><table><thead><tr><th>序号</th><th><strong><a href="#6.2.1">链表逆序部分</a></strong></th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/reverse-linked-list/">LeetCode 206.反转链表</a></td><td><a href="#6.2.1.1">6.2.1.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">LeetCode 92.反转链表 II</a></td><td><a href="#6.2.1.2">6.2.1.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">LeetCode 25. K 个一组翻转链表</a></td><td><a href="#6.2.1.3">6.2.1.3题解</a></td></tr></tbody></table></div><p><span id="6.2.1.1"></span>  </p><h3 id="6-2-1-1-反转链表"><a href="#6-2-1-1-反转链表" class="headerlink" title="6.2.1.1 反转链表"></a>6.2.1.1 反转链表</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/">LeetCode 206.反转链表</a>| | <a href="#6.2.1">返回目录6.2.1</a></p><blockquote><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。    </p></blockquote><font color="#3399FF">思路：链表逆序在章节6-1中已经详细讲解过了。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.递归法&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recursive_func</span>(<span class="params">node:ListNode</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">            </span><br><span class="line">            node_new = recursive_func(node.<span class="built_in">next</span>)</span><br><span class="line">            node.<span class="built_in">next</span>.<span class="built_in">next</span> = node</span><br><span class="line">            node.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> node_new</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> recursive_func(head)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归法&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 在时间和内存上的消耗比 递归法 要好</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        node_A, node_B = head, head.<span class="built_in">next</span> </span><br><span class="line">        <span class="keyword">while</span> node_B.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            node_C = node_B.<span class="built_in">next</span></span><br><span class="line">            node_B.<span class="built_in">next</span> = node_C.<span class="built_in">next</span></span><br><span class="line">            node_C.<span class="built_in">next</span> = node_A.<span class="built_in">next</span></span><br><span class="line">            node_A.<span class="built_in">next</span> = node_C</span><br><span class="line">        node_B.<span class="built_in">next</span> = node_A</span><br><span class="line">        new_head = node_A.<span class="built_in">next</span></span><br><span class="line">        node_A.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;3.非递归法-2&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 速度最快，消耗内存最少</span></span><br><span class="line">        pre, cur = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            rest = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = rest</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><p><span id="6.2.1.2"></span>  </p><h3 id="6-2-1-2-反转链表-II"><a href="#6-2-1-2-反转链表-II" class="headerlink" title="6.2.1.2 反转链表 II"></a>6.2.1.2 反转链表 II</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">LeetCode 92.反转链表 II</a>| | <a href="#6.2.1">返回目录6.2.1</a></p><font color="#3399FF">思路：区间内反转链表，最主要的是找准区间左右边界点。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        start, node_L, pre = <span class="number">1</span>, head, <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 先找到node_L,反转起始结点</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; left:</span><br><span class="line">            pre = node_L</span><br><span class="line">            node_L = node_L.<span class="built_in">next</span></span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 采用code最简单的那个反转方式</span></span><br><span class="line">        <span class="comment"># 这里不用专门找结束位置，因为可以通过控制 i 与 right 的关系来停止</span></span><br><span class="line">        front, cur, i = <span class="literal">None</span>, node_L, left</span><br><span class="line">        <span class="keyword">while</span> i &lt;= right:</span><br><span class="line">            res = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = front</span><br><span class="line">            front = cur</span><br><span class="line">            cur = res</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 反转完成后，这一部分的起始结点就是 front结点了</span></span><br><span class="line">        <span class="comment"># 这一部分的尾结点，就是原始这一区间的开头：node_L</span></span><br><span class="line">        <span class="comment"># 还需要和 区间之后的那一部分 链接起来</span></span><br><span class="line">        node_L.<span class="built_in">next</span> = res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 还需要和 区间之前的那一部分 也链接起来  </span></span><br><span class="line">        <span class="keyword">if</span> pre: <span class="comment"># pre不为初始值none，说明不是从头结点开始反转的</span></span><br><span class="line">            pre.<span class="built_in">next</span> = front</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># pre 为none，说明是从头结点开始反转的，需要更新头结点</span></span><br><span class="line">            <span class="keyword">return</span> front </span><br></pre></td></tr></table></figure><p><span id="6.2.1.3"></span>  </p><h3 id="6-2-1-3-K个一组翻转链表"><a href="#6-2-1-3-K个一组翻转链表" class="headerlink" title="6.2.1.3 K个一组翻转链表"></a>6.2.1.3 K个一组翻转链表</h3><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">LeetCode 25. K 个一组翻转链表</a> | | <a href="#6.2.1">返回目录6.2.1</a></p><font color="#3399FF">思路：反转链表的要点，还是要找准开始点和结束点。每隔k个结点一组反转，意思是索引为 k 的倍数的结点（索引从0开始计数），是上一个区间的右边界。比如示例中的 索引2（结点3）, 索引4（结点5）；同时它也是下一次反转区间的起始结点。（如果下一次还足够反转的话）</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse_linklist</span>(<span class="params">node, k</span>):</span><br><span class="line">            <span class="comment"># 因为该题只在有限区间内进行反转，所以需要用k来控制步长</span></span><br><span class="line">            <span class="comment"># 注意反转完成后，node变成这部分的尾部结点</span></span><br><span class="line">            pre, cur = <span class="literal">None</span>, node </span><br><span class="line">            i = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cur <span class="keyword">and</span> i &lt;=k:</span><br><span class="line">                res = cur.<span class="built_in">next</span> </span><br><span class="line">                cur.<span class="built_in">next</span> = pre </span><br><span class="line">                pre = cur </span><br><span class="line">                cur = res </span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span>  pre </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果只有1个结点或者k=1，就不用做反转</span></span><br><span class="line">        <span class="keyword">if</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> head </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先在前面设立一个哑结点</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        pre, start, j = dummy, head, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> start:</span><br><span class="line">            start = start.<span class="built_in">next</span> </span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j % k == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 根据我们的分析，索引是k的倍数时，</span></span><br><span class="line">                <span class="comment"># 当前结点start是前一个区间的右边界, 也是下一个区间的起始结点</span></span><br><span class="line">                <span class="comment"># 待反转区间的起始结点用pre来控制</span></span><br><span class="line">                old_begin = pre.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 反转之后得到该区间的新的起始结点</span></span><br><span class="line">                new_begin = reverse_linklist(old_begin, k)  </span><br><span class="line">                <span class="comment"># 将新的起始结点 new_begin 与 pre 进行连接              </span></span><br><span class="line">                pre.<span class="built_in">next</span> = new_begin</span><br><span class="line">                <span class="comment"># 反转后，老的起始结点是尾结点，自然要与右边界进行链接 </span></span><br><span class="line">                old_begin.<span class="built_in">next</span> = start</span><br><span class="line">                <span class="comment"># 所以 pre 更新为start的上一个结点，现在就是 old_begin</span></span><br><span class="line">                pre = old_begin    </span><br><span class="line">        <span class="comment"># 返回哑结点之后的部分</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span> </span><br></pre></td></tr></table></figure><h2 id="6-2-2-链表删除元素的相关题目"><a href="#6-2-2-链表删除元素的相关题目" class="headerlink" title="6.2.2 链表删除元素的相关题目"></a>6.2.2 链表删除元素的相关题目</h2><p><span id="6.2.2"></span>  </p><div class="table-container"><table><thead><tr><th>序号</th><th><strong><a href="#6.2.2">链表删除元素的相关题目</a></strong></th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">LeetCode 83.删除排序链表中的重复元素</a></td><td><a href="#6.2.2.1">6.2.2.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">LeetCode 82.删除排序链表中的重复元素 II</a></td><td><a href="#6.2.2.2">6.2.2.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">LeetCode 237.删除链表中的节点</a></td><td><a href="#6.2.2.3">6.2.2.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/remove-linked-list-elements/">LeetCode 203.移除链表元素</a></td><td><a href="#6.2.2.4">6.2.2.4题解</a></td></tr></tbody></table></div><p><span id="6.2.2.1"></span>  </p><h3 id="6-2-2-1-删除排序链表中的重复元素"><a href="#6-2-2-1-删除排序链表中的重复元素" class="headerlink" title="6.2.2.1 删除排序链表中的重复元素"></a>6.2.2.1 删除排序链表中的重复元素</h3><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">LeetCode 83.删除排序链表中的重复元素</a> | | <a href="#6.2.2">返回目录6.2.2</a> </p><font color="#3399FF">思路 1：题目中说了已排序，已经简化了问题了，也就是重复部分只要保留第一个就行。  如果未排序的话，可能会用到哈希表。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 使用哑结点作为虚拟头结点，就可以不用单独讨论头结点是否为空的情况</span></span><br><span class="line">        dummy = ListNode(-<span class="number">200</span>)</span><br><span class="line">        <span class="comment"># 哑结点的值取-200是因为题目中的结点值范围在-100到100间</span></span><br><span class="line">        dummy.<span class="built_in">next</span> = head </span><br><span class="line"></span><br><span class="line">        pre, cur = dummy, head </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 如果当前结点值和前一个结点值相等，就删除当前结点</span></span><br><span class="line">            <span class="keyword">if</span> pre.val == cur.val:</span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur </span><br><span class="line">            cur = cur.<span class="built_in">next</span> </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span>        </span><br></pre></td></tr></table></figure><font color="#3399FF">思路 2 ：思路 1 的 code 的想法是，每遇到一个和 pre 重复的结点，就将它删除，这样有点费时间，比如若中间有很多个重复出现的值，就要一个一个的进行删除操作。  如果直接找到重复数字区域的最末尾，从末尾处断开，这样每个区域只用执行一次断开和链接操作，理论上来说会更快一点。</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line"></span><br><span class="line">        dummy = ListNode(-<span class="number">200</span>, head)</span><br><span class="line">        pre, cur = dummy, head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.<span class="built_in">next</span> :</span><br><span class="line">            <span class="comment"># 如果出现了重复，就进入下面的循环</span></span><br><span class="line">            <span class="keyword">if</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 直接将中间这段重复数值的区域全部删除</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><span id="6.2.2.2"></span>  </p><h3 id="6-2-2-2-删除排序链表中的重复元素-II"><a href="#6-2-2-2-删除排序链表中的重复元素-II" class="headerlink" title="6.2.2.2 删除排序链表中的重复元素 II"></a>6.2.2.2 删除排序链表中的重复元素 II</h3><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">LeetCode 82.删除排序链表中的重复元素 II</a> | | <a href="#6.2.2">返回目录6.2.2</a></p><font color="#3399FF">思路：这道题与上一道题的区别在于，若出现重复的元素，就将结点全部删除，而非简单的去重。比较容易想到的思路是哈希表，先遍历一道元素，将value和出现的次数cnt记录入哈希表中；第二次遍历的时候就删除cnt>1的val对应的node。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1. 哈希表存储&#x27;&#x27;&#x27;</span></span><br><span class="line">        hash_s = &#123;&#125;</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val <span class="keyword">in</span> hash_s:</span><br><span class="line">                hash_s[cur.val] +=<span class="number">1</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_s[cur.val] = <span class="number">0</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        dummy = ListNode(-<span class="number">200</span>, head)</span><br><span class="line">        pre, cur = dummy, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 仍然是遇到满足删除条件，就删除该结点</span></span><br><span class="line">            <span class="keyword">if</span> hash_s[cur.val] &gt; <span class="number">0</span>:</span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><font color="#3399FF">思路 2：很明显哈希表的思路过于简单，可能不是它想考察的点。由于该链表是已经有序的了，基于上一题的思路 2，这一次让pre位于重复区域的前方，而不是第一个结点即可。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 因为要删除重复过的结点，所以头结点可能会变化，这里就先建立一个哑结点</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        pre, cur = dummy, head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> :</span><br><span class="line">            <span class="comment"># 如果出现了重复，就进入下面的循环</span></span><br><span class="line">            <span class="keyword">if</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">                <span class="comment"># 因为我们要对比 cur 和cur.next 的值，所以while的条件要确保 cur.next 也不为None</span></span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">                    cur = cur.<span class="built_in">next</span> </span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 因为循环结束后，cur是重复区域的最后一个结点，</span></span><br><span class="line">                <span class="comment"># 如果它后面还有结点，就要将cur后移一位 </span></span><br><span class="line">                <span class="keyword">if</span> cur.<span class="built_in">next</span>: cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果没有重复就正常遍历</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur=cur.<span class="built_in">next</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span>        </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="6.2.2.3"></span>  </p><h3 id="6-2-2-3-删除链表中的节点"><a href="#6-2-2-3-删除链表中的节点" class="headerlink" title="6.2.2.3 删除链表中的节点"></a>6.2.2.3 删除链表中的节点</h3><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">LeetCode 237.删除链表中的节点</a> | | <a href="#6.2.2">返回目录6.2.2</a></p><font color="#3399FF">思路：这个题乍一看很唬人，因为平时删除结点，都是利用 pre 指针，但此题无法访问head结点，也就无法访问pre结点，感觉好像无法做。但是题目中已经在疯狂暗示解法了：① 题目中明确说了【<b>注意，删除节点并不是指从内存中删除它</b>】。意思是并不用将这个结点 node 从链表中移开。  ② 题目强调了，【<b>node 一定不是最后一个结点</b>】。那说明什么？说明 node.next 一定存在。  回忆一下，平常删除结点是遍历到要删除的结点 node，然后 pre.next = node.next;那么我们现在知道题目给的 node 结点，也知道一定存在 node.next 结点；  此题在暗示不用删除 node，但是又要结点少1，那明显就是要删除 node.next 这个结点：node.next = node.next.next</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type node: ListNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 先把下一个结点的值复制给node</span></span><br><span class="line">        node.val = node.<span class="built_in">next</span>.val</span><br><span class="line">        <span class="comment"># 然后删除 node的下一个结点</span></span><br><span class="line">        node.<span class="built_in">next</span> = node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><span id="6.2.2.4"></span>  </p><h3 id="6-2-2-4-移除链表元素"><a href="#6-2-2-4-移除链表元素" class="headerlink" title="6.2.2.4 移除链表元素"></a>6.2.2.4 移除链表元素</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">LeetCode 203.移除链表元素</a> | | <a href="#6.2.2">返回目录6.2.2</a></p><blockquote><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。  </p></blockquote><font color="#3399FF">思路：比较简单,就是普通的链表删除结点操作。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 因为可能会删除首结点，所以这里搞一个哑结点</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        pre, cur = dummy, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span>  </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><span id="6.2.3"></span></p><h2 id="6-2-3-链表双指针"><a href="#6-2-3-链表双指针" class="headerlink" title="6.2.3 链表双指针"></a>6.2.3 链表双指针</h2><div class="table-container"><table><thead><tr><th>序号</th><th><strong><a href="#6.2.3">链表双指针</a></strong></th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">LeetCode 876.链表的中间结点</a></td><td><a href="#6.2.3.1">6.2.3.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/">LeetCode 2095.删除链表的中间节点</a></td><td><a href="#6.2.3.2">6.2.3.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/palindrome-linked-list/">LeetCode 234.回文链表</a></td><td><a href="#6.2.3.3">6.2.3.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">LeetCode 剑指 Offer 22.链表中倒数第k个节点</a></td><td><a href="#6.2.3.4">6.2.3.4题解</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">LeetCode 19.删除链表的倒数第 N 个结点</a></td><td><a href="#6.2.3.5">6.2.3.5题解</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/rotate-list/">LeetCode 61.旋转链表</a></td><td><a href="#6.2.3.6">6.2.3.6题解</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/add-two-numbers/description/">LeetCode 2.两数相加</a></td><td><a href="#6.2.3.7">6.2.3.7题解</a></td></tr><tr><td>⑧</td><td><a href="https://leetcode.cn/problems/add-two-numbers-ii/">LeetCode 445.两数相加II</a></td><td><a href="#6.2.3.8">6.2.3.8题解</a></td></tr></tbody></table></div><p><span id="6.2.3.1"></span>  </p><h3 id="6-2-3-1-链表的中间结点"><a href="#6-2-3-1-链表的中间结点" class="headerlink" title="6.2.3.1 链表的中间结点"></a>6.2.3.1 链表的中间结点</h3><p><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">LeetCode 876.链表的中间结点</a> | | <a href="#6.2.3">返回目录6.2.3</a></p><font color="#3399FF">思路：这是链表快慢双指针的典型应用，即“寻找链表的中间结点”。  正常来讲，可以先遍历一遍链表，统计链表长度 N, 然后第二遍遍历 N/2 次基本就能找到中间结点。  但是使用快慢指针只需要O(N/2)即可找到中间结点。这里来稍微总结一下找链表中点的两种情况：</font><font color="green">方案一：fast指针从头结点出发，那么slow指针最后要么正好是中间点(奇数链表),要么是中间两个结点的后一个(偶数链表) 。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">slow, fast = head, head</span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">    slow = slow.<span class="built_in">next</span></span><br><span class="line">    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>方案二：fast从第二个结点开始出发，slow最后要么正好是中间点(奇数链表),要么是中间两个结点的前一个(偶数链表)。  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">slow, fast = head, head.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">    slow = slow.<span class="built_in">next</span></span><br><span class="line">    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><b>根据不同的需求，选用不同的fast指针起始点。</b></font> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">middleNode</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;由于此题要找的是 中间or偏后的结点，所以选用上述的方案 一 &#x27;&#x27;&#x27;</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="6.2.3.2"></span>  </p><h3 id="6-2-3-2-删除链表的中间节点"><a href="#6-2-3-2-删除链表的中间节点" class="headerlink" title="6.2.3.2 删除链表的中间节点"></a>6.2.3.2 删除链表的中间节点</h3><p><a href="https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/">LeetCode 2095.删除链表的中间节点</a> | | <a href="#6.2.3">返回目录6.2.3</a></p><font color="#3399FF">思路：这里要删除的是中间链表，或者是中间两个链表中的右侧链表。所以采取之前讲过的方案一，来寻求中间结点。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteMiddle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 因为可能会删除首结点，所以这里搞一个哑结点</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        <span class="comment"># fast从头结点开始，</span></span><br><span class="line">        pre, slow, fast = dummy, head, head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            pre = slow</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># slow就是我们要删除的那个中间点    </span></span><br><span class="line">        pre.<span class="built_in">next</span> = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><span id="6.2.3.3"></span>  </p><h3 id="6-2-3-3-回文链表"><a href="#6-2-3-3-回文链表" class="headerlink" title="6.2.3.3 回文链表"></a>6.2.3.3 回文链表</h3><p><a href="https://leetcode.cn/problems/palindrome-linked-list/">LeetCode 234.回文链表</a> | | <a href="#6.2.3">返回目录6.2.3</a></p><font color="#3399FF">思路：所谓回文链表，就是指链表的前后两半数据，是不是以中间轴为对称的关系。换句话说，只要将链表的后一半数据逆序，然后看看与前一半是否相等，即可。 后一半的起始结点如何判断？      1. 如果链表个数为奇数，那么就是中间那个结点本身为对称轴，既不算在前一半，也不算在后一半。后一半从中间结点的下一个开始算起。    2. 如果链表个数为偶数，那么中间的两个结点之间为对称轴，两个结点中的右侧的结点是后一半的起始结点。    为了统一表达形式，可以看做两个结点中的左侧结点的下一个结点，是后一半的起始结点。  故此，我们需要找到中间结点（奇数个链表结点），或者中间左侧结点（偶数个链表结点）--> 这就是上面提到的链表中点的 【方案二】；然后取该结点的下一位，作为后一半的“头结点”，表达形式就完成统一了。  然后只需要将后一半的逆序，再与前一半一一对比即可。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        slow, fast = head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast= fast.<span class="built_in">next</span>.<span class="built_in">next</span> </span><br><span class="line">        <span class="comment"># 循环结束后，slow指向中间结点，或者中间两个中靠左侧的结点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将右侧的链表进行逆序</span></span><br><span class="line">        pre, cur = <span class="literal">None</span>, slow.<span class="built_in">next</span> </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            rest = cur.<span class="built_in">next</span> </span><br><span class="line">            cur.<span class="built_in">next</span> = pre </span><br><span class="line">            pre = cur </span><br><span class="line">            cur = rest</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 左右两部分进行对比</span></span><br><span class="line">        left, right = head, pre </span><br><span class="line">        <span class="keyword">while</span> right:</span><br><span class="line">            <span class="keyword">if</span> right.val != left.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            right = right.<span class="built_in">next</span> </span><br><span class="line">            left = left.<span class="built_in">next</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        每个循环都只遍历了 一半的链表，所以时间复杂度是O(3N/2)-&gt;O(N)</span></span><br><span class="line"><span class="string">        只使用了有限个辅助变量，空间复杂度是O(1)</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><span id="6.2.3.4"></span>  </p><h3 id="6-2-3-4-链表中倒数第k个节点"><a href="#6-2-3-4-链表中倒数第k个节点" class="headerlink" title="6.2.3.4 链表中倒数第k个节点"></a>6.2.3.4 链表中倒数第k个节点</h3><p><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">LeetCode 剑指 Offer 22.链表中倒数第k个节点</a> | | <a href="#6.2.3">返回目录6.2.3</a></p><font color="#3399FF">思路：利用快慢指针，快指针先走K步之后（遍历完k个结点），慢指针再启动；（即快指针指向k+1结点的时候，慢指针指向head结点）此时还剩下 n-k 个结点，等快指针遍历完序要遍历 n-k 次（此时快指针指向None结点）；慢指针也走了 n-k 次，当前正好指向倒数第k个结点。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getKthFromEnd</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> head </span><br><span class="line"></span><br><span class="line">        fast, slow = head, head </span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            <span class="keyword">if</span> cnt &gt; k:</span><br><span class="line">                <span class="comment"># 慢指针仅在快指针超过k个点的情况下才往后遍历</span></span><br><span class="line">                slow = slow.<span class="built_in">next</span> </span><br><span class="line">            fast = fast.<span class="built_in">next</span> </span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow </span><br><span class="line">        </span><br></pre></td></tr></table></figure><p><span id="6.2.3.5"></span>  </p><h3 id="6-2-3-5-删除链表的倒数第-N-个结点"><a href="#6-2-3-5-删除链表的倒数第-N-个结点" class="headerlink" title="6.2.3.5 删除链表的倒数第 N 个结点"></a>6.2.3.5 删除链表的倒数第 N 个结点</h3><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">LeetCode 19.删除链表的倒数第 N 个结点</a> | | <a href="#6.2.3">返回目录6.2.3</a></p><font color="#3399FF">思路：和上一题的本质是一样的，先要定位到倒数第 k 个结点，然后再做删除操作。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>,head)</span><br><span class="line">        fast, slow, pre = head, head, dummy</span><br><span class="line">        k = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            <span class="comment"># 慢指针仅在快指针超过k个点的情况下才往后遍历</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n:</span><br><span class="line">                pre = pre.<span class="built_in">next</span></span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            k+=<span class="number">1</span></span><br><span class="line">        pre.<span class="built_in">next</span> = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><span id="6.2.3.6"></span>  </p><h3 id="6-2-3-6-旋转链表"><a href="#6-2-3-6-旋转链表" class="headerlink" title="6.2.3.6 旋转链表"></a>6.2.3.6 旋转链表</h3><p><a href="https://leetcode.cn/problems/rotate-list/">LeetCode 61.旋转链表</a> | | <a href="#6.2.3">返回目录6.2.3</a></p><font color="#3399FF">思路：观察示例可以发现，旋转后的链表，其实新的头结点，就是原来的倒数第 k 个结点。所以本质思路和上面两道题是一样的，只不过这里要注意，k 可能会大于链表长度，所以要先遍历一道链表，确定其长度，然后再对k求模。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotateRight</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> head </span><br><span class="line">        <span class="comment"># 1.计算链表长度</span></span><br><span class="line">        cnt, cur = <span class="number">1</span>, head </span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            cnt+=<span class="number">1</span></span><br><span class="line">            cur= cur.<span class="built_in">next</span> </span><br><span class="line">        <span class="comment"># cur 此时指向最后一个结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2.求模</span></span><br><span class="line">        N = k % cnt </span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> head </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3.原链表首尾相连成环</span></span><br><span class="line">        cur.<span class="built_in">next</span> = head</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 向右移动 k 个位置，其实等效于成环之后，原倒数第k个结点做新的头结点</span></span><br><span class="line">        <span class="comment"># 所以问题转化为 定位倒数第 k 个结点</span></span><br><span class="line">        fast, slow, pre = head, head, cur</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= cnt:</span><br><span class="line">            <span class="keyword">if</span> i &gt; N:</span><br><span class="line">                pre = pre.<span class="built_in">next</span></span><br><span class="line">                slow = slow.<span class="built_in">next</span> </span><br><span class="line">            fast = fast.<span class="built_in">next</span>  </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 此时slow指向倒数第k个结点，可以作为新的头结点，在此处断开环</span></span><br><span class="line">        pre.<span class="built_in">next</span> = <span class="literal">None</span> </span><br><span class="line">        <span class="keyword">return</span> slow </span><br></pre></td></tr></table></figure><p><span id="6.2.3.7"></span>  </p><h3 id="6-2-3-7-两数相加"><a href="#6-2-3-7-两数相加" class="headerlink" title="6.2.3.7 两数相加"></a>6.2.3.7 两数相加</h3><p><a href="https://leetcode.cn/problems/add-two-numbers/description/">LeetCode 2.两数相加</a>| | <a href="#6.2.3">返回目录6.2.3</a></p><font color="#3399FF">思路：此题和 【LeetCode 415.字符串相加】这一题本质是一样的，区别在于，我们无法直接获得链表的长度。但是由于题目中提及是逆序存储的数字，且返回的也是相同形式（即逆序）相当于简化了这个题。只要每个位置对应相加即可。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line"></span><br><span class="line">        cur1, cur2, dummy = l1, l2, ListNode(<span class="number">0</span>)</span><br><span class="line">        add = <span class="number">0</span></span><br><span class="line">        pre = dummy</span><br><span class="line">        <span class="keyword">while</span> add&gt;<span class="number">0</span> <span class="keyword">or</span> cur1 <span class="keyword">or</span> cur2:</span><br><span class="line">            <span class="keyword">if</span> cur1: </span><br><span class="line">                a = cur1.val </span><br><span class="line">                cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur2: </span><br><span class="line">                b = cur2.val </span><br><span class="line">                cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            digit = (a+b+add) % <span class="number">10</span></span><br><span class="line">            add = (a+b+add-digit) // <span class="number">10</span></span><br><span class="line">            pre.<span class="built_in">next</span> = ListNode(digit) </span><br><span class="line">            pre = pre.<span class="built_in">next</span> </span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><span id="6.2.3.8"></span>  </p><h3 id="6-2-3-8-两数相加II"><a href="#6-2-3-8-两数相加II" class="headerlink" title="6.2.3.8 两数相加II"></a>6.2.3.8 两数相加II</h3><p><a href="https://leetcode.cn/problems/add-two-numbers-ii/">LeetCode 445.两数相加II</a>| | <a href="#6.2.3">返回目录6.2.3</a></p><font color="#3399FF">思路：此题是上一题的升级版，因为顺序变成正序了。可以先反转两个链表，然后基本就和上一题差不多。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse_linklist</span>(<span class="params">head</span>):</span><br><span class="line">            pre, cur = <span class="literal">None</span>, head </span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                rest = cur.<span class="built_in">next</span> </span><br><span class="line">                cur.<span class="built_in">next</span> = pre</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = rest </span><br><span class="line">            <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">        cur1, cur2 = reverse_linklist(l1), reverse_linklist(l2)</span><br><span class="line">        <span class="comment"># pre = dummy</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;可以选择上一题一样的做法，先逆序构造链表，然后在调用逆序函数处理一次；</span></span><br><span class="line"><span class="string">        但是这样时间消耗的有点多；</span></span><br><span class="line"><span class="string">        所以对code做了一点改动，生成链表的时候，直接逆序着生成&#x27;&#x27;&#x27;</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> add&gt;<span class="number">0</span> <span class="keyword">or</span> cur1 <span class="keyword">or</span> cur2:</span><br><span class="line">            <span class="keyword">if</span> cur1: </span><br><span class="line">                a = cur1.val </span><br><span class="line">                cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> cur2: </span><br><span class="line">                b = cur2.val </span><br><span class="line">                cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            digit = (a+b+add) % <span class="number">10</span></span><br><span class="line">            add = (a+b+add-digit) // <span class="number">10</span></span><br><span class="line">            <span class="comment"># pre.next = ListNode(digit) </span></span><br><span class="line">            cur = ListNode(digit)</span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur </span><br><span class="line"></span><br><span class="line">        <span class="comment"># return reverse_linklist(dummy.next)</span></span><br><span class="line">        <span class="keyword">return</span> pre </span><br></pre></td></tr></table></figure><p><span id="6.2.4"></span>  </p><h2 id="6-2-4-链表排序部分"><a href="#6-2-4-链表排序部分" class="headerlink" title="6.2.4 链表排序部分"></a>6.2.4 链表排序部分</h2><div class="table-container"><table><thead><tr><th>序号</th><th><strong><a href="#6.2.4">链表排序部分</a></strong></th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">LeetCode 21.合并两个有序链表</a></td><td><a href="#6.2.4.1">6.2.4.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">LeetCode 23.合并 K 个升序链表</a></td><td><a href="#6.2.4.2">6.2.4.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/sort-list/">LeetCode 148.排序链表</a></td><td><a href="#6.2.4.3">6.2.4.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/insertion-sort-list/">LeetCode 147.对链表进行插入排序</a></td><td><a href="#6.2.4.4">6.2.4.4题解</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/odd-even-linked-list/">LeetCode 328.奇偶链表</a></td><td><a href="#6.2.4.5">6.2.4.5题解</a></td></tr></tbody></table></div><p><span id="6.2.4.1"></span>  </p><h3 id="6-2-4-1-合并两个有序链表"><a href="#6-2-4-1-合并两个有序链表" class="headerlink" title="6.2.4.1 合并两个有序链表"></a>6.2.4.1 合并两个有序链表</h3><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">LeetCode 21.合并两个有序链表</a>| |<a href="#6.2.4">返回目录6.2.4</a> </p><font color="#3399FF">思路1 ：对于两个有序部分合并成一个新的有序部分，很自然会想到归并排序中的归并操作。</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1 <span class="keyword">and</span> <span class="keyword">not</span> list2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> list1:</span><br><span class="line">            <span class="keyword">return</span> list2</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> list2:</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur1, cur2 = list1, list2</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;1.利用辅助数组&#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="comment"># q = []</span></span><br><span class="line">            <span class="comment"># while cur1 and cur2:</span></span><br><span class="line">            <span class="comment">#     if cur1.val &lt;= cur2.val:</span></span><br><span class="line">            <span class="comment">#         q.append(cur1)</span></span><br><span class="line">            <span class="comment">#         cur1 = cur1.next</span></span><br><span class="line">            <span class="comment">#     else:</span></span><br><span class="line">            <span class="comment">#         q.append(cur2)</span></span><br><span class="line">            <span class="comment">#         cur2 = cur2.next</span></span><br><span class="line">            <span class="comment"># while cur1:</span></span><br><span class="line">            <span class="comment">#     q.append(cur1)</span></span><br><span class="line">            <span class="comment">#     cur1 = cur1.next</span></span><br><span class="line">            <span class="comment"># while cur2:</span></span><br><span class="line">            <span class="comment">#     q.append(cur2)</span></span><br><span class="line">            <span class="comment">#     cur2 = cur2.next</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># head = q.pop(0)</span></span><br><span class="line">            <span class="comment"># cur = head</span></span><br><span class="line">            <span class="comment"># while q:</span></span><br><span class="line">            <span class="comment">#     node = q.pop(0)</span></span><br><span class="line">            <span class="comment">#     cur.next = node</span></span><br><span class="line">            <span class="comment">#     cur = cur.next</span></span><br><span class="line">            <span class="comment"># cur.next = None</span></span><br><span class="line">            <span class="comment"># return head</span></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;2.不用辅助数组，只用几个辅助node&#x27;&#x27;&#x27;</span></span><br><span class="line">            dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">            pre = dummy</span><br><span class="line">            <span class="keyword">while</span> cur1 <span class="keyword">and</span> cur2:</span><br><span class="line">                <span class="keyword">if</span> cur1.val &lt;= cur2.val:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur1</span><br><span class="line">                    pre = cur1</span><br><span class="line">                    cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur2</span><br><span class="line">                    pre = cur2</span><br><span class="line">                    cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> cur1:</span><br><span class="line">                <span class="comment"># 如果此时cur1不为空，说明上面最后一个node一定来自于cur2</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur1</span><br><span class="line">            <span class="keyword">if</span> cur2:</span><br><span class="line">                <span class="comment"># 如果此时cur2不为空，说明上面最后一个node一定来自于cur1</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur2</span><br><span class="line">            <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><font color="#3399FF">思路2: 递归操作</font><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> list1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> list2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> list1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> list2</span><br><span class="line">        <span class="keyword">elif</span> list2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">elif</span> list1.val &lt;= list2.val:</span><br><span class="line">            <span class="comment"># 当前list1点的值更小, 那么就让list1的后面部分去和list2做过合并</span></span><br><span class="line">            list1.<span class="built_in">next</span> = self.mergeTwoLists(list1.<span class="built_in">next</span>,list2)</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 当前list2点的值更小, 那么就让list2的后面部分去和list1做过合并</span></span><br><span class="line">            list2.<span class="built_in">next</span> = self.mergeTwoLists(list1,list2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> list2</span><br></pre></td></tr></table></figure><p><span id="6.2.4.2"></span>  </p><h3 id="6-2-4-2-合并-K-个升序链表"><a href="#6-2-4-2-合并-K-个升序链表" class="headerlink" title="6.2.4.2 合并 K 个升序链表"></a>6.2.4.2 合并 K 个升序链表</h3><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">LeetCode 23.合并 K 个升序链表</a>| | <a href="#6.2.4">返回目录6.2.4</a></p><font color="#3399FF">思路1：该题是上题的加强版，从合并2个链表变为合并k个链表。那么比较自然的想法就是，先写出合并两个链表的函数，再对链表的list进行依次两两合并即可。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 直接复用上一题的合并两个链表的函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge_two_linklist</span>(<span class="params">head1: <span class="type">Optional</span>[ListNode], head2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head1 <span class="keyword">and</span> <span class="keyword">not</span> head2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> head1:</span><br><span class="line">                <span class="keyword">return</span> head2</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> head2:</span><br><span class="line">                <span class="keyword">return</span> head1</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">                pre = dummy</span><br><span class="line">                cur1, cur2 = head1, head2</span><br><span class="line">                <span class="keyword">while</span> cur1 <span class="keyword">and</span> cur2:</span><br><span class="line">                    <span class="keyword">if</span> cur1.val &lt; cur2.val:</span><br><span class="line">                        pre.<span class="built_in">next</span> = cur1</span><br><span class="line">                        pre = pre.<span class="built_in">next</span></span><br><span class="line">                        cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        pre.<span class="built_in">next</span> = cur2</span><br><span class="line">                        pre = pre.<span class="built_in">next</span></span><br><span class="line">                        cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> cur1:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur1</span><br><span class="line">                <span class="keyword">if</span> cur2:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur2</span><br><span class="line">            <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 思路1：从头到尾依次两两合并，耗费时间明显会很多</span></span><br><span class="line">        res_node = lists[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(lists)):</span><br><span class="line">            res_node = merge_two_linklist(res_node, lists[i])</span><br><span class="line">        <span class="keyword">return</span> res_node</span><br></pre></td></tr></table></figure><font color="#3399FF">思路 2：两两之间先合并，然后合并后的链表再两两之间合并。换句话说，就是使用二分法，进行递归操作，减少时间复杂度。</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 直接复用上一题的合并两个链表的函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge_two_linklist</span>(<span class="params">head1: <span class="type">Optional</span>[ListNode], head2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head1 <span class="keyword">and</span> <span class="keyword">not</span> head2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> head1:</span><br><span class="line">                <span class="keyword">return</span> head2</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> head2:</span><br><span class="line">                <span class="keyword">return</span> head1</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">                pre = dummy</span><br><span class="line">                cur1, cur2 = head1, head2</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> cur1 <span class="keyword">and</span> cur2:</span><br><span class="line">                    <span class="keyword">if</span> cur1.val &lt; cur2.val:</span><br><span class="line">                        pre.<span class="built_in">next</span> = cur1</span><br><span class="line">                        pre = pre.<span class="built_in">next</span></span><br><span class="line">                        cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        pre.<span class="built_in">next</span> = cur2</span><br><span class="line">                        pre = pre.<span class="built_in">next</span></span><br><span class="line">                        cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> cur1:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur1</span><br><span class="line">                <span class="keyword">if</span> cur2:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur2</span><br><span class="line">            <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 思路2： 既然是两两合并，很明显可以用二分法的思想，分而治之，用递归进行，耗时明显下降</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge_k_linklist</span>(<span class="params">lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]], Left:<span class="built_in">int</span>, Right:<span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">            <span class="keyword">if</span> Left == Right:</span><br><span class="line">                <span class="keyword">return</span> lists[Left]</span><br><span class="line">            M = (Right-Left)//<span class="number">2</span> + Left</span><br><span class="line"></span><br><span class="line">            L_node = merge_k_linklist(lists, Left, M)</span><br><span class="line">            R_node = merge_k_linklist(lists, M+<span class="number">1</span>, Right)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> merge_two_linklist(L_node, R_node)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  merge_k_linklist(lists, <span class="number">0</span>, <span class="built_in">len</span>(lists)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><span id="6.2.4.3"></span>  </p><h3 id="6-2-4-3-排序链表"><a href="#6-2-4-3-排序链表" class="headerlink" title="6.2.4.3 排序链表"></a>6.2.4.3 排序链表</h3><p><a href="https://leetcode.cn/problems/sort-list/">LeetCode 148.排序链表</a>| | <a href="#6.2.4">返回目录6.2.4</a></p><font color="#3399FF">思路：可以使用归并排序的思路。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">MergeTwoList</span>(<span class="params">list1:<span class="type">Optional</span>[ListNode], list2:<span class="type">Optional</span>[ListNode]</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> list1 <span class="keyword">and</span> <span class="keyword">not</span> list2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> list2:</span><br><span class="line">                <span class="keyword">return</span> list1</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> list1:</span><br><span class="line">                <span class="keyword">return</span> list2</span><br><span class="line">            <span class="keyword">elif</span> list1 == list2:</span><br><span class="line">                <span class="keyword">return</span> list1 </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 因为考虑到要使用递归操作，所以这里不创建哑结点</span></span><br><span class="line">                <span class="comment"># 否则可能会创建很多无用的哑结点，浪费内存</span></span><br><span class="line">                cur1, cur2 = list1, list2 </span><br><span class="line">                <span class="keyword">if</span> cur1.val &lt;= cur2.val:</span><br><span class="line">                    head, cur1 = cur1, cur1.<span class="built_in">next</span> </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    head, cur2 = cur2, cur2.<span class="built_in">next</span></span><br><span class="line">                pre = head </span><br><span class="line">                <span class="keyword">while</span> cur1 <span class="keyword">and</span> cur2:</span><br><span class="line">                    <span class="keyword">if</span> cur1.val &lt;= cur2.val:</span><br><span class="line">                        pre.<span class="built_in">next</span> = cur1 </span><br><span class="line">                        pre = pre.<span class="built_in">next</span></span><br><span class="line">                        cur1 = cur1.<span class="built_in">next</span> </span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        pre.<span class="built_in">next</span> = cur2 </span><br><span class="line">                        pre = pre.<span class="built_in">next</span></span><br><span class="line">                        cur2 = cur2.<span class="built_in">next</span> </span><br><span class="line">                <span class="keyword">if</span> cur1:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur1 </span><br><span class="line">                <span class="keyword">if</span> cur2:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur2 </span><br><span class="line">            <span class="keyword">return</span> head </span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">MergeSort</span>(<span class="params">start, end</span>):</span><br><span class="line">            <span class="keyword">if</span> start <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> start.<span class="built_in">next</span> == end:</span><br><span class="line">                <span class="comment"># 在定义的MergeSort函数的时候，规定的是end位置的结点是不取的</span></span><br><span class="line">                <span class="comment"># 比如最外层调用时传入的是 MergeSort(head, None)</span></span><br><span class="line">                <span class="comment"># 所以 start.next == end 的情况，就是在说，当前部分只有一个结点</span></span><br><span class="line">                <span class="comment"># 同时一定要注意，需要在这里将start彻底断开，使其真的成为一个孤立结点</span></span><br><span class="line">                start.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">return</span> start</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 然后使用快慢指针寻找中间结点</span></span><br><span class="line">            slow, fast = start, start</span><br><span class="line">            <span class="comment"># 需要注意的是此时 fast的终点是 end，一定不要遗漏这一点</span></span><br><span class="line">            <span class="keyword">while</span> fast != end <span class="keyword">and</span> fast.<span class="built_in">next</span> != end:</span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">                fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># slow指向中间结点，或者中间二结点的右边那个结点</span></span><br><span class="line">            mid = slow</span><br><span class="line">            </span><br><span class="line">            left_h = MergeSort(start,mid)</span><br><span class="line">            <span class="comment"># 这里也要注意，右侧的起始点是 mid，因为根据定义左侧部分是不取mid结点的</span></span><br><span class="line">            right_h = MergeSort(mid, end)</span><br><span class="line">            <span class="keyword">return</span> merge_two_linklist(left_h, right_h)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># MergeSort函数也有另一种写法，即末尾head2规定可以取到的情况</span></span><br><span class="line">        <span class="comment"># def MergeSort(head1, head2):</span></span><br><span class="line">        <span class="comment">#     if head1 is None or  head1.next is None:</span></span><br><span class="line">        <span class="comment">#         return head1</span></span><br><span class="line">        <span class="comment">#     if head1 == head2:</span></span><br><span class="line">        <span class="comment">#     # 此时，判断是否是一个结点的条件就变为了 head1==head2</span></span><br><span class="line">        <span class="comment">#     # 同样要将 head1 断开</span></span><br><span class="line">        <span class="comment">#         head1.next = None</span></span><br><span class="line">        <span class="comment">#         return head1</span></span><br><span class="line">        <span class="comment">#     # 然后快慢结点的写法也稍作修改，找寻中间二结点中左侧的那个结点</span></span><br><span class="line">        <span class="comment">#     slow, fast = head1, head1.next</span></span><br><span class="line">        <span class="comment">#     while fast != head2 and fast.next != head2:</span></span><br><span class="line">        <span class="comment">#         slow = slow.next</span></span><br><span class="line">        <span class="comment">#         fast = fast.next.next</span></span><br><span class="line">        <span class="comment">#     left_end = slow</span></span><br><span class="line">        <span class="comment">#     right_start = slow.next</span></span><br><span class="line">        <span class="comment">#     # 因为规定了head2部分可以取到，所以left_end就要填入左侧的递归函数中</span></span><br><span class="line">        <span class="comment">#     left_h = MergeSort(head1, left_end)</span></span><br><span class="line">        <span class="comment">#     right_h = MergeSort(right_start, head2)</span></span><br><span class="line">        <span class="comment">#     return merge_two_linklist(left_h, right_h)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> MergeSort(head, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><span id="6.2.4.4"></span>  </p><h3 id="6-2-4-4-对链表进行插入排序"><a href="#6-2-4-4-对链表进行插入排序" class="headerlink" title="6.2.4.4 对链表进行插入排序"></a>6.2.4.4 对链表进行插入排序</h3><p><a href="https://leetcode.cn/problems/insertion-sort-list/">LeetCode 147.对链表进行插入排序</a>| |<a href="#6.2.4">返回目录6.2.4</a></p><font color="#3399FF">思路：因如果链表只有一个结点，默认有序；所以我们从第二个结点开始遍历，每一次都需要去该结点之前，对比数字的大小，并在适当的位置进行结点插入。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertionSortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        <span class="comment"># 从第二个结点开始遍历</span></span><br><span class="line">        tail, cur = head, head.<span class="built_in">next</span> </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> tail.val &lt;= cur.val:</span><br><span class="line">                <span class="comment"># 先就近对比tail和cur</span></span><br><span class="line">                tail = cur</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 将cur从链表中先断开</span></span><br><span class="line">                tail.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 从head开始到tail之前找</span></span><br><span class="line">                pre = dummy</span><br><span class="line">                <span class="keyword">while</span> pre.<span class="built_in">next</span>.val &lt;= cur.val:</span><br><span class="line">                    pre = pre.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 因为上面先判断了和tail的大小关系</span></span><br><span class="line">                <span class="comment"># 所以此处的while循环，一定会在tail之前停下来</span></span><br><span class="line">                <span class="comment"># 此时 pre.next.val &gt; cur.val</span></span><br><span class="line">                <span class="comment"># 所以 cur 将会在pre和pre.next中间插入</span></span><br><span class="line">                cur.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur</span><br><span class="line">            <span class="comment"># 更新cur</span></span><br><span class="line">            cur = tail.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span> </span><br></pre></td></tr></table></figure><p><span id="6.2.4.5"></span>  </p><h3 id="6-2-4-5-奇偶链表"><a href="#6-2-4-5-奇偶链表" class="headerlink" title="6.2.4.5 奇偶链表"></a>6.2.4.5 奇偶链表</h3><p><a href="https://leetcode.cn/problems/odd-even-linked-list/">LeetCode 328.奇偶链表</a>| | <a href="#6.2.4">返回目录6.2.4</a></p><font color="#3399FF">思路：创建两个头结点，一个用来连接奇数结点，另一个用来链接偶数结点。最后将两个链表合并。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">oddEvenList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span> <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            <span class="comment"># 如果结点数是0、1、2 直接返回head</span></span><br><span class="line">            <span class="keyword">return</span> head </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># odd, even = head, head.next </span></span><br><span class="line">        <span class="comment"># 创建两个哑结点，分别作为 奇偶链表的头结点</span></span><br><span class="line">        dummy_odd = ListNode(<span class="number">0</span>,head)</span><br><span class="line">        dummy_even = ListNode(<span class="number">0</span>,head.<span class="built_in">next</span>)</span><br><span class="line">        pre_odd, pre_even, cur = dummy_odd, dummy_even, head</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 遍历的时候判断当前是 奇数 还是 偶数 即可</span></span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                pre_odd.<span class="built_in">next</span> = cur </span><br><span class="line">                pre_odd = cur </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre_even.<span class="built_in">next</span> = cur </span><br><span class="line">                pre_even = cur </span><br><span class="line">            cur = cur.<span class="built_in">next</span> </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        pre_odd.<span class="built_in">next</span> = dummy_even.<span class="built_in">next</span> </span><br><span class="line">        pre_even.<span class="built_in">next</span> = <span class="literal">None</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy_odd.<span class="built_in">next</span> </span><br></pre></td></tr></table></figure><p><span id="6.2.5"></span>  </p><h2 id="6-2-5-链表有环与相交"><a href="#6-2-5-链表有环与相交" class="headerlink" title="6.2.5 链表有环与相交"></a>6.2.5 链表有环与相交</h2><div class="table-container"><table><thead><tr><th>序号</th><th><strong><a href="#6.2.5">链表有环与相交</a></strong></th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/linked-list-cycle/">LeetCode 141.环形链表</a></td><td><a href="#6.2.5.1">6.2.5.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">LeetCode 142.环形链表II</a></td><td><a href="#6.2.5.2">6.2.5.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">LeetCode 160.相交链表</a></td><td><a href="#6.2.5.3">6.2.5.3题解</a></td></tr><tr><td>④</td><td><a href="##6.2.5.4">有环链表相交的情况</a></td><td><a href="#6.2.5.4">6.2.5.4题解</a></td></tr></tbody></table></div><p><span id="6.2.5.1"></span>  </p><h3 id="6-2-5-1-环形链表"><a href="#6-2-5-1-环形链表" class="headerlink" title="6.2.5.1 环形链表"></a>6.2.5.1 环形链表</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle/">LeetCode 141.环形链表</a>| | <a href="#6.2.5">返回目录6.2.5</a></p><font color="#3399FF">思路：使用快慢指针，一个跑得快，一个跑得慢，如果快指针反而与慢指针相遇，则一定是有环的。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><span id="6.2.5.2"></span>  </p><h3 id="6-2-5-2-环形链表-II"><a href="#6-2-5-2-环形链表-II" class="headerlink" title="6.2.5.2 环形链表 II"></a>6.2.5.2 环形链表 II</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">LeetCode 142.环形链表II</a>| | <a href="#6.2.5">返回目录6.2.5</a></p><font color="#3399FF">思路：这是上一题的升级版，不光要判断是否有环，还要返回入环的那个结点。  通过上一个题，我们已经知道如何判断有环。  在有环的情况下，开始寻找入环结点：再设置两个游标，cur1从快慢指针相遇点开始，cur2从头结点开始，每次都只走一步，这两个游标再一次相遇的点一定是入环结点</font>  <p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/6_2_5_2.webp" width="100%">   </p><font color="green">因为fast指针是一步走两个节点，slow指针一步走一个节点，所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：  x + y + n (z + y) = (x + y) * 2 , n>=1两边消掉一个（x+y）得: x + y = n (z + y) 求 x 的表达式的：x = n (z + y) - y = (n-1)*(z + y) + z  x = (n-1)*环 + z  这个等式意味着:如果另一个指针cur2从头结点开始走，走过x步；必然和从相遇点出发的cur1指针，在环的入口处相遇!我们不用管cur1在环内究竟转了几圈，只要关注cur2几时能遇到cur1即可。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                <span class="comment"># 说明有环</span></span><br><span class="line">                cur1, cur2 = head, slow</span><br><span class="line">                <span class="keyword">while</span> cur2 != cur1:</span><br><span class="line">                    cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">                    cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> cur2</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><span id="6.2.5.3"></span>  </p><h3 id="6-2-5-3-相交链表"><a href="#6-2-5-3-相交链表" class="headerlink" title="6.2.5.3 相交链表"></a>6.2.5.3 相交链表</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">LeetCode 160.相交链表</a>| | <a href="#6.2.5">返回目录6.2.5</a></p><blockquote><p><strong>题目数据保证整个链式结构中不存在环</strong>。     </p></blockquote><font color="#3399FF">思路 1.比较直接的思想是用哈希表来查询。只不过这样需要消耗较多的空间。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        curA = headA</span><br><span class="line">        curB = headB</span><br><span class="line">        hast_a = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> curA <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            hast_a[curA] = <span class="number">1</span></span><br><span class="line">            curA=curA.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> curB <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> curB <span class="keyword">in</span> hast_a:</span><br><span class="line">                <span class="keyword">return</span> curB</span><br><span class="line">            curB=curB.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><font color="#3399FF">思路 2.不用哈希表，这样比较省空间。+ 两个链表依次分别遍历，指针a负责遍历链表A，指针b负责遍历链表B，+ 若指针a指向了链表A的末尾，那么指针a就转头指向链表B，+ 同理指针b在指到末尾时也转头指向链表A，继续依次遍历。+ 当下一次指针a或者指针b其中一个又来到链表末尾，仍未找到相交结点，则确实没有相交。+ （一定要注意，指针a和指针b这个转向另外一个链表去遍历的行为，只能做一次，）+ 否则，在之前的遍历中，一定能够找到那个相交结点。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        curA = headA</span><br><span class="line">        curB = headB</span><br><span class="line">        <span class="comment"># 设置统计两个游标转换链表次数的flag变量</span></span><br><span class="line">        end_a, end_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 遍历过程中发现相同的结点，即可返回</span></span><br><span class="line">            <span class="keyword">if</span> curA == curB:</span><br><span class="line">                <span class="keyword">return</span> curA</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 依次遍历</span></span><br><span class="line">                curA = curA.<span class="built_in">next</span></span><br><span class="line">                curB = curB.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 当游标a来到链表的末尾，就在不触发flag的条件下，转向另一个链表</span></span><br><span class="line">                <span class="keyword">if</span> curA <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="comment"># end_a +1 表示链表A已经遍历完成过一次</span></span><br><span class="line">                    end_a +=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> end_a &lt; <span class="number">2</span>:</span><br><span class="line">                        curA = headB</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">                <span class="comment"># 当游标b来到链表的末尾，就在不触发flag的条件下，转向另一个链表</span></span><br><span class="line">                <span class="keyword">if</span> curB <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="comment"># end_b +1 表示链表B已经遍历完成过一次</span></span><br><span class="line">                    end_b +=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> end_b &lt; <span class="number">2</span>:</span><br><span class="line">                        curB = headA</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><span id="6.2.5.4"></span>  </p><h3 id="6-2-5-4-有环链表相交"><a href="#6-2-5-4-有环链表相交" class="headerlink" title="6.2.5.4 有环链表相交"></a>6.2.5.4 有环链表相交</h3><p><a href="#6.2.5">返回目录6.2.5</a></p><blockquote><p>那么如果问题是有环的链表相交呢？没有在LeetCode上找到对应的题目，但是这里也拿出来讨论一下。</p></blockquote><font color="green">  无环链表相交的情况上一题已经讨论。对于有环链表，首先，可以排除一个有环，一个无环的情况，这种情况必不可能相交。所以，【有环】链表相交，一定是【两个都有环】链表的情况。分为3种情况：  ①不相交，各自有环②共用一个环，环外相交于一个点（或刚好入环点），然后才出现环。&emsp;这种情况，我们可以忽略那个环，就成了【从头结点到入环结点这段区间】的无环单链表相交的问题了。③环外不相交，各自从不同的结点入环。&emsp;这种情况，从入环结点CircleA开始沿着环移动，回到CircleA之前，会遇到另一入环结点CircleB。可以看到，要处理这个问题，就需要用到上面两个问题作为子问题：链表求环，链表相交。代码可能比较长，但确实逻辑上很清楚。</font><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;1.判断是否有环 &amp; 求入环结点的函数&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                <span class="comment"># 说明有环</span></span><br><span class="line">                cur1, cur2 = head, slow</span><br><span class="line">                <span class="keyword">while</span> cur2 != cur1:</span><br><span class="line">                    cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">                    cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> cur2</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;2.求无环链表相交结点的函数&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode_No_Circle</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 这里采用的是哈希表方法，代码写起来简洁一点</span></span><br><span class="line">        <span class="comment"># 也可以使用另一种方法</span></span><br><span class="line">        curA = headA</span><br><span class="line">        curB = headB</span><br><span class="line">        hast_a = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 遍历链表a，将所有结点装入哈希表</span></span><br><span class="line">        <span class="keyword">while</span> curA <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            hast_a.update(&#123;curA:<span class="number">1</span>&#125;)</span><br><span class="line">            curA=curA.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历链表b，每次都看看b的结点是否在哈希表中已经存在</span></span><br><span class="line">        <span class="keyword">while</span> curB <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> curB <span class="keyword">in</span> hast_a:</span><br><span class="line">                <span class="keyword">return</span> curB</span><br><span class="line">            curB=curB.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;3.求有环链表相交结点的函数&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode_With_Circle</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> headA <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> headB <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 1.判断链表A和B是否有环，如果有的话返回环的结点</span></span><br><span class="line">        Circle_A = self.detectCycle(headA)</span><br><span class="line">        Circle_B = self.detectCycle(headB)</span><br><span class="line">        <span class="comment"># 2.如果两个链表都无环，就使用求无环链表相交结点的函数</span></span><br><span class="line">        <span class="keyword">if</span> Circle_A <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> Circle_B <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.getIntersectionNode_No_Circle(headA, headB)</span><br><span class="line">        <span class="comment"># 3.如果一个有环一个无环，则必不可能相交，</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> Circle_A <span class="keyword">and</span> Circle_B:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> Circle_A <span class="keyword">and</span> <span class="keyword">not</span> Circle_B:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 4.两个链表都有环</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 4.1 两个链表入环结点一样，说明公用一个环,可以当做无环链表处理</span></span><br><span class="line">            <span class="keyword">if</span> Circle_A == Circle_B:</span><br><span class="line">                <span class="keyword">return</span> self.getIntersectionNode_No_Circle(headA, headB)</span><br><span class="line">            <span class="comment"># 4.2 入环结点不一样</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 从链表A的入环结点开始在环里遍历</span></span><br><span class="line">                cur = Circle_A</span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> != Circle_A:</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                    <span class="comment"># 在链表A的环里果然找到链表B的入环结点</span></span><br><span class="line">                    <span class="keyword">if</span> cur == Circle_B:</span><br><span class="line">                        <span class="comment"># 说明两个链表的公用一个环，但入环结点不一样</span></span><br><span class="line">                        <span class="keyword">return</span> Circle_A</span><br><span class="line">                        <span class="comment"># 其实 Circle_B 也是相交点 , 也可以 return Circle_B</span></span><br><span class="line">                        </span><br><span class="line">                <span class="comment"># 循环结束，没有遇到 Circle_B, 说明两个有环链表各自成环，且不相交</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6-1 链表</title>
      <link href="/Data-Structure/DS_61_link_list.html"/>
      <url>/Data-Structure/DS_61_link_list.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="6-1-链表"><a href="#6-1-链表" class="headerlink" title="6-1 链表"></a>6-1 链表</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="6-1-1-单链表"><a href="#6-1-1-单链表" class="headerlink" title="6.1.1 单链表"></a>6.1.1 单链表</h2><p>链表，别名链式存储结构或单链表，是链式存储结构中最简单和最基本的结构，与顺序表不同，链表不限制数据的物理存储状态。换句话说，使用链表存储的数据元素，其物理存储位置是随机的。在存储每个元素的同时，需要存储其直接后继(或直接前驱）的位置，这一部分称为：链。  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/6_1_1_1.webp" width="40%">  </p><h3 id="6-1-1-1-单链表结点"><a href="#6-1-1-1-单链表结点" class="headerlink" title="6.1.1.1 单链表结点"></a>6.1.1.1 单链表结点</h3><p>单向链表的每个元素都由两部分组成，存储元素的 <strong>数据域 data</strong>，和存储直接后继元素地址的 <strong>指针域 next</strong>，这样的一种结构成为结点。在C/C++中，可以用 struct 结构体来实现这个结构，在python中我们可以用class类来实现这种结构：  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/6_1_1_2.webp" width="20%">    </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># node</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="literal">None</span></span>):</span><br><span class="line">        self.val=val</span><br><span class="line">        self.<span class="built_in">next</span>=<span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="6-1-1-2-单链表的实现"><a href="#6-1-1-2-单链表的实现" class="headerlink" title="6.1.1.2 单链表的实现"></a>6.1.1.2 单链表的实现</h3><p>单链表在实现时，又可以分为两种情况：不带头结点的单链表、带头结点的单链表，二者的区别可以从下图中看到：  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/6_1_1_3.webp" width="50%">    </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/6_1_1_4.webp" width="50%">  </p><ul><li>这里所谓的“头结点”，就是指的专门设立一个结点node（上面的第2幅图），<strong>它的指针域保存的（指向的）是第一个实际存储了元素的区域的地址，如果没有元素，就是NULL。</strong> 即不管有没有元素，都有这么一个结点存在。头结点的数据域可以不存储任何信息（也可以存储像线性表的表长那样的数据信息，但一般都不存数据）。通常这个结点也被称为：<strong>哑结点</strong>。</li><li>头结点的作用是使所有链表（包括空表）的头指针非空，把空表和非空表的处理统一起来了，并使对单链表的插入、删除操作不需要区分是否为空表或是否在第一个位置进行，从而与其他位置的插入、删除操作一致。</li><li>比如说如果要删除第一个元素，没有头结点的链表，第一个元素的位置就是h，删除第一个元素之后，h 指针就得更新为原来的第二个元素的位置；但是对于有头结点的单链表，由于 h 指针指向的是头结点，所以删除第一个位置的元素和删除其他位置的元素的操作都是一样的，不需要再更新 h 指针！</li></ul><p>下面给出不带头结点的链表的python实现方式，因为这种情况处理更难一点，弄懂了这种情况的 code 写法，再写带头结点的链表的实现，就会简单很多。<strong>而且在很多场景，其实并没有这么严格的抠字眼说链表带不带头结点，题目中出现的大多数是这里谈及的 “不带头结点” 的单链表，但是也习惯称呼第一个结点为 “头结点”，这并不影响做题 。所以这里只是做一个概念上的了解，知道单链表有这么两种写法即可。在做题时根据实际情况写就行了。</strong>    </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/6_1_1_5.webp" width="60%">  </p><p><b>主要涉及到的，就是链表的<font color="red">增、删、改、查</font>操作。</b> </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># node</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="literal">None</span></span>):</span><br><span class="line">        self.val=val</span><br><span class="line">        self.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single_Link_List</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, node=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        该实现是构造“不带头结点的单链表”</span></span><br><span class="line"><span class="string">        一定要牢记,head就是第一个元素结点,而非head.next.</span></span><br><span class="line"><span class="string">        实际上head.next其实已经是第二个元素结点了</span></span><br><span class="line"><span class="string">        所以下面的某一些操作才会先判断head本身是不是空,即判断链表是否为空，</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.__head = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_random_init</span>(<span class="params">self, n=<span class="number">0</span></span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            self.append(random.randint(<span class="number">0</span>, <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.__head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt, cur = <span class="number">0</span>, self.__head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(cur.val, end=<span class="string">&#x27;-&gt;&#x27;</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">###############【增】###############</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;头插法&#x27;&#x27;&#x27;</span></span><br><span class="line">        node = Node(val)</span><br><span class="line">        node.<span class="built_in">next</span> = self.__head</span><br><span class="line">        self.__head = node</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;尾插法&#x27;&#x27;&#x27;</span></span><br><span class="line">        node, cur = Node(val), self.__head</span><br><span class="line">        <span class="comment"># 这里就需要先判断是否为空,否则None.next会报错</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.__head = node</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 循环结束后，cur指向最后一个数据结点</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;随机位置插入&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 先确保传入的pos属于[0, size]</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;insert pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> pos == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> self.add(val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = Node(val)</span><br><span class="line">                i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">                <span class="comment"># 循环结束后, cur指向pos-1的位置，因为pos的位置要留给node</span></span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos-<span class="number">1</span>:</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># print(&#x27;i:&#x27;,i,end=&#x27;-&gt;&#x27;)</span></span><br><span class="line">                    <span class="comment"># print(cur.val)</span></span><br><span class="line">                node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = node</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【删】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据值来删除第一个符合条件的结点&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;the linklist is empty!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        pre, cur = <span class="literal">None</span>, self.__head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                <span class="comment"># 先要判断是否删除的是首结点</span></span><br><span class="line">                <span class="keyword">if</span> cur == self.__head:</span><br><span class="line">                    <span class="comment"># 更新首结点</span></span><br><span class="line">                    self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">                    cur = self.__head</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                    cur = pre.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">del_pos</span>(<span class="params">self, pos</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据位置来指定删除&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;del pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 先要判断是否删除的是首结点</span></span><br><span class="line">            <span class="keyword">if</span> pos == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 更新首结点</span></span><br><span class="line">                self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line">                pre, cur = <span class="literal">None</span>, self.__head</span><br><span class="line">                <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                    pre = cur</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【改】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, pos: <span class="built_in">int</span>, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据位置改变值&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;change pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">            <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.val = val</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【查】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;依据值来定位位置(索引)&#x27;&#x27;&#x27;</span></span><br><span class="line">        i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;not find %s&#x27;</span> % <span class="built_in">str</span>(val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">locate</span>(<span class="params">self, pos: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;依据索引查找值&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">            <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> cur.val </span><br></pre></td></tr></table></figure><h3 id="6-1-1-3-带头结点单链表的实现"><a href="#6-1-1-3-带头结点单链表的实现" class="headerlink" title="6.1.1.3 带头结点单链表的实现"></a>6.1.1.3 带头结点单链表的实现</h3><p>带头结点的单链表逻辑思考上更为简单一点，其与【不带头结点】的链表的核心差别主要有以下：</p><ol><li>head 一定不为空，在首结点进行操作时，与其他位置的操作是一致的；</li><li>当游标cur 指向 head 时，其索引为 -1，表示首结点的前一位置，即首结点是从 head.next 开始算起。  </li></ol><p>掌握好这两个关键点，实现起来就十分简单了.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Single_Link_List_With_Head</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, node=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        这里实现的是所谓【带头结点】的单链表</span></span><br><span class="line"><span class="string">        所以初始化时不是为None或者从外面传入的node</span></span><br><span class="line"><span class="string">        初始化时就一定是一个结点，我们可以用这个结点的数据域来存储链表的长度</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.__head = Node(<span class="number">0</span>)</span><br><span class="line">        self.__head.<span class="built_in">next</span> = node</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>)-&gt;<span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.__head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">        cnt, cur = <span class="number">0</span>, self.__head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cnt +=<span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># self.__head.val = cnt  # 也可以用头结点的数据域来存储链表长度    </span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">print</span>(cur.val, end=<span class="string">&#x27;-&gt;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="comment">###############【增】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>)-&gt;<span class="built_in">bool</span>:</span><br><span class="line">        node = Node(val)</span><br><span class="line">        <span class="comment"># 注意这一步和不带头结点的链表的区别</span></span><br><span class="line">        node.<span class="built_in">next</span> = self.__head.<span class="built_in">next</span></span><br><span class="line">        self.__head.<span class="built_in">next</span> = node</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, val</span>)-&gt;<span class="built_in">bool</span>:</span><br><span class="line">        node= Node(val)</span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="comment"># 这里就不用单独判断链表是否为空了</span></span><br><span class="line">        <span class="comment"># 空链表也包含在下面的情况</span></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = node</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos:<span class="built_in">int</span>, val</span>)-&gt;<span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;failed! insert pos out of range!&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.__head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;empty link-list!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = Node(val)</span><br><span class="line">            i, cur = -<span class="number">1</span>, self.__head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i&lt;pos-<span class="number">1</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">###############【删】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val</span>)-&gt;<span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;empty link-list!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        pre, cur = self.__head, self.__head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;not find %s&#x27;</span> % <span class="built_in">str</span>(val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">del_pos</span>(<span class="params">self, pos:<span class="built_in">int</span></span>)-&gt;<span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        删除指定pos的结点</span></span><br><span class="line"><span class="string">        与【不带头结点】的单链表对比,不用特殊处理首结点(pos==0)的删除</span></span><br><span class="line"><span class="string">        只是索引从-1开始,其他的部分不变</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;failed! insert pos out of range!&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.__head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;empty link-list!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = -<span class="number">1</span>, self.__head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos-<span class="number">1</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【改】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, pos: <span class="built_in">int</span>, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据位置改变值&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;change pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = -<span class="number">1</span>, self.__head</span><br><span class="line">            <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.val = val</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【查】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;依据值来定位位置(索引)&#x27;&#x27;&#x27;</span></span><br><span class="line">        i, cur = -<span class="number">1</span>, self.__head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                <span class="keyword">return</span> i             </span><br><span class="line">                </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;not find %s&#x27;</span> % <span class="built_in">str</span>(val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">locate</span>(<span class="params">self, pos: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;依据索引查找值&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = -<span class="number">1</span>, self.__head</span><br><span class="line">            <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> cur.val</span><br></pre></td></tr></table></figure><h2 id="6-1-2-双链表"><a href="#6-1-2-双链表" class="headerlink" title="6.1.2 双链表"></a>6.1.2 双链表</h2><p>双向链表除了相当于在单链表的基础上，每个结点多了一个指针域prior，用于存储其直接前驱的地址。同时保留有next，用于存储其直接后继的地址。  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/6_1_2_1.webp" width="40%"> </p><p>所以对于双链表，其实很多操作都和单链表是一样的，因为你完全可以忽视掉它有个 prior指针，这样就可以当做单链表来使用。  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/6_1_2_2.webp" width="60%">   </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/6_1_2_3.webp" width="80%">  </p><p>因为有了prior指针，所以在插入和删除新元素时，应该考虑可以利用这一值。<br>鉴于有些操作其实可以和单链表保持一致，比如判空、求长度、遍历、查找等等，所以我们可以用类的继承来实现双链表，主要要修改的其实就是<b><font color="red">增、删</font>元素两种操作，因为涉及到“链”的变化。</b><br>特别注意：在更新某结点node的prior链接时，也要记得check一下该node是否为空！<br>下面的code是继承不带头结点的单链表的类来进行实现。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D_Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val      <span class="comment"># 数据源</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span>    <span class="comment"># 后继</span></span><br><span class="line">        self.prior=<span class="literal">None</span>     <span class="comment"># 前驱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Double_Link_List</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, node=<span class="literal">None</span></span>):</span><br><span class="line">        self.__head = node</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_random_init</span>(<span class="params">self, n=<span class="number">0</span></span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            self.append(random.randint(<span class="number">0</span>, <span class="number">20</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;普通的三项基本操作和简单的单链表一样&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt, cur = <span class="number">0</span>, self.__head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> cnt </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(cur.val, end=<span class="string">&#x27;-&gt;&#x27;</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">###############【增】###############</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;增加元素的操作一定要记得 prior 指针连接上&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;头插法&#x27;&#x27;&#x27;</span></span><br><span class="line">        node = D_Node(val)</span><br><span class="line">        node.<span class="built_in">next</span> = self.__head</span><br><span class="line">        <span class="keyword">if</span> self.__head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.__head.prior = node</span><br><span class="line">        self.__head = node</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;尾插法&#x27;&#x27;&#x27;</span></span><br><span class="line">        node, cur = D_Node(val), self.__head</span><br><span class="line">        <span class="comment"># 这里就需要先判断是否为空,否则None.next会报错</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.__head = node</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 循环结束后，cur指向最后一个数据结点</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line">            node.prior = cur</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;随机位置插入&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 先确保传入的pos属于[0, size]</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;insert pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> pos == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> self.add(val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = D_Node(val)</span><br><span class="line">                i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">                <span class="comment"># 循环结束后, cur指向pos-1的位置，因为pos的位置要留给node</span></span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos-<span class="number">1</span>:</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># print(&#x27;i:&#x27;,i,end=&#x27;-&gt;&#x27;)</span></span><br><span class="line">                    <span class="comment"># print(cur.val)</span></span><br><span class="line">                node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = node</span><br><span class="line">                </span><br><span class="line">                node.prior = cur</span><br><span class="line">                <span class="keyword">if</span> node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    node.<span class="built_in">next</span>.prior = node</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【删】###############</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;删除元素的操作也要记得重置prior&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据值来删除第一个符合条件的结点&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;the linklist is empty!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        pre, cur = <span class="literal">None</span>, self.__head</span><br><span class="line">        <span class="comment"># 这里的 pre 完全可以用 cur.prior 来表示，我懒得改了</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                <span class="comment"># 先要判断是否删除的是首结点</span></span><br><span class="line">                <span class="keyword">if</span> cur == self.__head:</span><br><span class="line">                    <span class="comment"># 更新首结点</span></span><br><span class="line">                    self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">                    <span class="comment"># 判断更新后的 self.__head 是否为空</span></span><br><span class="line">                    <span class="keyword">if</span> self.__head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                        self.__head.prior = cur.prior</span><br><span class="line">                    cur = self.__head</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                    <span class="comment"># 判断 cur.next 是否为空</span></span><br><span class="line">                    <span class="keyword">if</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                        cur.<span class="built_in">next</span>.prior = pre</span><br><span class="line">                    cur = pre.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">del_pos</span>(<span class="params">self, pos</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据位置来指定删除&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;del pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 先要判断是否删除的是首结点</span></span><br><span class="line">            <span class="keyword">if</span> pos == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 更新首结点</span></span><br><span class="line">                self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 判断更新后的 self.__head 是否为空</span></span><br><span class="line">                <span class="keyword">if</span> self.__head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    self.__head.prior = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 这里的 pre 完全可以用 cur.prior 来表示，我懒得改了</span></span><br><span class="line">                pre, cur = <span class="literal">None</span>, self.__head</span><br><span class="line">                <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                    pre = cur</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    cur.<span class="built_in">next</span>.prior = pre</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【改】###############</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;改元素值不涉及重连，所以与单链表一样&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, pos: <span class="built_in">int</span>, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据位置改变值&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;change pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">            <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.val = val</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【查】###############</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;改元素值不涉及重连，所以与单链表一样&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;依据值来定位位置(索引)&#x27;&#x27;&#x27;</span></span><br><span class="line">        i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;not find %s&#x27;</span> % <span class="built_in">str</span>(val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">locate</span>(<span class="params">self, pos: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;依据索引查找值&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">            <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> cur.val</span><br></pre></td></tr></table></figure><h2 id="6-1-3-循环链表"><a href="#6-1-3-循环链表" class="headerlink" title="6.1.3 循环链表"></a>6.1.3 循环链表</h2><p>循环链表就是链表首尾相接连成一个环，即链表的最后一个结点，的后继结点，是头（首）结点；可以用单向链表和双向链表来实现，分别形成单向循环链表和双向循环链表，又可再分为带头结点和不带头结点，这里只画出不带头结点的单向循环链表的例子示意图如下：  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/6_1_2_3.webp" width="60%">  </p><p>所以<b>判断是否是最后一个元素 的条件 也<font color="red">从 p-&gt;next != null; 变成了 p-&gt;next != head;</font></b>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Single_Cycle_Link_list</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单向循环链表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_random_init</span>(<span class="params">self, n=<span class="number">0</span></span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            self.append(random.randint(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.__head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        cnt, cur = <span class="number">1</span>, self.__head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            cnt +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="built_in">print</span>(cur.val, end=<span class="string">&#x27;-&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">print</span>(cur.val, end=<span class="string">&#x27;-&gt;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">###############【增】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>):</span><br><span class="line">        node = Node(val)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.__head = node</span><br><span class="line">            <span class="comment"># 循环链表要记得尾部也指向head</span></span><br><span class="line">            node.<span class="built_in">next</span> = self.__head</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.<span class="built_in">next</span> = self.__head</span><br><span class="line">            cur = self.__head</span><br><span class="line">            <span class="comment"># 循环结束后，cur到链表尾部</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将尾部的next指向node, 并将node更新为新的head</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line">            self.__head = node</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;尾插法&#x27;&#x27;&#x27;</span></span><br><span class="line">        node, cur = Node(val), self.__head</span><br><span class="line">        <span class="comment"># 这里就需要先判断是否为空,否则None.next会报错</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.__head = node</span><br><span class="line">            <span class="comment"># 循环链表要记得尾部也指向head</span></span><br><span class="line">            node.<span class="built_in">next</span> = self.__head</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 循环结束后，cur指向最后一个数据结点</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line">            <span class="comment"># 将node后继指向 head</span></span><br><span class="line">            node.<span class="built_in">next</span> = self.__head</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;随机位置插入&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 先确保传入的pos属于[0, size]</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;insert pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> pos == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> self.add(val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = Node(val)</span><br><span class="line">                i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">                <span class="comment"># 循环结束后, cur指向pos-1的位置，因为pos的位置要留给node</span></span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head <span class="keyword">and</span> i &lt; pos-<span class="number">1</span>:</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># print(&#x27;i:&#x27;,i,end=&#x27;-&gt;&#x27;)</span></span><br><span class="line">                    <span class="comment"># print(cur.val)</span></span><br><span class="line">                node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = node</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【删】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据值来删除第一个符合条件的结点&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;the linklist is empty!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="comment"># 先要判断首结点的值是否符合删除条件</span></span><br><span class="line">        <span class="keyword">if</span> cur.val == val:</span><br><span class="line">            <span class="comment"># 如果链表只有一个结点</span></span><br><span class="line">            <span class="keyword">if</span> cur.<span class="built_in">next</span> == self.__head:</span><br><span class="line">                self.__head = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 循环结束后cur指向最后一个结点</span></span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head:</span><br><span class="line">                    cur = cur.<span class="built_in">next</span> </span><br><span class="line">                <span class="comment"># 将尾部与新的首结点连起来</span></span><br><span class="line">                cur.<span class="built_in">next</span> = self.__head.<span class="built_in">next</span></span><br><span class="line">                self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 说明首结点的值不符合</span></span><br><span class="line">            pre, cur = self.__head, self.__head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> cur != self.__head:</span><br><span class="line">                <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span> </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre = cur</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;not find %s &#x27;</span> % <span class="built_in">str</span>(val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">del_pos</span>(<span class="params">self, pos</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据位置来指定删除&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;del pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 先要判断是否删除的是首结点</span></span><br><span class="line">            <span class="keyword">if</span> pos == <span class="number">0</span>:</span><br><span class="line">                cur = self.__head</span><br><span class="line">                <span class="comment"># 如果链表只有一个结点</span></span><br><span class="line">                <span class="keyword">if</span> cur.<span class="built_in">next</span> == self.__head:</span><br><span class="line">                    self.__head = <span class="literal">None</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 循环结束后cur指向最后一个结点</span></span><br><span class="line">                    <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head:</span><br><span class="line">                        cur = cur.<span class="built_in">next</span> </span><br><span class="line">                    <span class="comment">#print(&#x27;end val:&#x27;, cur.val)</span></span><br><span class="line">                    <span class="comment"># 将尾部与新的首结点连起来</span></span><br><span class="line">                    cur.<span class="built_in">next</span> = self.__head.<span class="built_in">next</span></span><br><span class="line">                    self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i = <span class="number">1</span></span><br><span class="line">                pre, cur = self.__head, self.__head.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">                <span class="keyword">while</span> cur != self.__head <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                    pre = cur</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【改】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, pos: <span class="built_in">int</span>, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据位置改变值&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;change pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">            <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.val = val</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【查】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;依据值来定位位置(索引)&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.__head.val == val:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = <span class="number">1</span>, self.__head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> cur != self.__head:</span><br><span class="line">                <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;not find %s&#x27;</span> % <span class="built_in">str</span>(val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">locate</span>(<span class="params">self, pos: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;依据索引查找值&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">            <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> cur.val</span><br></pre></td></tr></table></figure><h2 id="6-1-4-链表逆序"><a href="#6-1-4-链表逆序" class="headerlink" title="6.1.4 链表逆序"></a>6.1.4 链表逆序</h2><p>链表逆序就是把一个链表的尾变头，头变尾。属于链表中的经典问题。  </p><h3 id="6-1-4-1-方案一"><a href="#6-1-4-1-方案一" class="headerlink" title="6.1.4.1 方案一"></a>6.1.4.1 方案一</h3><p>将<b>第二个结点后面的元素依次插入到第一个结点后面</b>，<br>这个方法对于带不带头结点的链表都适用。<br>举例<br>① 不带头结点的链表<br>原始链表，其中第二个元素是 <font color="red">B</font><br>A -&gt; <font color="red">B</font>-&gt; ==C== -&gt; D -&gt; E -&gt; F -&gt; null<br>先进入循环,不断的把B的后继元素往第一个元素后面插<br>A -&gt; C -&gt; <font color="red">B</font> -&gt; ==D== -&gt; E -&gt; F -&gt; null   #将上面 B后的 C 插入到A后面<br>A -&gt; D -&gt; C -&gt; <font color="red">B</font> -&gt; ==E== -&gt; F -&gt; null   #将上面 B后的 D 插入到A后面<br>A -&gt; E -&gt; D -&gt; C -&gt; <font color="red">B</font> -&gt; ==F== -&gt; null   #将上面 B后的 E 插入到A后面<br>A -&gt; F -&gt; E -&gt; D -&gt; C -&gt; <font color="red">B</font> -&gt; null   #将上面 B后的 F 插入到A后面<br>最后将F作为新的首结点,将A放到B后面：<br>F -&gt; E -&gt; D -&gt; C -&gt; B -&gt; A -&gt; null  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">if</span> self.is_empty():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;empty link-list!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> self.__head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node_A, node_B = self.__head, self.__head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> node_B.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 相当于先把B后的结点从链表中断开</span></span><br><span class="line">            node_C = node_B.<span class="built_in">next</span></span><br><span class="line">            node_B.<span class="built_in">next</span> = node_C.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 然后插入首结点后面</span></span><br><span class="line">            node_C.<span class="built_in">next</span> = node_A.<span class="built_in">next</span></span><br><span class="line">            node_A.<span class="built_in">next</span> = node_C</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 尾首相连，相当于形成了一个循环链表了</span></span><br><span class="line">        node_B.<span class="built_in">next</span> = node_A</span><br><span class="line">        <span class="comment"># 然后从A点next处断开即可</span></span><br><span class="line">        self.__head = node_A.<span class="built_in">next</span></span><br><span class="line">        node_A.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>② 带头结点的链表<br>可以将头结点视为第一个元素，那么就是直接把 A 的后继元素不断的往head后面插：<br>带头结点原始链表，将头结点视为第1个元素，那么其中第2个元素是 A<br>Head -&gt; <font color="red">A</font> -&gt; ==B==-&gt; C -&gt; D -&gt; E -&gt; F -&gt; null<br>先进入循环,不断的把A的后继元素往头结点后面插<br>Head -&gt; B -&gt; <font color="red">A</font> -&gt; ==C== -&gt; D -&gt; E -&gt; F -&gt; null<br>Head -&gt; C -&gt; B -&gt; <font color="red">A</font> -&gt; ==D== -&gt; E -&gt; F -&gt; null<br>Head -&gt; D -&gt; C -&gt; B -&gt; <font color="red">A</font> -&gt; ==E== -&gt; F -&gt; null<br>Head -&gt; E -&gt; D -&gt; C -&gt; B -&gt; <font color="red">A</font> -&gt; ==F== -&gt; null<br>Head -&gt; F -&gt; E -&gt; D -&gt; C -&gt; B -&gt; <font color="red">A</font> -&gt; null</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">if</span> self.is_empty():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;empty link-list!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> self.__head.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node_H, node_B = self.__head, self.__head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> node_B.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 相当于先把B后的结点从链表中断开</span></span><br><span class="line">            node_C = node_B.<span class="built_in">next</span></span><br><span class="line">            node_B.<span class="built_in">next</span> = node_C.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 然后插入头结点后面</span></span><br><span class="line">            node_C.<span class="built_in">next</span> = node_H.<span class="built_in">next</span></span><br><span class="line">            node_H.<span class="built_in">next</span> = node_C</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 循环结束之后，结点B后的结点都被逆序插入到A之后</span></span><br><span class="line">        <span class="comment"># 由于A是作为头结点head一直稳定不变，所以已经结束了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="6-1-4-2-方案二"><a href="#6-1-4-2-方案二" class="headerlink" title="6.1.4.2 方案二"></a>6.1.4.2 方案二</h3><p>直接利用辅助变量，将node一个一个改变指向，这个方法就是要注意中间一定不能断了。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, head</span>):</span><br><span class="line">    pre, cur = <span class="literal">None</span>, head</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="comment"># 先保存剩余部分的头</span></span><br><span class="line">        rest = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 当前结点指向前面</span></span><br><span class="line">        cur.<span class="built_in">next</span> = pre</span><br><span class="line">        <span class="comment"># pre指针移动到当前结点</span></span><br><span class="line">        pre = cur</span><br><span class="line">        <span class="comment"># cur指针指向剩下部分的头</span></span><br><span class="line">        cur = rest</span><br><span class="line">    <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h3 id="6-1-4-3-方案三"><a href="#6-1-4-3-方案三" class="headerlink" title="6.1.4.3 方案三"></a>6.1.4.3 方案三</h3><p>采用递归的思路  </p><p>① 不带头结点<br>递归其实就是一直要找到最后一个结点，然后每次改一下。<br>这个时候其实 函数递归的时，<font color="red">函数用系统栈存储了前面每个结点的信息</font>，所以一步一步从最后面改动到前面去，最后返回了一个以原始尾结点的地址为头指针的 无头结点单链表。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_linklist_by_recursion</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 调用递归函数, 更新新的首结点</span></span><br><span class="line">    self.__head = self.__recursion_func(self.__head)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__recursion_func</span>(<span class="params">self, node</span>):</span><br><span class="line">    <span class="comment"># 结束的条件:链表为空或者链表最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="comment"># 递归调用</span></span><br><span class="line">    node_new = self.__recursion_func(node.<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每次都把当前结点 重新设置成 当前结点的下一个结点的下一个结点</span></span><br><span class="line">    node.<span class="built_in">next</span>.<span class="built_in">next</span> = node</span><br><span class="line">    <span class="comment"># 然后再把当前结点的新后继设置为空，相当于当前结点作为新链表的尾结点</span></span><br><span class="line">    node.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node_new</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/6_1_4_1.gif" width="70%">   </p><p>② 带头结点<br>其实依然可以用上面的函数，只是不能把头结点传入进去，因为头结点本身不该算在链表的存储的数据中。我们可以把带头结点的单链表的头结点后面的那部分，看成是不带头结点的单链表，即可复用上面的函数了。即，传入的指针应该是 head-&gt;next  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__reverse_linklist_by_recursion</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 这里直接把self.__head.next之后的链表，当作不带头结点的链表处理即可</span></span><br><span class="line">    self.__head.<span class="built_in">next</span> = self.recursion_func(self.__head.<span class="built_in">next</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__recursion_func</span>(<span class="params">self, node</span>):</span><br><span class="line">    <span class="comment"># 结束的条件:链表为空或者链表最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="comment"># 递归调用</span></span><br><span class="line">    node_new = self.__recursion_func(node.<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每次都把当前结点 重新设置成 当前结点的下一个结点的下一个结点</span></span><br><span class="line">    node.<span class="built_in">next</span>.<span class="built_in">next</span> = node</span><br><span class="line">    <span class="comment"># 然后再把当前结点的新后继设置为空，相当于当前结点作为新链表的尾结点</span></span><br><span class="line">    node.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node_new</span><br></pre></td></tr></table></figure><h2 id="6-1-5-顺序表和链表的对比"><a href="#6-1-5-顺序表和链表的对比" class="headerlink" title="6.1.5 顺序表和链表的对比"></a>6.1.5 顺序表和链表的对比</h2><ul><li>存储结构的不同<br>虽然它们同属于线性表，但数据的存储结构有本质的不同：<br>顺序表存储数据，需预先申请一整块足够大的存储空间，然后将数据按照次序逐一存储，逻辑关系就是靠元素间物理空间上的邻接关系来维持<br>链表 ，什么时候存储数据，什么时候才申请存储空间，数据之间的逻辑关系依靠每个数据元素携带的指针维持，</li><li>空间利用率<br>顺序表的空间利用率显然要比链表高。<br>首先是链表每个结点不光有数据域，还有指针域。这就比顺序表多耗费一点空间。<br>链表在存储数据时，每次只新开辟一个node的空间，且位置是随机的，会产生很多空间碎片，一定程序上造成了空间浪费。</li><li>时间复杂度<br>根据顺序表和链表在存储结构上的差异，问题类型主要分为以下 2 类：<br><strong>第 1 类问题：主要涉及访问元素的操作，元素的插入、删除和移动操作极少</strong>；<br>适合使用顺序表。这是因为，顺序表中存储的元素可以使用数组下标直接访问，无需遍历整个表，因此使用顺序表访问元素的时间复杂度为 O(1)；如果要在链表中访问元素，需要从头指针依次遍历，直到找到指定节点，花费的时间复杂度为 O(n).<br><strong>第 2 类问题:主要涉及元素的插入、删除和移动，访问元素的需求很少</strong>；<br>适合使用链表。链表中数据元素之间的逻辑关系靠的是节点之间的指针，当需要在链表中某处插入或删除节点时，只需改变相应节点的指针指向即可，不用大量移动元素，因此链表中插入、删除或移动数据所耗费的时间复杂度为 O(1)；而顺序表中，插入、删除和移动数据可能会牵涉到大量元素的整体移动，时间复杂度至少为 O(n).</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5-2 栈和队列相关题目</title>
      <link href="/Data-Structure/DS_52_stack_and_queue_exercises.html"/>
      <url>/Data-Structure/DS_52_stack_and_queue_exercises.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="5-2-栈和队列相关题目"><a href="#5-2-栈和队列相关题目" class="headerlink" title="5-2 栈和队列相关题目"></a>5-2 栈和队列相关题目</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p><span id="5.2.1"></span>  </p><h2 id="5-2-1-栈的常见题目："><a href="#5-2-1-栈的常见题目：" class="headerlink" title="5.2.1 栈的常见题目："></a>5.2.1 栈的常见题目：</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">LeetCode 232.用栈实现队列 </a></td><td><a href="#5.2.1.1">5.2.1.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/min-stack">LeetCode 155.最小栈</a></td><td><a href="#5.2.1.2">5.2.1.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string">LeetCode 1047.删除字符串中的所有相邻重复项</a></td><td><a href="#5.2.1.3">5.2.1.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/valid-parentheses">LeetCode 20.有效的括号</a></td><td><a href="#5.2.1.4">5.2.1.4题解</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/longest-valid-parentheses">LeetCode 32.最长有效括号</a></td><td><a href="#5.2.1.5">5.2.1.5题解</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/basic-calculator">LeetCode 224.基本计算器</a></td><td><a href="#5.2.1.6">5.2.1.6题解</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/basic-calculator-ii">LeetCode 227.基本计算器II</a></td><td><a href="#5.2.1.7">5.2.1.7题解</a></td></tr><tr><td>⑧</td><td><a href="https://leetcode.cn/problems/decode-string">LeetCode 394.字符串解码</a></td><td><a href="#5.2.1.8">5.2.1.8题解</a></td></tr><tr><td>⑨</td><td><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">LeetCode 150.逆波兰表达式求值</a></td><td><a href="#5.2.1.9">5.2.1.9题解</a></td></tr><tr><td>⑩</td><td><a href="https://leetcode.cn/problems/validate-stack-sequences/">LeetCode 946. 验证栈序列</a></td><td><a href="#5.2.1.10">5.2.1.10题解</a></td></tr></tbody></table></div><p><span id="5.2.1.1"></span>   </p><h3 id="5-2-1-1-用栈实现队列"><a href="#5-2-1-1-用栈实现队列" class="headerlink" title="5.2.1.1 用栈实现队列"></a>5.2.1.1 用栈实现队列</h3><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">LeetCode 232.用栈实现队列 </a> | | <a href="#5.2.1">返回目录5.2.1</a></p><font color="#3399FF">思路：队列是先入的先出，所以要用一个栈存储数据，另一个栈用来调整顺序。</font>    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__s_a = []</span><br><span class="line">        self.__s_b = []</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 专门用 a 栈来存储数据</span></span><br><span class="line">        self.__s_a.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先将a栈的数据全部导入b栈，此时顺序就反过来了</span></span><br><span class="line">        <span class="keyword">while</span> self.__s_a:</span><br><span class="line">            self.__s_b.append(self.__s_a.pop())</span><br><span class="line">        <span class="comment"># 这样b栈的栈顶元素就是刚刚的队头元素，将其弹出给res</span></span><br><span class="line">        res = self.__s_b.pop()</span><br><span class="line">        <span class="comment"># 然后再把b栈里的元素恢复到a栈中，保持a栈存储元素,b栈常态为空的状态</span></span><br><span class="line">        <span class="keyword">while</span> self.__s_b:</span><br><span class="line">            self.__s_a.append(self.__s_b.pop())</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 与pop的操作几乎一致，只不过不用使用pop弹出</span></span><br><span class="line">        <span class="keyword">while</span> self.__s_a:</span><br><span class="line">            self.__s_b.append(self.__s_a.pop())</span><br><span class="line">        res = self.__s_b[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> self.__s_b:</span><br><span class="line">            self.__s_a.append(self.__s_b.pop())</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.__s_a</span><br></pre></td></tr></table></figure><p><span id="5.2.1.2"></span>  </p><h3 id="5-2-1-2-最小栈"><a href="#5-2-1-2-最小栈" class="headerlink" title="5.2.1.2 最小栈"></a>5.2.1.2 最小栈</h3><p><a href="https://leetcode.cn/problems/min-stack">LeetCode 155.最小栈</a> | | <a href="#5.2.1">返回目录5.2.1</a></p><font color="#3399FF">思路1：用一个栈维护数据，再用另一个栈维护最小值。数据栈在进行入栈、出栈操作时，也要同时对最小值栈进行操作。  </font><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>:</span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__stack_list=[]</span><br><span class="line">        self.__min_list=[]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.__stack_list.append(val)</span><br><span class="line">        <span class="keyword">if</span> self.__min_list:</span><br><span class="line">            <span class="comment">#self.__min_list.append(val)</span></span><br><span class="line">            min_v = <span class="built_in">min</span>(val, self.__min_list[-<span class="number">1</span>])</span><br><span class="line">            self.__min_list.append(min_v)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__min_list.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> self.__stack_list:</span><br><span class="line">            self.__stack_list.pop()</span><br><span class="line">            self.__min_list.pop()</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.__stack_list:</span><br><span class="line">            <span class="keyword">return</span> self.__stack_list[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> math.nan</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.__min_list:</span><br><span class="line">            <span class="keyword">return</span> self.__min_list[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> math.nan</span><br></pre></td></tr></table></figure><font color="#3399FF">思路2：由于思路1中用到了一个辅助栈，空间的消耗会是原始数据的2倍。这里可以考虑一个不用辅助栈的方案.只维护一个栈，栈里存储的是与 min_value 的差值:deltamin_value 其实承担了两个功能，第一个就是栈中最小值，另一个就是如果delta是小于0的话，那就是栈中对应位置的真实值。换句话说，那个delta栈，想从它恢复成原始数据栈，要么就是对应的delta值加上min，要么就是直接填入min值。这完全取决于delta的正负，这个正负的信息其实很重要。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 维护一个delta栈，和一个最小值</span></span><br><span class="line">        self.__delta_stack = []</span><br><span class="line">        self.__minv = -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 这个最小值的初始值可以不用在意，</span></span><br><span class="line">        <span class="comment"># 最小值是在栈不为空的时候才会有意义的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.__delta_stack) == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 如果栈为空，当前数就是唯一存在的数，自然就是最小值</span></span><br><span class="line">            self.__minv = val</span><br><span class="line">            <span class="comment"># 它与自己的差值明显就是 0</span></span><br><span class="line">            self.__delta_stack.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            delta = val - self.__minv</span><br><span class="line">            <span class="keyword">if</span> delta &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 说明新来的val比已有的minv更小，需要更新 minv 为当前val</span></span><br><span class="line">                self.__minv = val</span><br><span class="line">            <span class="comment"># 如果delta大于0 ，说明原来的minv确实还是更小的，就不用更新</span></span><br><span class="line">            <span class="comment"># 然后不管是大于0还是小于0 ，依然要将delta入栈</span></span><br><span class="line">            self.__delta_stack.append(delta)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> self.__delta_stack:</span><br><span class="line">            delta = self.__delta_stack.pop()</span><br><span class="line">            <span class="keyword">if</span> delta &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 说明min_v储存的值就是对应的 val</span></span><br><span class="line">                <span class="comment"># 这是由我们之前的入栈操作决定的</span></span><br><span class="line">                val = self.__minv</span><br><span class="line">                <span class="comment"># 并还原之前的 minv</span></span><br><span class="line">                self.__minv = val - delta</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                val = delta + self.__minv</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.__delta_stack:</span><br><span class="line">            delta = self.__delta_stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> self.__minv <span class="keyword">if</span> delta &lt; <span class="number">0</span> <span class="keyword">else</span> delta+self.__minv</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.__minv <span class="keyword">if</span> self.__delta_stack <span class="keyword">else</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><span id="5.2.1.3"></span>   </p><h3 id="5-2-1-3-删除字符串中的所有相邻重复项"><a href="#5-2-1-3-删除字符串中的所有相邻重复项" class="headerlink" title="5.2.1.3 删除字符串中的所有相邻重复项"></a>5.2.1.3 删除字符串中的所有相邻重复项</h3><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string">LeetCode 1047.删除字符串中的所有相邻重复项</a> | | <a href="#5.2.1">返回目录5.2.1</a></p><font color="#3399FF">方案：用一个栈来循环装入每个字符，每个字符入栈时，都要与栈顶元素（即前一个字符）对比一下，若不相同才装入；若相同就不装入，同时删除栈顶元素。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        char_s = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char_s: <span class="comment"># 如果栈不为空才进行后续操作</span></span><br><span class="line">                <span class="keyword">if</span> ch == char_s[-<span class="number">1</span>]:</span><br><span class="line">                    char_s.pop()</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            char_s.append(ch)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(char_s)</span><br></pre></td></tr></table></figure><p><span id="5.2.1.4"></span>  </p><h3 id="5-2-1-4-有效的括号"><a href="#5-2-1-4-有效的括号" class="headerlink" title="5.2.1.4 有效的括号"></a>5.2.1.4 有效的括号</h3><p><a href="https://leetcode.cn/problems/valid-parentheses">LeetCode 20.有效的括号</a> | | <a href="#5.2.1">返回目录5.2.1</a></p><font color="#3399FF">方案：和上面的  [5.2.1.2](#5.2.1.2) 的思想类似，只不过上面是成对的消字符，这里是成对的消除括号，原理是一样的。如果中途就碰见不能消除的情况，就返回False了。最终消除完之后看看是否还剩的有括号</font><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        bracket_s = []</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">&#x27;(&#x27;</span> <span class="keyword">or</span> ch == <span class="string">&#x27;[&#x27;</span> <span class="keyword">or</span> ch == <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                bracket_s.append(ch)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> ch == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> bracket_s <span class="keyword">and</span> bracket_s[-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    bracket_s.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> ch == <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> bracket_s <span class="keyword">and</span> bracket_s[-<span class="number">1</span>] == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                    bracket_s.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> ch == <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> bracket_s <span class="keyword">and</span> bracket_s[-<span class="number">1</span>] == <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                    bracket_s.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(bracket_s) == <span class="number">0</span></span><br></pre></td></tr></table></figure><p><span id="5.2.1.5"></span>  </p><h3 id="5-2-1-5-最长有效括号"><a href="#5-2-1-5-最长有效括号" class="headerlink" title="5.2.1.5 最长有效括号"></a>5.2.1.5 最长有效括号</h3><p><a href="https://leetcode.cn/problems/longest-valid-parentheses">LeetCode 32.最长有效括号</a> | |<a href="#5.2.1">返回目录5.2.1</a></p><font color="#3399FF">方案：此题依旧和上面两个题是一样的原理，做消消乐。同样是成对的消括号，只不过这一次要算一下消除的区域的长度。一个很自然的想法就是：需要消掉的部分的最后一个字符的索引index，减去尚未被消除的部分的最后一个字符的索引index，就是此次消除区域的长度gap。最后要得到的是最长的这个gap，只需要每次用一个max函数更新一下就行。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;code version.1&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestValidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 我们将(符号，索引) 的结构进行入栈，这样就既能判断符号，又可以知道对应的索引了</span></span><br><span class="line">        <span class="comment"># 这里为何要将 stack 初始化为 (&#x27;)&#x27;, -1)？ </span></span><br><span class="line">        <span class="comment"># 因为如果字符串是 &quot;()&quot;开头，这块区域消掉之后，前面并没有未消除区域，我们不太好追溯左边界的索引值，所以要人为设置一个左边界</span></span><br><span class="line">        <span class="comment"># 所以我们假设是由&#x27;)&#x27;开头，且位于-1位置，这样不影响原数据。</span></span><br><span class="line">        <span class="comment"># 而且这个开头一定不会被消掉，相当于规定了一个边界值。所以我们的栈一定不会为空，简化了条件</span></span><br><span class="line">        stack,  gap = [[<span class="string">&#x27;)&#x27;</span>, -<span class="number">1</span>]], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            ch = s[i]</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                <span class="comment"># 如果为左括号，直接入栈符号和其索引</span></span><br><span class="line">                stack.append([ch, i])</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 如果来的是右括号</span></span><br><span class="line">                <span class="keyword">if</span> stack[-<span class="number">1</span>][<span class="number">0</span>] ==<span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                <span class="comment"># 当前来的是右括号，且栈顶元素（上一个符号）是左括号</span></span><br><span class="line">                <span class="comment"># 说明可以被消掉，则先消除前面的符号</span></span><br><span class="line">                    stack.pop()</span><br><span class="line">                    <span class="comment"># 然后用当前索引 i, 减去尚未消掉部分的最后一个字符的索引，得到gap</span></span><br><span class="line">                    gap = <span class="built_in">max</span>(gap, i-stack[-<span class="number">1</span>][<span class="number">1</span>]) </span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                <span class="comment"># 如果为右括号，且无法消掉，直接修改其索引，相当于更新边界</span></span><br><span class="line">                    stack[-<span class="number">1</span>][<span class="number">1</span>] = i</span><br><span class="line">                    <span class="comment"># stack.append([ch, i]) </span></span><br><span class="line">        <span class="keyword">return</span> gap</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27; code version.2</span></span><br><span class="line"><span class="string">上面的code中，栈每次入栈的时候，同时存下了(符号，索引)， 两个数据；</span></span><br><span class="line"><span class="string">这样的好处是便于理解，从直观上看和我们上面的题目的code能统一；</span></span><br><span class="line"><span class="string">但是辅助栈消耗的空间就较大了，这里可以在原有的基础上进一步update</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">### update 进行如下修改</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestValidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack,  gap = [-<span class="number">1</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            ch = s[i]</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                <span class="comment"># 如果为左括号，直接入栈 索引</span></span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 直接弹出栈顶元素</span></span><br><span class="line">                stack.pop()</span><br><span class="line">                <span class="comment"># 下面这段实现的功能是：</span></span><br><span class="line">                <span class="comment"># 如果栈不为空，那就可以直接计算gap值。</span></span><br><span class="line">                <span class="comment"># 如果 弹出栈顶元素之后，栈为空了，那就将现在的右括号的索引入栈存下</span></span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    gap = <span class="built_in">max</span>(gap, i-stack[-<span class="number">1</span>]) </span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    stack.append(i)</span><br><span class="line">                <span class="comment"># 和上面的code发现判断条件从 是左括号还是右括号的，变成了判断栈是否为空</span></span><br><span class="line">                <span class="comment"># ① 假设弹出的是左括号，那么必然不为空，</span></span><br><span class="line">                <span class="comment"># 因为栈中剩下的要么是左括号，要么是右括号（因为我们一开始先假设了一个右括号放在-1位置作为边界值）</span></span><br><span class="line">                <span class="comment"># ② 假设弹出的是右括号，那么栈必然空了，因为在上面的code，我们始终只维护了一个作为边界的右括号；即如果栈不为空，那么有且只有一个右括号存在，且位于最左侧</span></span><br><span class="line">                <span class="comment"># 既然我们不需要再判断出栈的元素是左括号还是右括号，只需要判断栈是否为空</span></span><br><span class="line">                <span class="comment"># 那么意味着我们不需要将符号入栈了！！！只需要入栈索引即可，所以code就改为了这个版本</span></span><br><span class="line">        <span class="keyword">return</span> gap</span><br></pre></td></tr></table></figure><p><span id="5.2.1.6"></span>  </p><h3 id="5-2-1-6-基本计算器"><a href="#5-2-1-6-基本计算器" class="headerlink" title="5.2.1.6 基本计算器"></a>5.2.1.6 基本计算器</h3><p><a href="https://leetcode.cn/problems/basic-calculator">LeetCode 224.基本计算器</a> | | <a href="#5.2.1">返回目录5.2.1</a></p><font color="#3399FF">方案：  这个题只有加法和减法两种运算符出现，而这两种运算符根据交换律和结合律，是可以从左到右依次计算就行。但是此题还涉及到括号'('和')'，那么这个括号会造成什么影响呢？从直观上来看，括号内的区域要先计算，所以一种思路是先判断括号，然后先计算括号内区域的值，最后退化成只有普通加减法的情况，当涉及到括号的多层嵌套的时候，可能会有点复杂；</font><font color="#3399FF">另一种思路，那就是消掉括号，把式子改写为没有括号的情况，而且由于只涉及到加、减运算，消掉括号后依然能保持从左往右的基本计算顺序，只要保证消括号时数字前面的运算符能够完成转换即可。</font>  <font color="#3399FF">这里采用第二种思路，消括号的思路。 如果把一对括号( )包含的区域视为一个整体的话，这个整体都会受到括号外的正/负号的影响。  比如括号外是'+'，那么括号内的每一个运算符都要在原来的基础上多一个'+',对于加减运算而言，相当于原来的符号不变；如果括号外是'-'，那么括号内的每一个运算符都要取一次反，即括号内'+'变'-'，括号内'-'变'+'。我们在代码中用+1和-1来描述这两种状态。</font>  <font color="#3399FF">此外该题目还隐藏了一个陷阱： <u>题目举的例子中都是个位数</u>。如果遇到十位、百位不为空的情况，是需要注意，这个数字也会按照字符被分割开。比如12会被分割成1和2的字符依次输入，我们需要将其还原为原始的12！</font><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 把一对括号()包含的区域视为一个整体的话，这个整体都会受到括号外的正/负号的影响</span></span><br><span class="line">        <span class="comment"># 所以对括号内数组的正负号再乘以括号外这个整体的正负号，才是实际的正负号</span></span><br><span class="line">        <span class="comment"># 这里用 +1 表示正，-1表示负，初始状态明显为正</span></span><br><span class="line">        num, preSign = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="comment"># 用一个栈来存储每一个括号区域整体的正负号</span></span><br><span class="line">        sign_list = [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 因为题目中说，字符仅仅包含  数字、&#x27;+&#x27;、&#x27;-&#x27;、&#x27;(&#x27;、&#x27;)&#x27;、和 &#x27; &#x27; </span></span><br><span class="line">        <span class="comment"># 所以我们人为设置一个右边界 + ---&gt; s + &#x27;+&#x27;</span></span><br><span class="line">        <span class="comment"># 这是为了在遇到以数字结尾的情况时，仍能进入运算阶段</span></span><br><span class="line">        <span class="comment"># 就好比在使用计算器时，如果不使用&#x27;=&#x27;号键，按&#x27;+&#x27;键也能得出之前的加减结果</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s + <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> ch.isdigit():</span><br><span class="line">                <span class="comment"># 如果是几个数字字符连续出现，这样就能获得整个数字的实际值，比如&quot;12&quot;</span></span><br><span class="line">                num = num*<span class="number">10</span> + <span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># ch == &#x27;(&#x27; or &#x27;)&#x27; or &#x27;+&#x27; or &#x27;-&#x27;</span></span><br><span class="line">                <span class="comment"># 进入到非数字环节，就要结算前面的数字部分</span></span><br><span class="line">                res += preSign * num</span><br><span class="line">                <span class="comment"># 需要将数字部分重新置零</span></span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">in</span> <span class="string">&#x27;-+&#x27;</span>:</span><br><span class="line">                    <span class="comment"># 后面区域的真实的符号，是要和最近一层的括号区域的符号乘以一次进行修正</span></span><br><span class="line">                    preSign = sign_list[-<span class="number">1</span>]*(-<span class="number">1</span> <span class="keyword">if</span> ch == <span class="string">&#x27;-&#x27;</span> <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">elif</span> ch == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    <span class="comment"># 遇到左括号， 就需要对前面的符号进行暂存</span></span><br><span class="line">                    sign_list.append(preSign)</span><br><span class="line">                <span class="keyword">elif</span> ch == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                    <span class="comment"># 当一个括号结束时，就要消掉一个括号区域的符号</span></span><br><span class="line">                    sign_list.pop()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="5.2.1.7"></span>  </p><h3 id="5-2-1-7-基本计算器Ⅱ"><a href="#5-2-1-7-基本计算器Ⅱ" class="headerlink" title="5.2.1.7 基本计算器Ⅱ"></a>5.2.1.7 基本计算器Ⅱ</h3><p><a href="https://leetcode.cn/problems/basic-calculator-ii">LeetCode 227.基本计算器II</a> | | <a href="#5.2.1">返回目录5.2.1</a>  </p><font color="#3399FF">方案：  这里相对于上题来说，没有括号符，但是又多了乘法和除法运算符，而这两个运算符的优先级比加、减运算要高。所以我们可以考虑先对高优先级的部分进行运算，其余部分不动。就能退化为简单的没有括号的数组相加形式。具体实现方式为：如果遇到'+'号，就将数字直接存入栈中；如果遇到'-'号，就将数字取反后存入栈中；如果遇到'*、/'号，就将数字与栈顶元素运算之后，替换原有栈顶元素存入栈中；</font><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        num_stack = []</span><br><span class="line">        preSign = <span class="string">&#x27;+&#x27;</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s+<span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> ch.isdigit():</span><br><span class="line">                num = num*<span class="number">10</span> + <span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">if</span> preSign == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    num_stack.append(num)</span><br><span class="line">                <span class="keyword">elif</span> preSign == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    num_stack.append(-num)</span><br><span class="line">                <span class="keyword">elif</span> preSign == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    num_stack.append(num_stack.pop() * num)</span><br><span class="line">                    <span class="comment"># 也可以写成 num_stack[-1] = num_stack[-1] * num</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    num_stack.append(<span class="built_in">int</span>(num_stack.pop() / num))</span><br><span class="line">                    <span class="comment"># 也可以写成 num_stack[-1] = int(num_stack[-1] / num)</span></span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                preSign = ch</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(num_stack)</span><br></pre></td></tr></table></figure><p><span id="5.2.1.8"></span> </p><h3 id="5-2-1-8-字符串解码"><a href="#5-2-1-8-字符串解码" class="headerlink" title="5.2.1.8 字符串解码"></a>5.2.1.8 字符串解码</h3><p><a href="https://leetcode.cn/problems/decode-string">LeetCode 394.字符串解码</a> | | <a href="#5.2.1">返回目录5.2.1</a></p><font color="#3399FF">这个题的思想和 [5.2.1.6](#5.2.1.6) 很相似，也是有括号，只不过这里是中括号[ ];同样也会有括号外的因素影响括号内的值，5.2.1.6是括号外的符号影响括号内的符号，此题是括号的数字影响括号内的字符重复次数；所以我们也需要用辅助栈来存储括号外的值：建立辅助栈 num_list 和 str_list 来分别存储括号外的数字和字符串。对于数字和字符本身的处理，也借鉴5.2.1.6中的处理方式。</font><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decodeString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        num, tmp_str = <span class="number">0</span>, <span class="string">&#x27;&#x27;</span></span><br><span class="line">        num_list, str_list = [], []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch.isdigit():</span><br><span class="line">                <span class="comment"># 如果出现连续的数字字符，通过此方法来还原其真实数值</span></span><br><span class="line">                num = num*<span class="number">10</span> + <span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> ch.isalpha():</span><br><span class="line">                <span class="comment"># 如果出现连续的单字符，也通过此方法来还原大的字符串</span></span><br><span class="line">                tmp_str += ch</span><br><span class="line">            <span class="keyword">elif</span> ch == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                <span class="comment"># 出现左括号，意味着要对括号外的元素进行存储了</span></span><br><span class="line">                num_list.append(num)</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                str_list.append(tmp_str)</span><br><span class="line">                tmp_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 出现右括号，意味着要对最近的一对括号进行清算了</span></span><br><span class="line">                out_num = num_list.pop()</span><br><span class="line">                out_str = str_list.pop()</span><br><span class="line">                <span class="comment"># 一定要注意，括号外的顺序是 out_str + out_num</span></span><br><span class="line">                <span class="comment"># out_num要乘以的是当前括号内的tmp_str                </span></span><br><span class="line">                tmp_str = out_str + out_num * tmp_str</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmp_str</span><br></pre></td></tr></table></figure><p><span id="5.2.1.9"></span></p><h3 id="5-2-1-9-逆波兰表达式求值"><a href="#5-2-1-9-逆波兰表达式求值" class="headerlink" title="5.2.1.9  逆波兰表达式求值"></a>5.2.1.9  逆波兰表达式求值</h3><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">LeetCode 150.逆波兰表达式求值</a> | | <a href="#5.2.1">返回目录5.2.1</a></p><font color="#3399FF">方案：该题的思路其实在例3中已经体现出来了，就是观察规律而已。规律就是每遇到一个运算符号，就要用这个符号与运算左侧最近的两个数字，得到一个数字后，继续向右遍历。所以又需要用辅助栈来存储数字。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&quot;+-*/&quot;</span>:</span><br><span class="line">            <span class="comment"># 如果遇到了数字，直接用栈进行存储</span></span><br><span class="line">                s.append(<span class="built_in">int</span>(ch))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果遇到的是运算符，就先把左侧两个数出栈</span></span><br><span class="line">            <span class="comment"># 然后就要用运算符去结合这两个数，得到的结果，存入栈中</span></span><br><span class="line">                a2 = s.pop()</span><br><span class="line">                a1 = s.pop()</span><br><span class="line">                <span class="keyword">if</span> ch == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    s.append(a1+a2)</span><br><span class="line">                <span class="keyword">elif</span> ch == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    s.append(a1-a2)</span><br><span class="line">                <span class="keyword">elif</span> ch == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    s.append(a1*a2)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    s.append(<span class="built_in">int</span>(a1/a2))</span><br><span class="line">        <span class="keyword">return</span> s[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><span id="5.2.1.10"></span></p><h3 id="5-2-1-10-验证栈序列"><a href="#5-2-1-10-验证栈序列" class="headerlink" title="5.2.1.10  验证栈序列"></a>5.2.1.10  验证栈序列</h3><p><a href="https://leetcode.cn/problems/validate-stack-sequences/">LeetCode 946. 验证栈序列</a> | | <a href="#5.2.1">返回目录5.2.1</a></p><font color="#3399FF">方案：此题主要是模拟栈的压入压出操作。对于pushed的数字，先假设都能压入，那么每来一个数字，都压入辅助栈；每次压入之后，都要看看栈顶元素是否是poped中的对应位置的数字，是的话，那就又把该数字pop出去</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validateStackSequences</span>(<span class="params">self, pushed: <span class="type">List</span>[<span class="built_in">int</span>], popped: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        s, i = [], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> pushed:</span><br><span class="line">            <span class="comment"># 每遍历一个pushed中的数字，就将其压入辅助栈</span></span><br><span class="line">            s.append(num)</span><br><span class="line">            <span class="keyword">while</span> (s <span class="keyword">and</span> s[-<span class="number">1</span>] == popped[i]):</span><br><span class="line">                s.pop()</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s) == <span class="number">0</span></span><br></pre></td></tr></table></figure><p><span id="5.2.2"></span></p><h2 id="5-2-2-单调栈"><a href="#5-2-2-单调栈" class="headerlink" title="5.2.2 单调栈"></a>5.2.2 单调栈</h2><p>所谓单调栈，就是从栈顶到栈底的方向上是单调递增(减)，所以其实从栈底到栈顶的方向也是单调的。（因为python中一般用 list 来当栈用，所以从序号0开始看的话，我们一般都是看栈底到栈顶的方向。）  </p><p>单调栈如何用操作呢？假设讨论单调递增的情况，如果一个元素比栈顶的元素大，我们才入栈；否则就先pop掉栈顶元素，然后继续比；直到满足等待入栈的元素比栈顶元素大了，或者栈已经为空了，才入栈。<b>这样栈中的元素就是能保持单调递增的关系</b>。</p><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>〇</td><td><a href="#5.2.2.0">解法总结</a></td><td><a href="#5.2.2.0">5.2.2.0题解</a></td></tr><tr><td>①</td><td><a href="https://leetcode.cn/problems/daily-temperatures">LeetCode 739.每日温度</a></td><td><a href="#5.2.2.1">5.2.2.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/next-greater-element-i">LeetCode 496.下一个更大元素 I</a></td><td><a href="#5.2.2.2">5.2.2.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/next-greater-element-ii">LeetCode 503.下一个更大元素 II</a></td><td><a href="#5.2.2.3">5.2.2.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/online-stock-span">LeetCode 901.股票价格跨度</a></td><td><a href="#5.2.2.4">5.2.2.4题解</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">LeetCode 84.柱状图中最大的矩形</a></td><td><a href="#5.2.2.5">5.2.2.5题解</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/trapping-rain-water">LeetCode 42.接雨水</a></td><td><a href="#5.2.2.7">5.2.2.7题解</a></td></tr></tbody></table></div><p><span id="5.2.2.0"></span>  </p><h3 id="5-2-2-0-解法总结"><a href="#5-2-2-0-解法总结" class="headerlink" title="5.2.2.0 解法总结"></a>5.2.2.0 解法总结</h3><font color="#3399FF">单调栈通常被用来解决：求上一个更大（小）值 和 下一个更大（小）值的问题，如果遇到这类题型，其核心code的写法几乎都是差不多的，在这里先总结一下。</font><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27; 假设 数据列表是 data_lt, 单调栈是 help_s ；</span></span><br><span class="line"><span class="string">    在下面讨论的情况中，单调栈存储的都是索引值index&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;(1) 求下一个更大值 &#x27;&#x27;&#x27;</span> </span><br><span class="line"><span class="comment"># 此时构造单调栈的目标是【单调递减】(可以相等)</span></span><br><span class="line"><span class="comment"># 理由如下：</span></span><br><span class="line"><span class="comment"># 如果元素一直递减(或相等)，意味着【下一个更大数】一直未出现；</span></span><br><span class="line"><span class="comment"># 那么栈就可以一直默认压入元素</span></span><br><span class="line"><span class="comment"># 直到遇到一个【更大数】，栈才会进行pop出栈操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 核心code</span></span><br><span class="line"><span class="keyword">while</span> help_s <span class="keyword">and</span> data_lt[help_s[-<span class="number">1</span>]] &lt; data_lt[i]:</span><br><span class="line">    <span class="comment"># 当栈不为空，且遇当前数 &gt; 栈顶元素，说明遇到了【下一个更大数】</span></span><br><span class="line">    <span class="comment"># 就需要出栈，直到当前数 &lt;= 栈顶元素，栈又能保持单调递减性，既可以跳出循环</span></span><br><span class="line">    <span class="comment"># old_i 代表栈顶元素的索引，很明显，当前i位置的数，就是old_i位置数的【下一个更大数】</span></span><br><span class="line">    old_i = help_s.pop()</span><br><span class="line">    <span class="comment"># gap存储的是old_i位置的数，距离它的【下一个更大数】i位置的 间距</span></span><br><span class="line">    gap[old_i] = i - old_i </span><br><span class="line">    <span class="comment"># next_big_id，存储的是old_i位置数，的【下一个更大数】的索引</span></span><br><span class="line">    next_big_id[old_i] = i  </span><br><span class="line"><span class="comment"># 如果i位置的数能能保持栈的单调递减，就压入i位置的索引</span></span><br><span class="line">help_s.append(i)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;(4) 求下一个更小值&#x27;&#x27;&#x27;</span> </span><br><span class="line"><span class="comment"># 此时构造单调栈的目标是【单调递增】(可以相等)</span></span><br><span class="line"><span class="comment"># 理由如下：</span></span><br><span class="line"><span class="comment"># 如果元素一直递增(或相等)，意味着【下一个更小数】一直未出现；</span></span><br><span class="line"><span class="comment"># 那么栈就可以一直默认压入元素</span></span><br><span class="line"><span class="comment"># 直到遇到一个【更小数】，栈才会进行pop出栈操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 核心code</span></span><br><span class="line"><span class="keyword">while</span> help_s <span class="keyword">and</span> data_lt[help_s[-<span class="number">1</span>]] &gt; data_lt[i]:</span><br><span class="line">    <span class="comment"># 当栈不为空，且遇当前数 &lt; 栈顶元素，说明遇到了【下一个更小数】</span></span><br><span class="line">    <span class="comment"># 就需要出栈，直到当前数 &gt;= 栈顶元素，栈又能保持单调递减性，既可以跳出循环</span></span><br><span class="line">    <span class="comment"># old_i 代表栈顶元素的索引，很明显，当前i位置的数，就是old_i位置数的【下一个更小数】</span></span><br><span class="line">    old_i = help_s.pop()</span><br><span class="line">    gap[old_i] = i - old_i </span><br><span class="line">    next_small_id[old_i] = i  </span><br><span class="line"></span><br><span class="line">help_s.append(i)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;(3) 求上一个更大值 &#x27;&#x27;&#x27;</span> </span><br><span class="line"><span class="comment"># 此时构造单调栈的目标是【单调递减】(不可以相等)</span></span><br><span class="line"><span class="comment"># 理由如下：</span></span><br><span class="line"><span class="comment"># 如果元素一直递减(不可以相等)，意味着前面的数一直比后面的数大，故后面的数的【上一个更大数】，就是紧邻它的上一个数；</span></span><br><span class="line"><span class="comment"># 那么栈就可以一直默认压入元素</span></span><br><span class="line"><span class="comment"># 直到遇到一个较大的数，此时栈顶元素小，为了寻找前面是否有当前数的【上一个更大数】，就需要出栈操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里要注意，相较于求【下一个更大数】，此时的单调栈中是不允许出现连续相等值的</span></span><br><span class="line"><span class="comment"># 因为如果出现相等值，比如连续出现两个6，那么第二个6的前一个数。并不是它的【上一个更大数】</span></span><br><span class="line"><span class="comment"># 为了去寻找上一个更大数，只能往更前方去寻找，所以还是要执行出栈操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 核心code</span></span><br><span class="line"><span class="keyword">while</span> help_s <span class="keyword">and</span> data_lt[help_s[-<span class="number">1</span>]] &lt;= data_lt[i]:</span><br><span class="line">    <span class="comment"># 当栈不为空，且遇当前数 &gt;= 栈顶元素，说明当前数需要去更前方寻找【上一个更大数】</span></span><br><span class="line">    <span class="comment"># 就需要出栈，直到当前数 &lt; 栈顶元素，栈又能保持单调性，说明找到了当前数的【上一个更大数】</span></span><br><span class="line">    help_s.pop()</span><br><span class="line"><span class="comment"># 跳出while循环后，栈顶的数是满足&lt;上一个更大数&gt;的条件的</span></span><br><span class="line">last_big_id[i] = help_s[-<span class="number">1</span>] <span class="keyword">if</span> help_s <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">gap[i] = i - help_s[-<span class="number">1</span>] <span class="keyword">if</span> help_s <span class="keyword">else</span> i <span class="comment"># or -1</span></span><br><span class="line"> </span><br><span class="line">help_s.append(i)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;(4) 上一个更小值 &#x27;&#x27;&#x27;</span> </span><br><span class="line"><span class="comment"># 此时构造单调栈的目标是【单调递增】(不可以相等)</span></span><br><span class="line"><span class="comment"># 理由如下：</span></span><br><span class="line"><span class="comment"># 如果元素一直递增(不可以相等)，意味着前面的数一直比后面的数小，故后面的数的【上一个更小数】，就是紧邻它的上一个数；</span></span><br><span class="line"><span class="comment"># 直到遇到一个较小的数，此时栈顶元素较大，为了寻找前面是否有当前数的【上一个更小数】，就需要出栈操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里要注意，相较于求【下一个更小数】，此时的单调栈中是不允许出现连续相等值的</span></span><br><span class="line"><span class="comment"># 因为如果出现相等值，比如连续出现两个6，那么第二个6的前一个数。并不是它的【上一个更小数】</span></span><br><span class="line"><span class="comment"># 为了去寻找上一个更小数，只能往更前方去寻找，所以还是要执行出栈操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 核心code</span></span><br><span class="line"><span class="keyword">while</span> help_s <span class="keyword">and</span> data_lt[help_s[-<span class="number">1</span>]] &gt;= data_lt[i]:</span><br><span class="line">    <span class="comment"># 当栈不为空，且遇当前数 &lt;= 栈顶元素，说明当前数需要去更前方寻找【上一个更小数】</span></span><br><span class="line">    <span class="comment"># 就需要出栈，直到当前数 &gt; 栈顶元素，栈又能保持单调性，说明找到了当前数的【上一个更小数】</span></span><br><span class="line">    help_s.pop()</span><br><span class="line"><span class="comment"># 跳出while循环后，栈顶的数是满足&lt;上一个更小数&gt;的条件的</span></span><br><span class="line">last_small_id = help_s[-<span class="number">1</span>] <span class="keyword">if</span> help_s <span class="keyword">else</span> -<span class="number">1</span> </span><br><span class="line">gap[i] = i - help_s[-<span class="number">1</span>] <span class="keyword">if</span> help_s <span class="keyword">else</span> i <span class="comment"># or -1</span></span><br><span class="line"></span><br><span class="line">help_s.append(i)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">找更大 、 更小时，栈里的数据</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 找【更大】数，不管是上一个还是下一个，单调栈中 数据的趋势是递减的；</span></span><br><span class="line"><span class="comment"># 找【更小】数，不管是上一个还是下一个，单调栈中 数据的趋势是递增的。</span></span><br></pre></td></tr></table></figure><p><span id="5.2.2.1"></span>  </p><h3 id="5-2-2-1-每日温度"><a href="#5-2-2-1-每日温度" class="headerlink" title="5.2.2.1 每日温度"></a>5.2.2.1 每日温度</h3><p><a href="https://leetcode.cn/problems/daily-temperatures">LeetCode 739.每日温度</a> | | <a href="#5.2.2">返回目录5.2.2</a></p><font color="#3399FF">方案：此题的核心思想就是：【求下一个更大数】用的是单调栈，且保持单调递减的关系。就是如果后面的温度总比前一天小（或相等），我们就可以不管它，相当于直接入单调栈；如果后面的温度比前面的大，我们才来计算相差的gap天数。具体看操作看code：</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        s = [] <span class="comment"># s是单调栈</span></span><br><span class="line">        N = <span class="built_in">len</span>(temperatures)</span><br><span class="line">        <span class="comment"># gap 是用来保存相差天数的数组，默认为0</span></span><br><span class="line">        gap = [<span class="number">0</span>]*N</span><br><span class="line">        <span class="comment"># 这里我们的单调栈存储的是天数（index），但是用的是温度值进行比较大小</span></span><br><span class="line">        <span class="comment"># 因为只要能获得index，就能从温度数组中定位到具体的温度</span></span><br><span class="line">        <span class="comment"># 对于该方法，我们维护的单调栈是递减的（或相等）</span></span><br><span class="line">        <span class="comment"># 即每遍历到一个元素，栈顶的元素应当 不小于 当前元素</span></span><br><span class="line">        <span class="comment"># 否则，当前元素就是【更大数】，就需要出栈计算差值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="comment"># 单调栈不为空，且当前元素 比 栈顶元素大的情况，我们就需要操作</span></span><br><span class="line">            <span class="keyword">while</span> s <span class="keyword">and</span> temperatures[i] &gt; temperatures[s[-<span class="number">1</span>]]:</span><br><span class="line">                <span class="comment"># 将单调栈的栈顶元素出栈</span></span><br><span class="line">                <span class="comment"># 对于该题，lower_i 是之前较低温度的索引</span></span><br><span class="line">                lower_i = s.pop()</span><br><span class="line">                <span class="comment"># 同时顺便计算一波差值delta</span></span><br><span class="line">                <span class="comment"># 即被出栈的那一天，与当前日期的差值，（因为当前天就是一个高温值）</span></span><br><span class="line">                gap[lower_i] = i - lower_i</span><br><span class="line">            <span class="comment"># 直到满足了单调递减的关系，（或者栈为空），我们才入栈</span></span><br><span class="line">            s.append(i)</span><br><span class="line">        <span class="keyword">return</span> gap</span><br></pre></td></tr></table></figure><p><span id="5.2.2.2"></span>  </p><h3 id="5-2-2-2-下一个更大元素I"><a href="#5-2-2-2-下一个更大元素I" class="headerlink" title="5.2.2.2 下一个更大元素I"></a>5.2.2.2 下一个更大元素I</h3><p><a href="https://leetcode.cn/problems/next-greater-element-i">LeetCode 496.下一个更大元素 I</a> | | <a href="#5.2.2">返回目录5.2.2</a></p><font color="#3399FF">方案:问题分为两个子问题:①依据nums1中的元素定位到nums2中的索引位置；②求该位置下一个更大的元素;对于问题①，虽然可以用list.index(obj)来返回，但是该操作每次执行的时间复杂度是O(N)；所以干脆先遍历一道nums2，将元素和索引存入哈希表中，后续再查的时候，查询的时间复杂度就是O(1)。对于问题②，其实就是 【求下一更大数】 这个问题，直接套用单调栈核心code。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;方案1. 暴力求解&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hash_l = &#123;&#125;</span><br><span class="line">        N2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        <span class="comment"># 先将nums2的元素与序号对应关系存入哈希表</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums2):</span><br><span class="line">            hash_l[num] = i</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每次遍历nums1获得的num，都去num2中其位置右侧进行遍历，试图找到最近的最大值</span></span><br><span class="line">        <span class="comment"># 时间复杂度 O(N1*N2)</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums1:</span><br><span class="line">            index = hash_l[num]</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">while</span> index &lt; N2 <span class="keyword">and</span> <span class="keyword">not</span> flag:</span><br><span class="line">                <span class="keyword">if</span> nums2[index] &gt; num:</span><br><span class="line">                    res.append(nums2[index])</span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> flag: res.append(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;方案2. 利用单调栈，借鉴【5.2.8 每日温度】的解法&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        h=&#123;&#125;</span><br><span class="line">        N = <span class="built_in">len</span>(nums2)</span><br><span class="line">        s, next_big_val = [], [-<span class="number">1</span>]*N</span><br><span class="line">        <span class="comment"># 注意，此题需要求的是【下一个更大数】的数值，所以 next_big_val直接存入数值</span></span><br><span class="line">        <span class="comment"># 且题目中规定了，不存在的话值为-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            h[nums2[i]]=i</span><br><span class="line">            <span class="keyword">while</span> s <span class="keyword">and</span> nums2[s[-<span class="number">1</span>]] &lt; nums2[i]:</span><br><span class="line">                lower_i = s.pop()</span><br><span class="line">                next_big_val[lower_i] = nums2[i] <span class="comment"># 这里直接存储nums2的元素</span></span><br><span class="line">            s.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [next_big_val[h[num]] <span class="keyword">for</span> num <span class="keyword">in</span> nums1]</span><br></pre></td></tr></table></figure><p><span id="5.2.2.3"></span>  </p><h3 id="5-2-2-3-下一个更大元素-II"><a href="#5-2-2-3-下一个更大元素-II" class="headerlink" title="5.2.2.3 下一个更大元素 II"></a>5.2.2.3 下一个更大元素 II</h3><p><a href="https://leetcode.cn/problems/next-greater-element-ii">LeetCode 503.下一个更大元素 II</a> | | <a href="#5.2.2">返回目录5.2.2</a></p><font color="#3399FF">方案：问题本质依旧是【求下一个更大数】；核心点在于数组可以循环。也就是一个数能够往右看的范围，到数组尾部后，又可以从头可以回到它自己身上。那么说明如果看完一圈还没有找到更大的话，那再多看几圈也不会有更大的。所以数组最多遍历2次就够了。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;1.最简单的思路，就是把原来数组扩充一倍，</span></span><br><span class="line"><span class="string">    只不过返回结果的时候，只返回前N个就可以了&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElements</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        s, res = [], [-<span class="number">1</span>]*<span class="number">2</span>*N</span><br><span class="line">        nums2 = nums + nums</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums2)):</span><br><span class="line">            <span class="keyword">while</span> s <span class="keyword">and</span> nums2[i] &gt; nums2[s[-<span class="number">1</span>]]:</span><br><span class="line">                tmp_i = s.pop()</span><br><span class="line">                res[tmp_i] = nums2[i] <span class="comment"># 直接存储数字值</span></span><br><span class="line">            s.append(i)</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>:N]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;方案1稍微有点耗内存，可以考虑不用扩充数组的方式来循环，即求模运算。</span></span><br><span class="line"><span class="string">但求模可能又会多花点时间&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElements</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        s = []</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        next_big_val = [-<span class="number">1</span>]*N</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*N):</span><br><span class="line">            <span class="comment"># nums取值将index限定在[0,N-1]</span></span><br><span class="line">            <span class="keyword">while</span> s <span class="keyword">and</span> nums[s[-<span class="number">1</span>]] &lt; nums[i%N]:</span><br><span class="line">                lower_i = s.pop()</span><br><span class="line">                next_big_val[lower_i] = nums[i%N]</span><br><span class="line">            <span class="comment"># s存入index时，也要求模运算，将index限定在[0,N-1]</span></span><br><span class="line">            s.append(i%N)</span><br><span class="line">        <span class="keyword">return</span> next_big_val</span><br></pre></td></tr></table></figure><p><span id="5.2.2.4"></span>  </p><h3 id="5-2-2-4-股票价格跨度"><a href="#5-2-2-4-股票价格跨度" class="headerlink" title="5.2.2.4 股票价格跨度"></a>5.2.2.4 股票价格跨度</h3><p><a href="https://leetcode.cn/problems/online-stock-span">LeetCode 901.股票价格跨度</a> | | <a href="#5.2.2">返回目录5.2.2</a></p><font color="#3399FF">方案：问题本质：【求上一个更大数】。gap是当前 i 位置与上一个更大元素的位置的gap。那么在这个gap区间，所有的数都是小于当前值的，这就是该题要求的跨度。   所以我们需要维护一个 单调递减栈。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StockSpanner</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__s = []</span><br><span class="line">        self.__data = []</span><br><span class="line">        self.__<span class="built_in">len</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self, price: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 需要先存入新来的数据</span></span><br><span class="line">        self.__<span class="built_in">len</span> +=<span class="number">1</span></span><br><span class="line">        self.__data.append(price)</span><br><span class="line">        i = self.__<span class="built_in">len</span> - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> self.__s <span class="keyword">and</span> self.__data[self.__s[-<span class="number">1</span>]] &lt;= price:</span><br><span class="line">            self.__s.pop()</span><br><span class="line">        gap = i- self.__s[-<span class="number">1</span>] <span class="keyword">if</span> self.__s <span class="keyword">else</span> self.__<span class="built_in">len</span></span><br><span class="line">        self.__s.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> gap</span><br></pre></td></tr></table></figure><p><span id="5.2.2.5"></span></p><h3 id="5-2-2-5-柱状图中最大的矩形"><a href="#5-2-2-5-柱状图中最大的矩形" class="headerlink" title="5.2.2.5 柱状图中最大的矩形"></a>5.2.2.5 柱状图中最大的矩形</h3><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">LeetCode 84.柱状图中最大的矩形</a> | | <a href="#5.2.2">返回目录5.2.2</a></p><font color="#3399FF">方案：首先，对于每一个柱状体，都至少有一个面积，就是它自身。其次，如果一个柱状体的左右两侧都有高于或等于它的柱状体，那么它就能以它自身的高度进行横向扩展。所以，对于每一个柱状体能够构成的矩形，其高度是固定的，就是该柱状体的高度，我们只需要求能够扩展的宽度，就能求出以每一个柱状体为base，能够构成的最大矩形的面。所以这个题目，就转化成了一个求每个柱状体能够扩展的最大的宽度的这么一个问题。也就是说，对于每一个柱状体，需要找到左侧第一个比它小的柱状体，和右侧第一个比它小的柱状体。这二者之间间隔的宽度，就是能够扩展的最大宽度。</font><strong><font color="#FF0000">问题就转化成了：【上一个更小数】，和【下一个更小数】</font></strong>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(heights)</span><br><span class="line">        left_small_list, right_small_list = [-<span class="number">1</span>]*N, [N]*N</span><br><span class="line">        L_s, R_S = [], []</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="comment"># 求【上一个更小数】的索引</span></span><br><span class="line">            <span class="keyword">while</span> L_s <span class="keyword">and</span> heights[i] &lt;= heights[L_s[-<span class="number">1</span>]]:</span><br><span class="line">                L_s.pop()</span><br><span class="line">            left_small_list[i] = L_s[-<span class="number">1</span>] <span class="keyword">if</span> L_s <span class="keyword">else</span> -<span class="number">1</span> <span class="comment"># L_S 为空的话，最左侧边界为-1</span></span><br><span class="line">            L_s.append(i)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 求【下一个更小数】的索引</span></span><br><span class="line">            <span class="keyword">while</span> R_S <span class="keyword">and</span> heights[i] &lt; heights[R_S[-<span class="number">1</span>]]:</span><br><span class="line">                larger_i = R_S.pop()</span><br><span class="line">                right_small_list[larger_i] = i</span><br><span class="line">            R_S.append(i)</span><br><span class="line">        <span class="comment"># print(left_small_list, right_small_list)</span></span><br><span class="line">        <span class="comment"># 区间宽度就是：下一个最小的索引 - 上一个最小的索引 - 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>([heights[i]*(right_small_list[i] - left_small_list[i]-<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="5.2.2.7"></span>  </p><h3 id="5-2-2-7-接雨水"><a href="#5-2-2-7-接雨水" class="headerlink" title="5.2.2.7 接雨水"></a>5.2.2.7 接雨水</h3><p><a href="https://leetcode.cn/problems/trapping-rain-water">LeetCode 42.接雨水</a> | | <a href="#5.2.2">返回目录5.2.2</a></p><font color="#3399FF">该题在处已经讲过，但是同样可以用单调栈来做。考虑何时当前柱子能够接到水？必然是其左右侧都有高于它的边界才行。如果对于遍历的数，如果求【上一个更大数】，那么这上一个更大数（可相等），和当前数之间的区域，就都能装水；因为这区间的中的数，都小于当前数，同样更小于找到的【上一个更大数（相等数）】；由于维护的单调栈是单调递减的，所以在寻找【上一个更大数】的过程中，每从栈中pop处一个数，该数的左侧数一定是比它高的（因为递减关系），那么被pop出来的数 的左侧的数，就能作为被pop出的数的左边界。此时，就能计算从pop出的位置开始，向右延伸到当前位置为右边的，一条横的水柱的体积。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27; 单调栈解法&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(height)</span><br><span class="line">        <span class="comment"># 最左和最右的柱子只能当边界，无法装水</span></span><br><span class="line">        <span class="comment"># 柱子一定要至少有3个才能装水</span></span><br><span class="line">        water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> N &lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> water</span><br><span class="line"></span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">while</span> s <span class="keyword">and</span> height[i] &gt; height[s[-<span class="number">1</span>]]:</span><br><span class="line">                <span class="comment"># 过程中每pop出一个索引，就要计算pop出的这个位置，能装多少水</span></span><br><span class="line">                tmp = s.pop()</span><br><span class="line">                <span class="keyword">if</span> s:</span><br><span class="line">                <span class="comment"># 当栈中还有元素可以作为左边界时，才进行下面的运算</span></span><br><span class="line">                    <span class="comment"># 刚刚被pop出的tmp的左侧数，也就是当前栈顶元素，作为tmp的左边界</span></span><br><span class="line">                    L = s[-<span class="number">1</span>]</span><br><span class="line">                    <span class="comment"># 以当前位置i作为tmp的右边界，计算区间宽度</span></span><br><span class="line">                    W = i - L -<span class="number">1</span></span><br><span class="line">                    <span class="comment"># 计算这个横向水柱的高度</span></span><br><span class="line">                    H = <span class="built_in">min</span>(height[L], height[i]) - height[tmp]</span><br><span class="line">                    water += W * H </span><br><span class="line">            s.append(i)</span><br><span class="line">        <span class="keyword">return</span> water</span><br></pre></td></tr></table></figure><p><span id="5.2.3"></span>  </p><h2 id="5-2-3-队列的常见题目："><a href="#5-2-3-队列的常见题目：" class="headerlink" title="5.2.3 队列的常见题目："></a>5.2.3 队列的常见题目：</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/implement-stack-using-queues/">LeetCode 225.用队列实现栈</a></td><td><a href="#5.2.3.1">5.2.3.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/design-circular-queue/">LeetCode 622.设计循环队列</a></td><td><a href="#5.2.3.2">5.2.3.2题解</a></td></tr></tbody></table></div><p><span id="5.2.3.1"></span>  </p><h3 id="5-2-3-1-用队列实现栈"><a href="#5-2-3-1-用队列实现栈" class="headerlink" title="5.2.3.1 用队列实现栈"></a>5.2.3.1 用队列实现栈</h3><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">LeetCode 225.用队列实现栈</a> | | <a href="#5.2.3">返回目录5.2.3</a></p><font color="#3399FF">方案：核心点在于队列只能从队首元素出队，也就是说，先进的先出；而栈是后进的先出。那么如果要出栈，只需要把队尾的那个元素，挪到队首即可，怎么挪呢？可以把前面的所有元素先存到另一个队列里去，这样队列元素的顺序依然能够保持，剩下一个队尾元素，进行出队列操作即可。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 虽然也能用list来充当队列，但是这里可以用更为标准的队列类:deque来作为队列使用</span></span><br><span class="line">        <span class="comment"># 注意，deque其实是个双端队列，这里我们使用左侧为出队，右侧入队</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        self.__q_a = deque([])</span><br><span class="line">        self.__q_b = deque([])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.__q_a <span class="keyword">and</span> <span class="keyword">not</span> self.__q_b:</span><br><span class="line">            <span class="comment"># 如果两个队列初始都为空，就先默认用队列a来填充元素</span></span><br><span class="line">            self.__q_a.append(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 否则的话就使用二者中 不为空 的那个队列来填充</span></span><br><span class="line">        <span class="comment"># (我们在后续的操作中，会保证常规状态下至少有一个队列是空的，另一个队列用来装元素)</span></span><br><span class="line">        <span class="comment"># (所以不会出现两个队列都有元素的状态)</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> self.__q_a:</span><br><span class="line">            self.__q_b.append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__q_a.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果当前是队列a有元素</span></span><br><span class="line">        <span class="keyword">if</span> self.__q_a:</span><br><span class="line">            <span class="comment"># 那就将队列a中除了队尾元素之外的所有元素装入队列b</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self.__q_a)&gt;<span class="number">1</span>:</span><br><span class="line">                self.__q_b.append(self.__q_a.popleft())</span><br><span class="line">            <span class="comment"># 然后使用出队列操作弹出a队列中仅剩的这一个队尾元素（被当做栈顶元素）</span></span><br><span class="line">            <span class="keyword">return</span> self.__q_a.popleft()</span><br><span class="line">            <span class="comment"># 结束后，会发现队列a为空，元素全在队列b中了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果当前队列b有元素,操作同上</span></span><br><span class="line">        <span class="keyword">elif</span> self.__q_b:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self.__q_b)&gt; <span class="number">1</span>:</span><br><span class="line">                self.__q_a.append(self.__q_b.popleft())</span><br><span class="line">            <span class="keyword">return</span> self.__q_b.popleft()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 两个队列都为空</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 栈的top()操作本来就有队列中对应的 rear()操作，即取末尾元素</span></span><br><span class="line">        <span class="keyword">if</span> self.__q_a:</span><br><span class="line">            <span class="keyword">return</span> self.__q_a[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__q_b[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.__q_a <span class="keyword">and</span> <span class="keyword">not</span> self.__q_b:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><span id="5.2.3.2"></span>  </p><h3 id="5-2-3-2-设计循环队列"><a href="#5-2-3-2-设计循环队列" class="headerlink" title="5.2.3.2 设计循环队列"></a>5.2.3.2 设计循环队列</h3><p><a href="https://leetcode.cn/problems/design-circular-queue/">LeetCode 622.设计循环队列</a> | | <a href="#5.2.3">返回目录5.2.3</a></p><font color="#3399FF">思路：①首先，要设置 head 和 tail 两个游标，分别来控制队首和队尾；∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷②在初始化的时候，heal 和 tail 两个游标默认值通常是0的；那么也就推出，在后续判断队列是否为空的时候，判断条件就是 head == tail;∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷③对于普通队列，如果tail超过了数组的长度length，那就说明队列满了；但是由于此题是要构造循环队列，所以单纯用数组的长度来限制，是不够的；将数组收尾相连成环的话，会发现，如果 tail的下一个位置是head，说明确实无空间再存储新元素了；所以满队列的条件应当是 (tail +1) % length。∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷④关于tail游标指向的位置，是否应该指向最后一个元素？在初始化时，head 和 tail 都是0，且 判断空队列的条件是，head == tail;所以在队列为空的时候，tail指向的位置是head，但其实head处是没有元素的；如果新增一个元素，head位置有元素了，队列不为空，那么tail就不应该再指向head；而是应该指向head 的下一位；由此可以知道，tail其实并不指向最后一个元素的位置，而是应该指向最后一个元素的下一个位置；成为类似于“右边界”的存在。所以，如果要让队列能存储的数据有 K 个，那么实际上需要有 K+1 长度的数组；这样，当队列在不dequeue操作，第一次装满时：head=0，指向第一个元素；最后一个元素的位置是K；tail指向的是K+1</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k: <span class="built_in">int</span></span>):</span><br><span class="line">        self.__cycle_q = [-<span class="number">999</span>] *(k+<span class="number">1</span>)</span><br><span class="line">        self.__head = <span class="number">0</span></span><br><span class="line">        self.__tail = <span class="number">0</span></span><br><span class="line">        self.__<span class="built_in">len</span> = k+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enQueue</span>(<span class="params">self, value: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> self.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__cycle_q[self.__tail] = value</span><br><span class="line">            self.__tail = (self.__tail+<span class="number">1</span>) % self.__<span class="built_in">len</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deQueue</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 并不需要真的删除原来的head指向的元素</span></span><br><span class="line">            <span class="comment"># 只需要将它排除出有效区间即可</span></span><br><span class="line">            self.__head = (self.__head+<span class="number">1</span>) % self.__<span class="built_in">len</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Front</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:         </span><br><span class="line">            <span class="keyword">return</span> self.__cycle_q[self.__head]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Rear</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 这里要留心，tail指向的是最后元素的下一位</span></span><br><span class="line">            <span class="comment"># 所以最后的元素是 tail-1的位置！         </span></span><br><span class="line">            <span class="keyword">return</span> self.__cycle_q[self.__tail-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.__head == self.__tail</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isFull</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> (self.__tail+<span class="number">1</span>) % self.__<span class="built_in">len</span> == self.__head</span><br></pre></td></tr></table></figure><h2 id="5-2-4-优先队列："><a href="#5-2-4-优先队列：" class="headerlink" title="5.2.4 优先队列："></a>5.2.4 优先队列：</h2><p>优先队列，是一种特殊的队列。它的增加和删除元素的方式和普通队列一样，入队从队尾增加元素，出队删除队头元素。区别点在于，普通队列的内部元素顺序就是按照元素入队列的顺序排布的，而<b>优先队列自己会将内部元素按照一定的顺序进行排布。</b>  </p><p>也就是说，在新元素添加到队尾之后，队列会自己将这个新元素放到合适的位置，使得满足其顺序定义。而在出队列操作，弹出队首元素后，队列也会对剩下的元素重新梳理一遍顺序。而这个顺序，其实就是之前在排序章节，堆排序部分，讲过的堆结构的顺序。  </p><font color="purple"><b>所以优先队列也被称为堆队列(Heap queue)，可以理解为大（小）根堆。python中有自带的优先队列的库:`heapq`，[官方文档点击此处](https://docs.python.org/3/library/heapq.html)。[官方源码点击此处](https://github.com/python/cpython/blob/main/Lib/heapq.py)。下面讲解几个常用的操作：</b></font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">list_test = [<span class="number">10</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">1.heapify </span></span><br><span class="line"><span class="string">将list转换为一个 小根堆，最小的元素会被放到队首（根节点）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">heapq.heapify(list_test)</span><br><span class="line"><span class="built_in">print</span>(list_test)</span><br><span class="line"><span class="comment"># [0, 1, 4, 2, 5, 6, 8, 10, 9, 7]</span></span><br><span class="line"><span class="comment"># (结果顺序并不一定和这个相同，只要0在根结点，满足小根堆，都是对的)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">2.heappush </span></span><br><span class="line"><span class="string">将新元素插入末尾，并按照小根堆的顺序排序</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">heapq.heappush(list_test, -<span class="number">1</span>)</span><br><span class="line">heapq.heappush(list_test, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(list_test)</span><br><span class="line"><span class="comment"># [-1, 0, 4, 2, 1, 6, 8, 10, 9, 7, 5, 20]</span></span><br><span class="line"><span class="comment"># (结果顺序并不一定和这个相同，只要-1在根结点，20在某个叶子结点，满足小根堆，都是对的)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 3.heappop </span></span><br><span class="line"><span class="string">将队首元素（根节点）弹出，并将剩下的元素恢复成小根堆</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">top = heapq.heappop(list_test)</span><br><span class="line"><span class="built_in">print</span>(list_test)</span><br><span class="line"><span class="comment"># [0, 1, 4, 2, 5, 6, 8, 10, 9, 7, 20]</span></span><br><span class="line"><span class="built_in">print</span>(top)</span><br><span class="line"><span class="comment"># -1</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 4.heapreplace </span></span><br><span class="line"><span class="string">同时执行heappop和heappush，但注意，操作顺序是：</span></span><br><span class="line"><span class="string">先pop队首元素，然后push新元素</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">top2 = heapq.heapreplace(list_test, <span class="number">11</span>)</span><br><span class="line"><span class="built_in">print</span>(list_test)</span><br><span class="line"><span class="comment"># [1, 2, 4, 9, 5, 6, 8, 10, 11, 7, 20]</span></span><br><span class="line"><span class="built_in">print</span>(top2)</span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 5.heappushpop </span></span><br><span class="line"><span class="string">同时执行heappush和heappop，</span></span><br><span class="line"><span class="string">这里先push新元素，然后再pop队首元素</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">top3 = heapq.heappushpop(list_test, -<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(list_test)</span><br><span class="line"><span class="comment"># [1, 2, 4, 9, 5, 6, 8, 10, 11, 7, 20]</span></span><br><span class="line"><span class="built_in">print</span>(top3)</span><br><span class="line"><span class="comment"># -10 </span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 6.merge </span></span><br><span class="line"><span class="string"># 将多个堆合并,合并后的结果也是小根堆</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">a = [<span class="number">10</span>, <span class="number">7</span>, <span class="number">6</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">c = heapq.merge(a,b)</span><br><span class="line"><span class="built_in">print</span>(c, <span class="built_in">list</span>(c))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 7.nlargest </span></span><br><span class="line"><span class="string"> 查询堆中的最大n个元素， 并返回</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">nlarge = heapq.nlargest(<span class="number">3</span>, list_test)</span><br><span class="line"><span class="built_in">print</span>(nlarge)</span><br><span class="line"><span class="comment"># [20, 11, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 8.nsmallest </span></span><br><span class="line"><span class="string"># 查询堆中的最小n个元素</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">nsmall = heapq.nsmallest(<span class="number">3</span>, list_test)</span><br><span class="line"><span class="built_in">print</span>(nsmall)</span><br><span class="line"><span class="comment"># [1, 2, 4]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 9._heapify_max </span></span><br><span class="line"><span class="string"># 构造大根堆 </span></span><br><span class="line"><span class="string"># 注意, 对于数值型数据，一般都不会用到建立大根堆的操作</span></span><br><span class="line"><span class="string"># 因为将数值取反，建立小根堆，就能完成大根堆的目的</span></span><br><span class="line"><span class="string"># 举例： list_new = list(map(lambda x : -x, list_test))</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">heapq._heapify_max(list_test)</span><br><span class="line"><span class="built_in">print</span>(list_test)   </span><br><span class="line"><span class="comment"># 同时，如果是用这种方式构造的大根堆，其pop是：</span></span><br><span class="line"><span class="comment"># heapq._heappop_max</span></span><br><span class="line"><span class="comment"># 更为具体的一些写法参考源码： https://github.com/python/cpython/blob/main/Lib/heapq.py</span></span><br><span class="line"><span class="comment"># 大根堆对应的函数并不多，所以在日常中一般自己将数值取反，然后使用小根堆</span></span><br></pre></td></tr></table></figure><p><span id="5.2.4"></span>  </p><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/sliding-window-maximum/">LeetCode 239.滑动窗口最大值</a></td><td><a href="#5.2.4.1">5.2.4.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream/">LeetCode 703.数据流中的第 K 大元素</a></td><td><a href="#5.2.4.2">5.2.4.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">LeetCode 215.数组中的第K个最大元素</a></td><td><a href="#5.2.4.3">5.2.4.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/top-k-frequent-elements/">LeetCode 347.前 K 个高频元素</a></td><td><a href="#5.2.4.4">5.2.4.4题解</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/sort-characters-by-frequency/">LeetCode 451.根据字符出现频率排序</a></td><td><a href="#5.2.4.5">5.2.4.5题解</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/find-median-from-data-stream/">LeetCode 295.数据流的中位数</a></td><td><a href="#5.2.4.6">5.2.4.6题解</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/k-closest-points-to-origin/">LeetCode 973.最接近原点的 K 个点</a></td><td><a href="#5.2.4.7">5.2.4.7题解</a></td></tr></tbody></table></div><p><span id="5.2.4.1"></span>  </p><h3 id="5-2-4-1-滑动窗口最大值"><a href="#5-2-4-1-滑动窗口最大值" class="headerlink" title="5.2.4.1 滑动窗口最大值"></a>5.2.4.1 滑动窗口最大值</h3><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">LeetCode 239.滑动窗口最大值</a> | | <a href="#5.2.4">返回目录5.2.4</a></p><font color="#3399FF">思路：滑动窗口是典型的用优先队列的题目。如果直接使用暴力方法，一般都会超时。  这里由于要求窗口内最大的元素，所以要建立大根堆。但是python自带的`heapq`默认建立的是小根堆，我们只需要把元素取反即可适应它的默认结构，获取结果时记得取反取回来就好</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> N &lt;= k:</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">max</span>(nums)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 暴力求解会超时</span></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># for i in range(0,N-k+1):</span></span><br><span class="line">        <span class="comment">#     res.append(max(nums[i:i+k]))</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> heapq </span><br><span class="line">        <span class="comment"># 先将第一个宽度为k的窗口内的元素初始化为优先队列</span></span><br><span class="line">        <span class="comment"># 记得要将元素值取反去建立小根堆</span></span><br><span class="line">        window = [(-nums[i], i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">        heapq.heapify(window)</span><br><span class="line">        <span class="comment"># 小根堆最小的元素，取反之后的原数值就是最大的</span></span><br><span class="line">        res = [-window[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">        <span class="comment"># print(window)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 窗口每挪动一次，就用heappush添加一个数，维护成小根堆</span></span><br><span class="line">        <span class="comment"># 需要注意的是，如果堆顶元素，不在当前滑动窗口范围内，要及时pop出去</span></span><br><span class="line">        <span class="comment"># i 指向作为滑动窗口的最后一个元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, N):</span><br><span class="line">            <span class="comment"># 当前堆顶元素，不在当前窗口 i-k+1 ~ i 内</span></span><br><span class="line">            <span class="keyword">while</span> window <span class="keyword">and</span> window[<span class="number">0</span>][<span class="number">1</span>] &lt; i-k+<span class="number">1</span>:</span><br><span class="line">                heapq.heappop(window)</span><br><span class="line">            <span class="comment"># 将 i 位置的数push入</span></span><br><span class="line">            heapq.heappush(window, (-nums[i], i))</span><br><span class="line">            res.append(-window[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;值得注意的是，堆的规模其实并不一定会维持在k的大小；</span></span><br><span class="line"><span class="string">           因为pop操作只是在堆顶元素不在窗口内时执行；</span></span><br><span class="line"><span class="string">           有一些元素如果已经不在窗口内，但是其并不在堆顶的话，并不影响我们取值；</span></span><br><span class="line"><span class="string">           所以可以留在堆里不用管；</span></span><br><span class="line"><span class="string">           核心是，要保证每一次的堆顶元素，要在考察的窗口内！&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># print(window)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="5.2.4.2"></span>  </p><h3 id="5-2-4-2-数据流中的第-K-大元素"><a href="#5-2-4-2-数据流中的第-K-大元素" class="headerlink" title="5.2.4.2 数据流中的第 K 大元素"></a>5.2.4.2 数据流中的第 K 大元素</h3><p><a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream/">LeetCode 703.数据流中的第 K 大元素</a> | | <a href="#5.2.4">返回目录5.2.4</a></p><font color="#3399FF">思路：因为要返回第K大的元素，所以每新到一个数，我们就需要将其与原来的前k大的元素相比较，然后判断这个新的数是否能够被划入前 k 大的元素中，并可以丢弃那些已经不在前k大范围内的数。这是一个动态的过程，相当于维护了一个保留前k大数的数组。  python的默认优先队列是小根堆，意思是根节点的值一定比左右子树的值小。如果设置优先队列的长度为 k ， 那么根节点下面就有 k-1 个比它大树，那么根节点恰好就是就是第 k 大 的数。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        self.__nums = nums</span><br><span class="line">        <span class="comment"># 先将初始化列表构造为一个小根堆</span></span><br><span class="line">        heapq.heapify(self.__nums)</span><br><span class="line">        self.__k = k</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先将新来的元素入队列，形成一个新的小根堆</span></span><br><span class="line">        heapq.heappush(self.__nums, val)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.__nums) &gt; self.__k:</span><br><span class="line">            <span class="comment"># 如果队列的数目超过了限定的k</span></span><br><span class="line">            <span class="comment"># 那就把根节点的元素弹出，也就是这些数当中最小的那个数弹出</span></span><br><span class="line">            <span class="comment"># 剩下的数自然就是较大的k个数</span></span><br><span class="line">            heapq.heappop(self.__nums)</span><br><span class="line">        <span class="comment"># 根节点正好是第 k 大 的数</span></span><br><span class="line">        <span class="keyword">return</span> self.__nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><span id="5.2.4.3"></span>  </p><h3 id="5-2-4-3-数组中的第K个最大元素"><a href="#5-2-4-3-数组中的第K个最大元素" class="headerlink" title="5.2.4.3 数组中的第K个最大元素"></a>5.2.4.3 数组中的第K个最大元素</h3><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">LeetCode 215.数组中的第K个最大元素</a> | | <a href="#5.2.4">返回目录5.2.4</a></p><font color="#3399FF">思路：该题之前在[3-3 排序相关题目](https://teeyohuang.github.io/Data-Structure/DS_33_sort_exercises.html)的 [3.3.10](#3.3.10) 已经做过，当时是采用的排序算法，堆方案中也是手写的函数；这里尝试直接使用python自带的优先队列来写code。</font><p><b>写法一：对数组整体应用优先队列，然后再执行k-1次pop操作</b></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;写法1：使用默认的小根堆函数，所以需要先手动将数组取反&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 时间上更快, 空间消耗的反而比自己写heapify操作多一点</span></span><br><span class="line">        nums_new = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:-x,nums))</span><br><span class="line">        heapq.heapify(nums_new)</span><br><span class="line">        <span class="comment"># 因为是找第 k 个最大数, 所以pop掉k-1个即可</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):</span><br><span class="line">            heapq.heappop(nums_new)</span><br><span class="line">        <span class="keyword">return</span> -nums_new[<span class="number">0</span>] <span class="comment"># 这里要注意之前是将数组元素取反了的，现在要取回来</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.如果对函数熟悉的话，直接使用大根堆的函数&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 时间和空间的消耗都是最优的</span></span><br><span class="line">        <span class="comment"># heapq._heapify_max(nums)</span></span><br><span class="line">        <span class="comment"># for _ in range(k-1):</span></span><br><span class="line">        <span class="comment">#     heapq._heappop_max(nums)</span></span><br><span class="line">        <span class="comment"># return nums[0]</span></span><br></pre></td></tr></table></figure><p><b>写法二：像<a href="#5.2.2.2">5.2.2.2</a>那样，维护一个k大小的小根堆</b></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先初始化一个规模为k的优先队列</span></span><br><span class="line">        tmp = nums[:k].copy()</span><br><span class="line">        heapq.heapify(tmp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 每一次都先push入当前i位置i位置的数字</span></span><br><span class="line">            <span class="comment"># 然后对队列执行pop操作，这样使得队列的规模始终是 k </span></span><br><span class="line">            heapq.heappushpop(tmp, (nums[i]))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 循环结束后, 得到的就是整个数组的前K个最大数</span></span><br><span class="line">        <span class="comment"># 堆顶元素就是 第 k 大的数</span></span><br><span class="line">        <span class="keyword">return</span>  tmp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><span id="5.2.4.4"></span>  </p><h3 id="5-2-4-4-前-K-个高频元素"><a href="#5-2-4-4-前-K-个高频元素" class="headerlink" title="5.2.4.4 前 K 个高频元素"></a>5.2.4.4 前 K 个高频元素</h3><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">LeetCode 347.前 K 个高频元素</a> | | <a href="#5.2.4">返回目录5.2.4</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:  </span><br><span class="line">        <span class="keyword">import</span> heapq </span><br><span class="line">        h = &#123;&#125;</span><br><span class="line">        <span class="comment"># 遍历原始list，时间复杂度 O(N)</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> h:</span><br><span class="line">                h[num] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h[num] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        N = <span class="built_in">len</span>(h)</span><br><span class="line">        <span class="comment"># 频率放在数字前面，这样就能按照频率的大小 构造小根堆</span></span><br><span class="line">        new_nums = [(freq, num) <span class="keyword">for</span> num, freq <span class="keyword">in</span> h.items() ]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化一个 k 规模的小根堆</span></span><br><span class="line">        q = new_nums[:k]</span><br><span class="line">        heapq.heapify(q)</span><br><span class="line">        <span class="comment"># 遍历字典，时间复杂度不超过 O(N)，每一次都要恢复成小根堆，时间O(logk)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k,N):</span><br><span class="line">            <span class="comment"># 每一次都先push入当前i位置 的元素</span></span><br><span class="line">            <span class="comment"># 然后对队列执行pop操作，这样使得队列的规模始终是 k </span></span><br><span class="line">            heapq.heappushpop(q, new_nums[i])</span><br><span class="line">        <span class="keyword">return</span> [data[<span class="number">1</span>] <span class="keyword">for</span> data <span class="keyword">in</span> q]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最终时间复杂度应该是 O(N*logk)</span></span><br></pre></td></tr></table></figure><p><span id="5.2.4.5"></span>  </p><h3 id="5-2-4-5-根据字符出现频率排序"><a href="#5-2-4-5-根据字符出现频率排序" class="headerlink" title="5.2.4.5 根据字符出现频率排序"></a>5.2.4.5 根据字符出现频率排序</h3><p><a href="https://leetcode.cn/problems/sort-characters-by-frequency/">LeetCode 451.根据字符出现频率排序</a> | | <a href="#5.2.4">返回目录5.2.4</a></p><font color="#3399FF">思路：这个题和上题很相似，也是先统计频率，然后可以依据频率排序，也可以用优先队列做，两种写法都给出在下面。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">frequencySort</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        h = &#123;&#125;</span><br><span class="line">        <span class="comment"># 先用哈希表统计字符的频率</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> h:</span><br><span class="line">                h[ch] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h[ch] += <span class="number">1</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.排序后再处理&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 生成 (字符，频率)的列表，并依据频率排序 key = lambda x:x[1]</span></span><br><span class="line">        <span class="comment"># 这里为简便，直接使用了自带的sort方法；这里如果面试需要的话，可以换成自己现场写的排序code</span></span><br><span class="line">        <span class="comment"># tmp = [(k,v) for k,v in h.items()]</span></span><br><span class="line">        <span class="comment"># tmp.sort(key = lambda x:x[1], reverse=True)</span></span><br><span class="line">        <span class="comment"># res = [ k*v for k,v in tmp]</span></span><br><span class="line">        <span class="comment"># return &#x27;&#x27;.join(res)</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.使用优先队列&#x27;&#x27;&#x27;</span></span><br><span class="line">        s2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        <span class="comment"># 依然是根据哈希表，生成(频率,字符)的列表</span></span><br><span class="line">        <span class="comment"># 这里将频率放在前面是为了优先队列依据频率数值构造小根堆</span></span><br><span class="line">        tmp = [(v,k) <span class="keyword">for</span> k,v <span class="keyword">in</span> h.items()]</span><br><span class="line">        heapq.heapify(tmp)</span><br><span class="line">        <span class="comment"># print(tmp)</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(tmp)&gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 不断的弹出频率最低的字符和其频率</span></span><br><span class="line">            freq, ch = heapq.heappop(tmp)</span><br><span class="line">            <span class="comment"># 因为题目要求频率从高到低，后被pop出来的字符，频率是比先被pop出来的更高的</span></span><br><span class="line">            <span class="comment"># 即 s2应该放在右侧</span></span><br><span class="line">            s2 = ch*freq + s2</span><br><span class="line">        <span class="keyword">return</span> s2</span><br></pre></td></tr></table></figure><p><span id="5.2.4.6"></span>  </p><h3 id="5-2-4-6-数据流的中位数"><a href="#5-2-4-6-数据流的中位数" class="headerlink" title="5.2.4.6 数据流的中位数"></a>5.2.4.6 数据流的中位数</h3><p><a href="https://leetcode.cn/problems/find-median-from-data-stream/">LeetCode 295.数据流的中位数</a> | | <a href="#5.2.4">返回目录5.2.4</a></p><font color="#3399FF">思路：题目首先给了中位数的定义，是要在有序数组中进行查找。但是并没有保证输入的数据，一定是有序的。  如果按照排序再查找的话，那么每来一个数，就要排序一次，这样时间复杂度会很高。所以不如考虑每来一个数，给它找一个合适的位置放置，即用堆的想法。</font>  <font color="#3399FF">这里就可以分为两个堆，一个大根堆，存储小于等于中位数的那一半数字，这样它的堆顶(根节点)就是这一半数字中最接近中位数的那个；一个小根堆，存储大于等于中位数的那一半数字，这样它的堆顶(根节点)，也是最接近中位数的那个数。  ∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷只要能维护这两个堆，我们查找中位数就很方便了，只要保持两个堆都各存储一半的数字（偶数个时，规模相等；奇数个时规模相差一），中位数要么就是两个根节点其中之一，要么就是二者的均值。∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷我们在实际操作中，<font color="red">为了方便起见，始终保持前半部分的数目 大于等于后半部分，即如果是偶数个，就两部分相等；如果是奇数个，就让前半部分多一个。</font> </font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._left_heap = []</span><br><span class="line">        self._right_heap = []</span><br><span class="line">        self.__length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addNum</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.__length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># left_heap用来装小于中位数的那部分，且长度为 N//2 或 N//2+1</span></span><br><span class="line">        <span class="comment"># right_heap用来装大于中位数的那一部分, 且长度为 N//2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果left部分为空，或者新来的数的数值，小于等于目前的中位数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self._left_heap) == <span class="number">0</span> <span class="keyword">or</span> num &lt;= -self._left_heap[<span class="number">0</span>]:</span><br><span class="line">            <span class="comment"># 这里对 num取反，是因为该操作默认是维护小根堆，但我们需要该部分数字的关系是大根堆</span></span><br><span class="line">            heapq.heappush(self._left_heap, -num)</span><br><span class="line">            <span class="comment"># 然后需要判断两个部分的数的规模是否相差在1之内</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self._left_heap) &gt; <span class="built_in">len</span>(self._right_heap) + <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 因为上面是在往left添加元素，所以只可能会出现left比right多的情况</span></span><br><span class="line">                <span class="comment"># 此时就把left多出来的pop出来，然后push进right</span></span><br><span class="line">                heapq.heappush(self._right_heap, -heapq.heappop(self._left_heap))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果left不为空，且新来的数大于目前的中位数，就往right添加</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heapq.heappush(self._right_heap, num)</span><br><span class="line">            <span class="comment"># 如果right部分的长度超过了left，就需要pop一个出来，push入left</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self._right_heap) &gt; <span class="built_in">len</span>(self._left_heap):</span><br><span class="line">                heapq.heappush(self._left_heap, -heapq.heappop(self._right_heap))</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMedian</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self._left_heap) &gt; <span class="built_in">len</span>(self._right_heap):</span><br><span class="line">            <span class="comment"># 说明此时left部分是 N//2+1个数， right部分是 N//2个数</span></span><br><span class="line">            <span class="keyword">return</span> -self._left_heap[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 说明left和right部分各有 N//2个数</span></span><br><span class="line">            <span class="keyword">return</span> (-self._left_heap[<span class="number">0</span>] + self._right_heap[<span class="number">0</span>]) / <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 这是自己额外写的一个测试函数，可以查看两个堆里的数的情况</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;self._left_heap: &quot;</span>, self._left_heap)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;self._right_heap: &quot;</span>, self._right_heap)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="5.2.4.7"></span>  </p><h3 id="5-2-4-7-最接近原点的-K-个点"><a href="#5-2-4-7-最接近原点的-K-个点" class="headerlink" title="5.2.4.7 最接近原点的 K 个点"></a>5.2.4.7 最接近原点的 K 个点</h3><p><a href="https://leetcode.cn/problems/k-closest-points-to-origin/">LeetCode 973.最接近原点的 K 个点</a> | | <a href="#5.2.4">返回目录5.2.4</a></p><font color="#3399FF">思路：这个题最在排序部分也总结过，当时用的是排序的方法。这里也可以使用优先队列来解决。维护一个规模为 k 的堆</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kClosest</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        q = [(-x ** <span class="number">2</span> - y ** <span class="number">2</span>, i) <span class="keyword">for</span> i, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(points[:k])]</span><br><span class="line">        heapq.heapify(q)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 默认的是小根堆，所以要对元素值取反</span></span><br><span class="line">        <span class="comment"># 且元素是 d距离放在索引i前面, 这样会根据 d 的数值来进行堆的构造</span></span><br><span class="line">        N = <span class="built_in">len</span>(points)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, N):</span><br><span class="line">            x, y = points[i]</span><br><span class="line">            d = -(x ** <span class="number">2</span> + y ** <span class="number">2</span>)</span><br><span class="line">            heapq.heappushpop(q, (d, i))</span><br><span class="line">        </span><br><span class="line">        res = [points[idx] <span class="keyword">for</span> (_, idx) <span class="keyword">in</span> q]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5-1 栈和队列</title>
      <link href="/Data-Structure/DS_51_stack_and_queue.html"/>
      <url>/Data-Structure/DS_51_stack_and_queue.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="5-1-栈和队列"><a href="#5-1-栈和队列" class="headerlink" title="5-1 栈和队列"></a>5-1 栈和队列</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="5-1-1-栈的概念"><a href="#5-1-1-栈的概念" class="headerlink" title="5.1.1 栈的概念"></a>5.1.1 栈的概念</h2><p>栈是限制仅在<strong><font color="#FF0000">表的一端进行插入和删除</font></strong>操作的线性表。<br>通常称插入、删除的这一端为<strong>【栈顶】</strong>， 另一端称为栈底。当表中没有元素时称为空栈。<br>由于栈中元素的插入和删除操作都只能在<strong>栈顶进行</strong>，所以总是<strong><font color="#FF0000">后进栈的先出栈</font></strong>。即：<br><b>==(LIFO) Last In First Out. 后进先出==</b></p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/5_1_1.webp" width="40%">  </p><p>栈的基本操作有如下几种:<br>|操作名称|操作内容|<br>|—-|—-|<br>|init()|将栈初始化为空|<br>|empty()|判空栈，判断栈是否为空|<br>|size()|求长度，返回栈中元素的个数|<br>|top()|取栈顶， 读取栈顶元素，但并不修改栈|<br>|pop()|若栈非空，则删除栈顶元素，（亦称 弹出）|<br>|push(x)|在栈顶插入元素，（亦称为 压入/压栈）|  </p><h2 id="5-1-2-栈的python实现"><a href="#5-1-2-栈的python实现" class="headerlink" title="5.1.2 栈的python实现"></a>5.1.2 栈的python实现</h2><h3 id="5-1-2-1-顺序栈"><a href="#5-1-2-1-顺序栈" class="headerlink" title="5.1.2.1 顺序栈"></a>5.1.2.1 顺序栈</h3><p>就是用顺序表来实现栈，其 <font face="Times" new roman><em>python code</em></font> 如下所示:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sequence_Stack</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;使用空列表进行初始化&#x27;&#x27;&#x27;</span></span><br><span class="line">        self.__<span class="built_in">list</span> = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;判断栈是否为空&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.__<span class="built_in">list</span> == []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;返回栈里元素的个数&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.__<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;返回栈顶元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__<span class="built_in">list</span>[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;弹出栈顶元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.__<span class="built_in">list</span>.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;在栈顶压入元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        self.__<span class="built_in">list</span>.append(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>        </span><br></pre></td></tr></table></figure></p><h3 id="5-1-2-2-链栈"><a href="#5-1-2-2-链栈" class="headerlink" title="5.1.2.2 链栈"></a>5.1.2.2 链栈</h3><p>一般将链表<strong>头部作为栈顶</strong>，这样可以避免在 <strong>入栈 和 出栈</strong>的时候进行大量的遍历操作。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val    <span class="comment"># 数据域</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 指针域</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Link_stack</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__top = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__top <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        cur = self.__top</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__top.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        cur = self.__top</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.__top = cur.<span class="built_in">next</span> <span class="comment"># 修改头结点</span></span><br><span class="line">            <span class="keyword">return</span> cur.val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val</span>):</span><br><span class="line">        node = LNode(val)</span><br><span class="line">        node.<span class="built_in">next</span> = self.__top</span><br><span class="line">        self.__top = node <span class="comment"># 修改头结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p><h2 id="5-1-3-队列的概念"><a href="#5-1-3-队列的概念" class="headerlink" title="5.1.3 队列的概念"></a>5.1.3 队列的概念</h2><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的<strong><font color="#FF0000"> 前端（front）进行删除</font></strong>操作，而在表的<strong><font color="#FF0000">后端（rear）进行插入</font></strong>操作，和栈一样，队列是一种操作受限制的线性表。前端称为队头 ，后端称为队尾。<br><b>==FIFO (First In First Out) 先进先出==</b>  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/5_1_2.webp" width="50%">  </p><p>队列的基本操作有如下几种:<br>|操作名称|操作内容|<br>|—-|—-|<br>|init()|将队列初始化为空|<br>|empty()|判断队列是否为空|<br>|size()|求长度，返回队列中元素的个数|<br>|front()|取队头元素，若队列未空，则函数返回队头 数据元素，队列不变。|<br>|rear()|取队尾元素，若队列未空，则函数返回队尾 数据元素，队列不变。|<br>|enqueue(x)|入队列，若队列未满，在原队尾后加入数据元素x，使x成为新的队尾元素。|<br>|dequeue()|出队列，若队列未空，则将队列的队头元素删除。| </p><h2 id="5-1-4-队列的python实现"><a href="#5-1-4-队列的python实现" class="headerlink" title="5.1.4 队列的python实现"></a>5.1.4 队列的python实现</h2><h3 id="5-1-4-1-顺序表实现"><a href="#5-1-4-1-顺序表实现" class="headerlink" title="5.1.4.1 顺序表实现"></a>5.1.4.1 顺序表实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sq_Queue</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;使用空列表进行初始化&#x27;&#x27;&#x27;</span></span><br><span class="line">        self.__<span class="built_in">list</span> = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;判断队列是否为空&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.__<span class="built_in">list</span> == []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;返回队列里元素的个数&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.__<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">front</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;返回队头元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__<span class="built_in">list</span>[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rear</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;返回队尾元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__<span class="built_in">list</span>[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;弹出队头元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.__<span class="built_in">list</span>.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;在队尾压入元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        self.__<span class="built_in">list</span>.append(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="5-1-4-2-链表实现"><a href="#5-1-4-2-链表实现" class="headerlink" title="5.1.4.2 链表实现"></a>5.1.4.2 链表实现</h3><p>我们在插入的时候，选择在链表尾部使用尾插法插入，所以<strong>链表尾部视为队尾rear</strong>；<br>在删除时，为了方便起见，我们可以把<strong>头结点认为是front</strong>.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val    <span class="comment"># 数据域</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 指针域</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">L_Queue</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 初始化时同时设置头和尾两个指针</span></span><br><span class="line">        self.__front = <span class="literal">None</span></span><br><span class="line">        self.__rear = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__front <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cnt, cur = <span class="number">1</span>, self.__front</span><br><span class="line">            <span class="keyword">while</span> cur != self.__rear:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                cnt +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> cnt </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">front</span>(<span class="params">self</span>):</span><br><span class="line">        res = <span class="literal">None</span> <span class="keyword">if</span> self.is_empty() <span class="keyword">else</span> self.__front.val</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rear</span>(<span class="params">self</span>):</span><br><span class="line">        res = <span class="literal">None</span> <span class="keyword">if</span> self.is_empty() <span class="keyword">else</span> self.__rear.val</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):</span><br><span class="line">        cur = self.__front</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__front = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> self.__front <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 出队后队列为空(原队列仅含一个元素)</span></span><br><span class="line">                self.__rear = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> cur.val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self, val</span>):</span><br><span class="line">        node = LNode(val)</span><br><span class="line">        <span class="keyword">if</span> self.__rear <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 说明当前链表(队列)为空</span></span><br><span class="line">            self.__front = node</span><br><span class="line">            self.__rear = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__rear.<span class="built_in">next</span> = node</span><br><span class="line">            self.__rear = node</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4-2 字符串相关题目</title>
      <link href="/Data-Structure/DS_42_string_exercises.html"/>
      <url>/Data-Structure/DS_42_string_exercises.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="4-2-字符串相关题目"><a href="#4-2-字符串相关题目" class="headerlink" title="4-2 字符串相关题目"></a>4-2 字符串相关题目</h1><hr style="border:solid; height:1px; color=#000000 size=1">   <p><span id="4.2"></span>  </p><h2 id="4-2-题目表"><a href="#4-2-题目表" class="headerlink" title="4.2 题目表"></a>4.2 题目表</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/reverse-string/">LeetCode 344.反转字符串</a></td><td><a href="#4.2.1">4.2.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">LeetCode 151.反转字符串中的单词</a></td><td><a href="#4.2.2">4.2.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/">LeetCode 557.反转字符串中的单词 III</a></td><td><a href="#4.2.3">4.2.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">LeetCode 3.无重复字符的最长子串</a></td><td><a href="#4.2.4">4.2.4题解</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/group-anagrams/">LeetCode 49.字母异位词分组</a></td><td><a href="#4.2.5">4.2.5题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/valid-palindrome/">LeetCode 125.验证回文串</a></td><td><a href="#4.2.6">4.2.6题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/add-strings/">LeetCode 415.字符串相加</a></td><td><a href="#4.2.7">4.2.7题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/multiply-strings/">LeetCode 43.字符串相乘</a></td><td><a href="#4.2.8">4.2.8题解</a></td></tr></tbody></table></div><p><span id="4.2.1"></span>  </p><h3 id="4-2-1-反转字符串"><a href="#4-2-1-反转字符串" class="headerlink" title="4.2.1 反转字符串"></a>4.2.1 反转字符串</h3><p><a href="https://leetcode.cn/problems/reverse-string/">LeetCode 344.反转字符串</a> | | <a href="#4.2">返回目录4.2</a></p><font color="#3399FF">思路：这道题其实就是很简单的列表逆序的问题。可以用列表切片或者双指针。需要注意的是题目要求【使用 O(1) 的额外空间】</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 1.直接用列表切片法</span></span><br><span class="line"><span class="string">        # 但是不符合题目要求的O(1)额外空间</span></span><br><span class="line"><span class="string">        # 因为python的list切片操作会创建一个临时的list</span></span><br><span class="line"><span class="string">        s[:] = s[::-1]  </span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 2.用双指针</span></span><br><span class="line"></span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            s[L], s[R] = s[R], s[L]</span><br><span class="line">            L += <span class="number">1</span></span><br><span class="line">            R -=<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="4.2.2"></span>  </p><h3 id="4-2-2-反转字符串中的单词"><a href="#4-2-2-反转字符串中的单词" class="headerlink" title="4.2.2 反转字符串中的单词"></a>4.2.2 反转字符串中的单词</h3><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">LeetCode 151.反转字符串中的单词</a> | | <a href="#4.2">返回目录4.2</a></p><font color="#3399FF">思路：这个题可能用python来说比较容易，因为python的split能够默认处理空格……s.split()之后直接就是一个单词列表，然后用4.2.1中的逆序就解决了。而且此题还没有要求空间复杂度，可以直接用list切片操作。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(s.split()[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 或者也可以用 reversed方法使得 列表逆序</span></span><br><span class="line">        <span class="comment"># return &#x27; &#x27;.join( reversed(s.split()))</span></span><br></pre></td></tr></table></figure><p><span id="4.2.3"></span>  </p><h3 id="4-2-3-反转字符串中的单词III"><a href="#4-2-3-反转字符串中的单词III" class="headerlink" title="4.2.3 反转字符串中的单词III"></a>4.2.3 反转字符串中的单词III</h3><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/">LeetCode 557.反转字符串中的单词 III</a> | | <a href="#4.2">返回目录4.2</a></p><blockquote><p>示例 1</p><font color="#3399FF">思路：和4.2.2换汤不换药，只是对单词内部的字母的逆序而已，不对整体逆序。</font>  </blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s_list = s.split()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join([ ele[::-<span class="number">1</span>] <span class="keyword">for</span> ele <span class="keyword">in</span> s_list])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这种解法确实能跑通所有样例，是因为：</span></span><br><span class="line">        <span class="comment"># 题目最下方的提示中写了：所有单词都用一个空格隔开。</span></span><br><span class="line">        <span class="comment"># 所以在使用 &#x27; &#x27;.join时只用到1个空格， 是可以保证正确的</span></span><br><span class="line">        <span class="comment"># 如果题目不给出这个条件，那就不能直接这么写</span></span><br></pre></td></tr></table></figure><p>拓展：如果题目中没有规定单词之间只有一个空格</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s_list = <span class="built_in">list</span>(s)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义一个逆序的函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse_list</span>(<span class="params">a, L, R</span>):</span><br><span class="line">            <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                a[L], a[R] = a[R], a[L]</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                R -=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用快慢指针</span></span><br><span class="line">        p1, p2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        N = <span class="built_in">len</span>(s_list)</span><br><span class="line">        <span class="keyword">while</span> p2&lt;N:</span><br><span class="line">            <span class="keyword">if</span> p2== N-<span class="number">1</span> <span class="keyword">or</span> (s_list[p2] != <span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> s_list[p2+<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>):</span><br><span class="line">                reverse_list(s_list, p1, p2)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> s_list[p2] == <span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> s_list[p2+<span class="number">1</span>] != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                p1 = p2+<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            p2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s_list)</span><br></pre></td></tr></table></figure><p><span id="4.2.4"></span>  </p><h3 id="4-2-4-无重复字符的最长子串"><a href="#4-2-4-无重复字符的最长子串" class="headerlink" title="4.2.4 无重复字符的最长子串"></a>4.2.4 无重复字符的最长子串</h3><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">LeetCode 3.无重复字符的最长子串</a> | | <a href="#4.2">返回目录4.2</a></p><font color="#3399FF">思路：这个题的思路和 [2-3 数组数组双指针](https://teeyohuang.github.io/Data-Structure/DS_23_array_double_pointer_exercises.html) 的 [2.3.2.8](https://teeyohuang.github.io/Data-Structure/DS_22_array_exercises.html#2.3.2.8) 只能说一模一样。只不过一个是求连续重复1区间的长度，一个是求不出现重复的区间长度。：：：那么核心就是，判断重复与否的条件是什么？不重复的条件有两个：1.字符未出现过； 或者2.字符出现过，但是不在当前判断的区域内，即字符的索引在L边界左侧：：：所以对应的重复条件是：字符出现过，且位于当前判断的区间内，即字符的索引在L右侧</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span> <span class="keyword">or</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> N </span><br><span class="line">        L, R = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        h = &#123;&#125;</span><br><span class="line">        <span class="comment"># 慢指针L表示无重复区域的 左侧外边界</span></span><br><span class="line">        <span class="comment"># 快指针R用来判断当前位置的值是否已经在哈希表中出现</span></span><br><span class="line">        gap = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 有两种写法</span></span><br><span class="line">        <span class="comment"># 写法1：在未遇到重复字符之前，一直更新区间长度</span></span><br><span class="line">        <span class="comment"># 遇到重复值时，不更新区间长度，而是更新L边界</span></span><br><span class="line">        <span class="keyword">for</span> R <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="comment"># 如果s[R]未出现过, 或者索引位于L左侧, 即当前考察区域更左</span></span><br><span class="line">            <span class="comment"># 说明当前连续未重复区域仍未中断, 可以更新一下gap</span></span><br><span class="line">            <span class="keyword">if</span> s[R] <span class="keyword">not</span> <span class="keyword">in</span> h <span class="keyword">or</span> h[s[R]] &lt;= L:</span><br><span class="line">                gap = <span class="built_in">max</span>(gap, R-L)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># L 指向重复元素已经记录的索引位置</span></span><br><span class="line">            <span class="comment"># 相当于将该元素排除出去，新区间从该元素右侧开始考察</span></span><br><span class="line">                L = h[s[R]]</span><br><span class="line">            h[s[R]] = R</span><br><span class="line">        <span class="keyword">return</span> gap</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 写法2: 在遇到重复元素的时候，才计算一次区间长度</span></span><br><span class="line"><span class="string">        for R in range(N):</span></span><br><span class="line"><span class="string">            if s[R] in h and h[s[R]] &gt; L:</span></span><br><span class="line"><span class="string">            # 出现重复字符时，才计算区间长度，要注意当前位置不算在区间内</span></span><br><span class="line"><span class="string">                gap = max(gap, R-L -1)</span></span><br><span class="line"><span class="string">                L = h[s[R]]</span></span><br><span class="line"><span class="string">            h[s[R]] = R</span></span><br><span class="line"><span class="string">        # 这里要注意需要补充计算一下最后一段区间的长度</span></span><br><span class="line"><span class="string">        # 因为R取不到N，否则会漏算最后一段符合条件的区间</span></span><br><span class="line"><span class="string">        # 比如：若最后一段区间直到N-1都没有出现重复字符，是该计算长度的</span></span><br><span class="line"><span class="string">        # 但是由于计算的条件是出现重复字符才计算，所以上面并没有机会去计算</span></span><br><span class="line"><span class="string">        return max(gap, N-L-1)</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="4.2.5"></span>  </p><h3 id="4-2-5-字母异位词分组"><a href="#4-2-5-字母异位词分组" class="headerlink" title="4.2.5 字母异位词分组"></a>4.2.5 字母异位词分组</h3><p><a href="https://leetcode.cn/problems/group-anagrams/">LeetCode 49.字母异位词分组</a> | | <a href="#4.2">返回目录4.2</a></p><font color="#3399FF">思路：该题的核心点在于如何判断字母异位词，其实很简单。只需要把单词排序之后，看看它们是否相等。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">groupAnagrams</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        h = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> strs:</span><br><span class="line">            <span class="comment"># 将单词排序，然后来判断其是否出现过</span></span><br><span class="line">            key = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">sorted</span>(word))</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> h:</span><br><span class="line">                h[key] = [word]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h[key] += [word]</span><br><span class="line">        <span class="comment"># 直接返回字典的值列表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(h.values())</span><br></pre></td></tr></table></figure><p><span id="4.2.6"></span>  </p><h3 id="4-2-6-验证回文串"><a href="#4-2-6-验证回文串" class="headerlink" title="4.2.6 验证回文串"></a>4.2.6 验证回文串</h3><p><a href="https://leetcode.cn/problems/valid-palindrome/">LeetCode 125.验证回文串</a> | | <a href="#4.2">返回目录4.2</a></p><font color="#3399FF">思路：这个题也是采用双指针的思路。只不过需要注意，字符串中可能出现不是数字或者字母的字符，所以需要多一个判断条件。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 先将所有字母转换为小写</span></span><br><span class="line">        s = s.lower()</span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            <span class="comment"># while L &lt; R and not (s[L].isalpha() or s[L].isdigit()):</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> <span class="keyword">not</span> s[L].isalnum():</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="comment"># while L &lt; R and not (s[R].isalpha() or s[R].isdigit()):</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> <span class="keyword">not</span> s[R].isalnum():</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> L &lt; R:</span><br><span class="line">                <span class="keyword">if</span> s[L] == s[R]:</span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><span id="4.2.7"></span>  </p><h3 id="4-2-7-字符串相加"><a href="#4-2-7-字符串相加" class="headerlink" title="4.2.7 字符串相加"></a>4.2.7 字符串相加</h3><p><a href="https://leetcode.cn/problems/add-strings/">LeetCode 415.字符串相加</a> | | <a href="#4.2">返回目录4.2</a></p><font color="#3399FF">思路：由于题目中明确表示不能够直接将两个输入字符串转换成数字进行计算，所以就需要将其一位一位的拆分之后计算。此题考察的点就是希望手动模拟按位相加。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addStrings</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> num1 == <span class="string">&quot;0&quot;</span> :</span><br><span class="line">            <span class="keyword">return</span> num2</span><br><span class="line">        <span class="keyword">elif</span> num2 == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            </span><br><span class="line">            m, n = <span class="built_in">len</span>(num1), <span class="built_in">len</span>(num2)</span><br><span class="line">            s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            plus = <span class="number">0</span> <span class="comment"># plus是代表的进位的数字</span></span><br><span class="line">            k = <span class="number">1</span> </span><br><span class="line">            <span class="comment"># 因为加法是从个位开始，所以往左遍历字符串</span></span><br><span class="line">            <span class="keyword">while</span> plus &gt; <span class="number">0</span> <span class="keyword">or</span> k &lt;= <span class="built_in">max</span>(m, n):</span><br><span class="line">                a = <span class="built_in">int</span>(num1[m-k]) <span class="keyword">if</span> k&lt;=m <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                b = <span class="built_in">int</span>(num2[n-k]) <span class="keyword">if</span> k&lt;=n <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                <span class="comment"># digit 表示在当前位置应该出现的数字</span></span><br><span class="line">                digit = (plus + a + b ) % <span class="number">10</span> </span><br><span class="line">                <span class="comment"># 新来的字符要加在左侧</span></span><br><span class="line">                s = <span class="built_in">str</span>(digit)+s</span><br><span class="line">                <span class="comment"># 计算进位数字</span></span><br><span class="line">                plus = (plus + a+b - digit) // <span class="number">10</span></span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">                <span class="string">&#x27;&#x27;&#x27;需要注意的是，在计算的时候不要漏加了plus&#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p><span id="4.2.8"></span>  </p><h3 id="4-2-8-字符串相乘"><a href="#4-2-8-字符串相乘" class="headerlink" title="4.2.8 字符串相乘"></a>4.2.8 字符串相乘</h3><p><a href="https://leetcode.cn/problems/multiply-strings/">LeetCode 43.字符串相乘</a> | | <a href="#4.2">返回目录4.2</a></p><font color="#3399FF">思路：由于上一题做过字符串相加，我们可以套用其思想，让num2的每一位同num1相乘，然后再加起来即可。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">add_num_list</span>(<span class="params">num_list</span>):</span><br><span class="line">            <span class="comment"># </span></span><br><span class="line">            <span class="comment"># 对2个数字字符串相加的code稍加修改</span></span><br><span class="line">            <span class="comment"># 即可得到对 N 个数字字符串相加的code</span></span><br><span class="line">            <span class="comment"># 当然也可以不做修改，使用2数相加，只需要对每一次做乘法得到的结果，及时应用两数相加即可</span></span><br><span class="line">            <span class="comment"># </span></span><br><span class="line">            num_cnt = <span class="built_in">len</span>(num_list)</span><br><span class="line">            len_num = [<span class="built_in">len</span>(num) <span class="keyword">for</span> num <span class="keyword">in</span> num_list]</span><br><span class="line">            k = <span class="number">1</span></span><br><span class="line">            plus = <span class="number">0</span></span><br><span class="line">            s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">while</span> plus &gt; <span class="number">0</span> <span class="keyword">or</span> k &lt;= <span class="built_in">max</span>(len_num):</span><br><span class="line">                a = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_cnt):</span><br><span class="line">                    N_i = len_num[i]</span><br><span class="line">                    <span class="string">&#x27;&#x27;&#x27;要点1.是对第i个数字的倒数第k位取值&#x27;&#x27;&#x27;</span></span><br><span class="line">                    a += <span class="built_in">int</span>(num_list[i][N_i-k]) <span class="keyword">if</span> k&lt;= N_i <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                    <span class="comment"># print(k,a)</span></span><br><span class="line">                <span class="string">&#x27;&#x27;&#x27;要点2.这下面的几行要写在for循环之外</span></span><br><span class="line"><span class="string">                因为for循环结束后，对应位置的数字才相加完毕&#x27;&#x27;&#x27;</span></span><br><span class="line">                digit = (a+plus) % <span class="number">10</span></span><br><span class="line">                <span class="comment"># print(digit)</span></span><br><span class="line">                s = <span class="built_in">str</span>(digit) + s </span><br><span class="line">                plus = (a+plus-digit) // <span class="number">10</span></span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> num1 == <span class="string">&quot;0&quot;</span> <span class="keyword">or</span> num2 == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num_list = []</span><br><span class="line">            m, n = <span class="built_in">len</span>(num1), <span class="built_in">len</span>(num2)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 对num2从个位开始取数</span></span><br><span class="line">                <span class="string">&#x27;&#x27;&#x27;要点3.当j是来自十位、百位、千位...时，屁股后要接上相应个数的0&#x27;&#x27;&#x27;</span></span><br><span class="line">                res = <span class="string">&quot;0&quot;</span>*(j-<span class="number">1</span>)</span><br><span class="line">                b = <span class="built_in">int</span>(num2[n-j])</span><br><span class="line">                plus = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">                    a = <span class="built_in">int</span>(num1[m-i])</span><br><span class="line">                    digit = (plus + a*b) % <span class="number">10</span></span><br><span class="line">                    res = <span class="built_in">str</span>(digit) + res</span><br><span class="line">                    plus = (plus + a*b -digit) // <span class="number">10</span></span><br><span class="line">                <span class="string">&#x27;&#x27;&#x27;要点4.for循环玩之后，plus不用留到下一轮，因为该阶段的相加已经结束了</span></span><br><span class="line"><span class="string">                直接加到数前面去即可&#x27;&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> plus &gt; <span class="number">0</span>:</span><br><span class="line">                    res = <span class="built_in">str</span>(plus) + res</span><br><span class="line">                num_list.append(res)</span><br><span class="line">            <span class="built_in">print</span>(num_list)</span><br><span class="line">            <span class="keyword">return</span> add_N_num(num_list)</span><br><span class="line">        <span class="comment">##############################################################################</span></span><br><span class="line">        <span class="comment"># 每一次只对两个数字字符串相加，时间上稍微慢一点</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4-1 字符串</title>
      <link href="/Data-Structure/DS_41_string.html"/>
      <url>/Data-Structure/DS_41_string.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="4-1-字符串"><a href="#4-1-字符串" class="headerlink" title="4-1 字符串"></a>4-1 字符串</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="4-1-1-字符串简介"><a href="#4-1-1-字符串简介" class="headerlink" title="4.1.1 字符串简介"></a>4.1.1 字符串简介</h2><p>字符串是 Python 中最常用的数据类型，使用引号  ‘ 或 “  来创建字符串以及表示字符串。<br>和C/C++不同，python中的没有单字符这一个类型，即没有 char 类型，一个字符也是作为字符串类型来使用的, 这也就是它的单引号和双引号都能用来表示字符串的原因。  </p><h2 id="4-1-2-字符串的常用运算符"><a href="#4-1-2-字符串的常用运算符" class="headerlink" title="4.1.2 字符串的常用运算符"></a>4.1.2 字符串的常用运算符</h2><div class="table-container"><table><thead><tr><th>操作符</th><th>含义</th><th>例子</th></tr></thead><tbody><tr><td>+</td><td>字符串连接（拼接）</td><td>“hello” + “World”</td></tr><tr><td>*</td><td>重复输出字符串</td><td>“abc” * 3</td></tr><tr><td>[ ]</td><td>通过索引获取字符串中字符</td><td>a[1]</td></tr><tr><td>[ : ]</td><td>截取字符串中的一部分，和列表一样遵循左闭右开原则</td><td>a[3:5]</td></tr><tr><td>in</td><td>成员运算符 - 如果字符串中包含给定的字符返回 True</td><td>d in “word”</td></tr><tr><td>not in</td><td>成员运算符 - 如果字符串中不包含给定的字符返回 True</td><td>n not in “word”</td></tr><tr><td>r/R</td><td>将字符串转化为原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</td><td>print( r’\n’ )或print( R’\n’ )</td></tr></tbody></table></div><p>有一定需要特别注意，字符串和元组(tuple)一样，<font color="red"> <b>属于不变的类型</b> </font> ，即不能对一个字符串进行修改。比如下面的code就无法执行：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;P&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;TypeError: &#x27;str&#x27; object does not support item assignment.&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br>上面使用 <strong>‘+’</strong> 进行拼接操作,实际上是将结<strong>果存入一个新的地址，形成一个 新的字符串</strong>,而不是对原地址上的内容进行修改。  </p><pre><code class="lang-python">s = &quot;python&quot;print(id(s))s = s +&#39; hello&#39;print(id(s))&#39;&#39;&#39;20816785772642081678063472&#39;&#39;&#39;</code></pre><h2 id="4-1-3-字符串格式化"><a href="#4-1-3-字符串格式化" class="headerlink" title="4.1.3 字符串格式化"></a>4.1.3 字符串格式化</h2><p>后续有空再写……</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3-3 排序相关题目</title>
      <link href="/Data-Structure/DS_33_sort_exercises.html"/>
      <url>/Data-Structure/DS_33_sort_exercises.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="3-3-排序相关题目"><a href="#3-3-排序相关题目" class="headerlink" title="3-3 排序相关题目"></a>3-3 排序相关题目</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p><b>版权声明：以下题目均来自 <a href="https://leetcode.cn">LeetCode</a>， 仅仅提供跳转到力扣官网的链接，不在本页面出现题目内容，本文章内容禁止商业用途。</b></p><p><span id="3.3"></span>  </p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/sort-an-array/">LeetCode 912.排序数组</a></td><td><a href="#3.3.1">3.3.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45.把数组排成最小的数</a></td><td><a href="#3.3.2">3.3.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/largest-number/">LeetCode 179.最大数</a></td><td><a href="#3.3.3">3.3.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/move-zeroes/">LeetCode 283.移动零</a></td><td><a href="#3.3.4">3.3.4题解</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/sort-colors/">LeetCode 75.颜色分类</a></td><td><a href="#3.3.5">3.3.5题解</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/contains-duplicate/">LeetCode 217.存在重复元素</a></td><td><a href="#3.3.6">3.3.6题解</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/contains-duplicate-ii/">LeetCode 219. 存在重复元素II</a></td><td><a href="#3.3.7">3.3.7题解</a></td></tr><tr><td>⑧</td><td><a href="https://leetcode.cn/problems/contains-duplicate-iii/">LeetCode 220.存在重复元素 III</a></td><td><a href="#3.3.8">3.3.8题解</a></td></tr><tr><td>⑨</td><td><a href="https://leetcode.cn/problems/maximum-gap/">LeetCode 164.最大间距</a></td><td><a href="#3.3.9">3.3.9题解</a></td></tr><tr><td>⑩</td><td><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">LeetCode 215.数组中的第K个最大元素</a></td><td><a href="#3.3.10">3.3.10题解</a></td></tr><tr><td>⑪</td><td><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">LeetCode 剑指 Offer 40.最小的k个数</a></td><td><a href="#3.3.11">3.3.11题解</a></td></tr><tr><td>⑫</td><td><a href="https://leetcode.cn/problems/majority-element/">LeetCode 169.多数元素</a></td><td><a href="#3.3.12">3.3.12题解</a></td></tr><tr><td>⑬</td><td><a href="https://leetcode.cn/problems/merge-sorted-array/">LeetCode 88.合并两个有序数组</a></td><td><a href="#3.3.13">3.3.13题解</a></td></tr><tr><td>⑭</td><td><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">LeetCode 剑指 Offer 51.数组中的逆序对</a></td><td><a href="#3.3.14">3.3.14题解</a></td></tr><tr><td>⑮</td><td><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">LeetCode 315.计算右侧小于当前元素的个数</a></td><td><a href="#3.3.15">3.3.15题解</a></td></tr><tr><td>⑯</td><td><a href="https://leetcode.cn/problems/k-closest-points-to-origin/">LeetCode 973.最接近原点的 K 个点</a></td><td><a href="#3.3.16">3.3.16题解</a></td></tr></tbody></table></div><p><span id="3.3.1"></span>  </p><h3 id="3-3-1-排序数组"><a href="#3-3-1-排序数组" class="headerlink" title="3.3.1 排序数组"></a>3.3.1 排序数组</h3><p><a href="https://leetcode.cn/problems/sort-an-array/">LeetCode 912.排序数组</a> | |  <a href="#3.3">返回目录3.3</a></p><font color="#3399FF">思路：这个题就是简单的考察排序算法，可以用这个题来当作测试模板，看看自己写的各个版本的排序代码是不是正确的。但是一般在做题是很少会用到时间复杂度 O(n^2)的算法，一般都是用的 O(N*logN) 的算法，或者视具体情况使用计数排序、基数排序、桶排序。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 具体的排序算法 code 可以看 文章3-1 中的详细简介，这里就不写了</span></span><br></pre></td></tr></table></figure><p><span id="3.3.2"></span>  </p><h3 id="3-3-2-把数组排成最小的数"><a href="#3-3-2-把数组排成最小的数" class="headerlink" title="3.3.2 把数组排成最小的数"></a>3.3.2 把数组排成最小的数</h3><p><a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45.把数组排成最小的数</a> | | <a href="#3.3">返回目录3.3</a></p><font color="#3399FF">思路：这个题就其实比较新奇，是考察排序，但是排序的规则不是按照我们平时的数值大小。  针对此题，我们对<b>字符串 x, y </b>的大小 作如下 <b>自定义</b>：  如果：x + y > y + x , 则 x > y;  如果：x + y == y + x , 则 x = y;  如果：x + y < y + x , 则 x < y;<b>按照我们自定义的规则进行排序即可</b>，题目要求是最小的数，那么就按照降序排列。  同时，题目中叙述 “最后结果不需要去掉前导 0”，意思是如果出现 [1,2,0] 这样的数组，结果可以输出 “012” 这样的字符串。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">comp_str</span>(<span class="params">x:<span class="built_in">str</span>,y:<span class="built_in">str</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            definition:</span></span><br><span class="line"><span class="string">            if x+y &gt; y+x: x&gt;y</span></span><br><span class="line"><span class="string">            elif x+y == y+x: x==y</span></span><br><span class="line"><span class="string">            else: x&lt;y</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> x+y &gt; y+x:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">            <span class="keyword">elif</span> x+y == y+x:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">QuickSort</span>(<span class="params">a, L, R</span>):</span><br><span class="line">            <span class="keyword">if</span> L &gt;= R:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            pl, pr, key = L-<span class="number">1</span>, R, R </span><br><span class="line">            i = pl+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; pr:</span><br><span class="line">                <span class="comment"># 利用自定义的大小规则，进行快速排序的大小比对</span></span><br><span class="line">                comp = comp_str(a[i], a[key])</span><br><span class="line">                <span class="keyword">if</span> comp == <span class="number">1</span>:</span><br><span class="line">                    a[i], a[pl+<span class="number">1</span>] = a[pl+<span class="number">1</span>], a[i]</span><br><span class="line">                    pl += <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> comp == <span class="number">2</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    a[i], a[pr-<span class="number">1</span>] = a[pr-<span class="number">1</span>], a[i]</span><br><span class="line">                    pr -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># i==pr </span></span><br><span class="line">            a[pr], a[key] = a[key], a[pr]</span><br><span class="line">            QuickSort(a,L, pl)</span><br><span class="line">            QuickSort(a, pr+<span class="number">1</span>, R)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="comment"># 将数字转化为字符串</span></span><br><span class="line">        str_list = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>,nums))</span><br><span class="line">        QuickSort(str_list, <span class="number">0</span>, <span class="built_in">len</span>(str_list)-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(str_list)</span><br></pre></td></tr></table></figure><p><span id="3.3.3"></span>  </p><h3 id="3-3-3-最大数"><a href="#3-3-3-最大数" class="headerlink" title="3.3.3 最大数"></a>3.3.3 最大数</h3><p><a href="https://leetcode.cn/problems/largest-number/">LeetCode 179.最大数</a> | | <a href="#3.3">返回目录3.3</a></p><font color="#3399FF">思路：这个题和上一个题其实是一回事，只不过一个要最小数，一个要最大数。所以这个题需要按自定义规则从大到小排序即可。。但要注意的是，由于此题是要求排列最大的情况，所以如果有单个0和其他整数出现，0必不会出现在开头，而是会出现在末尾。只有一种特殊情况，那就是数组中只有0的时候，比如[0,0,0]，字符串的结果是 “000”，我们需要处理成对应的整数形式 “0” </font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">comp_str</span>(<span class="params">x:<span class="built_in">str</span>,y:<span class="built_in">str</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            definition:</span></span><br><span class="line"><span class="string">            if x+y &gt; y+x: x&gt;y</span></span><br><span class="line"><span class="string">            elif x+y == y+x: x==y</span></span><br><span class="line"><span class="string">            else: x&lt;y</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> x+y &gt; y+x:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> x+y == y+x:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">QuickSort</span>(<span class="params">a, L, R</span>):</span><br><span class="line">            <span class="keyword">if</span> L &gt;= R:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            pl, pr, key = L-<span class="number">1</span>, R, R </span><br><span class="line">            i = pl+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; pr:</span><br><span class="line">                comp = comp_str(a[i], a[key])</span><br><span class="line">                <span class="keyword">if</span> comp == <span class="number">1</span>:</span><br><span class="line">                    a[i], a[pl+<span class="number">1</span>] = a[pl+<span class="number">1</span>], a[i]</span><br><span class="line">                    pl += <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> comp == <span class="number">2</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    a[i], a[pr-<span class="number">1</span>] = a[pr-<span class="number">1</span>], a[i]</span><br><span class="line">                    pr -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># i==pr </span></span><br><span class="line">            a[pr], a[key] = a[key], a[pr]</span><br><span class="line">            QuickSort(a,L, pl)</span><br><span class="line">            QuickSort(a, pr+<span class="number">1</span>, R)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        str_list = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>,nums))</span><br><span class="line">        QuickSort(str_list, <span class="number">0</span>, <span class="built_in">len</span>(str_list)-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        s = <span class="string">&#x27;&#x27;</span>.join(str_list)</span><br><span class="line">        <span class="comment"># 这个题的要求没有说可以不处理先导 0</span></span><br><span class="line">        <span class="comment"># 所以如果出现了&quot;000&quot;这种情况，要手动处理成 &#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p><span id="3.3.4"></span>  </p><h3 id="3-3-4-移动零"><a href="#3-3-4-移动零" class="headerlink" title="3.3.4 移动零"></a>3.3.4 移动零</h3><p><a href="https://leetcode.cn/problems/move-zeroes/">LeetCode 283.移动零</a> | | <a href="#3.3">返回目录3.3</a> </p><font color="#3399FF">思路：这个提已经在 [2-3 数组双指针](https://teeyohuang.github.io/Data-Structure/DS_23_array_double_pointer_exercises.html) 中的 [2.3.2.5](https://teeyohuang.github.io/Data-Structure/DS_23_array_double_pointer_exercises.html#2.3.2.5) 讲解过，在[3-2快速排序讨论]()中时，介绍的partition问题也对其进行深入讨论过。按照partition问题的理解，就是与0比较，非0数排左侧，0排右侧。  需要注意的是，Partition 操作本身是不稳定移动，（这也是快速排序是不稳定排序的原因）但是应用到该题中，只有0的部分会不稳定，（即几个0之间可能发生相对位置的变化）而非0部分的相对顺序是不会变的。是符合题目要求的。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        ps, pf = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pf &lt;N:</span><br><span class="line">            <span class="keyword">if</span> nums[pf] != <span class="number">0</span>:</span><br><span class="line">                nums[pf], nums[ps+<span class="number">1</span>] = nums[ps+<span class="number">1</span>], nums[pf]</span><br><span class="line">                ps += <span class="number">1</span></span><br><span class="line">            pf += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="3.3.5"></span></p><h3 id="3-3-5-颜色分类"><a href="#3-3-5-颜色分类" class="headerlink" title="3.3.5 颜色分类"></a>3.3.5 颜色分类</h3><p><a href="https://leetcode.cn/problems/sort-colors/">LeetCode 75.颜色分类</a> | | <a href="#3.3">返回目录3.3</a></p><font color="#3399FF">思路：在[3-2快速排序讨论]()中讨论过的荷兰国旗问题。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;荷兰国旗问题&#x27;&#x27;&#x27;</span></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        L, R = -<span class="number">1</span>, N</span><br><span class="line">        i = L+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; R:</span><br><span class="line">            <span class="keyword">if</span> L &lt; R <span class="keyword">and</span> nums[i] &lt; <span class="number">1</span>:</span><br><span class="line">                nums[i], nums[L+<span class="number">1</span>] = nums[L+<span class="number">1</span>], nums[i]</span><br><span class="line">                L+=<span class="number">1</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> L &lt; R <span class="keyword">and</span> nums[i] == <span class="number">1</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[i], nums[R-<span class="number">1</span>] = nums[R-<span class="number">1</span>], nums[i]</span><br><span class="line">                R -=<span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="3.3.6"></span>  </p><h3 id="3-3-6-存在重复元素"><a href="#3-3-6-存在重复元素" class="headerlink" title="3.3.6 存在重复元素"></a>3.3.6 存在重复元素</h3><p><a href="https://leetcode.cn/problems/contains-duplicate/">LeetCode 217.存在重复元素</a> | | <a href="#3.3">返回目录3.3</a></p><blockquote><p>给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。  </p></blockquote><font color="#3399FF">思路：较为简单，使用哈希表计数即可。这个题主要是为了下面两个题做铺垫。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        h = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">not</span> <span class="keyword">in</span> h:</span><br><span class="line">                h[nums[i]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><span id="3.3.7"></span>  </p><h3 id="3-3-7-存在重复元素II"><a href="#3-3-7-存在重复元素II" class="headerlink" title="3.3.7 存在重复元素II"></a>3.3.7 存在重复元素II</h3><p><a href="https://leetcode.cn/problems/contains-duplicate-ii/">LeetCode 219. 存在重复元素II</a> | | <a href="#3.3">返回目录3.3</a></p><font color="#3399FF">思路1：这个题也可以理解为找寻找至少出现两次的元素，只不过多了一个条件，即两数索引之间的距离不能超过 k。  简单的思路是：用哈希表存储数字的索引，计算重复出现的数字的索引之差，满足条件则可以返回True；否则就用最新的索引 i 进行覆盖，以方便下一次判断条件。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        h = <span class="built_in">dict</span>()</span><br><span class="line">        N =<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> h <span class="keyword">and</span> i-h[nums[i]] &lt;=k :</span><br><span class="line">                <span class="comment"># 如果哈希表中已经存在该数, 且索引之差 &lt;=k</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 用最新的索引 i 覆盖</span></span><br><span class="line">                h[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><font color="#3399FF">思路 2：还有一种方案，那就是 每次遍历到 i 时，将哈希表中，<b>前 k 个位置 之前的元素 删除掉</b>。如果是在最近的 k 个数范围内，就不删除。即哈希表中只保留距离i最近的k个数，这样就不需要去计算是否符合索引值差小于等于k，因为只要没被删除的，就一定在 最近的 k 个范围。该思路的时间消耗比思路1长，但是空间消耗比思路1小。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        h = <span class="built_in">dict</span>()</span><br><span class="line">        N =<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">if</span> i &gt; k: <span class="comment"># 说明目前遍历的已经超过了 k 个数</span></span><br><span class="line">                <span class="comment"># 且仍未返回True</span></span><br><span class="line">                <span class="comment"># 那么直接删除 距离当前 i 超过 k 的元素对应的键值对</span></span><br><span class="line">                <span class="comment"># 即哈希表中只保留距离i最近的k个数</span></span><br><span class="line">                h.pop(nums[i-(k+<span class="number">1</span>)])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> h:</span><br><span class="line">                <span class="comment"># 哈希表中已存在该数, 说明是第二次出现了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h[nums[i]] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><span id="3.3.8"></span>  </p><h3 id="3-3-8-存在重复元素-III"><a href="#3-3-8-存在重复元素-III" class="headerlink" title="3.3.8 存在重复元素 III"></a>3.3.8 存在重复元素 III</h3><p><a href="https://leetcode.cn/problems/contains-duplicate-iii/">LeetCode 220.存在重复元素 III</a> | | <a href="#3.3">返回目录3.3</a></p><font color="#3399FF">思路1：遍历数组，每次遍历时，在大小为 indexDiff 区间上进行遍历，看看是否有符合条件的数字。这种思路比较直观，容易想到，能跑通大部分用例；但是对于某一些用例，会出现超时现象。因为时间复杂度是O(N*indexDiff)</font><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], indexDiff: <span class="built_in">int</span>, valueDiff: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        N =<span class="built_in">len</span>(nums)</span><br><span class="line">        k = indexDiff</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N):</span><br><span class="line">            <span class="comment"># 对于数组的每一个数字，都在它前方的 indexDiff 区间对比数值</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(<span class="number">0</span>,i-k),i):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(nums[i] - nums[j]) &lt;= valueDiff:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><font color="#3399FF">思路2：所以如何能高效判断 abs(nums[i] - nums[j]) <= 0 valuediff ？ 是该题的要点。 + 上面两个题，是要判断【两个数字在重复出现】的情况下，索引的差值是否满足条件。 那么这里如果将元素按照值域进行分组呢？满足条件的数落到同一个分桶里。那么问题就转化为： 两个数字在重复出现在一个分桶，即【两个数字的分桶序号重复出现】的情况下，索引的差值是否满足条件。 然后思路就是一样的了。 所以先对数字进行分桶操作：设 t="valueDiff" 取最差的情况，即两个数相差 t，比如 和 t, 那么可见每个分桶内应该有(t+1)个元素，那么我们就每隔(t+1)的值进行分桶，即看数字是 (t+1) 的多少倍，就分入哪个桶。 另外，如果两个数落在不同分桶，也不是说就一定不满足情况，比如 若a="t" b="t+1按照我们上面的分桶规则，就会分别分入0号桶和1号桶，但是他们也是有可能满足索引差值的条件的。所以还需考察相邻的桶的元素。" 还有，这里说的对数字进行分桶，并不是先对全部数字分好桶，而是一边遍历，一边对数字进行分桶；参考上两个题在遍历时对数字存入hash表，这里也是在遍历时分桶，然后将分桶的序号存入哈希表。 < font>  <p><b>写法一：参考上一题目<a href="#3.3.7">3.3.7</a>的思路1的代码写法</b></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], indexDiff: <span class="built_in">int</span>, valueDiff: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        h = <span class="built_in">dict</span>()</span><br><span class="line">        N =<span class="built_in">len</span>(nums)</span><br><span class="line">        t, k = valueDiff, indexDiff</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="comment"># 先计算当前数字的分桶序号 group_idx</span></span><br><span class="line">            group_idx = nums[i] // (t + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> group_idx <span class="keyword">in</span> h <span class="keyword">and</span> i-h[group_idx] &lt;=k :</span><br><span class="line">                <span class="comment"># 如果哈希表中已存在该序号，说明两数之差 &lt;=t</span></span><br><span class="line">                <span class="comment"># 且索引之差也&lt;=k</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 用最新的索引 i 覆盖 </span></span><br><span class="line">                h[group_idx] = i</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 要考虑左右相邻两个桶内是否也有符合条件的数</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> group_idx-<span class="number">1</span> <span class="keyword">in</span> h <span class="keyword">and</span> <span class="built_in">abs</span>(i-h[group_idx-<span class="number">1</span>]) &lt;= k <span class="keyword">and</span> <span class="built_in">abs</span>(nums[i]-nums[h[group_idx-<span class="number">1</span>]]) &lt;=t :</span><br><span class="line">            <span class="comment"># # 如果1.左桶存在； and 2.数字序号之差 &lt;=k; and 3.数值之差&lt;=t</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> group_idx+<span class="number">1</span> <span class="keyword">in</span> h <span class="keyword">and</span> <span class="built_in">abs</span>(i-h[group_idx+<span class="number">1</span>]) &lt;= k <span class="keyword">and</span> <span class="built_in">abs</span>(nums[i]-nums[h[group_idx+<span class="number">1</span>]]) &lt;=t :</span><br><span class="line">            <span class="comment"># # 如果1.右桶存在； and 2.数字序号之差 &lt;=k; and 3.数值之差&lt;=t</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>   </span><br></pre></td></tr></table></figure><p><b>写法二：参考上一题目<a href="#3.3.7">3.3.7</a>的思路2的代码写法</b></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], indexDiff: <span class="built_in">int</span>, valueDiff: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;因为哈希表只存储最近的k个数，所以比上面的代码要节省空间&#x27;&#x27;&#x27;</span></span><br><span class="line">        group = <span class="built_in">dict</span>()</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        t, k = valueDiff, indexDiff</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="comment"># 即哈希表中只保留距离i最近的k个数</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; k:</span><br><span class="line">                <span class="comment"># 计算更前面的数字的分桶序号, 并将其从哈希表中移除</span></span><br><span class="line">                old_key = nums[i - (k+<span class="number">1</span>)] // (t + <span class="number">1</span>)</span><br><span class="line">                group.pop(old_key)</span><br><span class="line">            <span class="comment"># 经过这个if条件，各个桶中如果仍存在元素，则必然满足 abs(i-j)&lt;=k这个条件</span></span><br><span class="line">            <span class="comment"># 下面只需要考察 abs(nums[i] - nums[j]) &lt;= t 这个条件即可</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算当前i位置数字的分桶序号</span></span><br><span class="line">            key = nums[i] // (t + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> group:</span><br><span class="line">                <span class="comment"># 哈希表中已存在该分桶序号，说明这两个数被分入同一个桶</span></span><br><span class="line">                <span class="comment"># 即 abs(nums[i] - nums[j]) &lt;= t 满足</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 用最新的索引 i 覆盖 </span></span><br><span class="line">                group[key] = i</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断左右侧桶是否满足条件</span></span><br><span class="line">            <span class="comment"># 这里注意到，因为哈希表中只保留了距离i最近的k个数，所以这里相较于上面的代码</span></span><br><span class="line">            <span class="comment"># 可以不用比较索引是否满足条件，因为一定满足条件</span></span><br><span class="line">            <span class="comment"># 只需要比较数值之差是否满足条件</span></span><br><span class="line">            <span class="keyword">if</span> (key - <span class="number">1</span>) <span class="keyword">in</span> group <span class="keyword">and</span> <span class="built_in">abs</span>(nums[group[key - <span class="number">1</span>]] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 判断右侧桶是否满足条件</span></span><br><span class="line">            <span class="keyword">if</span> (key + <span class="number">1</span>) <span class="keyword">in</span> group <span class="keyword">and</span> <span class="built_in">abs</span>(nums[group[key + <span class="number">1</span>]] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><span id="3.3.9"></span>  </p><h3 id="3-3-9-最大间距"><a href="#3-3-9-最大间距" class="headerlink" title="3.3.9 最大间距"></a>3.3.9 最大间距</h3><p><a href="https://leetcode.cn/problems/maximum-gap/">LeetCode 164.最大间距</a> | | <a href="#3.3">返回目录3.3</a></p><font color="#3399FF">思路：此题要求 时间复杂度是 O(N), 空间复杂度也是O(N)已经在暗示要从计数排序、基数排序、桶排序中找方法做了。该题数字的范围看起来要比数字规模大，计数排序可能没有桶排序表现好，我这里使用桶排序。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumGap</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> N &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;最基础的情况，元素都为非负整数&#x27;&#x27;&#x27;</span></span><br><span class="line">        max_v = <span class="built_in">max</span>(nums)</span><br><span class="line">        <span class="comment"># d 这里在统计最高的位数</span></span><br><span class="line">        d = <span class="built_in">len</span>(<span class="built_in">str</span>(max_v))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">            radix = <span class="number">10</span> ** i <span class="comment"># radix 代表本次循环基于哪一个位</span></span><br><span class="line">            Groups = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="comment"># 初始化从0到9，共10个分组</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                digit = num // radix % <span class="number">10</span></span><br><span class="line">                <span class="comment"># 按照当前位的数字，将原始数据分别装入不同的group中</span></span><br><span class="line">                Groups[digit].append(num)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 该 print 函数能打印各个阶段 数字装入分组后的状况，</span></span><br><span class="line">            <span class="comment"># 可以取消注释后打印中间结果，帮助理解</span></span><br><span class="line">            <span class="comment"># print(i, Groups)        </span></span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> group <span class="keyword">in</span> Groups:</span><br><span class="line">                <span class="keyword">for</span> num <span class="keyword">in</span> group:</span><br><span class="line">                    nums[j] = num </span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(nums)</span><br><span class="line">        max_res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N):</span><br><span class="line">            max_res = <span class="built_in">max</span>(max_res, <span class="built_in">abs</span>(nums[m-<span class="number">1</span>]-nums[m]))</span><br><span class="line">            <span class="comment"># print(max_res)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_res</span><br></pre></td></tr></table></figure><p><span id="3.3.10"></span>  </p><h3 id="3-3-10-数组中的第K个最大元素"><a href="#3-3-10-数组中的第K个最大元素" class="headerlink" title="3.3.10 数组中的第K个最大元素"></a>3.3.10 数组中的第K个最大元素</h3><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">LeetCode 215.数组中的第K个最大元素</a> | | <a href="#3.3">返回目录3.3</a></p><font color="#3399FF">思路 1：题目中又出现了 【时间复杂度为 O(n)】，又可以考虑计数排序、基数排序、桶排序。计数排序 O(n+width),该题 n 最大为 10^5; width最大为 2*10^4:即最大的 n > 最大的 width，所以可以先用计数排序尝试一次</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;题目条件中可能出现负数，所以要用delta做偏移&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">CountSort_update</span>(<span class="params">a, K</span>):</span><br><span class="line">            max_v, min_v = <span class="built_in">max</span>(a), <span class="built_in">min</span>(a)</span><br><span class="line">            <span class="comment"># max、min 函数的时间复杂度是 O(n)，符合题意</span></span><br><span class="line"></span><br><span class="line">            delta = -<span class="built_in">min</span>(<span class="number">0</span>, min_v)</span><br><span class="line">            <span class="comment"># 空间复杂度 O(width)</span></span><br><span class="line">            count_list = [<span class="number">0</span>]*(<span class="number">1</span>+max_v+delta)</span><br><span class="line">            <span class="comment"># 遍历数组a，时间负责度 O(n)</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> a:</span><br><span class="line">                count_list[num+delta] +=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 注意，由于题目中要求的是 第 k 大的数</span></span><br><span class="line">            <span class="comment"># 我们此时从后往前取，就是从大的那边开始取，取够k个就停止</span></span><br><span class="line">            <span class="comment"># 所以该循环时间复杂度是O(k), k最大也就只能是n, 不会超过数组本身规模</span></span><br><span class="line">            <span class="comment"># (极端情况，第 n 大的数, 也就是数组中最小的数)</span></span><br><span class="line">            <span class="keyword">for</span> elem <span class="keyword">in</span> <span class="built_in">range</span>(max_v+delta, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">while</span> count_list[elem] &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># a[i] = elem - delta</span></span><br><span class="line">                    <span class="comment"># i 是从0开始的，所以 i == k-1时，就是第 k 个数</span></span><br><span class="line">                    <span class="keyword">if</span> i == K-<span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> elem - delta</span><br><span class="line">                    count_list[elem] -= <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 综上所述, 时间复杂度依然是O(n)，符合题意</span></span><br><span class="line">        <span class="keyword">return</span> CountSort_update(nums,k)</span><br></pre></td></tr></table></figure><font color="#3399FF">思路 2： 由于数字最多只有5位： -10000 or 10000；更多的情况只有 4 位，所以基数排序的时间复杂度 O(n*d) = O(5*n) = O(n),也值得一试。只不过要注意这里会有负数，所以处理上要稍微仔细一点。 </font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;简单基数排序也能跑通所有样例&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">RadixSort</span>(<span class="params">nums</span>):</span><br><span class="line">            max_v, min_v = <span class="built_in">max</span>(nums), <span class="built_in">min</span>(nums)</span><br><span class="line">            <span class="comment"># 因为可能存在负数，所以要排除负号</span></span><br><span class="line">            d1 = <span class="built_in">len</span>(<span class="built_in">str</span>(max_v)) <span class="keyword">if</span> max_v &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">len</span>(<span class="built_in">str</span>(max_v)) -<span class="number">1</span></span><br><span class="line">            d2 = <span class="built_in">len</span>(<span class="built_in">str</span>(min_v)) <span class="keyword">if</span> min_v &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">len</span>(<span class="built_in">str</span>(min_v)) -<span class="number">1</span></span><br><span class="line">            d = <span class="built_in">max</span>(d1, d2)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">                radix = <span class="number">10</span>**i</span><br><span class="line">                Groups = [ [] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">                Groups_neg = [ [] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">                <span class="comment"># Groups_neg: [0:-9], [1:-8], [8:-1], [9:-0]</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                    digit = <span class="built_in">int</span>(num/radix) % <span class="number">10</span> </span><br><span class="line">                    <span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">                        Groups[digit].append(num)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        Groups_neg[digit-<span class="number">1</span>].append(num) </span><br><span class="line"></span><br><span class="line">                j = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> group <span class="keyword">in</span> Groups_neg:</span><br><span class="line">                    <span class="keyword">for</span> num <span class="keyword">in</span> group:</span><br><span class="line">                        nums[j] = num </span><br><span class="line">                        j+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> group <span class="keyword">in</span> Groups:</span><br><span class="line">                    <span class="keyword">for</span> num <span class="keyword">in</span> group:</span><br><span class="line">                        nums[j] = num </span><br><span class="line">                        j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        RadixSort(nums)</span><br><span class="line">        <span class="comment"># 因为我们是从小到大排序的，所以这里取数时要注意换算</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums) - k]</span><br><span class="line"></span><br></pre></td></tr></table></figure><font color="#3399FF">思路 3： 使用堆排序。虽然完整的堆排序，时间复杂度是 O(NlogN);但是我们并不需要使用完整的堆排序，先构造大根堆,时间复杂度O(N)；再进行 k-1次 heapify恢复大根堆操作，时间复杂度 k*O(logN);总时间复杂度 O(N) +  k*O(logN) 约为 O(N), 也可以尝试一下 </font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">Heapify</span>(<span class="params">a, index, heapsize</span>):</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;时间复杂度 o(logN) &#x27;&#x27;&#x27;</span></span><br><span class="line">            L = <span class="number">2</span>*index+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt;= heapsize:</span><br><span class="line">                R = L+<span class="number">1</span></span><br><span class="line">                large = R <span class="keyword">if</span>(R&lt;=heapsize <span class="keyword">and</span> a[R] &gt; a[L]) <span class="keyword">else</span> L</span><br><span class="line">                large = large <span class="keyword">if</span> a[large] &gt; a[index] <span class="keyword">else</span> index</span><br><span class="line">                <span class="keyword">if</span> large == index :</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                a[index], a[large] = a[large], a[index]</span><br><span class="line">                index = large </span><br><span class="line">                L = <span class="number">2</span>*index+<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;构造大根堆 时间复杂度 o(N) &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(N/<span class="number">2</span>), -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            Heapify(nums, i, N-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># small = min(nums)-1</span></span><br><span class="line">        small = -<span class="number">10001</span> </span><br><span class="line">        <span class="comment"># 用更小的数替换掉大根堆堆顶, 相当与将这个最大数给删除了，因为我们本来就不需要它</span></span><br><span class="line">        <span class="comment"># k*O(logN) = O(logN)</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):</span><br><span class="line">            nums[<span class="number">0</span>] = small </span><br><span class="line">            Heapify(nums, <span class="number">0</span>, N-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><span id="3.3.11"></span>  </p><h3 id="3-3-11-最小的k个数"><a href="#3-3-11-最小的k个数" class="headerlink" title="3.3.11 最小的k个数"></a>3.3.11 最小的k个数</h3><p><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">LeetCode 剑指 Offer 40.最小的k个数</a> | | <a href="#3.3">返回目录3.3</a>  </p><font color="#3399FF">思路： 由于此题没有要求时间复杂度，可以直接调用原生sort函数，或者用任意一种排序方法，先排序。  如果要追求时间复杂度较低的话，和上一道题有异曲同工之妙，此题找到是最小的k个数，所以仍然可以复用方法。 </font><ul><li>写法一：直接调用sort</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLeastNumbers</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        arr.sort()</span><br><span class="line">        <span class="keyword">return</span> arr[:k]</span><br></pre></td></tr></table></figure><ul><li>写法二：复用上一题目的思路<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLeastNumbers</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;由于和上一题几乎一样，这里仅给出用自带的heapq的code，其他的不赘述&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heapq.heapify(arr)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            res.append(arr[<span class="number">0</span>])</span><br><span class="line">            heapq.heappop(arr)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment"># 甚至可以直接调用求最小的n个函数</span></span><br><span class="line">        <span class="comment"># return heapq.nsmallest(k, arr)</span></span><br></pre></td></tr></table></figure></li></ul><p><span id="3.3.12"></span>  </p><h3 id="3-3-12-多数元素"><a href="#3-3-12-多数元素" class="headerlink" title="3.3.12 多数元素"></a>3.3.12 多数元素</h3><p><a href="https://leetcode.cn/problems/majority-element/">LeetCode 169.多数元素</a>| | | <a href="#3.3">返回目录3.3</a></p><font color="#3399FF">思路：该题就是先排序，至于排序方法可以任选，反正没有要求时间复杂度。拍完序后，该数一定会出现在 [n/2]位置，因为它的个数超过了[n/2]</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><span id="3.3.13"></span>  </p><h3 id="3-3-13-合并两个有序数组"><a href="#3-3-13-合并两个有序数组" class="headerlink" title="3.3.13 合并两个有序数组"></a>3.3.13 合并两个有序数组</h3><p><a href="https://leetcode.cn/problems/merge-sorted-array/">LeetCode 88.合并两个有序数组</a> | | <a href="#3.3">返回目录3.3</a></p><font color="#3399FF">思路 1：这个题一看就知道可以用归并排序中的 【归并】步骤做。只不过这里是直接在nums1上进行填充（题目中nums1的空间是有冗余的），所以对nums1从右往左进行填充。这样的话就是从右往左遍历，较大数往nums1右侧填充即可。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">        p1, p2 = m-<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">        i = m+n-<span class="number">1</span></span><br><span class="line">        <span class="comment"># p1, p2, i 都是从右往左遍历</span></span><br><span class="line">        <span class="comment"># 较大数往 i 位置填充</span></span><br><span class="line">        <span class="keyword">while</span> p1 &gt;=<span class="number">0</span> <span class="keyword">and</span> p2 &gt;=<span class="number">0</span> :</span><br><span class="line">            <span class="keyword">if</span> nums1[p1] &gt; nums2[p2]:</span><br><span class="line">                nums1[i] =  nums1[p1] </span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">                i-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[i] =  nums2[p2] </span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">                i-=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果 p1 &gt;= 0，说明 nums2的数已经全部填入合适位置了</span></span><br><span class="line">        <span class="comment"># 那 nums1剩下的部分可以不用动，所以这部分可以注释掉</span></span><br><span class="line">        <span class="comment"># while p1 &gt;= 0:</span></span><br><span class="line">        <span class="comment">#     nums1[i] =  nums1[p1]</span></span><br><span class="line">        <span class="comment">#     p1 -= 1</span></span><br><span class="line">        <span class="comment">#     i-=1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p2 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 如果nums2还有剩余，就继续填充即可</span></span><br><span class="line">            nums1[i] =  nums2[p2]</span><br><span class="line">            p2 -= <span class="number">1</span></span><br><span class="line">            i-=<span class="number">1</span></span><br></pre></td></tr></table></figure><font color="#3399FF">思路 2：因为 nums1 也已经是有序部分，所以可以用插入排序的思路做，即将 nums2 中的元素逐个插入到 nums1 中合适的位置即可。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># .插入排序</span></span><br><span class="line">        <span class="comment"># 换句话说nums1 在 (0,m) 区间 已经有序了</span></span><br><span class="line">        <span class="comment"># 那可以用插入排序，将 nums2的数一个一个插入到合适的位置</span></span><br><span class="line">        <span class="comment"># 只需要考察 m 到 m+n-1 的位置了</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m, m+n):</span><br><span class="line">            nums1[i] = nums2[i-m]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums1[j] &gt; nums1[j+<span class="number">1</span>]:</span><br><span class="line">                    nums1[j+<span class="number">1</span>], nums1[j] = nums1[j], nums1[j+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><span id="3.3.14"></span>  </p><h3 id="3-3-14-逆序对"><a href="#3-3-14-逆序对" class="headerlink" title="3.3.14 逆序对"></a>3.3.14 逆序对</h3><p><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">LeetCode 剑指 Offer 51.数组中的逆序对</a> | | <a href="#3.3">返回目录3.3</a></p><font color="#3399FF">思路：如果用暴力手段去遍历的话，可能会超时。逆序对问题，可以用归并排序的过程来求解，具体的讲解放在注释中了。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePairs</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 就是手写归并排序，只不过这里需要多传入一个统计量 cnt 参与计数</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;核心思想就是在归并操作，对比左右两部分的数字的时候，</span></span><br><span class="line"><span class="string">           考察右侧的每一个数，在左边有多少个数比它大，则左边的这些数就都能与右侧的该数，</span></span><br><span class="line"><span class="string">           组成逆序对</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, L, R, cnt</span>):</span><br><span class="line">            <span class="keyword">if</span> L &gt;= R :</span><br><span class="line">                <span class="keyword">return</span> cnt </span><br><span class="line">            </span><br><span class="line">            M = L + (R-L) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            cnt = func(a,L,M,cnt)</span><br><span class="line">            cnt = func(a,M+<span class="number">1</span>,R,cnt)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># merge </span></span><br><span class="line">            p1, p2 = L, M+<span class="number">1</span></span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">while</span> p1&lt;=M <span class="keyword">and</span> p2 &lt;=R:</span><br><span class="line">                <span class="keyword">if</span> a[p1] &lt;= a[p2]:</span><br><span class="line">                    <span class="comment"># 左边的比右边的小，不构成逆序对，不用考虑</span></span><br><span class="line">                    res.append(a[p1])</span><br><span class="line">                    p1+=<span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># a[p1] &gt; a[p2]</span></span><br><span class="line">                    <span class="comment"># 因为归并排序的特点，左右两部分都各自已经是有序的了</span></span><br><span class="line">                    <span class="comment"># 所以left部分的 [p1,M] 区间的数都比 a[p1] 大</span></span><br><span class="line">                    <span class="comment"># 那么自然也比a[p2]大，都可与a[p2]组成逆序对</span></span><br><span class="line">                    cnt += M - p1 + <span class="number">1</span></span><br><span class="line">                    res.append(a[p2])</span><br><span class="line">                    p2+=<span class="number">1</span>     </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果是左侧数组还剩余有元素</span></span><br><span class="line">            <span class="comment"># 说明右侧数组已经考察完了</span></span><br><span class="line">            <span class="comment"># 而我们上面的计算方案是，对于右侧数组中的数字，计算其在左侧有多少个比它大</span></span><br><span class="line">            <span class="comment"># 此时右侧数组已经考察完，就说明cnt不用再计算了</span></span><br><span class="line">            <span class="keyword">while</span> p1 &lt;= M:</span><br><span class="line">                res.append(a[p1])</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果是右侧数组还剩余有元素</span></span><br><span class="line">            <span class="comment"># 说明左侧数组已经全部考察完了</span></span><br><span class="line">            <span class="comment"># 那么右侧数组剩余的数字一定是比左侧数组中的数字都大</span></span><br><span class="line">            <span class="comment"># 所以cnt也不用再计算了</span></span><br><span class="line">            <span class="keyword">while</span> p2 &lt;= R:</span><br><span class="line">                res.append(a[p2])</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,R-L+<span class="number">1</span>):</span><br><span class="line">                a[L+i] = res[i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> cnt</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> func(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><span id="3.3.15"></span>  </p><h3 id="3-3-15-计算右侧小于当前元素的个数"><a href="#3-3-15-计算右侧小于当前元素的个数" class="headerlink" title="3.3.15 计算右侧小于当前元素的个数"></a>3.3.15 计算右侧小于当前元素的个数</h3><p><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">LeetCode 315.计算右侧小于当前元素的个数</a> | | <a href="#3.3">返回目录3.3</a></p><font color="#3399FF">思路：该题是上一题的升级版，难度稍微上升了一点。因为这一次等于是要计算对应位置上的逆序对，而位置在排序的时候是会移动的，就是要在这里考虑这一点。  所以排序的时候，可以带着索引一起排；这样对每个位置计算其各个merge阶段的逆序对的时候，还是按照索引来进行改动。    将索引和数字绑定在一起形成一个元素：nums2 = [[idx, num] for idx, num in enumerate(nums)]   另外，由于我们是对每个位置计算其右侧的逆序对，所以这个题中，在考虑计算逆序对的时机时，应该是以left数为准，计算右侧有多少个数比它小。（<i>上一题在merge时，是对右侧的每个数计算其左侧有多少个数可以和其组成逆序对，因为只考虑逆序对的个数，而不考虑具体哪个位置上逆序对的个数，所以这么写code方便一些</i>）</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSmaller</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 先产生一个(索引，数字)为元素的新数组</span></span><br><span class="line">        nums2 = [[idx, num] <span class="keyword">for</span> idx,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums)]</span><br><span class="line">        <span class="comment"># 初始化一个全0的结果list</span></span><br><span class="line">        cnt_list = [<span class="number">0</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, L, R</span>):</span><br><span class="line">            <span class="keyword">if</span> L &gt;= R:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            M = L + (R-L)//<span class="number">2</span></span><br><span class="line">            func(a, L, M)</span><br><span class="line">            func(a, M+<span class="number">1</span>, R)</span><br><span class="line"></span><br><span class="line">            p1, p2 = L, M+<span class="number">1</span></span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">while</span> p1 &lt;= M <span class="keyword">and</span> p2 &lt;= R:</span><br><span class="line">                <span class="comment"># 元素是(idx, num)</span></span><br><span class="line">                <span class="comment"># 所以这里要对比的是 p1 和 p2 位置上的第二个值：num</span></span><br><span class="line">                <span class="keyword">if</span> a[p1][<span class="number">1</span>]&lt;=a[p2][<span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># 此时轮到左侧 p1 位置上的元素进入tmp</span></span><br><span class="line">                    <span class="comment"># 说明右侧的 [M+1, p2-1] 区间先于 p1的数字进入 tmp</span></span><br><span class="line">                    <span class="comment"># 即右侧的 [M+1, p2-1]区间 比 p1位置的数小</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 获取 a[p1][0]，对该位置记录的逆序对进行修改</span></span><br><span class="line">                    cnt_list[a[p1][<span class="number">0</span>]] += p2 - (M+<span class="number">1</span>)</span><br><span class="line">                    tmp.append(a[p1])</span><br><span class="line">                    p1 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp.append(a[p2])</span><br><span class="line">                    p2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果左侧数组还剩下数字没有进入tmp</span></span><br><span class="line">            <span class="comment"># 那说明剩下的这些数字都比右侧数组的数大            </span></span><br><span class="line">            <span class="keyword">while</span> p1 &lt;= M:</span><br><span class="line">                cnt_list[a[p1][<span class="number">0</span>]] += p2 -(M+<span class="number">1</span>)</span><br><span class="line">                tmp.append(a[p1])</span><br><span class="line">                p1 += <span class="number">1</span>    </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果是右侧数组还剩下数字，说明左侧的已经考察完了</span></span><br><span class="line">            <span class="comment"># 由于我们的计算方案是对每个左侧数字计算右侧中比它大的数，</span></span><br><span class="line">            <span class="comment"># 所以此时不用变动cnt了</span></span><br><span class="line">            <span class="keyword">while</span> p2 &lt;= R:</span><br><span class="line">                tmp.append(a[p2])</span><br><span class="line">                p2 += <span class="number">1</span>       </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp)):</span><br><span class="line">                a[L+i] = tmp[i]</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        func(nums2, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)                     </span><br><span class="line">        <span class="keyword">return</span>  cnt_list  </span><br></pre></td></tr></table></figure><p><span id="3.3.16"></span>  </p><h3 id="3-3-16-最接近原点的-K-个点"><a href="#3-3-16-最接近原点的-K-个点" class="headerlink" title="3.3.16 最接近原点的 K 个点"></a>3.3.16 最接近原点的 K 个点</h3><p><a href="https://leetcode.cn/problems/k-closest-points-to-origin/">LeetCode 973.最接近原点的 K 个点</a> | | <a href="#3.3">返回目录3.3</a></p><font color="#3399FF">思路：这个题最简单的思路就是排序时的条件设置为距离。不管是用自带的sort还是自己写的排序code，只要两个元素之间的大小关系的对比，设置为自定义即可。和3.3.2以及 3.3.3的核心思想一样。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kClosest</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 这里简便起见，直接使用自带的sort方法</span></span><br><span class="line">        points.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]*x[<span class="number">0</span>] + x[<span class="number">1</span>]*x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> points[:k]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果要使用自己写的排序code，就需要定义一个比较大小的函数</span></span><br><span class="line">        <span class="comment"># 根据其返回值确定两个元素谁大，然后套用各种排序code即可</span></span><br><span class="line">        <span class="comment"># def Compare_two_ele(x,y):</span></span><br><span class="line">        <span class="comment">#     if x[0]*x[0] + x[1]*x[1]  &gt; y[0]*x[0] + y[1]*y[1]:</span></span><br><span class="line">        <span class="comment">#         return 1</span></span><br><span class="line">        <span class="comment">#     elif x[0]*x[0] + x[1]*x[1] == y[0]*x[0] + y[1]*y[1]:</span></span><br><span class="line">        <span class="comment">#         return 2</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         return 3</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure></=></font>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3-2 快速排序讨论</title>
      <link href="/Data-Structure/DS_32_quick_sort_discussion.html"/>
      <url>/Data-Structure/DS_32_quick_sort_discussion.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="3-2-快速排序讨论"><a href="#3-2-快速排序讨论" class="headerlink" title="3-2 快速排序讨论"></a>3-2 快速排序讨论</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>3.2.1</td><td><a href="#3.2.1">基础问题-分块操作</a></td></tr><tr><td>3.2.2</td><td><a href="#3.2.2">经典快速排序问题</a></td></tr><tr><td>3.2.3</td><td><a href="#3.2.3">荷兰国旗问题</a></td></tr><tr><td>3.2.4</td><td><a href="#3.2.4">利用荷兰国旗问题改进快</a></td></tr><tr><td>3.2.5</td><td><a href="#3.2.5">快速排序再改进</a></td></tr></tbody></table></div><p><span id="3.2.1"></span>  </p><h2 id="3-2-1-基础问题-分块操作"><a href="#3-2-1-基础问题-分块操作" class="headerlink" title="3.2.1 基础问题-分块操作"></a>3.2.1 基础问题-分块操作</h2><p>分块问题（Partition 问题）：<br>给定一个数组arr，和一个数num，请把小于 num的数放在数组的左边，大于等于num的数放在数组的右边。<br>要求额外空间复杂度O(1)，时间复杂度O(N)。  </p><ul><li>解决思路_1：<br>  设立一个游标，该游标可以从左向右逐渐移动，移动的条件为，将数组中小于num的数，不断的插入到游标的位置，然后游标右移。<br>  这样，游标的左侧区域就逐渐扩张，相当于顶着游标在往右移动。<br>  最终，当所有元素都考察过之后，游标左侧区域的数，一定是小于num，游标右侧的数大于等于num。  </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Swap</span>(<span class="params">a, i, j</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a[i], a[j] = a[j], a[i]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(i, j)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Partition_1</span>(<span class="params">a</span>):</span><br><span class="line"></span><br><span class="line">    N = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="comment"># 我们现在假设待比较的num是数组最后的元素，即N-1位置的元素</span></span><br><span class="line">    <span class="comment"># L 就是我们的游标，在这里，我们设置游标L指向 小于等于num区域 的最后一个数的位置</span></span><br><span class="line">    <span class="comment"># 由于最开始的时候，左侧区域是没有数的，所以游标初始值是-1</span></span><br><span class="line">    key, L = N-<span class="number">1</span>, -<span class="number">1</span></span><br><span class="line">    base = a[key]</span><br><span class="line">    <span class="comment"># 因为 N-1位置的值，被我们当作比较的基准，所以只用遍历前N-1个数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, N-<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 这里的意思是，如果i位置的数，小于基准数</span></span><br><span class="line">        <span class="comment"># 就将i位置的数，与游标L右侧紧挨着的数交换位置，同时游标L右移一位，左侧区域扩张一位</span></span><br><span class="line">        <span class="keyword">if</span> a[i] &lt; base:</span><br><span class="line">            Swap(a, i, L+<span class="number">1</span>)</span><br><span class="line">            L+=<span class="number">1</span></span><br><span class="line">    <span class="comment"># for循环遍历完之后, 数组 0-L位置上的数都是小于base的数</span></span><br><span class="line">    <span class="comment"># 最后将key位置的基准数num与游标右侧L+1位置的数字交换，</span></span><br><span class="line">    <span class="comment"># 因为while循环结束之后，游标右侧的数一定是大于等于base的</span></span><br><span class="line">    <span class="comment"># 所以base与L+1位置的数交换，不影响区域的大小，但便于观察数据</span></span><br><span class="line">    <span class="comment"># 这样的话， 0-L 上的数小于base; L+1 的数等于base; L+2 至 N-1 位置上的数 大于等于 base</span></span><br><span class="line"></span><br><span class="line">    Swap(a, L+<span class="number">1</span>, key)</span><br><span class="line">    <span class="keyword">return</span> (a, L+<span class="number">1</span>, base)</span><br></pre></td></tr></table></figure><ul><li>解题思路_2: 双指针法<br>  上面的方案，设立了一个游标 L 从左往右移动，使得 L 左侧的值小于base。但是i要从左往右遍历一次，速度不够快。<br>  这里可以改进一下，再增加一个游标 R，让其从右往左移动，使得 R 右侧的数，大于等于base。<br>  当L和R撞在一起的时候，就可以结束了。  </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Partition_2</span>(<span class="params">a</span>):</span><br><span class="line"></span><br><span class="line">    N = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="comment"># 这里仍然取最后一个元素为base</span></span><br><span class="line">    <span class="comment"># 但是 L 不是从-1开始，而是从0开始；这是因为下面不是与L+1位置的数做交换了</span></span><br><span class="line">    <span class="comment"># 而是 L 和 R 两个游标指向的数做交换！即 L 和 R 指向各自区域内的边界位置</span></span><br><span class="line">    L, R, key = <span class="number">0</span>, N-<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">    base = a[key]</span><br><span class="line">    <span class="keyword">while</span> L &lt; R:</span><br><span class="line">    <span class="comment"># L 一旦等于R了，就说明两个游标都已经将区域确立好了，就该停止了</span></span><br><span class="line">    <span class="comment"># 所以下面的步骤也需要注意这个停止条件</span></span><br><span class="line">        <span class="keyword">while</span> a[L] &lt; base <span class="keyword">and</span> L&lt;R:</span><br><span class="line">            <span class="comment"># L 从0开始，如果L指向的数满足条件，则L就往右移动            </span></span><br><span class="line">            L+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果L指向了大于等于base的数，就先跳出左侧区域循环，等着下面和R位置交换</span></span><br><span class="line">        <span class="keyword">while</span> a[R] &gt;= base <span class="keyword">and</span> L&lt;R:</span><br><span class="line">            <span class="comment"># R 从 N-1 开始，如果R指向的数满足条件，则R就往左移动</span></span><br><span class="line">            R-=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果R指向了小于base的数，就先跳出右侧区域循环，等着下面和L位置交换</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行到这里，如果不是 L&gt;=R这个条件触发，那么一定是这样的情况：</span></span><br><span class="line">        <span class="comment"># L 指向的数大于等于base，R指向的数小于base</span></span><br><span class="line">        <span class="comment"># 则正好将它俩交换一下位置，然后进行下一次循环    </span></span><br><span class="line">        <span class="keyword">if</span> L&lt; R: Swap(a, R, L)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 循环结束时 L==R，此时该位置的数必然 &gt;= a[key]，直接将其交换</span></span><br><span class="line">    <span class="comment"># 这里之所以有这个结论，其实跟上面的一些设置有关系</span></span><br><span class="line">    <span class="comment"># 首先是选取的key是数组最右侧的数，其次是因为循环里先移动L的位置</span></span><br><span class="line">    <span class="comment"># 如果我们选择0作为key，那么就应该先移动右边的数，然后循环结束时，该位置的数一定&lt;=a[0]</span></span><br><span class="line">    <span class="comment"># 这段解析可以细品一下，或者自己多找几个数组试一下  </span></span><br><span class="line">    Swap(a, R, key)</span><br><span class="line">    <span class="keyword">return</span>(a, R, base)</span><br></pre></td></tr></table></figure><p><span id="3.2.2"></span>   </p><h2 id="3-2-2-经典快速排序问题"><a href="#3-2-2-经典快速排序问题" class="headerlink" title="3.2.2 经典快速排序问题"></a>3.2.2 经典快速排序问题</h2><p>在了解了上面的分区域（partition）操作之后，就已经可以将其应用到快速排序中了。<br>快速排序其实也是一种分而治之思想在排序算法上的典型应用，而且使用了递归的方法。<br>不断的将数组分为更小的两块区域，使其在最小的区域上能有序，进而在全局都有序。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">QuickSort_1</span>(<span class="params">a, L, R</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;经典快速排序&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span>(L&gt;=R):</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="comment"># partition stage            </span></span><br><span class="line">    pl, pr, key = L, R, L</span><br><span class="line">    <span class="comment"># 这里选择 partition_2的思路来做分块partition</span></span><br><span class="line">    <span class="comment"># 这里选择每一次的0作为key，以及先移动右边的数，</span></span><br><span class="line">    <span class="comment"># 然后循环结束时，该位置的数一定 &lt;=a[0]</span></span><br><span class="line">    <span class="comment"># 然后与 pl位置的进行交换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> pl &lt; pr:</span><br><span class="line">        <span class="keyword">while</span> a[pr] &gt; a[key] <span class="keyword">and</span> pl &lt; pr:</span><br><span class="line">            pr-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> a[pl] &lt;= a[key] <span class="keyword">and</span> pl &lt; pr:</span><br><span class="line">            pl+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> pl&lt; pr: Swap(a,pl,pr)</span><br><span class="line">    Swap(a,pl,key)</span><br><span class="line">    <span class="comment"># recursion stage</span></span><br><span class="line">    QuickSort_1(a, L, pl-<span class="number">1</span>)</span><br><span class="line">    QuickSort_1(a, pl+<span class="number">1</span>, R)</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p><span id="3.2.3"></span>   </p><h2 id="3-2-3-荷兰国旗问题"><a href="#3-2-3-荷兰国旗问题" class="headerlink" title="3.2.3 荷兰国旗问题"></a>3.2.3 荷兰国旗问题</h2><p>之前的Partition操作只要求分为两块区域，一部分小于等于，另一部分大于（或者一部分小于，另一部分大于等于）。<br>会发现，等于基准base的数，并不一定处于中间位置，尤其当有很多个数等于base的时候。<br>那么如果现在分为三块区域，即【小于，等于，大于】，就能加速排序过程。<br>举个例子，比如三个区域各有 N/3个数，那么下一轮迭代，就不用考虑等于区域的数了，就减少了计算量。<br>所以三块区域的 partition 问题，被称为【荷兰国旗问题】。<br>（可是荷兰国旗明明是横着的三块区域，我也不知道为什么当初人们起这个名字，我觉得更像法国国旗……）  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Partition_3</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;荷兰国旗问题，分三块&#x27;&#x27;&#x27;</span></span><br><span class="line">    N = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="comment"># 这里还是选择两个游标，但注意，这里L又是从-1开始了，因为下面i是在和L+1的位置交换</span></span><br><span class="line">    <span class="comment"># R 从 N-1开始，但因为我们的key是选的N-1，所以R也相当于是从待分块的区域外开始</span></span><br><span class="line">    <span class="comment"># 也就是说， L 和 R 一开始都是没有指向待比较元素的</span></span><br><span class="line">    L, R, key = -<span class="number">1</span>, N-<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">    base = a[key]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里其实就是i从初始游标L右侧开始，即 待比较区域 的第1个元素开始遍历</span></span><br><span class="line">    <span class="comment"># 如果只是对整个数组应用一次该函数，其实写 i=0 更好理解</span></span><br><span class="line">    <span class="comment"># 但是在遇到递归操作时，i不可能永远是从0开始，而写L+1能够适应这种变化</span></span><br><span class="line">    i = L+<span class="number">1</span> </span><br><span class="line">    <span class="keyword">while</span> i &lt;R:</span><br><span class="line">        <span class="comment"># 我们的目标是R及其右侧的区域是【大于区域】，所以若i==R，说明该停止了</span></span><br><span class="line">        <span class="keyword">if</span> a[i]&lt;base:</span><br><span class="line">        <span class="comment"># 这里是最开始已经讲过的，左侧区域向右扩展，L和i都增加</span></span><br><span class="line">            Swap(a, i, L+<span class="number">1</span>)</span><br><span class="line">            L+=<span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span>                       </span><br><span class="line">        <span class="keyword">elif</span> a[i] == base:</span><br><span class="line">        <span class="comment"># 这里的条件，L不扩展，但i继续向右侧遍历，相当于单独留了一个等于区域出来</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">                      </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># i 和 R-1位置上的数交换，就是和大于区域左侧的那个数交换，然后大于区域向左扩张（R-=1）</span></span><br><span class="line">        <span class="comment"># 其实和小于区域L的处理，是镜像的，很容易理解，一个往右扩张，一个往左扩张</span></span><br><span class="line">            Swap(a, i , R-<span class="number">1</span>)</span><br><span class="line">            R -=<span class="number">1</span></span><br><span class="line">            <span class="comment"># i+=1 一定要注意！ 大于区域扩展之后，i不应该增加！！！</span></span><br><span class="line">            <span class="comment"># 因为这个数字是从原来R-1位置换过去的，我们其实还没有进行与base比较这个操作</span></span><br><span class="line">            <span class="comment"># 就是说这个数没有得到遍历，我们得又再看一下现在i位置的值和base的关系</span></span><br><span class="line">    <span class="comment"># 循环结束时， i==R</span></span><br><span class="line">    <span class="comment"># 然后 [L+1, R-1] 区间应当是等于 base的区域 </span></span><br><span class="line">    <span class="comment"># 这时候需要把一开始选择的key位置上的 base数放入该区域中</span></span><br><span class="line">    <span class="comment"># 也就是需要进行一次交换</span></span><br><span class="line">    <span class="comment"># 下方为何与 R 交换呢？因为这个base的位置key是在右侧，</span></span><br><span class="line">    <span class="comment"># 所以R位置上，的数本来就大于 base，把它交换到 key位置上，仍然处于右侧【大于区域】</span></span><br><span class="line">    <span class="comment"># 如果我们一开始的 key 选择的是左侧的数，比如0位置上的数</span></span><br><span class="line">    <span class="comment"># 这里就应该 Swap(a,L,key), L上的数本来就小于base，放到0位置上去也不会影响partition</span></span><br><span class="line">    Swap(a, R , key) </span><br><span class="line">    <span class="comment"># 此时：R 位置为base值，[R+1, N-1] 上的数大于 base; [L+1,R]上的数等于base; [0, L]上的值小于base</span></span><br><span class="line">    <span class="comment"># 如此一来，就分为了三个部分，且端点位置我们也能知道</span></span><br><span class="line">    <span class="keyword">return</span> (a, L, R, base)</span><br></pre></td></tr></table></figure><p><span id="3.2.4"></span>   </p><h2 id="3-2-4-利用荷兰国旗问题改进快速排序"><a href="#3-2-4-利用荷兰国旗问题改进快速排序" class="headerlink" title="3.2.4 利用荷兰国旗问题改进快速排序"></a>3.2.4 利用荷兰国旗问题改进快速排序</h2><p>快速排序的架构其实很简单，就是先Partition，然后递归左右两侧区域，<br>这里我们只需要把 Partition 的方法换成 3区域 的方法即可：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">QuickSort_2</span>(<span class="params">a, L, R</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;利用荷兰国旗问题进行小加速&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span>(L&gt;=R):</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="comment"># partition stage    </span></span><br><span class="line">    pl, pr, key = L-<span class="number">1</span>, R, R</span><br><span class="line">    <span class="comment"># print(pl, pr, key)</span></span><br><span class="line">    i = pl+<span class="number">1</span> <span class="comment"># 注意，这里如果写i=0的话会导致右半部分出错！</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; pr:</span><br><span class="line">        <span class="keyword">if</span> a[i] &lt; a[key]:</span><br><span class="line">            Swap(a, i, pl+<span class="number">1</span>)</span><br><span class="line">            pl+=<span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> a[i] == a[key]:</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Swap(a, i, pr-<span class="number">1</span>)</span><br><span class="line">            pr-=<span class="number">1</span></span><br><span class="line">    <span class="comment"># 循环结束时， i==pr</span></span><br><span class="line">    </span><br><span class="line">    Swap(a, pr, key)</span><br><span class="line">    <span class="comment"># recursion stage</span></span><br><span class="line">    <span class="comment"># 观察下面的输入游标发现：</span></span><br><span class="line">    <span class="comment"># 比起改进之前，中间的 [pl+1,pr] 这一部分若干个元素就可以不用计算了，达成加速</span></span><br><span class="line">    QuickSort_2(a, L, pl)</span><br><span class="line">    QuickSort_2(a, pr+<span class="number">1</span>, R)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p><span id="3.2.5"></span>   </p><h2 id="3-2-5-快速排序再改进"><a href="#3-2-5-快速排序再改进" class="headerlink" title="3.2.5 快速排序再改进"></a>3.2.5 快速排序再改进</h2><p>&emsp;&emsp;前面的所有 Partition 方法，都是固定了一个位置的数，作为base来进行比较，大多数时候我们习惯直接用最右侧的数。  </p><p>&emsp;&emsp;但是这样就有一个问题，那就是当数据处于某一种情况的时候，每一次的取右侧那个数作为基准，可能都会导致有较多的swap操作。  </p><p>&emsp;&emsp;输入数据是我们不可控的，为了使得算法稳定，我们可以使得每一次的key，都是随机产生的，这样从统计学角度讲，会是比较稳定快速排序。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">QuickSort_3</span>(<span class="params">a, L ,R</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;对每次取的key做随机处理，可以再次改进&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span>(L&gt;=R):</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="comment"># partition stage    </span></span><br><span class="line">    pl, pr = L-<span class="number">1</span>, R</span><br><span class="line">    key = random.randint(L,R) <span class="comment"># 在 L~R范围上随机取一个位置</span></span><br><span class="line">    Swap(a, key, R) <span class="comment"># 但是还是将该数放到R位置上，这样就能复用之前的code了</span></span><br><span class="line">    key = R <span class="comment"># 再更新一下key</span></span><br><span class="line">    <span class="comment"># 这样虽然用的还是R，但是这里的R位置上的数，其实是随机从待排区域中抽取的</span></span><br><span class="line">    i = pl+<span class="number">1</span> <span class="comment"># 注意，这里如果写i=0的话会导致右半部分出错！</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; pr:</span><br><span class="line">        <span class="keyword">if</span> a[i] &lt; a[key]:</span><br><span class="line">            Swap(a, i, pl+<span class="number">1</span>)</span><br><span class="line">            pl+=<span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> a[i] == a[key]:</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Swap(a, i, pr-<span class="number">1</span>)</span><br><span class="line">            pr-=<span class="number">1</span></span><br><span class="line">    <span class="comment"># 循环结束时， i==pr</span></span><br><span class="line">    </span><br><span class="line">    Swap(a, pr, key)</span><br><span class="line">    <span class="comment"># recursion stage</span></span><br><span class="line">    QuickSort_2(a, L, pl)</span><br><span class="line">    QuickSort_2(a, pr+<span class="number">1</span>, R)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3-1 排序</title>
      <link href="/Data-Structure/DS_31_sort_algorithm.html"/>
      <url>/Data-Structure/DS_31_sort_algorithm.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="3-1-排序与查找"><a href="#3-1-排序与查找" class="headerlink" title="3-1 排序与查找"></a>3-1 排序与查找</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>3.1.1.1</td><td><a href="#3.1.1.1">冒泡排序</a></td></tr><tr><td>3.1.1.2</td><td><a href="#3.1.1.2">选择排序</a></td></tr><tr><td>3.1.1.3</td><td><a href="#3.1.1.3">插入排序</a></td></tr><tr><td>3.1.1.4</td><td><a href="#3.1.1.4">希尔排序</a></td></tr><tr><td>3.1.1.5</td><td><a href="#3.1.1.5">归并排序</a></td></tr><tr><td>3.1.1.6</td><td><a href="#3.1.1.6">堆排序</a></td></tr><tr><td>3.1.1.7</td><td><a href="#3.1.1.7">快速排序</a></td></tr><tr><td>3.1.1.8</td><td><a href="#3.1.1.8">计数排序</a></td></tr><tr><td>3.1.1.9</td><td><a href="#3.1.1.9">基数排序</a></td></tr><tr><td>3.1.1.10</td><td><a href="#3.1.1.10">桶排序</a></td></tr><tr><td>3.1.2</td><td><a href="#3.1.2">二分查找</a></td></tr></tbody></table></div><h2 id="3-1-1-排序部分"><a href="#3-1-1-排序部分" class="headerlink" title="3.1.1 排序部分"></a>3.1.1 排序部分</h2><p>排序算法可以分为内部排序和外部排序，<br>内部排序是数据记录在内存中进行排序，<br>外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要额外辅助空间。  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/3_1_1.webp" width="80%">   </p><p><span id="3.1.1.1"></span> </p><h3 id="3-1-1-1-冒泡排序"><a href="#3-1-1-1-冒泡排序" class="headerlink" title="3.1.1.1 冒泡排序"></a>3.1.1.1 冒泡排序</h3><p>它重复地遍历过要排序的数列，<b>每次比较相邻两个元素，如果其大小顺序错误就交换位置</b>。<br>遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br>这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。<br>(或者也可以让大的元素慢慢“沉”到后面去，这种写法就是右部为有序区域）<br>冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># code 写法并不唯一，思路是固定的：通过对比相邻元素，然后交换</span></span><br><span class="line"><span class="comment"># 我这里的写法是每一轮把剩余的一个最大值, 送到右侧去</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Bubble_Sort</span>(<span class="params">x</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(x)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">            <span class="keyword">if</span> x[j] &gt; x[j+<span class="number">1</span>]:</span><br><span class="line">                x[j], x[j+<span class="number">1</span>] = x[j+<span class="number">1</span>], x[j]</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><blockquote><p>上述 code 思路：<br>不断地从左侧对比出最大的值，按次序放在右侧<br>第一轮:要比较的相邻索引是 (0, 1), (1,2), … ,(N-2, N-1), 遍历完后，最大数落在 N-1 位置<br>第二轮:要比较的相邻索引是 (0, 1), (1,2), … ,(N-3, N-2), 遍历完后，最大数落在 N-2 位置<br>…<br>倒数第二轮，要比较的相邻索引是 (0, 1), (1,2), 遍历完后，最大数落在 2 位置<br>最后一轮，数据对索引是 (0, 1), 遍历完后，最大数落在 1 位置<br>故而，如果用 i 代表每一轮的对比的末尾，i 从 N-1 到 1，即 i in range(N-1,0,-1)<br>   用 j 来代表数据待比较区域的索引，j 从 0 到 i-1，即 j in range (0, i)</p></blockquote><p><span id="3.1.1.2"></span> </p><h3 id="3-1-1-2-选择排序"><a href="#3-1-1-2-选择排序" class="headerlink" title="3.1.1.2 选择排序"></a>3.1.1.2 选择排序</h3><p>每次遍历时，都将未排序区域的第一个值，假设为本次遍历的最小值，<br>然后开始遍历未排序区域，直到找到未排序区域中最小的值的序号min_Index，<br>遍历完一次后，比较 min_Index 位置的值 与 假设的最小值的大小，不及预期，则可以交换位置，同时，未排序区域减少一个位置。<br>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。<br>==排序过程中，左侧区域是已排序区域，右侧区域是未排序区域。==</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">SelectSort</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-<span class="number">1</span>):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,N):</span><br><span class="line">            min_index = j <span class="keyword">if</span> (a[j]&lt;a[min_index]) <span class="keyword">else</span> min_index</span><br><span class="line">        <span class="keyword">if</span> i != min_index:</span><br><span class="line">            a[i], a[min_index] = a[min_index], a[i]</span><br><span class="line">    <span class="keyword">return</span> a </span><br></pre></td></tr></table></figure><blockquote><p>code 思路  </p><p>第一轮:假设 0位置最小，从 1~N-1位置上找到最小的，与0位置比较，看谁更小，更小的放在0位置<br>第二轮:假设 1位置最小，从 2~N-1位置上找到最小的，与1位置比较，看谁更小，更小的放在1位置<br>. . .<br>倒数第二轮，假设 N-3位置最小, 从 N-2~N-1位置上找到最小的，与N-3位置比较，看谁更小，更小的放在N-3位置<br>最后一轮，假设 N-2位置最小, 从 N-1位置上找到最小的，与N-2位置比较，看谁更小，更小的放在N-2位置<br>故而，如果用 i 代表每一轮的假设最小位置，则 i 从 0 到 N-2，即 i in range(0,N-1)<br>          用 j 来代表数据每一轮寻找区域的起始值，则 j 从 i+1 到 N-1，即 j in range(i+1,N)  </p></blockquote><p><span id="3.1.1.3"></span>  </p><h3 id="3-1-1-3-插入排序"><a href="#3-1-1-3-插入排序" class="headerlink" title="3.1.1.3 插入排序"></a>3.1.1.3 插入排序</h3><p>工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。和打扑克时整理排序类似。<br>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">InsertSort</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> a[j]&gt;a[j+<span class="number">1</span>]:</span><br><span class="line">                a[j], a[j+<span class="number">1</span>] = a[j+<span class="number">1</span>], a[j]</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><blockquote><p>code 思路  </p><p>不断地将右侧未排序区域的第一个位置，插入到左侧已排序区域的合适位置上<br>只有1个元素时不用排序，所以右侧未排序区域的起始位置是1<br>第一轮:取得 1 位置上的值，与0位置比较，看谁更小，在合适的位置放下<br>第二轮:取得 2 位置上的值，与0~1位置比较，看谁更小，在合适的位置放下<br>。。。<br>倒数第二轮，取得 N-2 位置上的值，与0~N-3位置比较，看谁更小，在合适的位置放下<br>最后一轮，取得 N-1 位置上的值，与0~N-2位置比较，看谁更小，在合适的位置放下<br>故而，如果用 i 代表每一轮获得的起始位置，则 i 从 1 到 N-1，即 i in range(1,N)<br>          用 j 来代表数据已排序的位置，则 j 从0 到 i-1，即 j in range(0,i)<br>          <b>但要注意，我们进行对比时，是在已排序区域从右往左对比更方便，因为离i更近。<br>          所以 j 在取的时候，是先看离 i 位置近的 j， 即反过来， j in range(i-1, -1, -1) </b>  </p></blockquote><p><span id="3.1.1.4"></span>  </p><h3 id="3-1-1-4-希尔排序"><a href="#3-1-1-4-希尔排序" class="headerlink" title="3.1.1.4 希尔排序"></a>3.1.1.4 希尔排序</h3><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ShellSort</span>(<span class="params">a, d=<span class="number">4</span></span>):</span><br><span class="line">    N = <span class="built_in">len</span>(a)</span><br><span class="line">    gap = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> gap &lt; N//d:</span><br><span class="line">        gap = d*gap+<span class="number">1</span></span><br><span class="line">    <span class="comment"># gap 可以理解为分组的数量</span></span><br><span class="line">    <span class="comment"># 这里的 d 其实就是第一次分组后，组内元素的上限</span></span><br><span class="line">    <span class="comment"># 所以这里可以理解为，初始分成gap组，每组内的元素最多d个</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-gap, -<span class="number">1</span>, -gap):</span><br><span class="line">                <span class="keyword">if</span> a[j] &gt; a[j+gap]:</span><br><span class="line">                    a[j+gap], a[j] = a[j], a[j+gap]</span><br><span class="line">        <span class="comment"># 随着循环进行，要将分组数调小</span></span><br><span class="line">        gap = gap//d</span><br><span class="line">    <span class="keyword">return</span> a  </span><br></pre></td></tr></table></figure><p><span id="3.1.1.5"></span>  </p><h3 id="3-1-1-5-归并排序"><a href="#3-1-1-5-归并排序" class="headerlink" title="3.1.1.5 归并排序"></a>3.1.1.5 归并排序</h3><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>可以使用递归的方法来实现，<b>每一次都将数据分为左右两块，每一次都分别让左右两块各自排好序，然后再将两块 Merge 起来，</b>从而 整体有序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">MergeSort</span>(<span class="params">a,L,R</span>):</span><br><span class="line">    <span class="keyword">if</span> L&gt;=R:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    M = L+(R-L)//<span class="number">2</span></span><br><span class="line">    Mergesort(a, L, M)</span><br><span class="line">    MergeSort(a, M+<span class="number">1</span>, R)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Merge stage</span></span><br><span class="line">    p1,p2 = L,M+<span class="number">1</span></span><br><span class="line">    res =[] <span class="comment"># 归并排序申请了辅助空间，所以是 外部排序</span></span><br><span class="line">    <span class="keyword">while</span> p1 &lt;=M <span class="keyword">and</span> p2 &lt;=R:</span><br><span class="line">        <span class="comment"># 分离双指针</span></span><br><span class="line">        <span class="keyword">if</span> a[p1]&lt;=a[p2]:</span><br><span class="line">            res.append(a[p1])</span><br><span class="line">            p1+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(a[p2])</span><br><span class="line">            p2+=<span class="number">1</span></span><br><span class="line">    <span class="comment"># 循环结束后，p1、p2中至少有一个已经越界，下面对没有越界的部分连接</span></span><br><span class="line">    <span class="keyword">while</span> p1&lt;=M:</span><br><span class="line">        res.append(a[p1])</span><br><span class="line">        p1+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> p2&lt;=R:</span><br><span class="line">        res.append(a[p2])</span><br><span class="line">        p2+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res)): <span class="comment"># len(res) = R-L+1</span></span><br><span class="line">        a[L+k] = res[k]</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p><span id="3.1.1.6"></span>   </p><h3 id="3-1-1-6-堆排序"><a href="#3-1-1-6-堆排序" class="headerlink" title="3.1.1.6 堆排序"></a>3.1.1.6 堆排序</h3><p>堆排序需要涉及到一些二叉树的基础知识，但不需要完全了解二叉树，只需要在草稿纸上模拟一下就行。  </p><p>这里提前介绍一下 大/小根堆：<br><strong>大根堆/小根堆，就是属于完全二叉树；</strong><br>大根堆：根节点是整棵树的最大值；并且对于每一棵子树而言，其最大值也都在子树根节点<br>小根堆：根节点是整棵树的最小值；并且对于每一棵子树而言，其最小值也都在子树根节点<br>下图左侧是大根堆的示意图，右侧是小根堆的示意图：  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/3_1_1_6.webp" width="70%">  </p><h4 id="3-1-1-6-1-数组转成大根堆形式"><a href="#3-1-1-6-1-数组转成大根堆形式" class="headerlink" title="3.1.1.6.1 数组转成大根堆形式"></a>3.1.1.6.1 数组转成大根堆形式</h4><p>① HeapInsert 操作  </p><p>HeapInsert 操作，就是对于新加入数组的元素，我们将其移动到大（小）根堆的合适的位置。<br>对于新加入的元素，假设其数组索引是 i, 那么在堆中，它的父亲结点的索引就是 int((i-1)/2)。可以自己在画一下完全二叉树验证这个关系。HeapInsert 操作就是将新元素，不断地与其父亲结点的值比较大小，假设是构造大根堆，那新元素若比父亲结点大，它就往上移动（与父亲结点交换），然后再与新的父亲结点比较大小……直到无法再向上移动，即找到它合适的位置了。示意图如下：  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/3_1_1_7.webp" width="100%">   </p><p>这种方式与之前讲的 插入排序 的思路很像，就是对于下一个数， 将它插入到前面结构的合适的位置上，所以这种构造大（小）根堆的方式也被称为 HeapInsert.  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">HeapInsert</span>(<span class="params">x, index</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    # 该函数只是对index位置的值，进行heap insert 操作;时间复杂度：O(logN)</span></span><br><span class="line"><span class="string">    # 因为最多往上移动的次数 就是 该二叉树的高度：log_2(N)</span></span><br><span class="line"><span class="string">    # 如果要将一个随机数组构造成 大（小）根堆，则需遍历每一个元素，应用此函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 这里直接用int取整即可，(//向下取整，会在-0.5时取到-1,当index=0时使用//无法正确取数，所以用int)，</span></span><br><span class="line">    father = <span class="built_in">int</span>((index-<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> x[index] &gt; x[father]:  <span class="comment">#  此处改为小于即可用于生成小根堆</span></span><br><span class="line">        x[index], x[father] = x[father], x[index]</span><br><span class="line">        <span class="comment"># 与父亲结点交换后，index 和 father 都要更新</span></span><br><span class="line">        index = father</span><br><span class="line">        father = <span class="built_in">int</span>((index-<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>那么，如果我们对数组中的元素，从左往右依次进行 HeapInsert 操作，最后就讲这整个数组的数据转变成了大根堆的形式：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">TurnToMaxHeap</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    问题一：将一个完全二叉树（实际结构是数组）转换成大根堆</span></span><br><span class="line"><span class="string">    时间复杂度：O(N*logN)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="comment"># 从 0 开始，将每一个 a[k] 视为新加入的数，构造大根堆</span></span><br><span class="line">        arr = HeapInsert(arr, i)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><p>② Heapify 操作  </p><p>上面的 HeapInsert 操作是对新来的数字“往上浮”，这里讲的是对原有的数字“往下沉”。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Heapify</span>(<span class="params">a, index, heapsize</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    heapify过程：将一个原本是大根堆的完全二叉树，根结点的值发生变化，要重新变成大根堆的过程.</span></span><br><span class="line"><span class="string">    方法：index位置的元素和它的左右孩子比较，如果小于它的左右孩子那么就往下沉；否则不动</span></span><br><span class="line"><span class="string">    时间复杂度Olog(N)</span></span><br><span class="line"><span class="string">    heapsize小于等于数组最后一个索引(也就是表示0~heapsize区间是个大根堆)；</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    left = <span class="number">2</span> * index +<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= heapsize:</span><br><span class="line">        right = left + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 先比较左右孩子中更大的结点</span></span><br><span class="line">        large = right <span class="keyword">if</span> (right &lt;= heapsize <span class="keyword">and</span> a[right]&gt;a[left]) <span class="keyword">else</span> left</span><br><span class="line">        <span class="comment"># 再比较当前结点与最大孩子的值</span></span><br><span class="line">        large = large <span class="keyword">if</span> (a[large] &gt; a[index]) <span class="keyword">else</span> index</span><br><span class="line">        <span class="comment"># 如果最大的是当前结点，说明不需要下沉了，停止循环</span></span><br><span class="line">        <span class="keyword">if</span> large == index:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 否则就交换位置，并更新索引，准备下一轮循环</span></span><br><span class="line">        a[index], a[large] = a[large], a[index]</span><br><span class="line">        index = large</span><br><span class="line">        left = <span class="number">2</span>*index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a </span><br></pre></td></tr></table></figure><p>因为我们上面code的前提条件是，假设“<b>一个原本是大根堆的完全二叉树，根结点的值发生变化，重新调整根结点的位置，使其恢复为一个大根堆</b>”；所以对于一个本来不是大根堆的完全二叉树，想要利用Heapify的思路转换成大根堆，就<b>从下往上进行变换。</b><br>即从倒数第二层开始，让每一个子树都称为大根堆，不断往上扩展。子树变成大根堆后，它的父节点就可以视为外层大根堆被改变了值的那个根结点，又将该父结点下沉到合适位置，又再网上扩张一层。具体实现code 如下：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BuildMaxHeap</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;时间复杂度O(N)&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    N = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(math.floor(N/<span class="number">2</span>), -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        a = Heapify(a, i, N-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> a </span><br></pre></td></tr></table></figure><p><strong>为何用这种方法构造大根堆的时间复杂度是O(N)? 解释如下</strong>：</p><blockquote><p>对于一棵满的完全二叉树，二叉树一共有 N 个结点。则：<br>倒数第1层有 $\frac{N}{2}$ 个结点，每个结点遍历1次，最多往下沉 0 次，总共就是 $\frac{N}{2}$ 次操作； </p><p>倒数第2层有 $\frac{N}{4}$ 个结点，每个结点遍历1次，每个结点最多往下沉 1 次，总共就是 $\frac{2N}{4}$ 次操作； </p><p>倒数第3层有 $\frac{N}{8}$ 个结点，每个结点遍历1次，每个结点最多往下沉 2 次，总共就是 $\frac{3N}{8}$ 次操作；<br>……<br>所以时间复杂度为 $T(N) = \frac{N}{2} + \frac{2N}{4} + \frac{3N}{8} + \cdots $<br>故而  $T(N) = 2T(N) -T(N) = N + \frac{N}{2} + \frac{N}{4} + \frac{N}{8} + \cdots - \sigma $ 这是一个等比数列，结果是 $2N$，所以时间复杂度就是 $O(N)$。  </p></blockquote><h4 id="3-1-1-6-2-堆排序部分"><a href="#3-1-1-6-2-堆排序部分" class="headerlink" title="3.1.1.6.2 堆排序部分"></a>3.1.1.6.2 堆排序部分</h4><p>假设是按照从小到大排序，那么每一次构造一个大根堆后，未排序区域的最大值就到了根结点，那么只要将该数与未排序区域末尾数交换，则该区域的最大数就到了该区域的末尾。同时未排序区域缩小一格，然后恢复未排序区域的大根堆结构，重复操作。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">HeapSort</span>(<span class="params">a</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="comment"># 先构建大根堆</span></span><br><span class="line">    a = buildMaxHeap(a)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(N-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 每一次都将顶点和最后最后一个数进行交换，则最大数就被移动到数组末尾</span></span><br><span class="line">        a[<span class="number">0</span>], a[k] = a[k], a[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 相当于 a[0] 的位置发生了变化，正好用heapify重新调整为大根堆</span></span><br><span class="line">        <span class="comment"># 注意刚刚的最大值已经是有序区域中了，所以heapsize也要每次缩小一次</span></span><br><span class="line">        a = Heapify(a,<span class="number">0</span>,k-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    可以看到，不管最开始采用哪种方法构造大根堆，O(N)或者O(N*logN)都无所谓</span></span><br><span class="line"><span class="string">    后面不断交换位置的操作才是影响时间复杂度的大头，这部分是 O(N*logN)</span></span><br><span class="line"><span class="string">    所以堆排序的总体时间复杂度是 O(N*logN)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><span id="3.1.1.7"></span>   </p><h3 id="3-1-1-7-快速排序"><a href="#3-1-1-7-快速排序" class="headerlink" title="3.1.1.7 快速排序"></a>3.1.1.7 快速排序</h3><p>快速排序采用的思想也是分治法，先将数组大致分为有序的几块区域，再对各个区域内分为几个有序的区域，直到区域已经不可再细分，这样整个数组也就有序了。下面只给出快速排序的code，至于其推导过程，见下一章【快速排序深入讨论】。  </p><p>快速排序虽然只用了几个额外的变量，<b><font color="red">但是其空间复杂度是O(logN)</font></b>&lt;/font&gt;!<br>这是因为快速排序使用递归操作，递归操作会调用系统栈，这个系统栈的深度是O(logN)。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">QuickSort</span>(<span class="params">a, L, R</span>):</span><br><span class="line">    <span class="keyword">if</span> L &gt;= R:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="comment"># partition stage:</span></span><br><span class="line">    <span class="comment"># 随机抽取一个基础值</span></span><br><span class="line">    key = random.randint(L, R)</span><br><span class="line">    a[key], a[R] = a[R], a[key]</span><br><span class="line">    <span class="comment"># 将基础值放在最右方便下面写code</span></span><br><span class="line">    key = R</span><br><span class="line">    p1, p2 = L-<span class="number">1</span>, R</span><br><span class="line">    <span class="comment"># 这一段partition已经是经过荷兰国旗问题优化后的partition了，原始的快速排序不是这么写</span></span><br><span class="line">    i = p1+<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; p2:</span><br><span class="line">        <span class="keyword">if</span> a[i] &lt; a[key]:</span><br><span class="line">            <span class="comment"># 如果 i 位置的值更小，i与小于区域的下一位的数交换，小于区域扩张1位</span></span><br><span class="line">            a[i], a[p1+<span class="number">1</span>] = a[p1+<span class="number">1</span>], a[i]</span><br><span class="line">            p1 += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> a[i] == a[key]:</span><br><span class="line">            <span class="comment"># 如果相等，i直接往后过，两个区域都不变化</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果i位置的值更大，i与大于区域的左侧数交换，大于区域扩张(p2减少1)</span></span><br><span class="line">            a[i], a[p2-<span class="number">1</span>] = a[p2-<span class="number">1</span>], a[i]</span><br><span class="line">            p2 -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 同时i不变，因为i位置的数刚从大于区域的左侧被交换过去，还没判断呢</span></span><br><span class="line">    <span class="comment"># 循环结束后 i==p2，i位置的值一定大于等于key位置</span></span><br><span class="line">    <span class="comment"># 将基础值与i位置进行交换</span></span><br><span class="line">    a[i], a[key] = a[key], a[i]</span><br><span class="line">    <span class="comment"># recursion stage</span></span><br><span class="line">    QuickSort(a, L, p1)</span><br><span class="line">    QuickSort(a, p2+<span class="number">1</span>, R)</span><br><span class="line">    <span class="keyword">return</span> a </span><br></pre></td></tr></table></figure><p><span id="3.1.1.8"></span>   </p><h3 id="3-1-1-8-计数排序"><a href="#3-1-1-8-计数排序" class="headerlink" title="3.1.1.8 计数排序"></a>3.1.1.8 计数排序</h3><p>要求元素一定是<strong>整数！整数！</strong>且元素值的<strong>范围最好不要太大</strong>，一般来说几万以内应该都还算比较快。<br><b>计数排序不是比较排序，排序的速度快于任何比较排序算法，只不过有上一行提到的先决条件</b>。<br>基本思路如下：<br>① <strong>找出待排序的数组中最大和最小的元素</strong>，因为计数的数组Count的长度取决于待排序数组中数据的范围，<br>② <strong>创建计数数组Count</strong>，长度等于待排序数组的最大值与最小值的差加上1,元素默认值为0.<br>③ <strong>遍历原数组中的元素，以原数组中的元素值作为Count数组的索引</strong>，以原数组中的元素出现次数作为Count数组的元素值。<br>    比如原始数组中有10个66，则Count[10]=66<br>④ <strong>按照count索引从小到大（也就是原始数组元素值从小到大）进行遍历</strong>，排布好新的数组</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">CountSort_1</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;最基础的情况，元素都为非负整数&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 1.获得最大值</span></span><br><span class="line">    <span class="comment"># 如果不想用自带的max函数，那其实也可以遍历一遍数组，时间复杂度也是O(N)</span></span><br><span class="line">    <span class="comment"># 因为计数排序本来就是O(N+K)，时间复杂度是忽略系数的，O(N) + O(N) 还是 O(N)</span></span><br><span class="line">    max_v = <span class="built_in">max</span>(a)</span><br><span class="line">    <span class="comment"># 2.创建辅助数组</span></span><br><span class="line">    count_list = [<span class="number">0</span>]*(max_v+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 3.统计原数组的元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">        count_list[a[k]] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 4.对原始数组的元素按顺序排布</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(count_list)):</span><br><span class="line">        <span class="keyword">while</span> count_list[k] &gt; <span class="number">0</span>:</span><br><span class="line">            a[i] = k</span><br><span class="line">            count_list[k] -= <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 这一段 while 循环体虽然可以改写成如下形式：</span></span><br><span class="line">        <span class="comment"># if count_list[k] &gt; 0:</span></span><br><span class="line">        <span class="comment">#     a[i:i+count_list[k]] = [k]*count_list[k]</span></span><br><span class="line">        <span class="comment">#     i += count_list[k]</span></span><br><span class="line">        <span class="comment"># 但是 python在实际操作中会 在等号右边创建一个临时的数组，然后赋值给左边</span></span><br><span class="line">        <span class="comment"># 这就相当于使用了 额外空间了，所以不建议这么写</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CountSort_2</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;若可能有负数出现，只需要引入一个bias即可&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 1.获得最大值，最小值</span></span><br><span class="line">    min_v, max_v = <span class="built_in">min</span>(a), <span class="built_in">max</span>(a)</span><br><span class="line">    <span class="comment"># bias = 0-min_v if min_v &lt; 0 else 0</span></span><br><span class="line">    bias = - <span class="built_in">min</span>(<span class="number">0</span>, min_v)</span><br><span class="line">    <span class="comment"># 2.创建辅助数组</span></span><br><span class="line">    count_list = [<span class="number">0</span>]*(max_v+<span class="number">1</span>+bias)</span><br><span class="line">    <span class="comment"># 3.统计原数组的元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">        count_list[a[k]+bias] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 4.对原始数组的元素按顺序排布</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(count_list)):</span><br><span class="line">        <span class="keyword">while</span> count_list[k] &gt; <span class="number">0</span>:</span><br><span class="line">            a[i] = k - bias</span><br><span class="line">            count_list[k] -= <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a </span><br><span class="line">    <span class="comment"># 可见这个写法不管有没有负数, 其实都能跑通</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>从代码中可以看出，计数排序的时间复杂度是 O(n+k),  空间复杂度是O(k)<br>其中n是数组规模， k是数组值域范围 max_v - min_v + 1</p><p><span id="3.1.1.9"></span>   </p><h3 id="3-1-1-9-基数排序"><a href="#3-1-1-9-基数排序" class="headerlink" title="3.1.1.9 基数排序"></a>3.1.1.9 基数排序</h3><p>所谓的基数，就是指的按照数字的哪一位来排序。<br>比如按照个位来排序，基数就是 10^0;<br>按照十位数进行排序，基数就是 10^1;<br>按照百位数进行排序：基数就是 10^2;<br>基数排序也不用进行比较，因为每一位数字都是 0-9组成的，天然有序，所以只要按照每一位的数字，将数字分到对应的分组去，那么对于当前位数来说，各个组之间就按照0-9排序了。<br>对于每一位都来一次，就能够实现整体有序。  </p><p>基数排序能够实现有序的关键点在于，当按照分组分号之后，从分组中取出来排布时，<b>各个分组的元素要做到先入先出</b>。 因为同一个分组内的元素，当前考察的基数那一位，肯定是相同的，但是其进入分组的顺序，是由上一轮的考察基数位的大小顺序决定的。  </p><p>举个例子：比如 58和51 被分到了一个分组，可以肯定，当前考察的是十位，因为它们的十位都是数字5，这才有可能被分到一个分组。那么上一轮考察的就是个位，个位分别是 1 和 8，那么可以肯定，1这个分组的数字是排在8这个分组的数字之前的。  </p><p>所以在考察十位上的数字进行分组时，一定是 51先遍历到，被分到5号组，然后才是58被遍历到，也分到5号组。所以组内的顺序是: [ 51, 58 ]。那么从分组内取出进行还原时，就要保证先取出 51， 再取出 58。所以各个分组，其实可以从逻辑上视为一个队列。当然不必真的使用队列，只要使用 list 时注意先入先出的顺序就好。  </p><p><b>基数排序通常也是只能处理<font color="red">非负 整数</font>，且要求数目不要过大。</b>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">RadixSort</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;最基础的情况，元素都为非负整数&#x27;&#x27;&#x27;</span></span><br><span class="line">    max_v = <span class="built_in">max</span>(a)</span><br><span class="line">    <span class="comment"># d 这里在统计最高的位数</span></span><br><span class="line">    <span class="comment"># d=0</span></span><br><span class="line">    <span class="comment"># while max_value &gt;0:</span></span><br><span class="line">    <span class="comment">#     d+=1</span></span><br><span class="line">    <span class="comment">#     max_value//=10</span></span><br><span class="line">    d = <span class="built_in">len</span>(<span class="built_in">str</span>(max_v))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">        radix = <span class="number">10</span> ** i <span class="comment"># radix 代表本次循环基于哪一个位</span></span><br><span class="line">        <span class="comment"># 每一轮都是重新初始化 Groups</span></span><br><span class="line">        Groups = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="comment"># 初始化从0到9，共10个分组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> a:</span><br><span class="line">            digit = num // radix % <span class="number">10</span></span><br><span class="line">            <span class="comment"># 按照当前位的数字，将原始数据分别装入不同的group中</span></span><br><span class="line">            Groups[digit].append(num)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 该 print 函数能打印各个阶段 数字装入分组后的状况，</span></span><br><span class="line">        <span class="comment"># 可以取消注释后打印中间结果，帮助理解</span></span><br><span class="line">        <span class="comment"># print(i, Groups)        </span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> Groups:</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> group:</span><br><span class="line">                a[j] = num </span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p><b>稍加改动也能处理出现<font color="red">负整数</font>的情况</b><br>对于负数部分，我们需要在设置一个长度为 10 的分组，用来装 -9 — 0 。<br>这里需要注意的点， </p><ul><li><p>① 10 和 -10 与 10% 进行求模运算后，结果都是 0；但是这两个数明显不能都放入 0 号组，<br>   10 是可以放入 0 号分组的，但是 -10 却是一个负数，它的实际位置应该比0还小。</p><pre><code>为了方便讨论，我们这里称呼 -10 % 10 为 -0；在负数部分的分组中，排在最大的位置。 即负数的10个分组对应的数字为：[-9], [-8], ..., [-1], [-0]</code></pre></li><li><p>② 在求每一位上的数字时，我们之前使用的是 整除号：// 。但是整除号是向下进位，对负数使用整除号时，会往远离 0 的方向进位。 比如 -18 // 10 = -2; 但是我们希望是得到 - 1，这样能照搬非负整数部分的处理，所以就是希望向 0 靠拢。可以使用 int函数。int(-18 / 10 ) = -1.    </p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">RadixSort_2</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;要处理的数据中可能出现 负整数&#x27;&#x27;&#x27;</span></span><br><span class="line">    max_v, min_v = <span class="built_in">max</span>(a), <span class="built_in">min</span>(a)</span><br><span class="line">    <span class="comment"># d 这里在统计最高的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果存在负数，str之后会有&#x27;-&#x27;，即比数字本身多了1位，所以需要判断</span></span><br><span class="line">    L_1 = <span class="built_in">len</span>(<span class="built_in">str</span>(max_v)) <span class="keyword">if</span> max_v &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">len</span>(<span class="built_in">str</span>(max_v))-<span class="number">1</span></span><br><span class="line">    L_2 = <span class="built_in">len</span>(<span class="built_in">str</span>(min_v)) <span class="keyword">if</span> min_v &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">len</span>(<span class="built_in">str</span>(min_v))-<span class="number">1</span></span><br><span class="line">    d = <span class="built_in">max</span>(L_1, L_2)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">        radix = <span class="number">10</span> ** i <span class="comment"># radix 代表本次循环基于哪一个位</span></span><br><span class="line">        Groups = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="comment"># 初始化从 0 到9，共10个分组</span></span><br><span class="line">        Groups_neg = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="comment"># 初始化从-9 到-0，共10个分组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> a:</span><br><span class="line">            <span class="comment"># digit = num // radix % 10</span></span><br><span class="line">            digit = <span class="built_in">int</span>(num / radix) % <span class="number">10</span></span><br><span class="line">            <span class="comment"># 注意: -10 和 10 与 10 求模运算后都得 0</span></span><br><span class="line">            <span class="comment"># 但是二者的大小明显不一样</span></span><br><span class="line">            <span class="comment"># 为了便于理解，我们可以假设 10 % 10 = +0； -10 % 10 = -0</span></span><br><span class="line">            <span class="comment"># 按照当前位的数字的正负属性，将原始数据分别装入不同的group中</span></span><br><span class="line">            <span class="keyword">if</span> num &gt;= <span class="number">0</span>:</span><br><span class="line">                Groups[digit].append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 这里需要注意 -9 % 10 = 1;...; -1 % 10 = 9; -10 % 10 = -0;</span></span><br><span class="line">                Groups_neg[digit-<span class="number">1</span>].append(num)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 该 print 函数能打印各个阶段 数字装入分组后的状况，</span></span><br><span class="line">        <span class="comment"># 可以取消注释后打印中间结果，帮助理解</span></span><br><span class="line">        <span class="comment"># print(i, Groups_neg, &#x27;---&#x27;, Groups)</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 先取出负数部分</span></span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> Groups_neg:</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> group:</span><br><span class="line">                a[j] = num </span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 再取出正数部分</span></span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> Groups:</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> group:</span><br><span class="line">                a[j] = num </span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p>从代码中可以看出，基数排序的时间复杂度是 O(n*k),  空间复杂度是O(n)<br>其中n是数组规模， k是数组中位数最长的一个数的宽度   </p><p><span id="3.1.1.10"></span>   </p><h3 id="3-1-1-10-桶排序"><a href="#3-1-1-10-桶排序" class="headerlink" title="3.1.1.10 桶排序"></a>3.1.1.10 桶排序</h3><p>将数据分到若干个桶（分组）中，每个桶的元素再进行单独排序。<br>通常是按照数值大小进行分组，比如若一个数组最大数为 200，最小数为1，就可以以 20的区间进行分组，分10个桶。但是有一些题目可能也会根据另外一些属性进行分组，总之要看具体情况。<br>对每个桶内的数据进行排序操作，也是看数据的具体情况，可以使用不同的排序方法。<br>最后将各个桶内的元素组合到一起，完成最终排序。 </p><p><span id="3.1.2"></span>   </p><h2 id="3-1-2-二分查找"><a href="#3-1-2-二分查找" class="headerlink" title="3.1.2 二分查找"></a>3.1.2 二分查找</h2><p>二分查找的时间复杂度是O(logN),<a href="https://www.suibibk.com/topic/678695904085016576/">参考链接 </a> </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BinarySearch</span> (arr, L, R, x): </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 基本判断</span></span><br><span class="line">    <span class="keyword">if</span> R &gt;= L: </span><br><span class="line">  </span><br><span class="line">        mid = L + <span class="built_in">int</span>((R - L)/<span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 元素整好的中间位置</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] == x: </span><br><span class="line">            <span class="keyword">return</span> mid </span><br><span class="line">          </span><br><span class="line">        <span class="comment"># 元素小于中间位置的元素，只需要再比较左边的元素</span></span><br><span class="line">        <span class="keyword">elif</span> x &lt; arr[mid]: </span><br><span class="line">            <span class="keyword">return</span> BinarySearch (arr, L, mid-<span class="number">1</span>, x) </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 元素大于中间位置的元素，只需要再比较右边的元素</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> BinarySearch (arr, mid+<span class="number">1</span>, R, x) </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="comment"># 不存在</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2-3 数组双指针</title>
      <link href="/Data-Structure/DS_23_array_double_pointer_exercises.html"/>
      <url>/Data-Structure/DS_23_array_double_pointer_exercises.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1"> <h1 id="2-3-数组双指针"><a href="#2-3-数组双指针" class="headerlink" title="2-3 数组双指针"></a>2-3 数组双指针</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p><b>版权声明：以下题目均来自 <a href="https://leetcode.cn">LeetCode</a>， 仅仅提供跳转到力扣官网的链接，不在本页面出现题目内容，本文章内容禁止商业用途。</b>  </p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>2.3.1</td><td><a href="#2.3.1">对撞指针</a></td></tr><tr><td>2.3.2</td><td><a href="#2.3.2">快慢指针</a></td></tr></tbody></table></div><p>指针的名字来源于链表，代表的是指向结点地址的位置变量。可以迁移到数组这边来，代表存储数组索引的变量。<br>而双指针的意思就是用两个变量来维护不同的索引，从而实现特定的功能。  </p><p><span id="2.3.1"></span>  </p><h2 id="2-3-1-对撞指针"><a href="#2-3-1-对撞指针" class="headerlink" title="2.3.1 对撞指针"></a>2.3.1 对撞指针</h2><p>所谓对撞指针，就是指的初始状态的两个指针一个在左，一个在右；终止条件为左指针等于右指针。  </p><p><span id="2.3.1"></span>  </p><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">LeetCode 167.两数之和II-输入有序数组</a></td><td><a href="#2.3.1.1">题解2.3.1.1</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/reverse-string/">LeetCode 344.反转字符串</a></td><td><a href="#2.3.1.2">题解2.3.1.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/reverse-vowels-of-a-string/">LeetCode 345.反转字符串中的元音字母</a></td><td><a href="#2.3.1.3">题解2.3.1.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/valid-palindrome/">LeetCode 125.验证回文串</a></td><td><a href="#2.3.1.4">题解2.3.1.4</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21.调整数组顺序使奇数位于偶数前面</a></td><td><a href="#2.3.1.5">题解2.3.1.5</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/boats-to-save-people/">LeetCode 881.救生艇</a></td><td><a href="#2.3.1.6">题解2.3.1.6</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/container-with-most-water/">LeetCode 11.盛最多水的容器</a></td><td><a href="#2.3.1.7">题解2.3.1.7</a></td></tr><tr><td>⑧</td><td><a href="https://leetcode.cn/problems/valid-triangle-number/">LeetCode 611.有效三角形的个数</a></td><td><a href="#2.3.1.8">题解2.3.1.8</a></td></tr><tr><td>⑨</td><td><a href="https://leetcode.cn/problems/3sum/">LeetCode 15.三数之和</a></td><td><a href="#2.3.1.9">题解2.3.1.9</a></td></tr><tr><td>⑩</td><td><a href="https://leetcode.cn/problems/3sum-closest/description/">LeetCode 16.最接近的三数之和</a></td><td><a href="#2.3.1.10">题解2.3.1.10</a></td></tr><tr><td>⑪</td><td><a href="https://leetcode.cn/problems/4sum/">LeetCode 18.四数之和</a></td><td><a href="#2.3.1.11">题解2.3.1.11</a></td></tr><tr><td>⑫</td><td><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">LeetCode 977.有序数组的平方</a></td><td><a href="#2.3.1.12">题解2.3.1.12</a></td></tr><tr><td>⑬</td><td><a href="https://leetcode.cn/problems/sort-colors/">LeetCode 75.颜色分类</a></td><td><a href="#2.3.1.13">题解2.3.1.13</a></td></tr><tr><td>⑭</td><td><a href="https://leetcode.cn/problems/trapping-rain-water/">LeetCode 42.接雨水</a></td><td><a href="#2.3.1.14">题解2.3.1.14</a></td></tr><tr><td>⑮</td><td><a href="https://leetcode.cn/problems/longest-mountain-in-array/">LeetCode 845.数组中的最长山脉</a></td><td><a href="#2.3.1.15">题解2.3.1.15</a></td></tr><tr><td>⑯</td><td><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">LeetCode 978.最长湍流子数组</a></td><td><a href="#2.3.1.16">题解2.3.1.16</a></td></tr></tbody></table></div><p><span id="2.3.1.1"></span>  </p><h3 id="2-3-1-1-两数之和II-输入有序数组"><a href="#2-3-1-1-两数之和II-输入有序数组" class="headerlink" title="2.3.1.1 两数之和II -输入有序数组"></a>2.3.1.1 两数之和II -输入有序数组</h3><p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">LeetCode 167.两数之和II-输入有序数组</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：数组已经有序，那可以从左右两侧向中间靠拢，逼近目标值。</font><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        N = <span class="built_in">len</span>(numbers)</span><br><span class="line">        L, R  =<span class="number">0</span>, N-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            <span class="keyword">while</span> L  &lt;R <span class="keyword">and</span>  numbers[L] +  numbers[R] &lt;target:</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> numbers[L] +  numbers[R] &gt; target:</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> L&lt; R <span class="keyword">and</span> numbers[L] +  numbers[R] == target:</span><br><span class="line">                <span class="keyword">return</span> [L+<span class="number">1</span>, R+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p><span id="2.3.1.2"></span></p><h3 id="2-3-1-2-反转字符串"><a href="#2-3-1-2-反转字符串" class="headerlink" title="2.3.1.2 反转字符串"></a>2.3.1.2 反转字符串</h3><p><a href="https://leetcode.cn/problems/reverse-string/">LeetCode 344.反转字符串</a> |  | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：这个题是对撞双指针的代表题目，也可以用它来进行数组逆序。</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            s[L], s[R] = s[R], s[L]</span><br><span class="line">            L += <span class="number">1</span></span><br><span class="line">            R -=<span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="2.3.1.3"></span>  </p><h3 id="2-3-1-3-反转字符串中的元音字母"><a href="#2-3-1-3-反转字符串中的元音字母" class="headerlink" title="2.3.1.3 反转字符串中的元音字母"></a>2.3.1.3 反转字符串中的元音字母</h3><p><a href="https://leetcode.cn/problems/reverse-vowels-of-a-string/">LeetCode 345.反转字符串中的元音字母</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路 1：先用哈希表记住元音字母原始的索引，然后按照索引逆序改变其对应位置的值。</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;思路1.使用哈希表&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        ll = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="comment"># from collections import defaultdict</span></span><br><span class="line">        <span class="comment"># dict_1 = defaultdict(str)</span></span><br><span class="line">        <span class="comment"># N = len(s)</span></span><br><span class="line">        <span class="comment"># for i in range(N):</span></span><br><span class="line">        <span class="comment">#     if ll[i] in &#x27;aeiouAEIOU&#x27;:</span></span><br><span class="line">        <span class="comment">#         dict_1[i] = ll[i]</span></span><br><span class="line">        <span class="comment"># 注释中的内容一行代码就可以写完</span></span><br><span class="line">        dict_1 = <span class="built_in">dict</span>((i,ch) <span class="keyword">for</span> (i,ch) <span class="keyword">in</span> <span class="built_in">enumerate</span>(ll) <span class="keyword">if</span> ch <span class="keyword">in</span> <span class="string">&#x27;aeiouAEIOU&#x27;</span>)</span><br><span class="line">        list_key = <span class="built_in">sorted</span>(<span class="built_in">list</span>(dict_1.keys()))</span><br><span class="line"></span><br><span class="line">        length = <span class="built_in">len</span>(list_key)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            ll[list_key[i]] =  dict_1[list_key[length-<span class="number">1</span>-i]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ll)</span><br></pre></td></tr></table></figure><font color="#3399FF">思路2：使用双指针，可以借鉴 [反转字符串](#2.3.1.2) 那道题的思路；只不过并不是直接反转，而是先要判断条件。由于我们反转的是元音字符，所以如果不是元音字符，双指针就不用停下来，而是一直向中间靠拢。一旦在相遇之前停下来，说明左右两个指针都遇到了元音字符，我们就将其交换位置（反转）即可；</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;思路2. 使用双指针&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(s)</span><br><span class="line">        ll = <span class="built_in">list</span>(s)</span><br><span class="line">        L, R = <span class="number">0</span>, N-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> ll[L] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;aeiouAEIOU&#x27;</span>:</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> ll[R] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;aeiouAEIOU&#x27;</span>:</span><br><span class="line">                R -=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> L&lt;R:</span><br><span class="line">                ll[L], ll[R] = ll[R], ll[L]</span><br><span class="line">                L +=<span class="number">1</span></span><br><span class="line">                R -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ll)</span><br></pre></td></tr></table></figure><p><span id="2.3.1.4"></span>  </p><h3 id="2-3-1-4-验证回文串"><a href="#2-3-1-4-验证回文串" class="headerlink" title="2.3.1.4 验证回文串"></a>2.3.1.4 验证回文串</h3><p><a href="https://leetcode.cn/problems/valid-palindrome/">LeetCode 125.验证回文串</a> | | <a href="#2.3.1">返回目录2.3.1</a>  </p><font color="#3399FF">思路：回文字符串就是以中心为对称的关系，而且题目中说明了只考虑小写字母和数字两种字符的情况，其他的就该跳过。  也是考虑使用对撞指针.</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 先将所有大写转成小写</span></span><br><span class="line">        s = s.lower()</span><br><span class="line">        <span class="comment"># 初始化双指针</span></span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> <span class="keyword">not</span> s[L].isalnum():</span><br><span class="line">                <span class="comment"># 对于非字母数字字符, 直接不考虑, 直接移动指针</span></span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> <span class="keyword">not</span> s[R].isalnum():</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> L &lt; R:</span><br><span class="line">                <span class="keyword">if</span> s[L] == s[R]:</span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果发现不相等的情况，说明左右不对称</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>   </span><br></pre></td></tr></table></figure><p><span id="2.3.1.5"></span>  </p><h3 id="2-3-1-5-调整数组顺序使奇数位于偶数前面"><a href="#2-3-1-5-调整数组顺序使奇数位于偶数前面" class="headerlink" title="2.3.1.5 调整数组顺序使奇数位于偶数前面"></a>2.3.1.5 调整数组顺序使奇数位于偶数前面</h3><p><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21.调整数组顺序使奇数位于偶数前面</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：该题和上面【 [反转字符串中的元音字母](#2.3.1.3) 】思路是一脉相承的；这里反转的不是元音字符，而是奇数or偶数，只需将判断条件做修改就行；</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exchange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        </span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[L] % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 题目要求奇数在前，所以如果是奇数，左指针就不用反转，直接指针把L指针右移</span></span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[R] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 题目要求偶数在后，所以如果是偶数，右指针就不用反转，直接指针把R指针左移</span></span><br><span class="line">                R -=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 前面两个循环执行完毕后，说明L遇到的是偶数，R遇到的是奇数，</span></span><br><span class="line">            <span class="comment"># 此时交换一下位置即可</span></span><br><span class="line">            <span class="keyword">if</span> L &lt; R:</span><br><span class="line">                nums[L], nums[R] = nums[R], nums[L]</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><span id="2.3.1.6"></span>  </p><h3 id="2-3-1-6-救生艇"><a href="#2-3-1-6-救生艇" class="headerlink" title="2.3.1.6 救生艇"></a>2.3.1.6 救生艇</h3><p><a href="https://leetcode.cn/problems/boats-to-save-people/">LeetCode 881.救生艇</a> || <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：该题说一艘船最多载两人，就容易联想到双指针。一个指针代表一个人，两个指针指向元素的和就是两个人的重量之和。只不过，这里有一个和之前的题目不同的点，那就是我们需要对数组先进行排序。为什么呢？因为如果两个人挤一条船，那么按照生活常识，我们肯定是希望尝试一个最轻的和一个最重的进行搭配，尽可能的利用船的承载能力。所以如果用双指针代表两个人，就需要一个是来自于轻的一组，一个是来自于重的一组，所以按照重量先排序，左侧的就是轻的，右侧的就是重的，就可以利用对撞双指针了。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numRescueBoats</span>(<span class="params">self, people: <span class="type">List</span>[<span class="built_in">int</span>], limit: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        people.sort()</span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(people)-<span class="number">1</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> L &lt;= R: </span><br><span class="line">        <span class="comment"># 注意, 这里的循环控制条件可以L==R, 因为 L==R时表示还剩一个人,这个人单独一艘船 </span></span><br><span class="line">            <span class="keyword">if</span> people[L] + people[R] &lt;= limit:</span><br><span class="line">                <span class="comment"># 如果较轻和较重的能够被一艘船容纳, 就刚好组成一对</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果较轻和较重的加起来比limit还大</span></span><br><span class="line">                <span class="comment"># 就将较重的用一艘船去容纳</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.3.1.7"></span>  </p><h3 id="2-3-1-7-盛水最多的容器"><a href="#2-3-1-7-盛水最多的容器" class="headerlink" title="2.3.1.7 盛水最多的容器"></a>2.3.1.7 盛水最多的容器</h3><p><a href="https://leetcode.cn/problems/container-with-most-water/">LeetCode 11.盛最多水的容器</a> | | <a href="#2.3.1">返回目录2.3.1</a>  </p><font color="#3399FF">思路：双指针代表的是 可以作为容器边界的所有位置的范围。在一开始，双指针指向数组的左右边界，表示 数组中所有的位置都可以作为容器的边界，每次将 <b>对应的数字较小的那个指针</b> 往 另一个指针 的方向移动一个位置，就表示我们认为 这个指针不可能再作为容器的边界了, 然后再比较当前装水容量和之前的装水容量, 看哪个更大即可。  > <b>因为水桶能装多少水，是最矮的那个边界决定的。> 意思是，如果不移动最矮的边界，而移动另一侧较高的边界，无论怎么移动，装水的容量都不可能变多。> 所以我们只好移动最矮的那个边界，看看移动它之后，是否能使得装水量变多。</b></font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">        water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">        <span class="comment"># 两个边界碰到一起之前, 能够装水</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> height[L] &lt;= height[R]:</span><br><span class="line">                water = <span class="built_in">max</span>(water, height[L]*(R-L))</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> height[L] &gt; height[R]:</span><br><span class="line">                water = <span class="built_in">max</span>(water, height[R]*(R-L))</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> water </span><br></pre></td></tr></table></figure><p><span id="2.3.1.8"></span>  </p><h3 id="2-3-1-8-有效三角形的个数"><a href="#2-3-1-8-有效三角形的个数" class="headerlink" title="2.3.1.8 有效三角形的个数"></a>2.3.1.8 有效三角形的个数</h3><p><a href="https://leetcode.cn/problems/valid-triangle-number/">LeetCode 611.有效三角形的个数</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：假设三条边分别为a,b,c;则满足三角形的条件为任意两边之和都大于第三边；如果知道a,b,c的大小关系，比如 a<=b<=c, <b>那么两小边之和大于长边就一定能形成三角形</=b<=c,></font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triangleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N =<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> N &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先从大到小排序</span></span><br><span class="line">        nums.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-<span class="number">2</span>):</span><br><span class="line">            <span class="comment"># 当前 i 位置的数左为最长边 lng； 另外两个小边就在[i+1, N-1]区间找</span></span><br><span class="line">            L, R = i+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;R:</span><br><span class="line">                <span class="comment"># 目标是期望 小边之和 &gt; 长边，即 a+b &gt; c</span></span><br><span class="line">                <span class="comment"># lng, mid, sht = nums[i], nums[L], nums[R]</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果 mid + sht 不够大，说明sht应该增大，即R侧应该往左移一次，找一个更大的sht</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt;= nums[L] + nums[R]:</span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># lng &lt; mid + sht</span></span><br><span class="line">                    <span class="comment"># 如果此时能满足条件, R位置充当最短边sht，则R左侧的更大的数更能成为sht</span></span><br><span class="line">                    <span class="comment"># 即从 L+1 ~ R位置的所有数都可以成为最短边 sht(使得mid + sht更大)</span></span><br><span class="line">                    <span class="comment"># 与mid (L位置的值)一起构造一对小边; sht可取的个数为  =&gt; R - L</span></span><br><span class="line">                    res += R - L</span><br><span class="line">                    <span class="comment"># 计数完之后，再将 L 右移一位，即 mid 减小一点，</span></span><br><span class="line">                    <span class="comment"># 这样会使得 mid + sht变小</span></span><br><span class="line">                    <span class="comment"># 看变小后的和是否还能大于lng</span></span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 使用双指针的核心就在这里, L和R靠拢时, mid+sht 的值是在缩小的</span></span><br><span class="line">                    <span class="comment"># 但只要大于lng, L和R遍历的范围就能够满足条件</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.3.1.9"></span>  </p><h3 id="2-3-1-9-三数之和"><a href="#2-3-1-9-三数之和" class="headerlink" title="2.3.1.9 三数之和"></a>2.3.1.9 三数之和</h3><p><a href="https://leetcode.cn/problems/3sum/">LeetCode 15.三数之和</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：此题和三角形那道题一样，只不过条件变为  nums[i] + nums[j] + nums[k] == 0 难点在于不能出现重复的三元组。如果我们先排序的话，然后遍历数组时，每次都将遍历的值，作为三元组开头的值，<b>如果一旦发现这个开头值和上一次的开头值一样**，那就说明重复，应该跳过。</b></font>  <ul><li><p>第一种代码写法 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-<span class="number">2</span>):</span><br><span class="line">            <span class="comment"># 如果三元组的开头值和上一次的开头值重复, 可能会出现重复三元组, 直接不考虑</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 每一次都在剩余可选范围内，维护左右两个指针</span></span><br><span class="line">            L, R = i+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;R:</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[L] + nums[R] &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 如果三数之和大于0, 就减小最大的数</span></span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[L] + nums[R] &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 如果三数之和小于0, 就增大中间数</span></span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 此时遇到满足条件的三个数</span></span><br><span class="line">                    <span class="keyword">if</span> res <span class="keyword">and</span> nums[i] == res[-<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">and</span> nums[L] == res[-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                        <span class="comment"># 若三个数中的前两个与之前的相同, 说明重复, 不添加进结果</span></span><br><span class="line">                        <span class="comment"># (因nums已经被排序过, 故重复的 L 一定会紧邻, 故可与rse[-1]进行比较)</span></span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res.append([nums[i], nums[L], nums[R]])</span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><p>第二种代码写法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 先从小到大排序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n-<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            L, R = i+<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                <span class="string">&#x27;&#x27;&#x27;这第二种写法就是在遍历L和R时, 直接判断L或R是否是紧邻重复出现</span></span><br><span class="line"><span class="string">                这第二种写法要考虑的条件比较细, 容易出现疏漏&#x27;&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">while</span> L&lt;R <span class="keyword">and</span> L&gt;i+<span class="number">1</span> <span class="keyword">and</span> nums[L-<span class="number">1</span>] == nums[L]:</span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> L&lt;R <span class="keyword">and</span> R &lt; n-<span class="number">1</span> <span class="keyword">and</span> nums[R+<span class="number">1</span>] == nums[R]:</span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> nums[L] + nums[R] + nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                    L +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> L&lt;R <span class="keyword">and</span> nums[L] + nums[R] + nums[i] == <span class="number">0</span>:</span><br><span class="line">                    res.append((nums[L], nums[R], nums[i]))</span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        如果不想这么麻烦的写，也可以在遍历的时候不考虑去重问题。</span></span><br><span class="line"><span class="string">        将结果先转为set，自动就去重了。然后又把set转回list，返回。 </span></span><br><span class="line"><span class="string">        但是调用 set 又转回 list 的话，耗时会剧增。</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p><span id="2.3.1.10"></span>  </p><h3 id="2-3-1-10-最接近的三数之和"><a href="#2-3-1-10-最接近的三数之和" class="headerlink" title="2.3.1.10 最接近的三数之和"></a>2.3.1.10 最接近的三数之和</h3><p><a href="https://leetcode.cn/problems/3sum-closest/description/">LeetCode 16.最接近的三数之和</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><blockquote><p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在恰好一个解.  </p></blockquote><font color="#3399FF">思路：和上面的三数之和思路一样，<b>这里可以不考虑重复问题。因为题目假定每组输入只存在恰好一个解。</b></font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 先将res初始化为一个极值</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-<span class="number">2</span>):</span><br><span class="line">            L, R = i+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;R :</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(nums[i]+nums[L]+nums[R] - target) &lt; <span class="built_in">abs</span>(res-target):</span><br><span class="line">                    res = nums[i]+nums[L]+nums[R]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[L]+nums[R] &lt; target:</span><br><span class="line">                    <span class="comment"># 三数和偏小, 试着增大, 以此靠近 target</span></span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i]+nums[L]+nums[R] &gt; target:</span><br><span class="line">                    <span class="comment"># 三数和偏大, 试着减小, 以此靠近 target</span></span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 如果出现相等的情况</span></span><br><span class="line">                    <span class="comment"># 那就是最接近target, 而且题目说唯一解, 可以直接返回了</span></span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.3.1.11"></span>  </p><h3 id="2-3-1-11-四数之和"><a href="#2-3-1-11-四数之和" class="headerlink" title="2.3.1.11 四数之和"></a>2.3.1.11 四数之和</h3><p><a href="https://leetcode.cn/problems/4sum/">LeetCode 18.四数之和</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：这就是升级版的三数之和问题，可以考虑多搞一层循环来直接套用三数之和的解答方式。</font>   <ul><li><p>第一种代码写法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = [] </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;相较于三数之和问题，多一层循环嵌套而已, 解法本质没有区别&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, N-<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, N-<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> j&gt;i+<span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                L, R = j+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                    <span class="keyword">if</span> nums[i] + nums[j] + nums[L] + nums[R] &gt; target:</span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> nums[i] + nums[j] + nums[L] + nums[R] &lt; target:</span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> res <span class="keyword">and</span> nums[i] == res[-<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">and</span> nums[j] == res[-<span class="number">1</span>][<span class="number">1</span>] <span class="keyword">and</span> nums[L] == res[-<span class="number">1</span>][<span class="number">2</span>]:</span><br><span class="line">                            L += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            res.append([nums[i], nums[j], nums[L], nums[R]])</span><br><span class="line">                            L += <span class="number">1</span></span><br><span class="line">                            R -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><p>第二种代码写法  </p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, N-<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> j&gt;i+<span class="number">1</span> <span class="keyword">and</span> nums[j] ==nums[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                L, R = j+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">while</span> L&lt;R <span class="keyword">and</span> L&gt;j+<span class="number">1</span> <span class="keyword">and</span> nums[L]==nums[L-<span class="number">1</span>]:</span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> R &lt;N-<span class="number">1</span> <span class="keyword">and</span> nums[R] == nums[R+<span class="number">1</span>]:</span><br><span class="line">                        R -=<span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> nums[i] + nums[j] + nums[L] + nums[R] &gt; target:</span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> L&lt;R <span class="keyword">and</span> nums[i] + nums[j] + nums[L] + nums[R] == target:</span><br><span class="line">                        res.append([nums[i], nums[j],nums[L], nums[R]])</span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        L +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.3.1.12"></span>  </p><h3 id="2-3-1-12-有序数组的平方"><a href="#2-3-1-12-有序数组的平方" class="headerlink" title="2.3.1.12 有序数组的平方"></a>2.3.1.12 有序数组的平方</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">LeetCode 977.有序数组的平方</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：要是直接对数组nums内的数进行平方，再排序，这个可能不太符合题目想考察的点。这个题目对于数字的操作其实就是模拟了 $ y=x^2 $ 这个函数，函数开口向上，对称轴为 $x=0$ , 所以对于数组中的数据，谁离0更远，谁平方后就更大。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        暴力解法：</span></span><br><span class="line"><span class="string">        res = [num**2 for num in nums]</span></span><br><span class="line"><span class="string">        return sorted(res)</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        N  = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [<span class="number">0</span>] * N</span><br><span class="line">        L, R, idx  = <span class="number">0</span>, N - <span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt;= R:</span><br><span class="line">            <span class="keyword">while</span> L&lt;=R <span class="keyword">and</span> <span class="built_in">abs</span>(nums[L]) &gt; <span class="built_in">abs</span>(nums[R]):</span><br><span class="line">                <span class="comment"># 如果 L 位置的数更远，就将其平方结果装入 res数组的末尾</span></span><br><span class="line">                res[idx] = nums[L]**<span class="number">2</span></span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                idx -=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;=R <span class="keyword">and</span> <span class="built_in">abs</span>(nums[L]) &lt;= <span class="built_in">abs</span>(nums[R]):</span><br><span class="line">                <span class="comment"># 如果 R 位置的数更远，就将其平方结果装入 res数组的末尾</span></span><br><span class="line">                res[idx] = nums[R]**<span class="number">2</span></span><br><span class="line">                R -=<span class="number">1</span></span><br><span class="line">                idx -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.3.1.13"></span>  </p><h3 id="2-3-1-13-颜色分类"><a href="#2-3-1-13-颜色分类" class="headerlink" title="2.3.1.13 颜色分类"></a>2.3.1.13 颜色分类</h3><p><a href="https://leetcode.cn/problems/sort-colors/">LeetCode 75.颜色分类</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：该题的本质其实是荷兰国旗问题，或者说简化版本的。后面讲排序问题的时候，会专门讨论荷兰国旗问题。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;荷兰国旗问题&#x27;&#x27;&#x27;</span></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        L, R = -<span class="number">1</span>, N</span><br><span class="line">        i = L+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; R:</span><br><span class="line">            <span class="keyword">if</span> L &lt; R <span class="keyword">and</span> nums[i] &lt; <span class="number">1</span>:</span><br><span class="line">                nums[i], nums[L+<span class="number">1</span>] = nums[L+<span class="number">1</span>], nums[i]</span><br><span class="line">                L+=<span class="number">1</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> L &lt; R <span class="keyword">and</span> nums[i] == <span class="number">1</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[i], nums[R-<span class="number">1</span>] = nums[R-<span class="number">1</span>], nums[i]</span><br><span class="line">                R -=<span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="2.3.1.14"></span>  </p><h3 id="2-3-1-14-接雨水"><a href="#2-3-1-14-接雨水" class="headerlink" title="2.3.1.14 接雨水"></a>2.3.1.14 接雨水</h3><p><a href="https://leetcode.cn/problems/trapping-rain-water/">LeetCode 42.接雨水</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路 1：暴力解法，计算每个位置上的最高左右边界，得到每个位置装"水柱"的大小，但是会超出时间限制。</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1.暴力解法</span></span><br><span class="line">        <span class="comment"># 计算每个位置上的&quot;水柱&quot;的大小</span></span><br><span class="line">        <span class="comment"># 注意，该方案超出时间限制，只是作为一个引子</span></span><br><span class="line">        </span><br><span class="line">        L_max, R_max = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        N = <span class="built_in">len</span>(height)</span><br><span class="line">        water = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 对每一个位置，找其左、右两侧最高的边界</span></span><br><span class="line">            <span class="comment"># max 方法的时间复杂度是O(N)</span></span><br><span class="line">            L_max = <span class="built_in">max</span>(height[<span class="number">0</span>:i])</span><br><span class="line">            R_max = <span class="built_in">max</span>(height[i+<span class="number">1</span>:N])</span><br><span class="line">            <span class="comment"># 只有左右两侧存在比当前还要高的边界，才能装水，不然水就流走了</span></span><br><span class="line">            <span class="keyword">if</span> L_max &gt; height[i] <span class="keyword">and</span> R_max &gt; height[i]:</span><br><span class="line">                <span class="comment"># 木桶能装水量是由短板决定的</span></span><br><span class="line">                H = <span class="built_in">min</span>(L_max, R_max)</span><br><span class="line">                water.append(H-height[i])</span><br><span class="line">        <span class="comment"># 整个函数的时间复杂度是O(N^2), 会有测试用例时间超限</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(water)</span><br></pre></td></tr></table></figure><font color="#3399FF">思路 2：在思路1的基础上进行改进。  思路1的想法是没问题的，能够跑通大部分用例，但是对于很长的height数组会超出时间限制。 如果能够将：【对每一个位置寻找其左右最高边界】这个操作的时间复杂度降下来，  那么就能够让整个函数的时间复杂度降低，所以很容易想到 “以空间换时间”。  如果从左往右遍历，要找左侧最高边界，就是在被遍历过的数中找，若能够将左侧遍历过的数中最高的边界，记录下来，那么每一次都只需将原来的左侧最高边界，与新遍历到的数进行对比，即：> 对于 i 位置： L_max = max(L_max, height[i-1]) > 对于右侧的最高边界，就也同理，从右往左遍历，即可得到：> 对于 j 位置， R_max = max(R_max, height[j+1])  这样，就能先遍历一道数组，将这些值记录在辅助数组中，时间复杂度O(N);再遍历一道，计算装水量，还是O(N)的时间复杂度；所以总体的时间复杂度就是O(N)+O(N), 还是 O(N)对于空间复杂度，额外使用了两个数组 L_max，R_max 来存放各个位置的左右边界，勉强也算是 O(2N) -> O(N)</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;思路2 “以空间换时间” &#x27;&#x27;&#x27;</span></span><br><span class="line">        N = <span class="built_in">len</span>(height)</span><br><span class="line">        <span class="comment"># 最左和最右的柱子只能当边界，无法装水</span></span><br><span class="line">        <span class="comment"># 柱子一定要至少有3个才能装水</span></span><br><span class="line">        water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> N &lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> water</span><br><span class="line">        L_max, R_max = height[<span class="number">0</span>], height[N-<span class="number">1</span>]        </span><br><span class="line">        L_boder, R_boder = [L_max]*N, [R_max]*N</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> L <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 将各个位置对应的左右最高边界分别存储到辅助数组中</span></span><br><span class="line">            L_boder[L] = <span class="built_in">max</span>(L_boder[L-<span class="number">1</span>], height[L])</span><br><span class="line">            R = N-<span class="number">1</span>-L</span><br><span class="line">            R_boder[R] = <span class="built_in">max</span>(height[R], R_boder[R+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 水柱高度由较矮边界决定：H = min(L_boder[i], R_boder[i])</span></span><br><span class="line">            <span class="comment"># 同时边界值还要比当前柱子本身要高才行：max(H-height[i], 0)</span></span><br><span class="line">            water += <span class="built_in">max</span>( <span class="built_in">min</span>(L_boder[i], R_boder[i]) - height[i], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> water</span><br><span class="line">        </span><br></pre></td></tr></table></figure><font color="#3399FF">思路 3：思路 2 的改进，能够跑通全部测试用例，但是用到了两个辅助数组，增加了空间复杂度。那么是否还有优化空间呢？  若在寻找左/右最高边界之时，直接计算装水量，岂不是可以不用辅助数组来存储数据了？  但是对于遍历到的数字，我们只能完全肯定其一边的最高边界。> 比如【 <b>从左往右遍历</b>时,考察的是 L 位置】, 可以肯定 L_max 一定是 L 左侧最高边界：> 此时 R_max 是 R 右侧的最高边界，并不一定是 L 右侧的最高边界> 但是 <b> R_max 它是不是 L位置 的右侧最高边界重要吗？</b>来讨论一下    > + <b>情况1</b>. if <font color="Red">R_max > L_max</font>, then H = L_max, 即 H 取值和 R_max 无关，原因如下：        >   如果 L\~R 之间，还有更高的边界可以作为L的右边界，那 L_max 依旧是更矮的，不影响 H 取值是 L_max>   如果 L\~R 之间，不存在更高的边界，那 R_max 就是 L 的最高右边界,哪怕 L~R区间都是更矮的也不影响，反正有 R_max 作为右边界兜底，故 H 取值还是更矮的 L_max>> + <b>情况2</b>.if <font color="gReen">L_max > R_max</font>, 那么确实就不好说了：        >   如果 L\~R 之间 存在更高的边界，那么就应该判断其与 L_max 的大小关系，       >   但是我们暂时无法找到这个值，无法确定更适合 L 位置的右边界          >   如果 L\~R 之间，不存在更高的边界,那 R_max 就是 L 的最高右边界, H=min(L_max, R_max)=R_max          >   主要问题在于，我们暂时无法获取 L~R之间的数字的信息，因为尚未遍历到  > 但是反其道而行之！！！对于当前条件：<font color="gReen">L_max > R_max</font>，无法判断 L 位置的 H 取值。但是却可以判断 R 位置的 H 取值！这正是我们讨论【从左往右遍历时,考察的是 L 位置】 时的情况1如果我们现在 【从 <b>右往左遍历</b> 时,考察的是 R 位置】，那么> + <font color="gReen">L_max > R_max</font> 这个情况>   就是 R 位置的<b>情况1</b>：此时 R 位置的 H = R_max> + 对于 R 位置的<b>情况2</b>：条件是 <font color="Red">R_max > L_max</font>， 同理，无法确定 L~R 之间是否有更适合作为 R 位置左边界的值>   但是，它又转换成了 对于 L 位置的情况1.   对于 R_max == L_max 的情况:  如果考察的是 L 位置，H 仍然能取 L_max如果考察的是 R 位置，H 仍然能取 R_max。仍然按照两个位置情况1的思路去理解在写代码时，只需要将这种情况固定划分到考察 L 或者 R 的一种之中去就行这样整个思路就能串通起来了,由于只需要遍历一次数组，时间复杂度 O(N), 只有有限个辅助变量，空间复杂度O(1)。</font>    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(height)</span><br><span class="line">        <span class="comment"># 最左和最右的柱子只能当边界，无法装水</span></span><br><span class="line">        <span class="comment"># 柱子一定要至少有3个才能装水</span></span><br><span class="line">        water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> N &lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> water</span><br><span class="line"></span><br><span class="line">        L_max, R_max = height[<span class="number">0</span>], height[N-<span class="number">1</span>]</span><br><span class="line">        L, R = <span class="number">1</span>, N-<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> L &lt;= R :</span><br><span class="line">            <span class="keyword">if</span> L_max &lt;= R_max:</span><br><span class="line">                <span class="comment"># 这是 从左往右遍历的 L 位置的情况1:H = L_max</span></span><br><span class="line">                L_max = <span class="built_in">max</span>(L_max, height[L])</span><br><span class="line">                water += L_max - height[L]</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 这是 从右往左遍历的 r 位置的情况1: H = R_max</span></span><br><span class="line">                R_max = <span class="built_in">max</span>(R_max, height[R])</span><br><span class="line">                water += R_max - height[R]</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> water </span><br></pre></td></tr></table></figure><p><span id="2.3.1.15"></span>  </p><h3 id="2-3-1-15-数组中的最长山脉"><a href="#2-3-1-15-数组中的最长山脉" class="headerlink" title="2.3.1.15 数组中的最长山脉"></a>2.3.1.15 数组中的最长山脉</h3><p><a href="https://leetcode.cn/problems/longest-mountain-in-array/">LeetCode 845.数组中的最长山脉</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：这个其实不是对撞指针了，是对每个位置展开一个左右指针，来对每个位置求山脉宽度。其实可以理解为对撞指针的<b>逆过程</b>，从中间开始往两边扩散两个指针。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestMountain</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(arr)</span><br><span class="line">        width = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 注意！根据题目中的要求，是左右侧都要有下降趋势的点才行</span></span><br><span class="line">        <span class="comment"># 所以 最左侧和最右侧元素，arr[0]/arr[N-1]由于只有一边有元素，不合题意</span></span><br><span class="line">        <span class="comment"># 可以不用遍历这两个位置，它俩一定不能作为山顶</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 首先判断是否是符合山顶条件，即左右两侧都有下降趋势</span></span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; arr[i - <span class="number">1</span>] <span class="keyword">and</span> arr[i] &gt; arr[i + <span class="number">1</span>]:</span><br><span class="line">                L = i - <span class="number">1</span></span><br><span class="line">                R = i + <span class="number">1</span></span><br><span class="line">                <span class="comment"># 左侧一直延伸到尽可能左</span></span><br><span class="line">                <span class="keyword">while</span> L &gt; <span class="number">0</span> <span class="keyword">and</span> arr[L - <span class="number">1</span>] &lt; arr[L]:</span><br><span class="line">                    L -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 右侧一直延伸到尽可能右</span></span><br><span class="line">                <span class="keyword">while</span> R &lt; N - <span class="number">1</span> <span class="keyword">and</span> arr[R + <span class="number">1</span>] &lt; arr[R]:</span><br><span class="line">                    R += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                width = <span class="built_in">max</span>(width, R-L+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> width</span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        #$#$#$#$#$#$ 改进后的代码，理论上可以稍微加速一点 #$#$#$#$#$#$#$</span></span><br><span class="line"><span class="string">        # 当然只是理论上, 至于实际是否加速, 得看机器和测试用例的的实际情况</span></span><br><span class="line"><span class="string">        # 改进的位置在while循环中 i 变化的情况</span></span><br><span class="line"><span class="string">        i = 1</span></span><br><span class="line"><span class="string">        while i &lt; N-1:</span></span><br><span class="line"><span class="string">            # 首先判断是否是符合山顶条件，即左右两侧都有下降趋势</span></span><br><span class="line"><span class="string">            if arr[i] &gt; arr[i - 1] and arr[i] &gt; arr[i + 1]:</span></span><br><span class="line"><span class="string">                L = i - 1</span></span><br><span class="line"><span class="string">                R = i + 1</span></span><br><span class="line"><span class="string">                # 左侧一直延伸到尽可能左</span></span><br><span class="line"><span class="string">                while L &gt; 0 and arr[L - 1] &lt; arr[L]:</span></span><br><span class="line"><span class="string">                    L -= 1</span></span><br><span class="line"><span class="string">                # 右侧一直延伸到尽可能右</span></span><br><span class="line"><span class="string">                while R &lt; N - 1 and arr[R] &gt; arr[R + 1]:</span></span><br><span class="line"><span class="string">                    R += 1</span></span><br><span class="line"><span class="string">                </span></span><br><span class="line"><span class="string">                width = max(width, R-L+1)</span></span><br><span class="line"><span class="string">                # 我们可以知道，在当前情况下，是有一个(L,i,R)的山脉</span></span><br><span class="line"><span class="string">                # 所以 在 i~R 区间，必然全是下坡路，不可能存在山顶</span></span><br><span class="line"><span class="string">                # 所以 i 可以直接跳到 R+1的位置去判断</span></span><br><span class="line"><span class="string">                # 省去了右边下山区间这么多元素的判断计算</span></span><br><span class="line"><span class="string">                i = R + 1</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">                i += 1</span></span><br><span class="line"><span class="string">        return width</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>        </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.3.1.16"></span>  </p><h3 id="2-3-1-16-最长湍流子数组"><a href="#2-3-1-16-最长湍流子数组" class="headerlink" title="2.3.1.16 最长湍流子数组"></a>2.3.1.16 最长湍流子数组</h3><p><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">LeetCode 978.最长湍流子数组</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：其实这个题最好的解法不是使用这种扩散指针，但是确实可以参考上面 <b>[数组中的最长山脉](#2.3.1.15)</b> 的思路来做。这里只是提供一种解法，拓展思路，但确实code比较复杂，看起来也不太容易懂，可以看着玩玩。<b>更好的解法还是建议看下面快慢指针部分 [2.3.2.7](#2.3.2.7)题解</b>，该题的code。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxTurbulenceSize</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        首先要搞清楚湍流是什么情况：</span></span><br><span class="line"><span class="string">        ···&lt; arr[M-2] &gt; arr[M-1] &lt; arr[M] &gt; arr[M+1] &lt; arr[M+2] &gt; ···</span></span><br><span class="line"><span class="string">                                    或者</span></span><br><span class="line"><span class="string">        ···&gt; arr[M-2] &lt; arr[M-1] &gt; arr[M] &lt; arr[M+1] &gt; arr[M+2] &lt; ···</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 按照 数组中的最长山脉 的题解思路来做， 特殊情况和边界情况的判断稍显复杂</span></span><br><span class="line">        N = <span class="built_in">len</span>(arr)</span><br><span class="line">        width = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:   </span><br><span class="line">            <span class="keyword">return</span> width</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; N:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> i == N-<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 端点值先特殊讨论</span></span><br><span class="line">                <span class="keyword">if</span> (arr[<span class="number">0</span>] != arr[<span class="number">1</span>]) <span class="keyword">or</span> (arr[N-<span class="number">2</span>] != arr[N-<span class="number">1</span>]): </span><br><span class="line">                    <span class="comment"># 只要端点值的相邻值和它不相等, 就一定是一个宽度为2的湍流</span></span><br><span class="line">                    width = <span class="built_in">max</span>(<span class="number">2</span>, width)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第 1 种 湍流模式, M 点是邻域极大值</span></span><br><span class="line">            <span class="keyword">elif</span> arr[i-<span class="number">1</span>] &lt; arr[i] <span class="keyword">and</span> arr[i] &gt; arr[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 这里的两个 flag是用来控制 &lt; 或 &gt; 符号的, 利用 -1 的不断自乘来实现转向</span></span><br><span class="line">                flag_L, flag_R, left, right = -<span class="number">1</span>, -<span class="number">1</span>, i-<span class="number">1</span>, i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> (arr[left] - arr[left-<span class="number">1</span>])* flag_L &gt; <span class="number">0</span>:</span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                    flag_L *= -<span class="number">1</span>  </span><br><span class="line">                <span class="keyword">while</span> right &lt; N-<span class="number">1</span> <span class="keyword">and</span> (arr[right] - arr[right+<span class="number">1</span>])* flag_R &gt; <span class="number">0</span>:</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">                    flag_R *= -<span class="number">1</span></span><br><span class="line">                width = <span class="built_in">max</span>(width, right-left+<span class="number">1</span>)</span><br><span class="line">                i = right</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 第 2 种 湍流模式, M 点是邻域极小值</span></span><br><span class="line">            <span class="keyword">elif</span> arr[i-<span class="number">1</span>] &gt; arr[i] <span class="keyword">and</span> arr[i] &lt; arr[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 这里的两个 flag是用来控制 &lt; 或 &gt; 符号的, 利用 -1 的不断自乘来实现转向</span></span><br><span class="line">                flag_L, flag_R, left, right = -<span class="number">1</span>, -<span class="number">1</span>, i-<span class="number">1</span>, i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> (arr[left] - arr[left-<span class="number">1</span>])* flag_L &lt; <span class="number">0</span>:</span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                    flag_L *= -<span class="number">1</span>  </span><br><span class="line">                <span class="keyword">while</span> right &lt; N-<span class="number">1</span> <span class="keyword">and</span> (arr[right] - arr[right+<span class="number">1</span>])* flag_R &lt; <span class="number">0</span>:</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">                    flag_R *= -<span class="number">1</span></span><br><span class="line">                width = <span class="built_in">max</span>(width, right-left+<span class="number">1</span>)</span><br><span class="line">                i = right </span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> width</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        这种代码写法的核心思路就是借鉴的 最长山脉那道题，难点在于:</span></span><br><span class="line"><span class="string">        1. 小于/大于符号在不断的交替, 这里是利用 -1 的自乘实现</span></span><br><span class="line"><span class="string">        2. 数组左右端点值的特殊情况容易忽略</span></span><br><span class="line"><span class="string">        总之这种代码写法稍微有点困难，也是因为刚刚才做完 最长山脉的题目，</span></span><br><span class="line"><span class="string">        陷入了 定式思维 的陷阱, 才写出了这种方法。</span></span><br><span class="line"><span class="string">        等下面用快慢指针的思路, 代码就更容易理解</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><span id="2.3.2"></span></p><h2 id="2-3-2-快慢指针"><a href="#2-3-2-快慢指针" class="headerlink" title="2.3.2 快慢指针"></a>2.3.2 快慢指针</h2><p>所谓快慢指针，就是指的两个指针的移动频率不同，其中快指针因为某个条件，总是跑在慢指针更右侧。<br>通常终止条件就是快指针遍历完了数组。  </p><p><span id="2.3.2"></span>  </p><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">LeetCode 26.删除有序数组中的重复项</a></td><td><a href="#2.3.2.1">题解2.3.2.1</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/string-compression/">LeetCode 443.压缩字符串</a></td><td><a href="#2.3.2.2">题解2.3.2.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">LeetCode 80.删除有序数组中的重复项II</a></td><td><a href="#2.3.2.3">题解2.3.2.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/remove-element/">LeetCode 27.移除元素</a></td><td><a href="#2.3.2.4">题解2.3.2.4</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/move-zeroes//">LeetCode 283.移动零</a></td><td><a href="#2.3.2.5">题解2.3.2.5</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/increasing-triplet-subsequence/">LeetCode 334.递增的三元子序列</a></td><td><a href="#2.3.2.6">题解2.3.2.6</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">LeetCode 978.最长湍流子数组</a></td><td><a href="#2.3.2.7">题解2.3.2.7</a></td></tr><tr><td>⑧</td><td><a href="https://leetcode.cn/problems/max-consecutive-ones/">LeetCode 485.最大连续 1 的个数</a></td><td><a href="#2.3.2.8">题解2.3.2.8</a></td></tr></tbody></table></div><p><span id="2.3.2.1"></span>  </p><h3 id="2-3-2-1-删除有序数组中的重复项"><a href="#2-3-2-1-删除有序数组中的重复项" class="headerlink" title="2.3.2.1 删除有序数组中的重复项"></a>2.3.2.1 删除有序数组中的重复项</h3><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">LeetCode 26.删除有序数组中的重复项</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><font color="#3399FF">思路：用快慢指针，快指针先去右侧看是否重复，慢指针用来修改原数组（维护去重部分的边界）</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> N &lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> N</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;方案一. 遍历到的重复的数, 先跳过，将重复区域的最后一个数, 加入唯一元素区域&#x27;&#x27;&#x27;</span></span><br><span class="line">        s, f = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="comment"># 慢指针代表筛选出的【唯一元素区域】的右边界, 一开始这个区域是空的, 所以s=0 </span></span><br><span class="line">        <span class="comment"># 快指针代表后续待比较区域的元素, 因为至少要有2个元素才能比较是否重复, 所以f从第2个元素开始,f=1</span></span><br><span class="line">        <span class="keyword">while</span> f &lt;= N:</span><br><span class="line">            <span class="keyword">if</span> f== N <span class="keyword">or</span> nums[f] != nums[f-<span class="number">1</span>] :</span><br><span class="line">                <span class="comment"># f位置的数与 f-1不相同, 说明：</span></span><br><span class="line">                <span class="comment"># f-1位置是某段重复区域的最后一个数了, f是新区域的第一个数.</span></span><br><span class="line">                <span class="comment"># 把f-1加进唯一元素区域</span></span><br><span class="line">                nums[s] = nums[f-<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 这个if条件里面之所以有 f==N 这个情况, 是因为f=N时, nums取不到值, </span></span><br><span class="line">                <span class="comment"># 且nums的最后一个数N-1位置一定可以加入唯一区域, 因为这个数一定是某段区域的最后一个数(不管这段区域是否重复)</span></span><br><span class="line">                <span class="comment"># 同时不要忘记 右边界s向右扩张1位</span></span><br><span class="line">                s += <span class="number">1</span></span><br><span class="line">            f += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s <span class="comment"># s是右边界, 即唯一元素区域实际是 0 ~ s-1, 共 s 个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        方案二： </span></span><br><span class="line"><span class="string">        上面的方案都是将重复区域的最后一个元素更新到s位置</span></span><br><span class="line"><span class="string">        这里是将重复区域的第一个元素更新到s位置</span></span><br><span class="line"><span class="string">        s, f = -1, 0</span></span><br><span class="line"><span class="string">        while f &lt; N:</span></span><br><span class="line"><span class="string">            # 这里的更新过程非常像在维护一个虚拟的栈</span></span><br><span class="line"><span class="string">            # 当栈为空 s==-1，或者f遇到的数不等于栈顶元素 nums[f] != nums[s]</span></span><br><span class="line"><span class="string">            # 就将栈的区域扩大一个：s+=1， 然后将f对应的元素入栈:nums[s] = nums[f]</span></span><br><span class="line"><span class="string">            if s==-1 or nums[f] != nums[s]:</span></span><br><span class="line"><span class="string">                s += 1</span></span><br><span class="line"><span class="string">                nums[s] = nums[f]</span></span><br><span class="line"><span class="string">            f += 1</span></span><br><span class="line"><span class="string">        # 虚拟栈的范围是 0 ~ s, 共 s+1 个元素       </span></span><br><span class="line"><span class="string">        return s+1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 用虚拟栈的思路会十分容易理解, 代码也很好写, 所以更推荐方案二</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>                 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.3.2.2"></span>  </p><h3 id="2-3-2-2-压缩字符串"><a href="#2-3-2-2-压缩字符串" class="headerlink" title="2.3.2.2 压缩字符串"></a>2.3.2.2 压缩字符串</h3><p><a href="https://leetcode.cn/problems/string-compression/">LeetCode 443.压缩字符串</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><font color="#3399FF">思路：题目中说到只能使用常量额外空间，即空间复杂度要求O(1)，说明没办法用辅助数组。然后这个题其实是上一题 <b>[删除有序数组中的重复项](#2.3.2.1)</b> 的升级版，稍微麻烦了一点而已，思路完全是一样的。同样是要判断连续的重复字符，只不过现在还要追加其数目而已。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compress</span>(<span class="params">self, chars: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(chars)</span><br><span class="line">        <span class="keyword">if</span> N &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> N </span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">rever_list</span>(<span class="params">arr, L, R</span>):</span><br><span class="line">            <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                arr[L], arr[R] = arr[R], arr[L]</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        s, f =  <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="comment"># 重复区域的开头位置begin初始化为0</span></span><br><span class="line">        begin = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> f &lt;= N :</span><br><span class="line">            <span class="keyword">if</span> f == N <span class="keyword">or</span> chars[f] != chars[f-<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 说明 f-1 位置是上一段重复区域的最后一个, f是下一段区域的开头</span></span><br><span class="line">                chars[s] = chars[f-<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 右边界右移一位</span></span><br><span class="line">                s += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 计算上一段重复区域的长度, 就是下一段区域的开头f 减去 上一段的开头位置 begin</span></span><br><span class="line">                cnt = f - begin</span><br><span class="line">                begin = f</span><br><span class="line">                <span class="keyword">if</span> cnt &gt; <span class="number">1</span>:</span><br><span class="line">                    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                    # 这种直接将数字字符串序列化, 每次都会产生一个list</span></span><br><span class="line"><span class="string">                    # 然后接着使用列表切片法进行赋值, 也会在等号右侧产生一个临时list</span></span><br><span class="line"><span class="string">                    # 虽然这种写法确实快, 但是有一点违背【使用常量额外空间】的条件的嫌疑</span></span><br><span class="line"><span class="string">                    # 如果要规避这一点, 可以使用for循环来处理这段逻辑</span></span><br><span class="line"><span class="string">                    # 也就是说题目要求【使用常量额外空间】时, 代码中还是尽量避免产生列表/数组的操作</span></span><br><span class="line"><span class="string">                    num_str = list(str(cnt))</span></span><br><span class="line"><span class="string">                    num_w = len(num_str)</span></span><br><span class="line"><span class="string">                    chars[s:s+num_w] = num_str[:]</span></span><br><span class="line"><span class="string">                    s += num_w</span></span><br><span class="line"><span class="string">                    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">                    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                    虽然这种写法代码比较复杂,而且实际跑出来的效果也许并不是最好的</span></span><br><span class="line"><span class="string">                    但确实在理论上更加严格的遵守了 【使用常量额外空间】 这一条件</span></span><br><span class="line"><span class="string">                    因为算法是要考虑到使用不同的代码时都能产生比较好的效果</span></span><br><span class="line"><span class="string">                    只使用了有限几个变量, 而没有产生列表/数组</span></span><br><span class="line"><span class="string">                    &#x27;&#x27;&#x27;</span></span><br><span class="line">                    <span class="keyword">if</span> cnt &lt; <span class="number">10</span>:</span><br><span class="line">                        <span class="comment"># cnt &lt; 10 时数字只有一个, 简单操作</span></span><br><span class="line">                        chars[s] = <span class="built_in">str</span>(cnt)</span><br><span class="line">                        s += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># cnt &gt;= 10时 数字会至少有2位</span></span><br><span class="line">                        L = s</span><br><span class="line">                        <span class="comment"># 循环产生的结果是先从【个位】开始取出数字填充</span></span><br><span class="line">                        <span class="comment"># 比如 123 产生的结果其实是 &#x27;3&#x27;,&#x27;2&#x27;,&#x27;1&#x27;</span></span><br><span class="line">                        <span class="keyword">while</span> cnt &gt; <span class="number">0</span>:</span><br><span class="line">                            chars[s] = <span class="built_in">str</span>(cnt % <span class="number">10</span>)</span><br><span class="line">                            cnt //= <span class="number">10</span></span><br><span class="line">                            s += <span class="number">1</span></span><br><span class="line">                        R = s-<span class="number">1</span></span><br><span class="line">                        <span class="comment"># 所以填充完之后还需要将该段数字的顺序转回来</span></span><br><span class="line">                        rever_list(chars, L, R)            </span><br><span class="line">            f += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p><span id="2.3.2.3"></span>  </p><h3 id="2-3-2-3-删除有序数组中的重复项II"><a href="#2-3-2-3-删除有序数组中的重复项II" class="headerlink" title="2.3.2.3 删除有序数组中的重复项II"></a>2.3.2.3 删除有序数组中的重复项II</h3><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">LeetCode 80.删除有序数组中的重复项II</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><font color="#3399FF">思路：思路和前面两道题一脉相承，代码稍加改动即可</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># if N &lt;= 2:</span></span><br><span class="line">        <span class="comment">#     return 2</span></span><br><span class="line">        s, f = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        begin = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> f &lt;= N:</span><br><span class="line">            <span class="keyword">if</span> f == N <span class="keyword">or</span> nums[f] != nums[f-<span class="number">1</span>]:</span><br><span class="line">                nums[s] = nums[f-<span class="number">1</span>]</span><br><span class="line">                s += <span class="number">1</span></span><br><span class="line">                cnt = f - begin</span><br><span class="line">                begin = f</span><br><span class="line">                <span class="keyword">if</span> cnt &gt;= <span class="number">2</span>:</span><br><span class="line">                    nums[s] = nums[f-<span class="number">1</span>]</span><br><span class="line">                    s += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            f += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p><span id="2.3.2.4"></span>  </p><h3 id="2-3-2-4-移除元素"><a href="#2-3-2-4-移除元素" class="headerlink" title="2.3.2.4 移除元素"></a>2.3.2.4 移除元素</h3><p><a href="https://leetcode.cn/problems/remove-element/">LeetCode 27.移除元素</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><font color="#3399FF">思路：和上面的题目一脉相承。用虚拟栈的思路会很容易理解。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 慢指针充当虚拟栈栈顶索引, 快指针用来遍历数组</span></span><br><span class="line">        s, f = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> f &lt; N:</span><br><span class="line">            <span class="keyword">if</span> nums[f] != val:</span><br><span class="line">                <span class="comment"># 将虚拟栈扩充一位, 并且将数放入栈顶</span></span><br><span class="line">                s += <span class="number">1</span></span><br><span class="line">                nums[s] = nums[f]</span><br><span class="line">            f += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 虚拟栈数据范围 0~s 共s+1个数字</span></span><br><span class="line">        <span class="keyword">return</span> s+<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.3.2.5"></span>  </p><h3 id="2-3-2-5-移动零"><a href="#2-3-2-5-移动零" class="headerlink" title="2.3.2.5 移动零"></a>2.3.2.5 移动零</h3><p><a href="https://leetcode.cn/problems/move-zeroes//">LeetCode 283.移动零</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><font color="#3399FF">思路: partition 问题，注意，下面的代码是 非稳定的因为不同的0的相对次序其实会变化，只不过题目只要求非0数据相对次序不变，所以还是能保证的。后面的章节讲排序问题的快速排序讨论, 会详细讲 partition 问题;这里还是先用虚拟栈的思考方式来理解更方便一点。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 慢指针充当虚拟栈栈顶索引，快指针用来遍历数组</span></span><br><span class="line">        ps, pf = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pf &lt;N:</span><br><span class="line">            <span class="keyword">if</span> nums[pf] != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 虚拟栈扩充一格</span></span><br><span class="line">                ps += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 栈顶位置的原始数字, 和 pf 位置的数字进行交换, </span></span><br><span class="line">                <span class="comment"># 就把pf位置的数放到栈里来了, 同时将原始数字放到栈外面去了</span></span><br><span class="line">                nums[pf], nums[ps] = nums[ps], nums[pf]</span><br><span class="line">            pf += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="2.3.2.6"></span>  </p><h3 id="2-3-2-6-递增的三元子序列"><a href="#2-3-2-6-递增的三元子序列" class="headerlink" title="2.3.2.6 递增的三元子序列"></a>2.3.2.6 递增的三元子序列</h3><p><a href="https://leetcode.cn/problems/increasing-triplet-subsequence/">LeetCode 334.递增的三元子序列</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><font color="#3399FF">思路：这个题虽然没有显式的使用快慢指针，但是思想是借鉴了快慢指针的。假设我们要找3个数a,b,c满足 a < b < c 的条件，<b>那么a应该尽可能的小，b也应该在大于a的情况下尽可能的小，这样才容易去找到满足条件的c</b>。那么，比方说我们<b><font color="#3333FF">如何找到一个数组中，最小的数呢（不调用min）</font>？？</b>那就是设定一个极大的初始值，遍历一道数组，在遍历过程中发现更小的数，就更新，最终就能找到这个最小的数。借鉴这个思想，我们的代码如下</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increasingTriplet</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        a = b = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &lt;= a:</span><br><span class="line">                <span class="comment"># 这样能够保证在遍历过的数字中，a一定是最小的那个数</span></span><br><span class="line">                a = num </span><br><span class="line">            <span class="keyword">elif</span> num &lt;=b:</span><br><span class="line">                <span class="comment"># elif隐含的条件是不满足上面的条件，即不满足小于等于a</span></span><br><span class="line">                <span class="comment"># 所以b一定能取到在遍历过的数目当中，位于a后面的，比a大的数当中，最小的一个数</span></span><br><span class="line">                b = num </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 在继续变量的过程中，只要遇到一个数不满足上面的条件，即比a和b都大</span></span><br><span class="line">                <span class="comment"># 这个数就能够充当 c 的角色</span></span><br><span class="line">                <span class="comment"># c = num </span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><span id="2.3.2.7"></span>  </p><h3 id="2-3-2-7-最长湍流子数组"><a href="#2-3-2-7-最长湍流子数组" class="headerlink" title="2.3.2.7 最长湍流子数组"></a>2.3.2.7 最长湍流子数组</h3><p><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">LeetCode 978.最长湍流子数组</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><font color="#3399FF">思路：该题在对撞指针中讲过一次，但是更好的解法是使用快慢指针。具体的思路可以看code中的注释，采用快慢指针要快许多</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxTurbulenceSize</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        注意到题目中给的例子，1个元素也算湍流，2个不相等的数也能组成宽度为2的湍流</span></span><br><span class="line"><span class="string">        其实不用像 山脉宽度 那样每次从一个中心点，向着左右扩散</span></span><br><span class="line"><span class="string">        湍流可以选择一个起始点，从左往右的方向一直扩散，比如：</span></span><br><span class="line"><span class="string">        情况1：arr[0] &gt; arr[1] &lt; arr[2] &gt; ··· </span></span><br><span class="line"><span class="string">        或 情况2：arr[0] &lt; arr[1] &gt; arr[2] &lt; ···</span></span><br><span class="line"><span class="string">        考虑用快慢指针，一个维护湍流的起点，另一个维护湍流的终点</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        N, width = <span class="built_in">len</span>(arr), <span class="number">1</span></span><br><span class="line">        L, R = <span class="number">0</span> ,<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> R &lt; N: <span class="comment"># 当湍流的右边界没有超过数组</span></span><br><span class="line">            <span class="comment"># 情况 1</span></span><br><span class="line">            <span class="keyword">if</span> arr[L] &gt; arr[R]:</span><br><span class="line">                flag = -<span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果右边一直能满足湍流的条件，就一直往右扩散</span></span><br><span class="line">                <span class="comment"># 这里是通过乘以 (-1)^k 来变相控制 大于/小于符号, 注意这里用的是 &gt;</span></span><br><span class="line">                <span class="keyword">while</span> R &lt; N-<span class="number">1</span> <span class="keyword">and</span> (arr[R]- arr[R+<span class="number">1</span>]) * flag &gt; <span class="number">0</span>:</span><br><span class="line">                    R += <span class="number">1</span></span><br><span class="line">                    flag *= -<span class="number">1</span></span><br><span class="line">                <span class="comment"># 循环结束后, R 指向该组湍流的最后一个满足条件的元素</span></span><br><span class="line">                width = <span class="built_in">max</span>(width, R-L+<span class="number">1</span>)                </span><br><span class="line">            <span class="comment"># 情况 2</span></span><br><span class="line">            <span class="keyword">elif</span> arr[L] &lt; arr[R]:</span><br><span class="line">                flag = -<span class="number">1</span> </span><br><span class="line">                <span class="comment"># 这里是通过乘以 (-1)^k 来变相控制 大于/小于符号, 注意这里用的是 &lt; </span></span><br><span class="line">                <span class="keyword">while</span> R &lt; N-<span class="number">1</span> <span class="keyword">and</span> (arr[R]- arr[R+<span class="number">1</span>]) * flag &lt; <span class="number">0</span>:</span><br><span class="line">                    R += <span class="number">1</span></span><br><span class="line">                    flag *= -<span class="number">1</span></span><br><span class="line">                width = <span class="built_in">max</span>(width, R-L+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 连续两个数字相等，直接pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="comment"># 更新起点和终点</span></span><br><span class="line">            L = R </span><br><span class="line">            R +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> width</span><br></pre></td></tr></table></figure><p><span id="2.3.2.8"></span>  </p><h3 id="2-3-2-8-最大连续-1-的个数"><a href="#2-3-2-8-最大连续-1-的个数" class="headerlink" title="2.3.2.8 最大连续 1 的个数"></a>2.3.2.8 最大连续 1 的个数</h3><p><a href="https://leetcode.cn/problems/max-consecutive-ones/">LeetCode 485.最大连续 1 的个数</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><font color="#3399FF">思路：该题在 [2-2 数组相关题目](https://teeyohuang.github.io/Data-Structure/DS_22_array_exercises.html) 的 [2.2.1.3](https://teeyohuang.github.io/Data-Structure/DS_22_array_exercises.html#2.2.1.3) 已经见过，现在再用快慢指针的思路，更容易理解。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxConsecutiveOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        L, R =-<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 慢指针用来标记连续1区域的左边界, 快指针用来判断当前位置是否是1</span></span><br><span class="line">        gap = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> R <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[R] == <span class="number">1</span>:</span><br><span class="line">                gap = <span class="built_in">max</span>(gap, R-L)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                L = R </span><br><span class="line">        <span class="keyword">return</span> gap </span><br></pre></td></tr></table></figure><p>。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2-2 数组相关题目</title>
      <link href="/Data-Structure/DS_22_array_exercises.html"/>
      <url>/Data-Structure/DS_22_array_exercises.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1"> <h1 id="2-2-数组相关题目"><a href="#2-2-数组相关题目" class="headerlink" title="2-2 数组相关题目"></a>2-2 数组相关题目</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p><b>版权声明：以下题目均来自 <a href="https://leetcode.cn">LeetCode</a>， 仅仅提供跳转到力扣官网的链接，不在本页面出现题目内容，本文章内容禁止商业用途。</b></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>2.2.1</td><td><a href="#2.2.1">一维数组的相关题目</a></td></tr><tr><td>2.2.2</td><td><a href="#2.2.2">二维数组相关题目</a></td></tr></tbody></table></div><p><span id="2.2.1"></span>  </p><h2 id="2-2-1-一维数组的相关题目"><a href="#2-2-1-一维数组的相关题目" class="headerlink" title="2.2.1 一维数组的相关题目"></a>2.2.1 一维数组的相关题目</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/rotate-array/">LeetCode 189.轮转数组</a></td><td><a href="#2.2.1.1">2.2.1.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/find-pivot-index/">LeetCode 724.寻找数组的中心下标</a></td><td><a href="#2.2.1.2">2.2.1.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/max-consecutive-ones/">LeetCode 485.最大连续 1 的个数</a></td><td><a href="#2.2.1.3">2.2.1.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/product-of-array-except-self/">LeetCode 238.除自身以外数组的乘积</a></td><td><a href="#2.2.1.4">2.2.1.4题解</a></td></tr></tbody></table></div><p><span id="2.2.1.1"></span>  </p><h3 id="2-2-1-1-轮转数组"><a href="#2-2-1-1-轮转数组" class="headerlink" title="2.2.1.1 轮转数组"></a>2.2.1.1 轮转数组</h3><p><a href="https://leetcode.cn/problems/rotate-array/">LeetCode 189.轮转数组</a> | |  <a href="#2.2.1">返回2.2.1目录</a>  </p><font color="#3399FF">方案一： 复制一个数组为参照，在原数组上进行修改。 </font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;时间复杂度O(n), 空间复杂度O(n)&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        tmp, n = nums.copy(), <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            nums[(i+k)%n] = tmp[i]</span><br></pre></td></tr></table></figure><font color="#3399FF">方案二： 不另外创建数组。 </font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 题目给的例子中，有k&gt;N的情况，所以先求模运算</span></span><br><span class="line">        k = k % N</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果假设数组首尾相接，是一个循环数组</span></span><br><span class="line">        <span class="comment"># 那么向右轮转k个位置，就相当于后面k个数被挤压到前面去了</span></span><br><span class="line">        <span class="comment"># 前面的 N-k 个数， 被挤压到后面全了</span></span><br><span class="line">        <span class="comment"># 所以就相当于 前 N-k 个数，和后 k个数，整体区域做一下交换</span></span><br><span class="line">        <span class="comment"># 那么如果我们直接从 第 N-k个数字后面的逗号，将数组旋转180度，他们的区域就交换了</span></span><br><span class="line">        nums[:] = nums[::-<span class="number">1</span>] <span class="comment"># 反转数组</span></span><br><span class="line">        <span class="comment"># 注意！如果写成 nums = nums[::-1],原数组num的值是不会被改变的，这种写法相当于创建了一个新的临时数组。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 但是反转数组后，各区域内的顺序也被反转了一遍，我们再将各区域的顺序调回来</span></span><br><span class="line">        <span class="comment"># 将转过来的前k个数字恢复原来的顺序（注意前k个数字序号是 0~k-1）</span></span><br><span class="line">        nums[:k] = nums[k-<span class="number">1</span>::-<span class="number">1</span>] </span><br><span class="line">        <span class="comment"># 将转过来的后的N-K个数字恢复原顺序（注意后N-K个数字序号是 k~N-1）</span></span><br><span class="line">        nums[k:] = nums[N-<span class="number">1</span>:k-<span class="number">1</span>:-<span class="number">1</span>] </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        但是问题是，python在进行切片操作的时候，</span></span><br><span class="line"><span class="string">        实际上是会在等式右边产生一个新的临时list，</span></span><br><span class="line"><span class="string">        然后将值赋给等式左边。也并不见得能省多少空间.</span></span><br><span class="line"><span class="string">        还有的解法是在反转数组的时候，自己写反转函数：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        def reverse_list(nums, start, end):</span></span><br><span class="line"><span class="string">            while start &lt; end:</span></span><br><span class="line"><span class="string">                nums[start], nums[end] = nums[end], nums[start]</span></span><br><span class="line"><span class="string">                start +=1</span></span><br><span class="line"><span class="string">                end -=1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        reverse_list(nums, 0, N-1)</span></span><br><span class="line"><span class="string">        reverse_list(nums, 0, k-1)</span></span><br><span class="line"><span class="string">        reverse_list(nums, k, N-1)     </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        这种的空间复杂度比起直接使用链表切片来说，理论上会少一些吧，反正leetcode的提交结果来看，</span></span><br><span class="line"><span class="string">        使用python2的话，空间消耗确实有减少，但是时间消耗一下就增加了</span></span><br><span class="line"><span class="string">        使用python3的话，空间消耗是真没有多少区别，时间消耗也是增加了。</span></span><br><span class="line"><span class="string">        总得来说，用切片就是快</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><span id="2.2.1.2"></span>  </p><h3 id="2-2-1-2-寻找数组的中心下标"><a href="#2-2-1-2-寻找数组的中心下标" class="headerlink" title="2.2.1.2  寻找数组的中心下标"></a>2.2.1.2  寻找数组的中心下标</h3><p><a href="https://leetcode.cn/problems/find-pivot-index/">LeetCode 724.寻找数组的中心下标</a> | | <a href="#2.2.1">返回2.2.1目录</a>  </p><font color="#3399FF">方案：最直接的思路就是遍历元素的时候，每一次都计算左侧的和 sum(nums[:i]) 和 右侧的和 sum(nums[i+1:])；但是这中间包含了大量重复计算，时间复杂度会很高。所以可以维护两个状态变量，分别记录左和右的累加和，每一次遍历的时候，直接修改状态变量即可。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 把左右结果放入中间变量缓存，就不用每次都调用sum了</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            cur_val = nums[i]</span><br><span class="line">            <span class="keyword">if</span> left == right - cur_val:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += cur_val</span><br><span class="line">                right -= cur_val</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="2.2.1.3"></span>  </p><h3 id="2-2-1-3-最大连续-1-的个数"><a href="#2-2-1-3-最大连续-1-的个数" class="headerlink" title="2.2.1.3 最大连续 1 的个数"></a>2.2.1.3 最大连续 1 的个数</h3><p><a href="https://leetcode.cn/problems/max-consecutive-ones/">LeetCode 485.最大连续 1 的个数</a> | | <a href="#2.2.1">返回2.2.1目录</a></p><font color="#3399FF">方案：这种求连续间隔的题，一般都是用索引相减来做。即右边界的索引，减去左边界的索引，就是这段区间的宽度。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxConsecutiveOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># index_0 用来记录上一次0出现的位置，作为连续1区间的左边界</span></span><br><span class="line">        index_0 = -<span class="number">1</span></span><br><span class="line">        N, gap = <span class="built_in">len</span>(nums), <span class="number">0</span></span><br><span class="line">        <span class="comment"># 在原始数组后面多加一个0，表示区域的最大右边界</span></span><br><span class="line">        nums.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 当遇到为0的时候，取该次i作为右边界，计算两个0之间的间隔</span></span><br><span class="line">                gap = <span class="built_in">max</span>(gap, i-index_0-<span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 更新完gap之后也要把index0更新为当前的0的索引。</span></span><br><span class="line">                index_0 = i</span><br><span class="line">        <span class="keyword">return</span> gap</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        当然也可以使用1来作为计算gap的判断条件，原理是一样的</span></span><br><span class="line"><span class="string">        index_0 = -1</span></span><br><span class="line"><span class="string">        N, gap = len(nums), 0</span></span><br><span class="line"><span class="string">        for i in range(N):</span></span><br><span class="line"><span class="string">            if nums[i] == 1:</span></span><br><span class="line"><span class="string">                gap = max(gap, i-index_0)</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">                index_0 = i</span></span><br><span class="line"><span class="string">        return gap</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><span id="2.2.1.4"></span>  </p><h3 id="2-2-1-4-除自身以外数组的乘积"><a href="#2-2-1-4-除自身以外数组的乘积" class="headerlink" title="2.2.1.4 除自身以外数组的乘积"></a>2.2.1.4 除自身以外数组的乘积</h3><p><a href="https://leetcode.cn/problems/product-of-array-except-self/">LeetCode 238.除自身以外数组的乘积</a> | | <a href="#2.2.1">返回2.2.1目录</a>    </p><font color="#3399FF">方案：最简单的做法就是先求所有元素的积，然后每遍历一个位置就除以该位置的值。但是题目规定不能使用除法！这也是为了避免出现0元素作为除数的情况。那么参考【2.2.2  寻找数组的中心下标】，我们可以维护两个状态，对于每一个位置，存储该数左侧全部元素的积，和右侧全部元素的积。由于不能使用除法，只好将这两个状态分别存入两个数组中，反正题目也没有要求空间复杂度。最终用了2次for循环，2个额外数组。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        l, r = [<span class="number">1</span>]*N, [<span class="number">1</span>]*N</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 原始数据从下表1开始遍历，因为0位置上的左侧积默认是1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N):</span><br><span class="line">            <span class="comment"># 对于i位置的左侧积，就是 i-1位置的左侧积，乘以 i-1 位置的值</span></span><br><span class="line">            l[i] = l[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>]</span><br><span class="line">            i2 = N-i</span><br><span class="line">            <span class="comment"># 同时倒着取索引，计算右侧积</span></span><br><span class="line">            r[i2-<span class="number">1</span>] = r[i2]*nums[i2]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [l[i]*r[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br></pre></td></tr></table></figure><font color="#3399FF">方案二：此题确实有空间复杂度更低的方法。因为输出结果本来就是一个数组，是不占额外空间复杂度的，可以利用该结果数组作为中间辅助数组。> 即第一轮从左往右遍历的时候，先把每个位置的左侧积暂存到结果数组res中；> 第二次从右往左遍历，这个时候只需要用一个变量来缓存右侧积即可，将每个位置的右侧积，乘以已经缓存在res数组中的左侧积，就可得到最终结果了。最终还是只使用了2次for循环，但是没有额外用两个辅助数组，只用了一个额外变量，空间复杂度成了O(1)</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#l,r = [1]*N, [1]*N</span></span><br><span class="line">        <span class="comment"># 不使用左右缓存数组，而是直接用结果数组来缓存</span></span><br><span class="line">        res = [<span class="number">1</span>] * N</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N):</span><br><span class="line">            <span class="comment"># 照常计算左侧积</span></span><br><span class="line">            res[i] = res[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第二次从右往左遍历，初始化右侧积 R_mul 为1</span></span><br><span class="line">        R_mul = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N-<span class="number">1</span>,-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># j 位置结果 = 缓存的 j 位置左侧积 * 右侧积</span></span><br><span class="line">            res[j] = res[j]*R_mul</span><br><span class="line">            <span class="comment"># 更新下一位置的右侧积</span></span><br><span class="line">            R_mul *= nums[j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.2.2"></span>  </p><h2 id="2-2-2-二维数组相关题目"><a href="#2-2-2-二维数组相关题目" class="headerlink" title="2.2.2 二维数组相关题目"></a>2.2.2 二维数组相关题目</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/rotate-image">LeetCode 48.旋转图像</a></td><td><a href="#2.2.2.1">题解2.2.2.1</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/diagonal-traverse/description/">LeetCode 498.对角线遍历</a></td><td><a href="#2.2.2.2">题解2.2.2.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/spiral-matrix">LeetCode 54. 螺旋矩阵</a></td><td><a href="#2.2.2.3">题解2.2.2.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/spiral-matrix-ii">LeetCode 59. 螺旋矩阵II</a></td><td><a href="#2.2.2.4">题解2.2.2.4</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/set-matrix-zeroes/">LeetCode 73. 矩阵置零</a></td><td><a href="#2.2.2.5">题解2.2.2.5</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/game-of-life">LeetCode 289. 生命游戏</a></td><td><a href="#2.2.2.6">题解2.2.2.6</a></td></tr></tbody></table></div><p><span id="2.2.2.1"></span>  </p><h3 id="2-2-2-1-旋转图像"><a href="#2-2-2-1-旋转图像" class="headerlink" title="2.2.2.1 旋转图像"></a>2.2.2.1 旋转图像</h3><p><a href="https://leetcode.cn/problems/rotate-image">LeetCode 48.旋转图像</a> | | <a href="#2.2.2">返回2.2.2目录</a></p><font face="Times" new roman> <font color="#3399FF">方案：顺时针旋转 90°，行变成了列，列变成了行。原来是第 _i_ 行, 现在就是 倒数 第 _i_ 列 (_N_-1-_i_)；原来是第 _j_ 列, 现在到了第 _j_ 行。对于原有的一个元素 _M[i][j]_, 旋转后出现在 <b>倒数</b> 第 _i_ 列的第 _j_ 行位置：_M[j][N-1-i]_对应四个位置上的元素的变化：  _M[N-1-j][i] --> M[i][j] --> M[j][N-1-i] --> M[N-1-i][N-1-j]_</font> </font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 转换关系 M[N-1-j][i] --&gt; M[i][j] --&gt; M[j][N-1-i] --&gt; M[N-1-i][N-1-j]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 可以发现元素互换都是在自己所在的那个圈层进行交换</span></span><br><span class="line">        <span class="comment"># 每处理完最外一圈，可以视为(待处理)矩阵缩小了一圈</span></span><br><span class="line">        <span class="comment"># 所以我们可以从外到内去处理，一共有 K圈， K = N//2</span></span><br><span class="line">        <span class="comment"># K=0时，圈层左上角是(0,0), K=1时，圈层左上角是(1,1), ...以此类推</span></span><br><span class="line">        N = <span class="built_in">len</span>(matrix)</span><br><span class="line">        K =  N // <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(K):</span><br><span class="line">            <span class="comment"># 对于每一个圈层，如果一次换4个对应位置的元素</span></span><br><span class="line">            <span class="comment"># 那么只要把该圈层的首行的每个元素都进行一次【4位置】交换</span></span><br><span class="line">            <span class="comment"># 该圈层就完成了交换了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 这里一定要注意，对于k圈层的首行，左起列是 k，右侧截止是 N-1-k</span></span><br><span class="line">            <span class="comment"># 但是最右侧那一列可以不用管，因为最后那一列的元素就是首行填充过去的</span></span><br><span class="line">            <span class="comment"># 所以右侧只用取到 N-1-k -1即可</span></span><br><span class="line">            <span class="comment"># 比如k=0时，首行如果是 1,2,3；则只需要移动元素 1及其对应4个位置的，和2及其4个对应位置的；</span></span><br><span class="line">            <span class="comment"># 不用考虑 3及其4个对应位置的数，因为3已经在元素1的4个对应位置当中处理了</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, N-<span class="number">1</span>-i):</span><br><span class="line">                matrix[i][j],     matrix[j][N-<span class="number">1</span>-i], matrix[N-<span class="number">1</span>-i][N-<span class="number">1</span>-j], matrix[N-<span class="number">1</span>-j][i] = \</span><br><span class="line">                matrix[N-<span class="number">1</span>-j][i], matrix[i][j],     matrix[j][N-<span class="number">1</span>-i],     matrix[N-<span class="number">1</span>-i][N-<span class="number">1</span>-j] </span><br><span class="line">            </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.2.2.2"></span>  </p><h3 id="2-2-2-2-对角线遍历"><a href="#2-2-2-2-对角线遍历" class="headerlink" title="2.2.2.2 对角线遍历"></a>2.2.2.2 对角线遍历</h3><p><a href="https://leetcode.cn/problems/diagonal-traverse/description/">LeetCode 498.对角线遍历</a> | | <a href="#2.2.2">返回2.2.2目录</a></p><font color="#3399FF">方案：这种矩阵遍历的问题，最关键的点就在于，如果考虑好边界条件，达到某一个边界条件之后，换方向.</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDiagonalOrder</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        m,n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        left, top, right, bottom = <span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>, m-<span class="number">1</span></span><br><span class="line">        <span class="comment"># i,j表示矩阵的i 行 j 列, k表示矩阵已经遍历了多少个元素</span></span><br><span class="line">        i, j, k = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> k &lt; m*n:</span><br><span class="line">            <span class="comment"># 朝着右上遍历</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= top <span class="keyword">and</span> j &lt;= right <span class="keyword">and</span> k &lt; m*n:</span><br><span class="line">            <span class="comment"># 当 i 未超过上边界, j 未超过右边界, k 未超过元素总数</span></span><br><span class="line">                res.append(mat[i][j])</span><br><span class="line">                i -= <span class="number">1</span> <span class="comment"># 往上移动, 故 i 减小</span></span><br><span class="line">                j += <span class="number">1</span> <span class="comment"># 往右移动, 故 j 增大</span></span><br><span class="line">                k += <span class="number">1</span> <span class="comment"># 已经遍历过一个元素</span></span><br><span class="line">            <span class="comment"># 当跳出了这个while循环时:</span></span><br><span class="line">            <span class="comment"># 1.如果是 k &lt; m*n 不满足, 可以不用管</span></span><br><span class="line">            <span class="comment"># 2.如果是 i &gt;= top 不满足, 说明上方出界, i要往下回来一行才能继续遍历</span></span><br><span class="line">            <span class="comment"># 3.如果是 j &lt;= right 不满足, 说明右侧出界, j要往左侧回来一列才能继续遍历;</span></span><br><span class="line">            <span class="comment">#   同时, 出右界, 说明刚刚那一行已经被遍历完了！！所以i即使没有越上界，依然要向下, 而且是向下两行！</span></span><br><span class="line">            <span class="comment">#   比如如果是 3行2列 的矩阵,（行多列少，j一定先出界） 就会出现这种情况</span></span><br><span class="line">            <span class="comment"># 如果是2.3都出现不满足, 说明刚刚遍历过的位置是右上角, 和情况3一样</span></span><br><span class="line">            <span class="comment"># 总结起来, 伪代码 就为 :</span></span><br><span class="line">            <span class="comment"># i = i + 1 (j没有越右界) or i + 2(j越了右界)</span></span><br><span class="line">            <span class="comment"># j = j (j没有越右界) or j - 1 (j越了右界)</span></span><br><span class="line">            i, j = (i+<span class="number">1</span>, j) <span class="keyword">if</span> (j &lt;=right) <span class="keyword">else</span> (i+<span class="number">2</span>, j-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 朝着左下遍历</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= bottom <span class="keyword">and</span> j &gt;= left <span class="keyword">and</span> k&lt;m*n:</span><br><span class="line">                res.append(mat[i][j])</span><br><span class="line">                i += <span class="number">1</span> <span class="comment"># 往下移动, 故 i 增大</span></span><br><span class="line">                j -= <span class="number">1</span> <span class="comment"># 往左移动, 故 j 减小</span></span><br><span class="line">                k += <span class="number">1</span> <span class="comment"># 已经遍历过一个元素</span></span><br><span class="line">            <span class="comment"># 分析同上（可以用3行4列的矩阵帮助思考，列多行少，i一定先出界）, 此处不赘述, 伪代码 就为 :</span></span><br><span class="line">            <span class="comment"># j = j + 1 (i没有越下界) or j + 2(i越了下界)</span></span><br><span class="line">            <span class="comment"># i = i (i没有越下界) or i - 1 (i越了下界)</span></span><br><span class="line">            j, i = (j+<span class="number">1</span>, i) <span class="keyword">if</span> (i&lt;=bottom) <span class="keyword">else</span> (j+<span class="number">2</span>, i-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.2.2.3"></span>  </p><h3 id="2-2-2-3-螺旋矩阵"><a href="#2-2-2-3-螺旋矩阵" class="headerlink" title="2.2.2.3 螺旋矩阵"></a>2.2.2.3 螺旋矩阵</h3><p><a href="https://leetcode.cn/problems/spiral-matrix">LeetCode 54. 螺旋矩阵</a> | | <a href="#2.2.2">返回2.2.2目录</a>   </p><font color="#3399FF">方案：设立四个边界值，遍历的指针碰到边界值之后，就停下来，换方向，同时更新边界值。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        i, j, k = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        left, up, right, down = <span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>, m-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(left, right+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][j])</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt;= m*n : <span class="keyword">break</span></span><br><span class="line">            up += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(up, down+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][j])</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt;= m*n : <span class="keyword">break</span></span><br><span class="line">            right -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(right, left-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][j])</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt;= m*n : <span class="keyword">break</span></span><br><span class="line">            down -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(down, up-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][j])</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt;= m*n : <span class="keyword">break</span></span><br><span class="line">            left +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.2.2.4"></span>  </p><h3 id="2-2-2-4-螺旋矩阵II"><a href="#2-2-2-4-螺旋矩阵II" class="headerlink" title="2.2.2.4 螺旋矩阵II"></a>2.2.2.4 螺旋矩阵II</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-ii">LeetCode 59. 螺旋矩阵II</a> | | <a href="#2.2.2">返回2.2.2.2目录</a>  </p><font color="#3399FF">方案：上一题中的遍历顺序搞懂了之后，这个题思路很简单，代码也差不多。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 创建一个 N*N的矩阵</span></span><br><span class="line"><span class="string">        # res = n*[n*[0]]</span></span><br><span class="line"><span class="string">        # 注意，这么写是错的，这样写的后果就是里面的每行都是来源于同一行 的copy，</span></span><br><span class="line"><span class="string">        # 会共享存储空间，属于python的浅拷贝！</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 应该这么写：</span></span><br><span class="line"><span class="string">        # res = []</span></span><br><span class="line"><span class="string">        # for i in range(n):</span></span><br><span class="line"><span class="string">        #   res.append([0]*n)</span></span><br><span class="line"><span class="string">        # 即每一行都是新创建一个 [0]*n的行，然后添加进去</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 简化为如下写法：</span></span><br><span class="line">        res = [ [<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        i, j, k = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        left, up, right, down = <span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(left, right+<span class="number">1</span>):</span><br><span class="line">                res[i][j]=k</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n*n: <span class="keyword">break</span></span><br><span class="line">            up +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(up, down+<span class="number">1</span>):</span><br><span class="line">                res[i][j]=k</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n*n: <span class="keyword">break</span></span><br><span class="line">            right -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(right, left-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res[i][j]=k</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n*n: <span class="keyword">break</span></span><br><span class="line">            down -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(down, up-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res[i][j]=k</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n*n: <span class="keyword">break</span></span><br><span class="line">            left +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.2.2.5"></span>  </p><h3 id="2-2-2-5-矩阵置零"><a href="#2-2-2-5-矩阵置零" class="headerlink" title="2.2.2.5 矩阵置零"></a>2.2.2.5 矩阵置零</h3><p><a href="https://leetcode.cn/problems/set-matrix-zeroes/">LeetCode 73. 矩阵置零</a> | | <a href="#2.2.2">返回2.2.2目录</a>   </p><font color="#3399FF">方案：我们需要知道原矩阵中哪些位置为0，如果在遍历的同时修改，那么原来不为0的元素可能会被置为0，会影响后面的元素的判断。比如如果左上角是0，在遍历的时候同时修改原数组，那么第一行和第一列的元素会全部变为0；会导致后面所有元素全部为0. 所以我们只能先遍历矩阵，然后找个地方把为0的位置先记住，然后再第二次遍历的时候进行修改。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setZeroes</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 如果在遍历的时候就修改，那么前面如果出现了0，修改完之后，后面很可能都被改为0</span></span><br><span class="line">        <span class="comment"># 所以先记住这些为0的行/列索引</span></span><br><span class="line">        <span class="comment"># 再改</span></span><br><span class="line">        </span><br><span class="line">        rows, cols = [], []</span><br><span class="line">        M, N = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">in</span> rows:</span><br><span class="line">                        rows.append(i)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> j <span class="keyword">in</span> cols:</span><br><span class="line">                        cols.append(j)</span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;注意，python的二维list不支持以下写法：</span></span><br><span class="line"><span class="string">        for i in rows:</span></span><br><span class="line"><span class="string">            matrix[i][:] =0</span></span><br><span class="line"><span class="string">        for j in cols:</span></span><br><span class="line"><span class="string">            matrix[:][j] = 0</span></span><br><span class="line"><span class="string">        这是 numpy array 才支持的写法</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> rows <span class="keyword">or</span> j <span class="keyword">in</span> cols:</span><br><span class="line">                    matrix[i][j] =<span class="number">0</span> </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;思路2.直接用第一列来记录哪一行出现过0，用第一行来记录哪一列出现过0；</span></span><br><span class="line"><span class="string">后续的元素出现0时，虽然第一行和第一列被修改了，但是第一行第一列对应的位置，按照规则本来也会被改成0. </span></span><br><span class="line"><span class="string">不过要提前记录第一行和第一列是否有0元素，有的话，最后再把他们全部变为0；没有的话就不用管&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setZeroes</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        flag_col0 = <span class="built_in">any</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m))</span><br><span class="line">        flag_row0 = <span class="built_in">any</span>(matrix[<span class="number">0</span>][j] == <span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 先用第一行和第一列来记录出现0的列和行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 根据第一行和第一列的记录，来修改原始矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">or</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 再来处理第一列</span></span><br><span class="line">        <span class="keyword">if</span> flag_col0:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 再来处理第一行</span></span><br><span class="line">        <span class="keyword">if</span> flag_row0:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p><span id="2.2.2.6"></span>  </p><h3 id="2-2-2-6-生命游戏"><a href="#2-2-2-6-生命游戏" class="headerlink" title="2.2.2.6 生命游戏"></a>2.2.2.6 生命游戏</h3><p><a href="https://leetcode.cn/problems/game-of-life">LeetCode 289. 生命游戏</a> | | <a href="#2.2.2">返回2.2.2目录</a>    </p><p><font color="#3399FF">方案：规则看起来很唬人，很多，但是就是对于每一个元素判断，判断其3*3窗口内的值，然后根据该值去改变当前元素的值，的这么一个条件判断语句。<br>另外，由于是同时发生改变，所以不能让变化后的值，影响到后面的元素的判断，所以也要先找一个地方，记录状态，和上题一样，只不过这里直接拷贝一个矩阵，拿他来记录原始状态</font>。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gameOfLife</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 因为是同时发生的，所以我们不能在原有矩阵上直接修改</span></span><br><span class="line">        <span class="comment"># 而是参照原有矩阵的值，对一个新的矩阵的值进行判定</span></span><br><span class="line">        <span class="comment"># 二维数组的 深度拷贝的方式有以下几种，不能直接用 = 号去拷贝，那样是python的浅拷贝，会共享存储区域</span></span><br><span class="line">        <span class="keyword">import</span> copy</span><br><span class="line">        copy_board = copy.deepcopy(board)</span><br><span class="line">        <span class="comment"># copy_board = [copy.deepcopy(row) for row in board]</span></span><br><span class="line">        <span class="comment"># copy_board = [[board[i][j] for j in range(n)] for i in range(m)]</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># left: max(0, j-1), right: min(n, j+1+1), top: max(0, i-1), bottom: min(m, i+1+1)</span></span><br><span class="line">                <span class="keyword">if</span> copy_board[i][j] == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 如果原始状态是1，进入下面的规则</span></span><br><span class="line">                    <span class="comment"># 由于我们要算周围8个格子的和</span></span><br><span class="line">                    <span class="comment"># 先将初始值置为-1，这样就直接考虑9宫格的和（相当于减去当前元素1）</span></span><br><span class="line">                    area_sum = -<span class="number">1</span></span><br><span class="line">                    <span class="comment"># 然后就是如何遍历以当前元素为中心的9宫格的问题了</span></span><br><span class="line">                    <span class="comment"># 理想情况下，i的遍历范围[i-1, i+1 +1), j的遍历范围 [j-1, j+1 +1)</span></span><br><span class="line">                    <span class="comment"># 但是要考虑格子本身就在矩阵边界的情况，所以:</span></span><br><span class="line">                    <span class="comment"># 上边界最小只能到 0: 取max(0, i-1); 左边界最小只能到 0: 取max(0, j-1)</span></span><br><span class="line">                    <span class="comment"># 下边界最大只能到 m: 取min(m, i+1 +1); 右边界最大只能到 n：取min(n, j+1 +1);</span></span><br><span class="line">                    <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(<span class="number">0</span>,i-<span class="number">1</span>), <span class="built_in">min</span>(m,i+<span class="number">1</span> +<span class="number">1</span>)):</span><br><span class="line">                        <span class="keyword">for</span> q <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(<span class="number">0</span>,j-<span class="number">1</span>), <span class="built_in">min</span>(n, j+<span class="number">1</span> +<span class="number">1</span>)):</span><br><span class="line">                            area_sum += copy_board[p][q]</span><br><span class="line">                    <span class="keyword">if</span> area_sum &lt; <span class="number">2</span>:</span><br><span class="line">                        board[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">elif</span> area_sum &gt; <span class="number">3</span>:</span><br><span class="line">                        board[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果原始状态是0，进入下面的规则</span></span><br><span class="line">                    area_sum = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(i-<span class="number">1</span>,<span class="number">0</span>), <span class="built_in">min</span>(m,i+<span class="number">1</span>+<span class="number">1</span>)):</span><br><span class="line">                        <span class="keyword">for</span> q <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(<span class="number">0</span>,j-<span class="number">1</span>), <span class="built_in">min</span>(n, j+<span class="number">1</span>+<span class="number">1</span>)):</span><br><span class="line">                            area_sum += copy_board[p][q]</span><br><span class="line">                    <span class="keyword">if</span> area_sum == <span class="number">3</span>:</span><br><span class="line">                        board[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2-1 顺序表</title>
      <link href="/Data-Structure/DS_21_SeqList.html"/>
      <url>/Data-Structure/DS_21_SeqList.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1"> <h1 id="2-1-顺序表"><a href="#2-1-顺序表" class="headerlink" title="2-1 顺序表"></a>2-1 顺序表</h1><hr style="border:solid; height:1px; color=#000000 size=1">   <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>2.1.1</td><td><a href="#2.1.1">线性表的概念</a></td></tr><tr><td>2.1.2</td><td><a href="#2.1.2">顺序表</a></td></tr><tr><td>2.1.3</td><td><a href="#2.1.3">Python中的顺序表</a></td></tr><tr><td>2.1.4</td><td><a href="#2.1.4">Python中list内置操作的时间复杂度</a></td></tr></tbody></table></div><p><span id="2.1.1"></span>  </p><h2 id="2-1-1-线性表的概念"><a href="#2-1-1-线性表的概念" class="headerlink" title="2.1.1 线性表的概念"></a>2.1.1 线性表的概念</h2><p>线性表<font face="Times" new roman>（linear list）</font>是数据结构的一种，一个线性表是n个具有相同特性的数据元素构成的有限序列，<b>其中的元素的前驱和后置都最多只有一个</b>。<br>线性表是最基本、最简单、也是最常用的一种数据结构。我们说“线性”和“非线性”，只在逻辑层次上讨论，而不考虑存储层次，所以常见的线性表包括：顺序表、栈和队列、链表。<br>线性表通常都具有：初始化、遍历、求长度和增删改查这些操作。  </p><p><span id="2.1.2"></span>   </p><h2 id="2-1-2-顺序表"><a href="#2-1-2-顺序表" class="headerlink" title="2.1.2 顺序表"></a>2.1.2 顺序表</h2><p>顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储区域，将数据元素顺序地存储在其中，就形成一个顺序表。<br>元素间的顺序关系由它们的存储顺序自然的表示。  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/2_1.webp" width="90%">  </p><p>顺序表的两种形式如图所示；<br>a) 是直接存储元素，这就要求元素的类型相同了，因为不同类型的元素占据的字节数是不一样的；<br>b) 是存储的地址，地址指向的是一些元素，由于地址本身这个类型（比如C++中的指针类型）占据的字节是固定的，所以可以存在顺序表中，这些地址指向的具体的位置，存放的元素又可以是不同的类型。  </p><p><span id="2.1.3"></span>  </p><h2 id="2-1-3-Python中的顺序表"><a href="#2-1-3-Python中的顺序表" class="headerlink" title="2.1.3 Python中的顺序表"></a>2.1.3 Python中的顺序表</h2><p>Python标准类型list（列表，就是一种线性表。但是比较特殊，它是一种元素个数可变的线性表。这种顺序表被称为【<strong>动态顺序表</strong>】，因其容量可以在使用过程中动态变化。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;执行以下code，你会发现list中相同的数:1, 竟然指向的是同一个地址</span></span><br><span class="line"><span class="string">这就跟C/C++的传统印象有区别&#x27;&#x27;&#x27;</span></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(nums[i]))</span><br><span class="line"></span><br><span class="line">nums[<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;#&#x27;</span>*<span class="number">14</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(nums[i]))</span><br><span class="line"><span class="comment">##### output ######</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073360</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073424</span></span><br><span class="line"><span class="string">##############</span></span><br><span class="line"><span class="string">1638490265040</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073360</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073424</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>Python 中的 list 的是一种 <u>采用分离式技术实现的动态顺序表</u> ，在建立空列表的时候，系统分配一块能容纳8个元素的存储区；在执行插入操作时(insert/append)，如果元素存储区满了，就换一块4倍大的存储区。但是如果当list的规模已经较大时，（目前阈值为50000），就换一块2倍大的存储区，避免出现过多的空闲存储位置。<br>Python 中的另一个顺序表，就是 tuple（元组），元组就不可以改变值了。</p><p><span id="2.1.4"></span>   </p><h2 id="2-1-4-Python中list内置操作的时间复杂度"><a href="#2-1-4-Python中list内置操作的时间复杂度" class="headerlink" title="2.1.4 Python中list内置操作的时间复杂度"></a>2.1.4 Python中list内置操作的时间复杂度</h2><div class="table-container"><table><thead><tr><th>操作</th><th>时间复杂度</th><th>举例</th></tr></thead><tbody><tr><td>a[ ]</td><td>O(1)</td><td>a[1]</td></tr><tr><td>pop()</td><td>O(1)</td><td>a.pop()</td></tr><tr><td>pop(i)</td><td>O(N)</td><td>a.pop(0)</td></tr><tr><td>insert(i,item)</td><td>O(N)</td><td>a.insert(3,100)</td></tr><tr><td>del</td><td>O(N)</td><td>del a[3]</td></tr><tr><td>len</td><td>O(N)</td><td>len(a)</td></tr><tr><td>iteration</td><td>O(N)</td><td>for x in a: print x</td></tr><tr><td>contains(in)</td><td>O(N)</td><td>3 in a</td></tr><tr><td>get slice[x:y]</td><td>O(k)</td><td>a[3:7]</td></tr><tr><td>del slice</td><td>O(N)</td><td>del a[3:7]</td></tr><tr><td>set slice</td><td>O(k+N)</td><td>a[3:7]=[3,4,5,6]</td></tr><tr><td>reverse</td><td>O(N)</td><td>a.reverse()</td></tr><tr><td>concatenate</td><td>O(k)</td><td>[1, 2, 3] + [4, 5, 6]</td></tr><tr><td>sort</td><td>O(nlogN)</td><td>a.sort()</td></tr><tr><td>multiply</td><td>O(kN)</td><td>[‘Hi!’] * 4</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1-1 数据结构与算法</title>
      <link href="/Data-Structure/DS_11_data_structure.html"/>
      <url>/Data-Structure/DS_11_data_structure.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1"> <h1 id="1-1-数据结构与算法"><a href="#1-1-数据结构与算法" class="headerlink" title="1-1 数据结构与算法"></a>1-1 数据结构与算法</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>1.1.1</td><td><a href="#1.1.1">数据结构与算法</a></td></tr><tr><td>1.1.2</td><td><a href="#1.1.2">算法</a></td></tr><tr><td>1.1.3</td><td><a href="#1.1.3">程序</a></td></tr></tbody></table></div><p><span id="1.1.1"></span>  </p><h2 id="1-1-1-数据结构"><a href="#1-1-1-数据结构" class="headerlink" title="1.1.1 数据结构"></a>1.1.1 数据结构</h2><p>数据结构是讨论计算机系统中 <font color="red"> 数据的存储、组织形式 及其 相互关系</font>。  </p><ul><li>数据：客观事物 采用计算机进行识别、存储和加工所进行的描述  </li><li>结构：事物间的相互关系和约束  </li><li>数据结构的基本单元是数据元素  </li></ul><p>数据结构的3个层次：<b>① 数据的逻辑结构；② 数据的存储结构；③ 数据的运算结构(操作集合)。</b>  </p><table border="1" align="center">    <tr>        <td rowspan="3"> ①逻辑结构</td>        <td colspan="2">            反映数据 元素之间 的 逻辑关系 的结构。<br>            逻辑关系是指数据元素之间的<b>前后间关系</b>，而与他们在计算机中的存储位置无关。        </td>    </tr>    <tr>        <td> 线性结构 </td>        <td>             有且仅有一个开始元素和终点元素;<br>            且所有数据元素最多只有一个直接前趋和一个直接后继。<br>             比如 线性表。         </td>    </tr>    <tr>        <td> 非线性结构 </td>        <td>             一个元素可能有多个直接前趋和多个直接后继。<br>            比如 树结构、图结构。        </td>    </tr>    <tr>        <td rowspan="2"> ②存储结构 </td>        <td colspan="2">             数据的逻辑结构在计算机存储空间中的存放形式称为数据的存储结构。<br>            (也称为物理结构)        </td>    </tr>    <tr>        <td colspan="2">            反应数据元素在计算机中的存储方案。<br>            比如：顺序存储、链接存储、索引存储、散列存储。        </td>    </tr>    <tr>        <td rowspan="7"> ③运算结构</td>        <td colspan="2">             数据结构的操作集合        </td>    </tr>    <tr>        <td>  遍历 </td>        <td>  在数据结构的各个元素中移动，或查看所有元素。</td>    </tr>      <tr>        <td>  插入<font color="red">(增)<font> </font></font></td>        <td>  往数据结构中 添加新的元素。</td>    </tr>     <tr>        <td>  删除<font color="red">(删)<font> </font></font></td>        <td>  把指定的数据结构元素移除。</td>    </tr>     <tr>        <td>  更新<font color="red">(改)<font> </font></font></td>        <td>  修改 或 替换数据结构中的 一个或多个元素。</td>    </tr>     <tr>        <td>  查找<font color="red">(查)<font> </font></font></td>        <td>  在数据结构中找寻满足一定条件的数据元素。</td>    </tr>     <tr>        <td>  排序 </td>        <td>  在保持数据结构中元素个数不变的前提条件下，把元素按照指定的顺序重新排列，排序一般是针对线性逻辑结构。</td>    </tr> </table>  <p><span id="1.1.2"></span>  </p><h2 id="1-1-2-算法"><a href="#1-1-2-算法" class="headerlink" title="1.1.2 算法"></a>1.1.2 算法</h2><p>指为解决特定问题 的 有穷的 操作规则 的集合。  </p><table>    <th colspan="2"> 算法的 5 个基本特性 </th>    <tr>        <td> ①有穷性 </td>        <td> 有始有终，不会无限循环，且执行时间可接受。 </td>    </tr>    <tr>        <td> ②确定性 </td>        <td> 算法操作的每一步，其顺序和内容都唯一确定，不会出现二义性。 </td>    </tr>    <tr>        <td> ③数据输入 </td>        <td> 算法具有0个或多个输入。 </td>    </tr>    <tr>        <td> ④数据输出 </td>        <td> 算法至少有一个输出。</td>    </tr>    <tr>        <td> ⑤可行性 </td>        <td> 算法任一步操作都是可以付诸实践的。 </td>    </tr></table>  <p>算法点的效率可分为 时间效率 和 空间效率。  </p><table>    <tr>        <td>             空间复杂度<br>            <font face="Times" new roman> <i>S(n)=O(f(n))</i> </font>        </td>        <td colspan="4">            除开存储数据结构本身外（比如指令、常数、变量 和输入数据），实现算法所需要的额外辅助空间有多少。        </td>    </tr>        <td rowspan="5">             时间复杂度<br>            <font face="Times" new roman> <i>T(n)=O(f(n))</i> </font>        </td>        <td colspan="4">            执行算法所需要的时间以 常数时间操作 的数量级来表示。<br>            相同规模的不同输入，仍可能导致算法的运行时间不同。<br>            <b>一般使用算法最坏情况下的的复杂度来做代表。</b>        </td>    <tr>        <td colspan="4">            常数时间操作是指我们在写代码的时候会涉及到一些指令,这些执令都是固定时间的操作。<br>这些指令是和数据量没有关系的,比如加、减、乘、除、模、位移运算,又或者数组的寻址。        </td>    </tr>    <tr>        <td colspan="4">            不同的机器常数时间操作不一样，比如新一代的机器可能性能更好，常数时间操作更短。<br>但是我们用常数时间操作的数量级（而非具体的数值）来衡量时间复杂度的话，就可以忽略机器的因素，而聚焦到算法本身上来。        </td>    </tr>    <tr>        <td colspan="4">            时间复杂度可以用T(n)的自然特性加以区分，如下：        </td>    </tr>    <tr>        <td> 常量时间 O(1) </td>        <td> 线性时间 O(n) </td>        <td> 对数时间 O(logn) </td>        <td> 指数时间 O(n**2) </td>    </tr></table>  <p>Python 中的 <code>timeit</code> 模块可以来测试代码的执行时间，网上有很多资料,这里不赘述。<br>时间复杂度大致上有以下的大小关系：  </p><p>O(1) &lt; O(logN) &lt; O(logN^2) &lt; O(N) &lt; O(N*logN) &lt; O(N^2) &lt; O(N^3)&lt; …&lt;O(N^k)<br>…  &lt; O( 2^N) &lt; O(3^N)  &lt; … &lt; O(k^N) &lt; O(N!)  </p><p>可以通过数学函数图像来加深理解。  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/1_1_math_func_img.webp" width="60%">   </p><p><span id="1.1.3"></span>  </p><h2 id="1-1-3-程序"><a href="#1-1-3-程序" class="headerlink" title="1.1.3 程序"></a>1.1.3 程序</h2><p>程序 = 算法 + 数据结构                —— 尼古拉斯·沃斯<br><b> <font color="red">Algorithm + Data Structures = Programs </font>   ——  Niklaus Wirth，1984 图灵奖 <B></B></b></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法_Python</title>
      <link href="/Data-Structure/DS_00_introduction.html"/>
      <url>/Data-Structure/DS_00_introduction.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p>本系列文章以Python语言为基础，简要介绍基本的数据结构与算法的相关知识。<br>并配合 <a href="https://leetcode.cn/">LeetCode</a> 网站的一些题目来加深相关概念的了解。<br><b><font color="red">注意！由于版权原因，本系列文章在引用LeetCode的题目时，只提供官方页面的跳转链接，而不会直接展示题目信息。</font></b> </p><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><h2 id="1-1-数据结构与算法"><a href="#1-1-数据结构与算法" class="headerlink" title="1-1 数据结构与算法"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_11_data_structure.html">1-1 数据结构与算法</a></h2><h2 id="2-1-顺序表"><a href="#2-1-顺序表" class="headerlink" title="2-1 顺序表"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_21_SeqList.html">2-1 顺序表</a></h2><h2 id="2-2-数组相关题目"><a href="#2-2-数组相关题目" class="headerlink" title="2-2 数组相关题目"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_22_array_exercises.html">2-2 数组相关题目</a></h2><h2 id="2-3-数组双指针"><a href="#2-3-数组双指针" class="headerlink" title="2-3 数组双指针"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_23_array_double_pointer_exercises.html">2-3 数组双指针</a></h2><h2 id="3-1-排序"><a href="#3-1-排序" class="headerlink" title="3-1 排序"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_31_sort_algorithm.html">3-1 排序</a></h2><h2 id="3-2-快速排序讨论"><a href="#3-2-快速排序讨论" class="headerlink" title="3-2 快速排序讨论"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_32_quick_sort_discussion.html">3-2 快速排序讨论</a></h2><h2 id="3-3-排序相关题目"><a href="#3-3-排序相关题目" class="headerlink" title="3-3 排序相关题目"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_33_sort_exercises.html">3-3 排序相关题目</a></h2><h2 id="4-1-字符串"><a href="#4-1-字符串" class="headerlink" title="4-1 字符串"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_41_string.html">4-1 字符串</a></h2><h2 id="4-2-字符串相关题目"><a href="#4-2-字符串相关题目" class="headerlink" title="4-2 字符串相关题目"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_42_string_exercises.html">4-2 字符串相关题目</a></h2><h2 id="5-1-栈和队列"><a href="#5-1-栈和队列" class="headerlink" title="5-1 栈和队列"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_51_stack_and_queue.html">5-1 栈和队列</a></h2><h2 id="5-2-栈和队列相关题目"><a href="#5-2-栈和队列相关题目" class="headerlink" title="5-2 栈和队列相关题目"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_52_stack_and_queue_exercises.html">5-2 栈和队列相关题目</a></h2><h2 id="6-1-链表"><a href="#6-1-链表" class="headerlink" title="6-1 链表"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_61_link_list.html">6-1 链表</a></h2><h2 id="6-2-链表相关题目"><a href="#6-2-链表相关题目" class="headerlink" title="6-2 链表相关题目"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_62_link_list_exercises.html">6-2 链表相关题目</a></h2><h2 id="7-1-树"><a href="#7-1-树" class="headerlink" title="7-1 树"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_71_tree.html">7-1 树</a></h2><h2 id="7-2-树相关的题目"><a href="#7-2-树相关的题目" class="headerlink" title="7-2 树相关的题目"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_72_tree_exercises.html">7-2 树相关的题目</a></h2><h2 id="8-1-图"><a href="#8-1-图" class="headerlink" title="8-1 图"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_81_graph.html">8-1 图</a></h2><h2 id="8-2-图相关题目"><a href="#8-2-图相关题目" class="headerlink" title="8-2 图相关题目"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_81_graph.html">8-2 图相关题目</a></h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图像分割测试用例</title>
      <link href="/Computer-Vision/Image-Segmentation-By-Deeplearning/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.html"/>
      <url>/Computer-Vision/Image-Segmentation-By-Deeplearning/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.html</url>
      
        <content type="html"><![CDATA[<p>图像分割测试用例</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 深度学习下的图像分割 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习导论</title>
      <link href="/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA.html"/>
      <url>/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA.html</url>
      
        <content type="html"><![CDATA[<p>机器学习导论</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
