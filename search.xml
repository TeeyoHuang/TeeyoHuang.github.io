<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>7-pandas数据分组聚合合并</title>
      <link href="/Pandas-Base/PD_07_Pandas_Senior_Data_Operations.html"/>
      <url>/Pandas-Base/PD_07_Pandas_Senior_Data_Operations.html</url>
      
        <content type="html"><![CDATA[<!-- <img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width=70%>   --><p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%"></p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="7-pandas数据分组聚合合并"><a href="#7-pandas数据分组聚合合并" class="headerlink" title="7.pandas数据分组聚合合并"></a>7.pandas数据分组聚合合并</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p>Pandas 处理数据时，常常会对数据分成若干个组，然后对各个组进行数据处理，比如求和、求平均值等，最后再将各个组的数据汇总起来形成一个新的数据集，这个过程通常被描述为“split-apply-combine” 。 </p><p>所以本篇要讲的就是 Pandas 中涉及 分组、聚合、合并的一些操作。  </p><p>在本章中依然使用 wine dataset 数据集：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#  nrows=6 表示仅仅读取前10行, 并且只使用 usecols 来限定只取部分列数据</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./datasets/wine&#x27;</span>, nrows=<span class="number">10</span>, usecols=[<span class="string">&#x27;citric acid&#x27;</span>, <span class="string">&#x27;chlorides&#x27;</span>, <span class="string">&#x27;density&#x27;</span>, <span class="string">&#x27;pH&#x27;</span>, <span class="string">&#x27;sulphates&#x27;</span> , <span class="string">&#x27;alcohol&#x27;</span>, <span class="string">&#x27;quality&#x27;</span>])</span><br><span class="line"><span class="comment"># 使用 rename 来修改一下 行索引和列索引, 使其更精简</span></span><br><span class="line">df.rename(<span class="built_in">dict</span>([(i, <span class="string">f&#x27;第<span class="subst">&#123;i&#125;</span>行&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> df.index]), inplace=<span class="literal">True</span>)</span><br><span class="line">df.rename(<span class="built_in">dict</span>([(col, col[:<span class="number">4</span>]) <span class="keyword">for</span> col <span class="keyword">in</span> df.columns]), axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">df</span><br></pre></td></tr></table></figure><h2 id="7-1-分组"><a href="#7-1-分组" class="headerlink" title="7.1 分组"></a>7.1 分组</h2><h3 id="7-1-1-groupby-方法"><a href="#7-1-1-groupby-方法" class="headerlink" title="7.1.1 groupby 方法"></a>7.1.1 groupby 方法</h3><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html">groupby</a>  </p><p><code>groupby</code> 函数是 Pandas 中分组的最核心函数，其基本参数如下：  </p><ul><li><code>by</code>: 该参数用于确定 <code>groupby</code> 操作的分组依据，以是一个映射（mapping）、函数（function）、标签（label）、pd.Grouper对象或这样的对象的列表。<br><ul><li>如果<code>by</code>是一个函数，那么这个函数会被应用到对象索引的每一个值上，依据函数的返回值进行分组；</li><li>如果<code>by</code>是 dict 或 Series，则将使用dict 或 Series 的值来确定分组；</li><li>…</li></ul></li><li><code>axis</code>: 该参数用于确定 对数据沿着什么方向分组，默认为 0，即按行分组，为1时按列分组；<i>该参数在未来新版本中可能会舍弃, 改为只对行数据进行分组，如果要对列数据进行分组，可以先将DataFrame进行转置；</i>  </li><li><code>level</code>: 该参数是DataFrame具备多层索引时才会用到，用于确定对多层索引的哪一层进行分组，默认为 None，即对所有层进行分组；也可以使用整数或索引名，或者由他们组成的元组序列；  </li><li><code>as_index</code>: 该参数用于确定分组后，是否将分组的字段作为结果中的索引，默认为 True；<ul><li>当 <code>as_index=True</code> ，groupby 操作后的返回结果会以分组标签作为索引，也就是说结果 DataFrame 的索引会是每个组的标签。这是最常见的使用方式。  </li><li>当 <code>as_index=False</code> ，groupby 操作后的返回结果会以原来的 DataFrame 的结构返回，也就是说结果 DataFrame 的索引和原 DataFrame 一样，而分组标签则成为新的列（或行）数据。  </li></ul></li><li><code>sort</code>: 该参数用于确定分组后，是否对分组结果按照分组的键（依据）进行排序，默认为 True；但是不会影响分组内部数据的顺序。 如果将该参数设置为 False，一般会执行的快一点，特别是对于数据量很大的DataFrame；  </li><li><code>group_keys</code>: 当<B>调用apply</B>并且by参数产生类似索引(即转换)结果时，向索引添加组键，以使得结果更具有可读性；</li><li><code>observed</code>: 该参数决定了对于分类组器（Categorical groupers）的处理方式，用于确定是否显示观察到的值，默认为 False，即显示观察到的值；当该参数设置为 True 时，会显示未观察到的值；<i>不过该参数在2.1.0版本后被弃用</i>；</li><li><code>dropna</code>: 该参数用于确定是否删除缺失的数据，默认为 False，即不删除缺失的数据；当该参数设置为 True 时，会删除缺失的数据；</li></ul><h3 id="7-1-2-GroupBy-对象"><a href="#7-1-2-GroupBy-对象" class="headerlink" title="7.1.2 GroupBy 对象"></a>7.1.2 GroupBy 对象</h3><p><code>groupby()</code> 函数并不是直接返回一个新的 DataFrame对象，而是返回一个 <code>GroupBy</code> 对象，该对象包含关于分组的信息。  </p><p>DataFrame 应用 groupby() 之后，返回的是 <code>pandas.api.typing.DataFrameGroupBy&gt;</code> 对象； </p><p>Series 应用 groupby() 之后，返回的是 <code>pandas.api.typing.SeriesGroupBy</code> 对象； </p><p>官方文档 : <a href="https://pandas.pydata.org/docs/reference/groupby.html">GroupBy</a>  </p><p>对于 <code>GroupBy</code> 对象，并不能直接查看其数据，如下所示：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 依据 qual 列的值，对行数据进行分组</span></span><br><span class="line">df_groupby = df.groupby(by=<span class="string">&#x27;qual&#x27;</span>)</span><br><span class="line">df_groupby</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/7_1_2.png" width="70%"></p><p>如果要查看 GroupBy 对象的信息，可以使用以下方法：  </p><ol><li><b>当作迭代器使用</b>  </li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 会依次产出各个分组的 name 和 分组后的 DataFrame 子集</span></span><br><span class="line"><span class="keyword">for</span> group_name, data <span class="keyword">in</span> df_groupby:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Group Name: <span class="subst">&#123;group_name&#125;</span>\n<span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/7_1_2_1.png" width="45%">  </p><ol><li><b>groups 方法</b>  </li></ol><p>会返回一个字典，字典的键为分组的组名，值为分组后聚在一起的标签：{group name : group labels}  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dict &#123;group name -&gt; group labels&#125;.</span></span><br><span class="line">df_groupby.groups</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/7_1_2_2.png" width="100%"> </p><ol><li><b>indices 方法</b>  </li></ol><p>会返回一个字典，字典的键为分组的组名，值为分组后聚在一起的数据的序号：{group name : group indices}  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dict &#123;group name -&gt; group indices&#125;.</span></span><br><span class="line">df_groupby.indices</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/7_1_2_3.png" width="45%">  </p><ol><li><b>get_group 方法</b>   </li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取 分组名为 5 的部分</span></span><br><span class="line">df_groupby.get_group(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/7_1_2_4.png" width="45%">  </p><h3 id="7-1-3-分组示例"><a href="#7-1-3-分组示例" class="headerlink" title="7.1.3 分组示例"></a>7.1.3 分组示例</h3><p>在知道如何查看 <code>GroupBy</code> 对象之后，可以来看一下 <code>groupby()</code> 方法的使用示例。</p><ol><li><b>按标签分组示例</b>    </li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按标签分组示例, 令 by=列名</span></span><br><span class="line">df.groupby(by=<span class="string">&#x27;alco&#x27;</span>).groups</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/7_1_3_1.png" width="100%">  </p><ol><li><b>按函数分组示例</b>    </li></ol><p>by 为函数时：it’s called on each value of the object’s index. 即将 DataFrame 对象的每个index都作为函数的输入去获取输出  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按函数分组示例, 会将 DataFrame 的每个 index 作为函数的输入</span></span><br><span class="line"><span class="comment"># 该示例的函数是以每一行数据的最小值作为分组依据</span></span><br><span class="line">df.groupby(<span class="keyword">lambda</span> x: <span class="built_in">min</span>(df.loc[x])).groups</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/7_1_3_2.png" width="100%">    </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 依据每一行 的 pH 的不同范围，映射不同的分组组名</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_key</span>(<span class="params">S_, col</span>):</span><br><span class="line">    <span class="keyword">if</span> S_[col] &lt;<span class="number">3.3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;G1&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> S_[col] &gt;<span class="number">3.4</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;G2&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;G3&#x27;</span></span><br><span class="line"></span><br><span class="line">df.groupby(by=<span class="keyword">lambda</span> index: gen_key(df.loc[index], <span class="string">&#x27;pH&#x27;</span>) ).apply(<span class="keyword">lambda</span> x:x)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/7_1_3_2_b.png" width="50%">    </p><ol><li><b>表达式分组示例</b>    </li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># by 为一个表达式，此例中的表达式是判断表达式, 所以会分为 False 或者 True 两种分组</span></span><br><span class="line">df.groupby(by=df.pH&gt;<span class="number">3.3</span>).groups</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/7_1_3_3.png" width="90%">   </p><ol><li><b>as_index 示例</b>  </li></ol><p>as_index 为 False 时，分组的组名不会作为index  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.groupby(by=df.pH&gt;<span class="number">3.3</span>, as_index=<span class="literal">True</span>).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/7_1_3_4_a.png" width="40%">   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.groupby(by=df.pH&gt;<span class="number">3.3</span>, as_index=<span class="literal">False</span>).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/7_1_3_4_b.png" width="40%">   </p><ol><li><b>分组器 Grouper</b>  </li></ol><p>分组器是 pandas 提供的一个可以执行较为复杂操作的分组工具，具体用法可以参考官方文档:<a href="https://pandas.pydata.org/docs/reference/api/pandas.Grouper.html">Grouper</a><br>它在处理一些复杂结构的 DataFrame时比较高效，比如有时间序列的 DataFrame，这里不过多描述。  </p><h3 id="7-1-4-分组对象的操作"><a href="#7-1-4-分组对象的操作" class="headerlink" title="7.1.4 分组对象的操作"></a>7.1.4 分组对象的操作</h3><p>使用 groupby 方法对数据进行分组之后，可以对分组对象进行一些操作，来对各个分组的数据做进一步的处理。在 7.1.2 小节中介绍了查看分组对象的操作，这里主要是讲一下如何对分组数据进行处理的操作。 </p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/groupby.html#function-application">function-application</a>  </p><ol><li><p><b>apply</b>  </p><p> 官方文档:<a href="https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.apply.html">DataFrameGroupBy.apply</a>  </p><p> 它和 DataFrame 的 apply 方法类似，只不过 DataFrameGroupBy 的 apply 方法是对分组后每个子集上的数据进行处理。从下面的code可以清晰的分辨出二者的区别：  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 DataFrame 的 apply 方法, 默认情况下是对整个DataFrame的每列数据进行处理</span></span><br><span class="line"><span class="comment"># 所以下方的 code 是求每一列的均值</span></span><br><span class="line">df.apply(<span class="keyword">lambda</span> x:x.mean())</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/7_1_4_1_a.png" width="20%"> </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 groupby 对象的 apply 方法, 是对各个分组内的 DataFrame 进行处理</span></span><br><span class="line"><span class="comment"># 所以以下code是对 分组 5,6,7 的三个 子 DataFrame 进行处理，分别得到了 3个不同分组内 各列的数据的均值</span></span><br><span class="line">df_groupby.apply(<span class="keyword">lambda</span> x: x.mean() )</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/7_1_4_1_b.png" width="60%"> </p><p> 由于 apply 是一个非常灵活的方法，所以如果有一些特定的方法支持特定的操作，建议使用特定的操作，这样效率更高，比如上面两个code可以改写为：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">df.mean()</span><br><span class="line">df_groupby.mean()</span><br></pre></td></tr></table></figure><p> 效果不变，但是运行效率更高。  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个 根据 col 的值，取最大的两行数据的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">first_2</span>(<span class="params">sub_df_, col</span>):</span><br><span class="line"><span class="keyword">return</span> sub_df_.nlargest(<span class="number">2</span>, col)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对各个分组应用这个函数, 第一个 sub_df_ 已经由各个分组的子 DataFrame 自动传入了</span></span><br><span class="line">df_groupby.apply(first_2, <span class="string">&#x27;chlo&#x27;</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/7_1_4_1_c.png" width="50%"><br> <br></p></li><li><p><b>transform</b>  </p><p> 它对每个分组调用一个函数，并返回一个与<b> 原始 DataFrame 具有<font color="orangered">相同索引</font>的 DataFrame，并使用经过转换的值替换原来位置的值。</b>  </p><p> 官方文档:<a href="https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.transform.html">transform</a>  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 依据 qual 分组, 然后对每组的数据应用 Transform</span></span><br><span class="line">df.groupby(by=<span class="string">&#x27;qual&#x27;</span>).transform(<span class="string">&#x27;mean&#x27;</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/7_1_4_2.png" width="70%">  </p><p> 由示例结果可知，分组的组名并未被展示出来，且数据也并未按照组别进行分布，<b>还是保持了与原来 DataFrame 的 index 相同的 index</b>。 但是仔细观察的话，会发现，<b> transform 确实是对各个组内的数据来进行应用的。</b>    </p><p> 比如   </p><ul><li>[‘第0行’, ‘第1行’, ‘第2行’, ‘第4行’, ‘第5行’, ‘第6行’, ‘第9行’] 的数据是一样的，这是因为这些行在分组时，被分到了同一个组(qual=5)，  </li><li>[‘第7行’, ‘第8行’] 的数据是一样的，这是因为这两行在分组时被分到了(qual=7)，  </li><li><p>还剩一个[ ‘第3行’ ] 的数据独自成组(qual=6);  </p><p>因此，各个组分别被应用了transform(‘mean’), 求出了各个组内的行均值，<b>并且原始的行数据被该结果替换掉。</b><br><br></p></li></ul></li><li><p><b>filter</b>   </p><p> 它对每个分组调用判断标准，并返回一个布尔值，<b>用于过滤分组，只保留通过过滤的组。</b></p><p> 官方文档:<a href="https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.filter.html">DataFrameGroupBy.filter</a>   </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 条件为: 各个分组内的 chlo列均值 小于 0.07</span></span><br><span class="line">df.groupby(by=<span class="string">&#x27;qual&#x27;</span>).<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x[<span class="string">&#x27;chlo&#x27;</span>].mean() &lt; <span class="number">0.07</span>)</span><br><span class="line"><span class="comment"># 只会返回满足条件的组</span></span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/7_1_4_3_a.png" width="55%">   </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其实可以应用 apply 函数来查看过滤条件返回的bool值</span></span><br><span class="line">df.groupby(by=<span class="string">&#x27;qual&#x27;</span>).apply(<span class="keyword">lambda</span> x: x[<span class="string">&#x27;chlo&#x27;</span>].mean() &lt; <span class="number">0.07</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/7_1_4_3_b.png" width="20%">   </p><p> 如果所示，filter 当中的过滤条件就是这样的，每个组都对应了一个 bool 值。<br> <br></p></li><li><p><b>pipe</b>  </p><p> 管道函数，可以将函数作为参数，<b>将函数作用于分组后的数据</b>。pipe 方法主要是为了增加可读性和代码简洁性。  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加新列的示例函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">assign_new_col</span>(<span class="params">df_, col</span>):</span><br><span class="line">    df_[<span class="string">&#x27;testa&#x27;</span>] = df_[col]*<span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> df_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用pipe管道对分组对象连续进行函数操作</span></span><br><span class="line">df.groupby(<span class="string">&#x27;qual&#x27;</span>).pipe(<span class="keyword">lambda</span> x: x.mean()) \</span><br><span class="line">                    .pipe(assign_new,<span class="string">&#x27;alco&#x27;</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/7_1_4_4.png" width="80%">   </p></li></ol><h2 id="7-2-聚合"><a href="#7-2-聚合" class="headerlink" title="7.2 聚合"></a>7.2 聚合</h2>]]></content>
      
      
      <categories>
          
          <category> Pandas基础入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6-pandas数据进阶操作</title>
      <link href="/Pandas-Base/PD_06_Pandas_Medior_Data_Operations.html"/>
      <url>/Pandas-Base/PD_06_Pandas_Medior_Data_Operations.html</url>
      
        <content type="html"><![CDATA[<!-- <img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width=70%>   --><p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%"></p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="6-pandas数据进阶操作"><a href="#6-pandas数据进阶操作" class="headerlink" title="6.pandas数据进阶操作"></a>6.pandas数据进阶操作</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="6-1-按条件查询数据"><a href="#6-1-按条件查询数据" class="headerlink" title="6.1 按条件查询数据"></a>6.1 按条件查询数据</h2><p>在这里使用wine数据集作为示例：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#  nrows=6 表示仅仅读取前10行, 并且只使用 usecols 来限定只取部分列数据</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./datasets/wine&#x27;</span>, nrows=<span class="number">10</span>, usecols=[<span class="string">&#x27;citric acid&#x27;</span>, <span class="string">&#x27;chlorides&#x27;</span>, <span class="string">&#x27;density&#x27;</span>, <span class="string">&#x27;pH&#x27;</span>, <span class="string">&#x27;sulphates&#x27;</span> , <span class="string">&#x27;alcohol&#x27;</span>, <span class="string">&#x27;quality&#x27;</span>])</span><br><span class="line"><span class="comment"># 使用 rename 来修改一下 行索引和列索引, 使其更精简</span></span><br><span class="line">df.rename(<span class="built_in">dict</span>([(i, <span class="string">f&#x27;第<span class="subst">&#123;i&#125;</span>行&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> df.index]), inplace=<span class="literal">True</span>)</span><br><span class="line">df.rename(<span class="built_in">dict</span>([(col, col[:<span class="number">4</span>]) <span class="keyword">for</span> col <span class="keyword">in</span> df.columns]), axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">df</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_1.png" width="50%">  </p><h3 id="6-1-1-按逻辑筛选"><a href="#6-1-1-按逻辑筛选" class="headerlink" title="6.1.1 按逻辑筛选"></a>6.1.1 按逻辑筛选</h3><p>之前在第5章介绍了数据的基础查询操作，比较常用的是 <code>df[&#39;列名&#39;]</code>, <code>df.loc[&#39;索引标签&#39;]</code>, <code>df.iloc[序号]</code> 这种形式去查询数据，在使用这些查询方式时，是支持按逻辑筛选的。  </p><ol><li><p><b>逻辑运算操作</b>   </p><p>针对索引的逻辑运算，返回的结果是一个<font color="navy"><b>array类型数组，该数组由布尔值组成，在符合条件的位置是 True, 不符合条件的位置是 False。</b></font>  </p><ul><li><p>示例一  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n逻辑运算示例一：df.pH&gt;3.3 \n &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.pH&gt;<span class="number">3.3</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_1_1_1_1.png" width="35%">  </p></li><li><p>示例二  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n逻辑运算示例二：列数据逻辑判断，df.loc[:, &#x27;pH&#x27;]&gt;3.3 \n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.loc[:, <span class="string">&#x27;pH&#x27;</span>]&gt;<span class="number">3.3</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_1_1_1_2.png" width="60%">  </p></li><li><p>示例三  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n逻辑运算示例三：行数据逻辑判断，df.loc[&#x27;第2行&#x27;]&gt;0.9 \n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="string">&#x27;第2行&#x27;</span>]&gt;<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_1_1_1_3.png" width="60%">  </p></li><li><p>示例四  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n逻辑运算示例四：多个条件 and \n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>((df[<span class="string">&#x27;pH&#x27;</span>]&gt;<span class="number">3.3</span>) &amp; (df[<span class="string">&#x27;qual&#x27;</span>]==<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_1_1_1_4.png" width="50%">   </p></li><li><p>示例五  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n逻辑运算示例五：返回的是一个二维 array \n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df &gt;<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_1_1_1_5.png" width="60%"></p></li></ul></li><li><p><b>逻辑筛选操作</b>  </p><p>上面的逻辑运算操作返回的是一个布尔值数组，我们可以利用这个数组来筛选数据，<b><font color="navy">返回的是筛选后的数据</font></b>。  </p><ul><li><p>示例一：  </p><p> 逻辑运算 <code>df.pH&gt;3.3</code> 是对列数据做逻辑运算，<br> 所以是在筛选哪些行满足条件  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df.pH&gt;<span class="number">3.3</span>]</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_1_1_2_1.png" width="50%">  </p></li><li><p>示例二：  </p><p> 逻辑 <code>df.loc[:, &#39;pH&#39;]&gt;3.3</code> 是对列数据做逻辑运算，<br> 所以是在筛选哪些行满足条件  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df.loc[:, <span class="string">&#x27;pH&#x27;</span>]&gt;<span class="number">3.3</span>]</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_1_1_2_2.png" width="50%">  </p></li><li><p>示例三：  </p><p> 逻辑 <code>df.loc[&#39;第2行&#39;]&gt;0.9</code> 是对行数据做逻辑运算，<br> 所以是在筛选一行当中哪些列满足条件  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.loc[:, df.loc[<span class="string">&#x27;第2行&#x27;</span>]&gt;<span class="number">0.9</span>]</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_1_1_2_3.png" width="40%">  </p></li><li><p>示例四：  </p><p> 逻辑 <code>df.loc[:, &#39;pH&#39;]&gt;3.3</code> 和 <code>df.loc[:, &#39;qual&#39;]==5</code> 都是在操作列数据<br> 所以是在筛选哪些行满足条件  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[(df.loc[:, <span class="string">&#x27;pH&#x27;</span>]&gt;<span class="number">3.3</span>) &amp; (df.loc[:, <span class="string">&#x27;qual&#x27;</span>]==<span class="number">5</span>)]  </span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_1_1_2_4.png" width="50%">  </p></li><li><p>示例五：  </p><p> 逻辑运算是对 DataFrame 的所有元素进行计算<br> 即 elementwise 的筛选<br> 为True的位置会取，为False的位置是用NAN填充 </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df &gt;<span class="number">0.5</span>]</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_1_1_2_5.png" width="50%">   </p></li></ul></li><li><p><b>比较函数</b>  </p><p>   在上面的逻辑运算中，用到的比较大小的符号，在pandas中有设置对应的函数：  </p></li></ol><div class="table-container"><table><thead><tr><th>函数</th><th>对应符号</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.lt.html">DataFrame.lt()</a></td><td><code>&lt;</code></td><td>小于</td><td><code>df[&#39;pH&#39;].lt(3.3)</code></td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.le.html">DataFrame.le()</a></td><td><code>&lt;=</code></td><td>小于等于</td><td><code>df[&#39;pH&#39;].le(3.3)</code></td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.gt.html">DataFrame.gt()</a></td><td><code>&gt;</code></td><td>大于</td><td><code>df.gt(1.1)</code></td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.ge.html">DataFrame.ge()</a></td><td><code>&gt;=</code></td><td>大于等于</td><td><code>df.ge(1.1)</code></td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.eq.html">DataFrame.eq()</a></td><td><code>==</code></td><td>等于</td><td><code>df.eq(5.5)</code></td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.ne.html">DataFrame.ne()</a></td><td><code>!=</code></td><td>不等于</td><td><code>df.ne(3.3)</code></td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.isin.html">DataFrame.isin()</a></td><td><code>in</code></td><td>是否在</td><td><code>df[&#39;pH&#39;].isin([3.3])</code></td></tr></tbody></table></div><h3 id="6-1-2-query-条件查询"><a href="#6-1-2-query-条件查询" class="headerlink" title="6.1.2 query() 条件查询"></a>6.1.2 query() 条件查询</h3><p><code>query()</code> 函数可以对 DataFrame 进行条件查询， 返回的是筛选后的 DataFrame。<br>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.query.html">query</a></p><ul><li><p>示例一  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.query(<span class="string">&#x27;sulp &gt; 0.55&#x27;</span>) <span class="comment"># 相当于 df[df.sulp &gt; 0.55]</span></span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_1_2_1.png" width="48%">   </p></li><li><p>示例二  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.query(<span class="string">&#x27;pH &gt; alco/3&#x27;</span>) <span class="comment"># 相当于 df[df[&#x27;pH&#x27;]&gt;df[&#x27;alco&#x27;]/3]</span></span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_1_2_2.png" width="50%">   </p></li></ul><h3 id="6-1-3-filter"><a href="#6-1-3-filter" class="headerlink" title="6.1.3 filter()"></a>6.1.3 filter()</h3><p>filter 根据指定的索引<b>标签</b>（行名or列名）筛选出 DataFrame的子集。<br>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.filter.html">filter</a> </p><p>可接收参数有：  </p><ul><li><code>items</code>：list格式的列名or行名；</li><li><code>like</code>: 字符串，模糊查询;</li><li><code>regex</code>: 正则表达式，模糊查询;  </li><li><p><code>axis</code>: 0 表示行，1表示列；  </p></li><li><p>示例一  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># axis = 0 ，筛选满足条件的 行</span></span><br><span class="line">df.<span class="built_in">filter</span>(items=[<span class="string">&#x27;第0行&#x27;</span>,<span class="string">&#x27;第9行&#x27;</span> ], axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_1_3_1.png" width="50%">   </p></li><li><p>示例二  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># axis = 1 ，筛选满足条件的 列</span></span><br><span class="line">df.<span class="built_in">filter</span>(items=[<span class="string">&#x27;citr&#x27;</span>,<span class="string">&#x27;pH&#x27;</span> ], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_1_3_2.png" width="18%">   </p></li><li><p>示例三  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用模糊查询，筛选出列名中含有 s 的列</span></span><br><span class="line">df.<span class="built_in">filter</span>(like=<span class="string">&#x27;s&#x27;</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_1_3_3.png" width="23%">   </p></li><li><p>示例四  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用正则表达式模糊查询, 筛选出列名以 o结尾 的列</span></span><br><span class="line">df.<span class="built_in">filter</span>(regex=<span class="string">&#x27;o$&#x27;</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_1_3_3.png" width="23%">   </p></li></ul><h2 id="6-2-查看统计信息"><a href="#6-2-查看统计信息" class="headerlink" title="6.2 查看统计信息"></a>6.2 查看统计信息</h2><h3 id="6-2-1-描述统计信息"><a href="#6-2-1-描述统计信息" class="headerlink" title="6.2.1 描述统计信息"></a>6.2.1 描述统计信息</h3><ol><li><p><b>describe()</b>  </p><p>官方文档： <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.describe.html">describe()</a>  </p><p><code>describe</code> 是返回一个总结性的统计信息描述。可接收参数有：  </p><ul><li><code>percentiles</code>：返回分位数的参数，默认为 25%, 50%, 75%；  </li><li><code>include</code>：返回统计信息的列，默认为所有列；  </li><li><code>exclude</code>：排除的列，默认为空；</li></ul><p>会返回 DataFrame 或者 Series 的 列数据的 <b>数目、平均值、标准差、最小值、最大值、分位数（默认为 25%, 50%, 75%分位）</b></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.describe()</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_2_1.png" width="80%">  </p></li></ol><h3 id="6-2-2-统计函数"><a href="#6-2-2-统计函数" class="headerlink" title="6.2.2 统计函数"></a>6.2.2 统计函数</h3><p>DataFrame 本身还有一些数学统计函数，用来获取特定的统计信息。  </p><p>这些统计函数包含mean、median、std、var、min、max、sum、quantile等。大部分都有 axis 这个参数，表示统计数据的考察范围是行还是列。  </p><ul><li>axis 默认为0，表示将 DataFrame 看作行数据  </li><li>axis 设置为1，表示将 DataFrame 看作列数据  </li></ul><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mean.html">mean()</a></td><td>平均值</td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.median.html">median()</a></td><td>中位数</td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.std.html">std()</a></td><td>标准差</td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.var.html">var()</a></td><td>方差</td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.min.html">min()</a></td><td>最小值</td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.max.html">max()</a></td><td>最大值</td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mode.html">mode()</a></td><td>众数</td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.quantile.html">quantile()</a></td><td>分位数</td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.corr.html">corr()</a></td><td>相关系数</td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.cov.html">cov()</a></td><td>协方差</td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.kurt.html">kurt()</a></td><td>峰度</td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.skew.html">skew()</a></td><td>偏度</td></tr></tbody></table></div><p>这里展示一些值得讲的方法的示例：  </p><ol><li><p><b>mode()</b>    </p><p>官方文档： <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mode.html">mode()</a></p><p>这个是取众数，但是众数有可能不止一个值，比如一列数据中有两个数出现的次数都是最高，所以就是有两个众数，那么这个方法会返回两个众数，比如：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.mode()</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_2_2_1.png" width="50%">  </p><p>其中有两行数据的列，就是有两个众数；第二行中为NAN的列，就说明其只有一个众数，在第一行就已经显示了。  </p></li><li><p><b>quantile()</b>  </p><p>官方文档： <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.quantile.html">quantile()</a></p><p>用来计算分位数，其可接收参数为：  </p><ul><li><p><code>q</code>：分位数，默认为0.5，表示中位数;<br> 也可以接收一个数组，表示计算多个分位数，比如[0.25,0.5,0.75]表示计算三个分位数。  </p></li><li><p><code>interpolation</code>：计算分位数的插值方式，默认为linear，表示线性插值，还有nearest、lower、higher和midpoint的方式，各自代表的意思可以查看官方文档。  </p></li><li>method：考虑数据的范围，默认为’single’，即考虑各个列的数据；还可以选择’table’，即考虑整张 DataFrame 表的数据。 </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.quantile([<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>]) </span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_2_2_2.png" width="50%"></p></li></ol><ol><li><p><b>corr()</b>  </p><p>官方文档： <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.corr.html">corr()</a></p><p>计算<b>列数据</b>之间<b>两两相关</b>系数，但不会包括NA/null值；其可接收参数为：  </p><ul><li><code>method</code>：计算相关系数的类型，默认为’pearson’，还可以选择’kendall’和’spearman’；</li><li><code>min_periods</code>：表示最小样本数，默认为1，表示计算相关系数时，如果某列数据少于1个，则不参与计算；  </li><li><code>numeric_only</code>: 表示是否只计算数值类型数据<i>(Include only float, int or boolean data)</i>，默认为False，计算所有数据。  </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.corr()</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_2_2_3.png" width="80%">  </p><p>返回的 DataFrame 对象其实就是相关矩阵，其中对角线上的元素为1，表示各列与自身的相关系数。其他位置的值，表示两两列之间的相关系数。  </p><p>很明显这是一个对称矩阵，即真正有用的信息只有一半。  </p></li><li><p><b>cov()</b>  </p><p>官方文档： <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.cov.html">cov()</a></p><p>计算<b>列数据</b>之间的协方差，但不会包括NA/null值；其可接收参数为：  </p><ul><li><code>min_periods</code>：表示最小样本数，默认为1，表示计算协方差时，如果某列数据少于1个，则不参与计算;  </li><li><code>ddof</code>：自由度。在计算中使用的除数是N - ddof，其中N表示元素的数量。此参数仅在数据框中没有nan时才适用。  </li><li><code>numeric_only</code>: 表示是否只计算数值类型数据<i>(Include only float, int or boolean data)</i>，默认为False，计算所有数据.  </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.cov()</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_2_2_4.png" width="85%">  </p></li><li><p><b>kurt()</b>  </p><p>官方文档： <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.kurt.html">kurt()</a></p><p>在新版pandas中，建议使用 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.kurtosis.html">kurtosis()</a>。  </p><p>是用来计算列数据的峰度值。axis默认为0，及考虑列数据。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.kurt() <span class="comment"># 新版建议使用 df.kurtosis()</span></span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_2_2_5.png" width="20%">  </p></li><li><p><b>skew()</b>  </p><p>官方文档： <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.skew.html">skew()</a></p><p>是用来计算列数据的偏度系数（均值偏离中位数的程度）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.skew()</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_2_2_6.png" width="20%">  </p></li></ol><h2 id="6-3-数据排序"><a href="#6-3-数据排序" class="headerlink" title="6.3 数据排序"></a>6.3 数据排序</h2><h3 id="6-3-1-按索引排序-sort-index"><a href="#6-3-1-按索引排序-sort-index" class="headerlink" title="6.3.1 按索引排序-sort_index"></a>6.3.1 按索引排序-sort_index</h3><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_index.html">sort_index()</a>   </p><p><code>sort_index</code> 按照 行索引 或者 列索引来进行排序。<font color="navy"> 默认不修改原数据，返回的是排序后的新 DataFrame，可以更改 inplace 参数。</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照行索引，降序排列</span></span><br><span class="line">df.sort_index(axis=<span class="number">0</span>, ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_3_1_1.png" width="50%">  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照列索引，升序排列</span></span><br><span class="line">df.sort_index(axis=<span class="number">1</span>, ascending=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_3_1_2.png" width="50%">  </p><h3 id="6-3-2-按数据值排序-sort-values"><a href="#6-3-2-按数据值排序-sort-values" class="headerlink" title="6.3.2 按数据值排序-sort_values"></a>6.3.2 按数据值排序-sort_values</h3><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_values.html">sort_values()</a>   </p><p><code>sort_values</code> 按照数据值进行排序，通过传入的 <code>by</code> 参数来作为排序的依据。<font color="navy"> 默认不修改原数据，返回的是排序后的新 DataFrame，可以更改 inplace 参数。</font>  </p><ul><li><p>示例一：  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># by=列名，axis=0，表示依据某列的数据值，对各行进行排序</span></span><br><span class="line">df.sort_values(by=<span class="string">&#x27;alco&#x27;</span>, axis=<span class="number">0</span>, ascending=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_3_2_1.png" width="50%">  </p></li><li><p>示例二：  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># by=行名，axis=1，表示依据某行的数据值，对各列进行排序</span></span><br><span class="line">df.sort_values(by=<span class="string">&#x27;第0行&#x27;</span>, axis=<span class="number">1</span>, ascending=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_3_2_2.png" width="50%">  </p></li><li><p>示例三：  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># by=[列名1, 列名2, ..]，axis=0，</span></span><br><span class="line"><span class="comment"># 表示依据多列的数据值，对各行进行排序；</span></span><br><span class="line"><span class="comment"># 多列数据的优先级依照list中的顺序考虑</span></span><br><span class="line">df.sort_values(by=[ <span class="string">&#x27;qual&#x27;</span>,<span class="string">&#x27;pH&#x27;</span>], axis=<span class="number">0</span>, ascending=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 这个意思是优先考虑 qual 的数据值，当某两行数据的 qual 也相同时，再对比它们 pH 的数据值</span></span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_3_2_3.png" width="50%">  </p></li><li><p>示例四：  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># by=[行名1, 行名2, ...] ，axis=1，</span></span><br><span class="line"><span class="comment"># 表示依据多行的数据值，对各列进行排序</span></span><br><span class="line"><span class="comment"># 多行数据的优先级依照list中的顺序考虑</span></span><br><span class="line">df.sort_values(by=[<span class="string">&#x27;第0行&#x27;</span>, <span class="string">&#x27;第1行&#x27;</span>], axis=<span class="number">1</span>, ascending=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 这个意思是优先考虑 第0行 的数据值，当某两列数据的 第0行 也相同时，再对比它们 第1行 的数据值</span></span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_3_2_4.png" width="50%">  </p></li></ul><h3 id="6-3-3-混合排序"><a href="#6-3-3-混合排序" class="headerlink" title="6.3.3 混合排序"></a>6.3.3 混合排序</h3><p>  <code>sort_values</code> 这里的 values 其实也能是 index 的 values，即 <code>sort_values</code> 也能实现 <code>sort_index</code> 的功能；  </p><p>  比如给行索引命名后，就能取到行索引的值，然后对行索引进行排序： </p>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先给index命名, 为了避免修改原始数据，这里将新 DataFrame 赋值给df2</span></span><br><span class="line">df2 = df.rename_axis(<span class="string">&#x27;行索引&#x27;</span>, axis=<span class="number">0</span>)</span><br><span class="line">df2</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">&lt;img src=<span class="string">&#x27;https://teeyohuang.github.io/pic_bed/Pandas_Base/6_3_3_1.png&#x27;</span> width=<span class="number">50</span>%&gt;  </span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="comment"># by 参数取index 的name：&#x27;行索引&#x27;, 就能利用 索引值进行排序了</span></span><br><span class="line">df2.sort_values(by=<span class="string">&#x27;行索引&#x27;</span>, axis=<span class="number">0</span>, ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>   <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_3_3_2.png" width="50%">  </p><p>   所以，既然 sort_values 也能实现 sort_index 的功能，那么 就能同时使用 index 的值 和数据列的值进行混合排序：  </p>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用该该特性，实现混合排序，优先考虑 alco 列的数据，其次考虑行索引值</span></span><br><span class="line">df2.sort_values(by=[<span class="string">&#x27;alco&#x27;</span>, <span class="string">&#x27;行索引&#x27;</span>], axis=<span class="number">0</span>, ascending=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>   <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_3_3_3.png" width="50%"></p><h3 id="6-3-4-取最大-最小的topN数据"><a href="#6-3-4-取最大-最小的topN数据" class="headerlink" title="6.3.4 取最大/最小的topN数据"></a>6.3.4 取最大/最小的topN数据</h3><ul><li><p><b>nsmallest</b>  </p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.nsmallest.html">nsmallest</a><br> 返回数据列中前n个最小值的数据行；  </p><p> 可接收参数： </p><ul><li>n : 返回n行数据；</li><li>columns： 列名或者列名组成的list，表示排序的依据；  </li><li><p>keep：first、 last、all, 表示遇到重复数据时取哪一个，默认为all，全取（所以可能会返回超过n行）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.nsmallest(<span class="number">2</span>,<span class="string">&#x27;qual&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_3_4_1.png" width="50%"></p></li></ul></li><li><p><b>nlargest</b>   </p><p> 官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.nlargest.html">nlargest</a><br> 返回数据列中前n个最大值的数据行；  </p><p> 可接收参数：</p><ul><li>n : 同上；</li><li>columns： 同上</li><li><p>keep：同上</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.nlargest(<span class="number">2</span>,<span class="string">&#x27;alco&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_3_4_2.png" width="50%"></p></li></ul></li></ul><p>对于 df.nsmallest(n, column)，其操作相当于 df.sort_values(columns, ascending=True).head(n)；<br>对于 df.nlargest(n, column)，其操作相当于 df.sort_values(columns, ascending=False).head(n);  </p><p><b>但是使用 nsmallest 和 nlargest 函数，效率更高；</b>  </p><p>在python的优先队列 <code>heapq</code> 模块中，也提供了 <code>nsmallest</code> 和 <code>nlargest</code> 这两个函数，它们内部的原理是使用堆排序，而且不用对所有数据进行排序，时间复杂度应该是 O(klogN)，其中 k 是取的topk的值。我估计pandas这两个函数也是采用的类似的方法，所以效率会更高。</p><h2 id="6-4-数据掩膜"><a href="#6-4-数据掩膜" class="headerlink" title="6.4 数据掩膜"></a>6.4 数据掩膜</h2><h3 id="6-4-1-where"><a href="#6-4-1-where" class="headerlink" title="6.4.1 where"></a>6.4.1 where</h3><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.where.html">where</a>    </p><p>给予一个判断条件，<code>where</code> 对 DataFrame 中<b>不满足条件的地方</b>进行处理，一般是<b>替换为某值</b>，该值可以由用户输入，默认使用NaN。 </p><p>主要参数简介：  </p><ul><li><code>cond</code>： 布尔类型，表示判断条件；  </li><li><code>other</code>： 表示不满足条件的位置用什么值进行替代，默认为NaN；</li><li><code>inplace</code>： 表示是否修改原数据，默认为False；  </li><li><code>axis</code>： 表示对行还是对列进行操作，默认为0，表示对行进行操作；</li><li><code>level</code>： 表示对多层索引进行操作，默认为None，表示对所有索引进行操作；  </li></ul><ol><li><p>示例一：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不满足条件的地方默认为 NaN</span></span><br><span class="line">df.where(df&gt;<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_4_1_1.png" width="50%">  </p></li><li><p>示例二：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以用自己指定的值来填充不满足条件的位置</span></span><br><span class="line">df.where(df&gt;<span class="number">0</span>,<span class="string">&#x27;不满足条件的位置&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_4_1_2.png" width="50%">  </p></li><li><p>示例三：  </p><p>判断条件不一定非得是对于整个DataFrame的element-wise的条件<br>也可以用之前提到的 关于 行或者列 的逻辑运算条件<br>比如下例就是使用 pH 值是否大于3.3来对行数据进行操作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.where(df.pH&gt;<span class="number">3.3</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_4_1_3.png" width="50%"></p></li><li><p>示例四：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#同样对不满足条件的行/或者列可以用指定值填充</span></span><br><span class="line">df.where(df.pH&gt;<span class="number">3.3</span>, <span class="string">&#x27;99999&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_4_1_4.png" width="55%">  </p></li><li><p>示例五：  </p><p>上面的例子都是使用一个标量(比如字符串/一个数值)来进行替换，实际上，并不局限于使用标量，也可以使用 Series 或者 DataFrame 来进行替换：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用于填充的值不一定非得是一个标量，也可以是一个Series/DataFrame</span></span><br><span class="line">df.where(df.pH&gt;<span class="number">3.3</span>, pd.Series(&#123;<span class="string">&#x27;citr&#x27;</span>:-<span class="number">1</span>, <span class="string">&#x27;chlo&#x27;</span>:-<span class="number">2</span>, <span class="string">&#x27;dens&#x27;</span>:-<span class="number">3</span>, <span class="string">&#x27;pH&#x27;</span>:-<span class="number">4</span>, <span class="string">&#x27;sulp&#x27;</span>:-<span class="number">5</span>, <span class="string">&#x27;alco&#x27;</span>:-<span class="number">6</span>, <span class="string">&#x27;qual&#x27;</span>:-<span class="number">7</span>&#125;), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_4_1_5.png" width="50%"></p></li></ol><h3 id="6-4-2-mask"><a href="#6-4-2-mask" class="headerlink" title="6.4.2 mask"></a>6.4.2 mask</h3><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mask.html">mask</a>  </p><p><code>mask</code> 操作与 <code>where</code> 操作是对偶操作，只不过 <code>where</code> 是对<b>不满足条件</b>的地方填充，而 <code>mask</code> 是对 <b><font color="orangered">满足条件</font></b>的地方进行填充。  </p><ol><li><p>示例一：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 满足条件的地方默认为 NaN</span></span><br><span class="line">df.mask(df&gt;<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_4_2_1.png" width="50%">  </p></li><li><p>示例二：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以用自己指定的值来填充 满足条件 的位置</span></span><br><span class="line">df.mask(df&gt;<span class="number">0</span>,<span class="string">&#x27;满足条件&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_4_2_2.png" width="70%">  </p></li><li><p>示例三：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 满足条件的行数据被遮掩</span></span><br><span class="line">df.mask(df.pH&gt;<span class="number">3.3</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_4_2_3.png" width="50%">  </p></li><li><p>示例四：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 满足条件的行数据被填充替换</span></span><br><span class="line">df.mask(df.pH&gt;<span class="number">3.3</span>, <span class="string">&#x27;99999&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_4_2_4.png" width="55%">  </p></li><li><p>示例五：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 满足条件的行数据被填充替换</span></span><br><span class="line">df.mask(df.pH&gt;<span class="number">3.3</span>, pd.Series(&#123;<span class="string">&#x27;citr&#x27;</span>:-<span class="number">1</span>, <span class="string">&#x27;chlo&#x27;</span>:-<span class="number">2</span>, <span class="string">&#x27;dens&#x27;</span>:-<span class="number">3</span>, <span class="string">&#x27;pH&#x27;</span>:-<span class="number">4</span>, <span class="string">&#x27;sulp&#x27;</span>:-<span class="number">5</span>, <span class="string">&#x27;alco&#x27;</span>:-<span class="number">6</span>, <span class="string">&#x27;qual&#x27;</span>:-<span class="number">7</span>&#125;), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_4_2_5.png" width="50%"></p></li></ol><h2 id="6-5-数据转换"><a href="#6-5-数据转换" class="headerlink" title="6.5 数据转换"></a>6.5 数据转换</h2><ol><li><p><b>astype</b>  </p><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.astype.html">astype</a>  </p><p>这是最常用、最简便的一种转换数据类型方法；<br>查看 DataFrame 的数据类型：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;当前 DataFrame 的数据类型为：\n<span class="subst">&#123;df.dtypes&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_5_1_1_1.png" width="45%">  </p><p>同时转换所有元素的数据类型：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 因为不会修改原始数据，所以将修改后的DataFrame赋值给一个新的df2</span></span><br><span class="line">df2 = df.astype(<span class="string">&#x27;float32&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;当前 DataFrame 的数据类型为：\n<span class="subst">&#123;df2.dtypes&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_5_1_1_2.png" width="42%">  </p><p>根据不同的列名，指定不同的类型：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df2 = df2.astype(&#123;<span class="string">&#x27;qual&#x27;</span>:<span class="string">&#x27;int32&#x27;</span>, <span class="string">&#x27;pH&#x27;</span>:<span class="string">&#x27;float64&#x27;</span>&#125;) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;当前 DataFrame 的数据类型为：\n<span class="subst">&#123;df2.dtypes&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_5_1_1_3.png" width="42%">  </p><p>也可以对某一列Series转换类型：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对单个列数据修改类型的方法</span></span><br><span class="line">df2[<span class="string">&#x27;chlo&#x27;</span>] = df2[<span class="string">&#x27;chlo&#x27;</span>].astype(<span class="string">&#x27;str&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df2.dtypes)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_5_1_1_4.png" width="40%">  </p></li></ol><h2 id="6-6-产生数据迭代器"><a href="#6-6-产生数据迭代器" class="headerlink" title="6.6 产生数据迭代器"></a>6.6 产生数据迭代器</h2><h3 id="6-6-1-使用zip对列数据进行打包"><a href="#6-6-1-使用zip对列数据进行打包" class="headerlink" title="6.6.1 使用zip对列数据进行打包"></a>6.6.1 使用zip对列数据进行打包</h3>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将列 pH 和 alco 的数据进行打包</span></span><br><span class="line"><span class="keyword">for</span>  pH, alco <span class="keyword">in</span> <span class="built_in">zip</span>(df.pH, df.alco):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pH&#125;</span> / <span class="subst">&#123;alco&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>   <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_6_1_1.png" width="20%"></p><h3 id="6-6-2-iterrows"><a href="#6-6-2-iterrows" class="headerlink" title="6.6.2. iterrows()"></a>6.6.2. iterrows()</h3><p>   将 DataFrame 的行数据 转换为产出 (index, Series) 的迭代器。  </p><p>   官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iterrows.html">iterrows</a>  </p>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用 iterrows 生成行数据的迭代器</span></span><br><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">    <span class="comment"># 这里对每一个行数据只取 dens 列输出示例</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;index&#125;</span>:  <span class="subst">&#123;row[<span class="string">&#x27;dens&#x27;</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>   <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_6_2_1.png" width="30%"></p><h3 id="6-6-3-itertuples"><a href="#6-6-3-itertuples" class="headerlink" title="6.6.3. itertuples()"></a>6.6.3. itertuples()</h3><p>   将 DataFrame 的行数据 转换为产出带名字的元组的迭代器。元组的名字默认使用’Pandas’。  </p><p>   df.itertuples()的运行效率比df.iterrows()高，因此，在处理大型DataFrame时，推荐使用df.itertuples()方法来迭代数据，因为它可以提供更高的运行效率和更少的内存占用。</p><p>   官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.itertuples.html">itertuples</a></p>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>  row <span class="keyword">in</span> df.itertuples():</span><br><span class="line">    <span class="built_in">print</span>(row) <span class="comment"># 查看返回的行数据元组</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(row))<span class="comment"># 查看返回的数据类型</span></span><br><span class="line">    <span class="built_in">print</span>(row.dens) <span class="comment"># 可以选取该行的具体某列的数据</span></span><br></pre></td></tr></table></figure><p>   <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_6_3_1.png" width="90%"></p><h3 id="6-6-4-items"><a href="#6-6-4-items" class="headerlink" title="6.6.4. items()"></a>6.6.4. items()</h3><p>   将 DataFrame 的列数据 转换为产出 (列名, Series) 的迭代器。<br>   注意：在老版本的pandas中可能使用的是 <code>iteritems</code> , 但该方法在新版本中已经被弃用。  </p><p>   官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.items.html">items</a></p>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> col_name, col_data <span class="keyword">in</span> df.items():</span><br><span class="line">    <span class="comment"># 这里指定输出每一列的第一行的数据</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;col_name&#125;</span>:  <span class="subst">&#123;col_data[<span class="string">&#x27;第1行&#x27;</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>   <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_6_4_1.png" width="25%"></p><h2 id="6-7-使用函数处理"><a href="#6-7-使用函数处理" class="headerlink" title="6.7 使用函数处理"></a>6.7 使用函数处理</h2><p>在对 DataFrame 的数据进行处理时，有时候其自带的方法可能无法完全满足需求，所以可以对 DataFrame 应用一些更为复杂的函数操作进行处理。  </p><h3 id="6-7-1-apply"><a href="#6-7-1-apply" class="headerlink" title="6.7.1 apply()"></a>6.7.1 apply()</h3><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.apply.html">apply</a>  </p><p>对DataFrame按行或者列进行函数处理；其主要参数为：  </p><ul><li><code>func</code>：函数，函数的参数为DataFrame的行(或者列)，返回值为Series或者DataFrame；  </li><li><code>axis</code>：默认为0，表示<b>对<font color="red">列</font>数据进行处理</b>；1<b>对<font color="red">行</font>数据进行处理</b>；    </li><li><code>raw</code>：决定行(或列)作为 Series 或者是 narray 对象传递；默认为 False，表示传递为 Series 对象；True表示传递为 narray 对象；  </li><li><code>result_type</code>：该参数仅仅当axis=1（处理行数据）时发挥作用，默认为None，取决于应用函数的返回值:类似列表的结果将作为一个Series返回。但是，如果apply函数返回一个Series，则将它们展开为列。；  <ul><li><code>expand</code>：如果结果为列表形式，它将被转换为列；</li><li><code>reduce</code>: 如果可能的话，返回一个Series而不是扩展列表结果。这是’expand’的反面;</li><li><code>broadcast</code>: 结果将被广播为原始的DataFrame形状，原始的索引和列将被保留。</li></ul></li><li><code>args</code>：表示函数的参数；  </li><li><code>by_row</code>: 只有当<code>func</code>是一个类似列表或字典的函数集合，并且单个函数不是一个字符串时，by_row参数才会起作用。  <ul><li>如果by_row设置为”compat”，Pandas会尝试将提供的函数转换为一个对应的Pandas方法（例如，Series().apply(np.sum)会被转换为Series().sum()）。如果这种转换成功，函数将被应用到DataFrame或Series的每一行。如果转换失败，Pandas会尝试再次调用apply()函数，这次将by_row设置为True。如果这仍然失败，Pandas会再次调用apply()函数，这次将by_row设置为False，这是向后兼容的设置。  </li><li>如果by_row设置为False，那么提供的函数将被一次性应用到整个DataFrame或Series。  </li><li>简单来说，当by_row=’compat’时，Pandas会尝试逐行应用函数，如果逐行应用失败，则会尝试一次性应用。如果by_row=False，则函数会被一次性应用到整个DataFrame或Series。  </li></ul></li></ul><p>示例一：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对行数据 应用 max 函数</span></span><br><span class="line">df.apply(<span class="built_in">max</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_7_1_1.png" width="25%">  </p><p>示例二：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对行数据 使用 lambda 匿名函数</span></span><br><span class="line"><span class="comment"># 该匿名函数是取每一行的 pH 和 alco 组成一个list 返回</span></span><br><span class="line">df.apply(<span class="keyword">lambda</span> row: [row.pH, row.alco], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_7_1_2.png" width="25%">  </p><p>示例三：<br>result_type=’expand’ 举例，直接在示例二的code的基础上增加 参数 <code>result_type=&#39;expand&#39;</code>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 处理行数据, 且返回的是list，调用 result_type=&#x27;expand&#x27;，则结果会被转换为列</span></span><br><span class="line">df.apply(<span class="keyword">lambda</span> row: [row.pH, row.alco], axis=<span class="number">1</span>, result_type=<span class="string">&#x27;expand&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_7_1_3.png" width="20%">  </p><p>示例四：<br>result_type=’reduce’ 举例，直接在示例二的code的基础上增加 参数 <code>result_type=&#39;reduce&#39;</code><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对列数据进行处理</span></span><br><span class="line"><span class="comment"># 取每一列 第1至第4号元素</span></span><br><span class="line">df.apply(<span class="keyword">lambda</span> col: col[<span class="number">1</span>:<span class="number">5</span>], axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_7_1_4.png" width="25%">  </p><p>会发现与示例2的结果一样，因为reduce本身就是希望最后能尽可能的返回一个 Series，而默认 的 None 参数本来就是希望对于返回的 list 结果能作为 Series返回。</p><p>示例五：  </p><p>观察 result_type=’expand’，和 result_type=’broadcast’ 的区别</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本来对row的处理是返回结果为list, 但使用 result_type=&#x27;expand&#x27; 后会将其扩展为列</span></span><br><span class="line">df.apply(<span class="keyword">lambda</span> row: <span class="built_in">sorted</span>(row), axis=<span class="number">1</span>, result_type=<span class="string">&#x27;expand&#x27;</span>)</span><br><span class="line"><span class="comment"># column 的名称是按照列的个数从0开始自动填充</span></span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_7_1_5_a.png" width="50%">  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># result_type=&#x27;broadcast&#x27;是将结果扩展为原来的DataFrame的形状； column 的名称是保留了原来的顺序，</span></span><br><span class="line"><span class="comment"># （虽然和列数据本身已经错位了，但这里主要是为了展示 broadcast 的作用）</span></span><br><span class="line">df.apply(<span class="keyword">lambda</span> row: <span class="built_in">sorted</span>(row), axis=<span class="number">1</span>, result_type=<span class="string">&#x27;broadcast&#x27;</span>)  </span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_7_1_5_b.png" width="50%">  </p><p>示例六：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对列数据进行处理</span></span><br><span class="line"><span class="comment"># 取每一列 第1至第4号元素</span></span><br><span class="line">df.apply(<span class="keyword">lambda</span> col: col[<span class="number">1</span>:<span class="number">5</span>], axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_7_1_6.png" width="50%">   </p><h3 id="6-7-2-applymap"><a href="#6-7-2-applymap" class="headerlink" title="6.7.2 applymap()"></a>6.7.2 applymap()</h3><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.applymap.html">applymap</a>   </p><p>从 版本2.1.0开始， DataFrame.applymap 就已经被弃用. 改为使用 DataFrame.map.</p><h3 id="6-7-3-map"><a href="#6-7-3-map" class="headerlink" title="6.7.3 map()"></a>6.7.3 map()</h3><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.map.html">map</a> </p><p>将一个函数应用到DataFrame的每一个元素上，这个函数接受一个标量（scalar）并返回一个标量。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将每个元素都转换为字符串格式，并且求其长度 </span></span><br><span class="line">df.<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">len</span>(<span class="built_in">str</span>(x)), na_action=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"><span class="comment"># 其中 na_action=&#x27;ignore&#x27; 表示无法进行处理的值，使用 NaN填充</span></span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_7_3_1.png" width="45%">   </p><h3 id="6-7-4-transform"><a href="#6-7-4-transform" class="headerlink" title="6.7.4 transform()"></a>6.7.4 transform()</h3><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.transform.html">transform</a>  </p><p>DataFrame或Series自身调用函数并返回一个与自身长度相同的数据。  </p><p>它和 apply 很类似，但是也有不同，即apply 是对整个 DataFrame 或者 Series 进行操作，也就是它可以实现跨行或者跨列的操作，<b>但是 transform 只能对一个对象进行操作，也就是只能实现单行或者单列的操作。</b>  </p><p>可以参考该链接：<a href="https://stackoverflow.com/questions/27517425/whether-to-use-apply-vs-transform-on-a-group-object-to-subtract-two-columns-and#">https://stackoverflow.com/questions/27517425/whether-to-use-apply-vs-transform-on-a-group-object-to-subtract-two-columns-and#</a>  </p><p>另外，transform 更多的是用于聚合操作时，对于组内数据进行处理；这一点在后面讲聚合操作时会讲到。 </p><h3 id="6-7-6-copy"><a href="#6-7-6-copy" class="headerlink" title="6.7.6 copy()"></a>6.7.6 copy()</h3><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.copy.html">copy</a>  </p><p>当希望用到 深拷贝 时，可以使用 copy() 方法。这一点可以联系 python 当中的 深拷贝和浅拷贝进行理解。  </p><p>参数 <code>deep</code> 为 True 的时候，就是进行深拷贝-deepcopy；<br>参数 <code>deep</code> 为 False 的时候，就是进行浅拷贝-shallowcopy。  </p>]]></content>
      
      
      <categories>
          
          <category> Pandas基础入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5-pandas数据基础操作</title>
      <link href="/Pandas-Base/PD_05_Pandas_Junior_Data_Operations.html"/>
      <url>/Pandas-Base/PD_05_Pandas_Junior_Data_Operations.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%"></p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="5-pandas数据基础操作"><a href="#5-pandas数据基础操作" class="headerlink" title="5.pandas数据基础操作"></a>5.pandas数据基础操作</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p>对一个数据对象进行操作，我们一般都是从<b>【增】、【删】、【改】、【查】</b> 这四个方面入手，了解这四个方面的基本用法，就能使用该数据对象应对大部分情况了。</p><h2 id="5-1-pandas-创建数据"><a href="#5-1-pandas-创建数据" class="headerlink" title="5.1 pandas 创建数据"></a>5.1 pandas 创建数据</h2><h3 id="5-1-1-pandas-创建-Series"><a href="#5-1-1-pandas-创建-Series" class="headerlink" title="5.1.1 pandas 创建 Series"></a>5.1.1 pandas 创建 Series</h3><ol><li><p><b>通过列表创建 Series</b>   </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">s = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p> 输出如下：<br> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_1_1_1.png" width="42%"> </p></li><li><p><b>通过字典创建 Series</b>   </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd     </span><br><span class="line">s = pd.Series(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;)     </span><br><span class="line"><span class="built_in">print</span>(s)            </span><br></pre></td></tr></table></figure><p> 输出如下：<br> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_1_1_2.png" width="42%">   </p></li><li><p><b>通过numpy数组创建 Series</b>   </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">s = pd.Series(np.arange(<span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p> 输出如下：<br> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_1_1_3.png" width="42%"> </p></li><li><p><b>通过标量创建 Series</b>   </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">s = pd.Series(<span class="number">5</span>, index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p> 输出如下：<br> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_1_1_4.png" width="42%">   </p></li></ol><h3 id="5-1-2-pandas-创建-DataFrame"><a href="#5-1-2-pandas-创建-DataFrame" class="headerlink" title="5.1.2 pandas 创建 DataFrame"></a>5.1.2 pandas 创建 DataFrame</h3><ol><li><p><b>通过列表创建 DataFrame</b>    </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><p> 输出如下：<br> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_1_2_1.png" width="47%">   </p></li><li><p><b>通过字典创建 DataFrame</b>   </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;b&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><p> 输出如下：<br> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_1_2_2.png" width="47%">  </p></li><li><p><b>通过numpy数组创建 DataFrame</b>  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">1</span>, <span class="number">7</span>).reshape(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><p> 输出如下：<br> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_1_2_3.png" width="47%">  </p></li><li><p><b>通过标量创建 DataFrame</b>  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(<span class="number">5</span>, index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], columns=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><p> 输出如下：<br> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_1_2_4.png" width="58%">  </p></li></ol><h2 id="5-2-索引操作"><a href="#5-2-索引操作" class="headerlink" title="5.2 索引操作"></a>5.2 索引操作</h2><p>之前在介绍pandas中的数据对象的时候，介绍过 Index 对象，这里先简要简介一下对于 Index 的一些操作。<br>需要注意的是，<b>这里介绍的是 DataFrame 对象对于 Index 的操作，而不是 Index 本身的操作方法，</b>关于 Index 本身的一些操作，可以去查询官方文档，我们这里还是着眼于 DataFrame 对象的操作。  </p><h3 id="5-2-1-创建索引"><a href="#5-2-1-创建索引" class="headerlink" title="5.2.1 创建索引"></a>5.2.1 创建索引</h3><p><b>set_index</b>   </p><p>官方文档链接: <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.set_index.html">set_index</a>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 galaxy demo data数据集为示例</span></span><br><span class="line">url2=<span class="string">&quot;https://hastie.su.domains/ElemStatLearn/datasets/galaxy.data&quot;</span> <span class="comment"># galaxy demo data</span></span><br><span class="line"><span class="comment"># 使用 nrows=10 来控制只读取10行作为示例</span></span><br><span class="line">df = pd.read_csv(filepath_or_buffer=url2, nrows=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 由于在读取时, 没有设置 Index, 所以会默认使用 0, 1, 2, ... 作为 Index</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_2_1_1.png" width="50%">   </p><p>使用 set_index 方法可以将一列 Series 数据作为 Index：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set_index 将数据中的某一列设置为 index</span></span><br><span class="line">df2=df.set_index([<span class="string">&#x27;velocity&#x27;</span>]) </span><br><span class="line"><span class="built_in">print</span>(df2)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_2_1_2.png" width="50%">  </p><p>该方法甚至可以设置多层 Index:   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以设置多层索引</span></span><br><span class="line">df2=df.set_index([<span class="string">&#x27;velocity&#x27;</span>, <span class="string">&#x27;angle&#x27;</span>]) </span><br><span class="line"><span class="built_in">print</span>(df2)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_2_1_3.png" width="50%">  </p><p>在上面选择 Series 数据作为 Index 时，列名本身（如’velocity’, ‘angle’）就成为 Index 名，即 Index的name属性。  </p><p>当然也可以不使用用原始数据中本来就有的 Series 数据，而使用自己创建的 Series 数据：    </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自己生成一个Series并将其设置为索引</span></span><br><span class="line">s = pd.Series([<span class="string">f&quot;第<span class="subst">&#123;i&#125;</span>行&quot;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>)]) </span><br><span class="line">df2=df.set_index(s)</span><br><span class="line"><span class="built_in">print</span>(df2)</span><br></pre></td></tr></table></figure><p>因为我们自己创建的这个 Series 没有指定 name，所以此时 Index 的name也就为空。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_2_1_4.png" width="52%">  </p><p>在上面使用 set_index 方法选择 DataFrame 中原有的 Series 作为 Index 时，会自动将原来的 Series 列删除，（或者可以理解为直接移动到 Index 去），如果不想删除，可以使用参数 drop=False：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df2=df.set_index([<span class="string">&#x27;velocity&#x27;</span>], drop=<span class="literal">False</span>) </span><br><span class="line"><span class="comment"># drop=False 保留原列,即原来的列 velocity 还存在于数据列中</span></span><br><span class="line"><span class="comment"># 复制了该列的数据去作为Index而已</span></span><br><span class="line"><span class="built_in">print</span>(df2)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_2_1_5.png" width="53%">  </p><p>上面说到 Index 不止可以设置一层，还可以设置多层，所以如果原来已经有 Index，其实可以采用“追加”的方式，将新的 Index 添加到原来的 Index 后面去；比如原来默认的 Index 是 [0, 1, 2, … 10]，现在想将 velocity 作为 Index 追加上去：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df2=df.set_index([<span class="string">&#x27;velocity&#x27;</span>], append=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 原来的默认 index:[0,1,2,...,10] 并未被直接替换，</span></span><br><span class="line"><span class="comment"># append=True 相当于多加了一层 index</span></span><br><span class="line"><span class="built_in">print</span>(df2)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_2_1_6.png" width="53%">   </p><p>上面对于 df 的索引操作都不会直接修改 原始df，除非添加参数 <b><i>inplace=True</i>, 但是这样会直接修改原始数据；在数据处理中，一般应该尽量避免直接修改原始数据，</b>所以上面都是先将df修改后的结果存入新的DataFrame，即df2，中再展示。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接修改原数据示例</span></span><br><span class="line">df.set_index([<span class="string">&#x27;velocity&#x27;</span>], append=<span class="literal">True</span>, drop=<span class="literal">False</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_2_1_7.png" width="55%">   </p><p>如果要重置 Index，可以使用 reset_index 方法： </p><p>官方文档链接：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.reset_index.html#">reset_index</a>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由于上一段直接在 df 上修改，此时查看 df 的 Index 就会看到有两层</span></span><br><span class="line"><span class="built_in">print</span>(df.index) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 仍然 inplace=True 表示仍然直接在 df 上修改</span></span><br><span class="line"><span class="comment">#  drop=True 表示将现阶段的 所有 Index 丢弃掉</span></span><br><span class="line"><span class="comment"># 然后重新添加默认的 0,1,2,3</span></span><br><span class="line"></span><br><span class="line">df.reset_index(inplace=<span class="literal">True</span>, drop=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(df) </span><br><span class="line"><span class="comment"># 这样操作一番之后，我们的df就又恢复原样</span></span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_2_1_8.png" width="60%">   </p><p>关于 set_index 和 reset_index 这两个方法的简单用法就介绍到这里，更详细的用法建议参考官方文档。  </p><h3 id="5-2-2-修改索引"><a href="#5-2-2-修改索引" class="headerlink" title="5.2.2 修改索引"></a>5.2.2 修改索引</h3><ol><li><p><b>rename_axis</b>  </p><p> 官方文档链接：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.rename_axis.html">rename_axis</a> </p><p> 要注意，这个修改的是 Index 或 Columns 的名字，即它们的name属性，而不是它们具体的值；比如：</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># axis参数默认为0, 表示修改的是 Index 本身的 name</span></span><br><span class="line">df2 = df.rename_axis(<span class="string">&#x27;row_num&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the name of index: %s&quot;</span> % df2.index.name) <span class="comment"># 查看 index 的 name</span></span><br><span class="line"><span class="comment"># df2 的index 的名字 &#x27;row_num&#x27; 位置要比 columns 矮一层！</span></span><br><span class="line"><span class="built_in">print</span>(df2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># axis参数设置为1, 表示修改的是 columns 的name</span></span><br><span class="line">df2 = df2.rename_axis(<span class="string">&#x27;information&#x27;</span>, axis=<span class="number">1</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the name of columns: %s&quot;</span> % df2.columns.name) <span class="comment"># 查看 columns 的 name</span></span><br><span class="line"><span class="comment"># columns 的名字 &#x27;information&#x27; 的位置 和 columns 是同一水平线</span></span><br><span class="line"><span class="built_in">print</span>(df2)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_2_2_1.png" width="58%">  </p><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_2_2_2.png" width="58%">  </p></li></ol><pre><code>查看修改 index 和 columns 后的详细结果:  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 df2 的 index 和 columns 的具体信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; index具体信息：\n&quot;</span>, df2.index)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n columns具体信息：\n&quot;</span>, df2.columns)</span><br><span class="line"><span class="comment"># 可以看到其中 name 部分已经是我们修改后的内容,而具体的值并没有变</span></span><br></pre></td></tr></table></figure>&lt;img src=&#39;https://teeyohuang.github.io/pic_bed/Pandas_Base/5_2_2_3.png&#39; width=58%&gt;</code></pre><ol><li><p><b>rename</b>  </p><p> 官方文档链接：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.rename.html">rename</a> </p><p> 这个就是修改 index 或者 columns 具体的值。给定一个字典，键是原名称，值是想要修改的名称，比如：  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以字典的方式准备好新 index 的具体内容</span></span><br><span class="line">new_index = <span class="built_in">dict</span>([ (i, <span class="string">f&quot;第<span class="subst">&#123;i&#125;</span>行&quot;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> df2.index])</span><br><span class="line"><span class="comment"># 查看该字典，会发现每一个 具体的index，都对应了一个新的值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;准备要替换为:  \n&quot;</span> , new_index)</span><br><span class="line"><span class="comment"># 使用rename进行修改，axis参数默认为0, 表示修改 index的内容</span></span><br><span class="line">df3 = df2.rename(new_index)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n修改后的index.values 信息 \n&quot;</span>, df3.index.values)</span><br><span class="line"><span class="built_in">print</span>(df3)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_2_2_4.png" width="68%"></p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以字典的方式准备好新 columns 的具体内容</span></span><br><span class="line">new_cols = <span class="built_in">dict</span>([ (col, col.split(<span class="string">&#x27;.&#x27;</span>)[-<span class="number">1</span>]) <span class="keyword">for</span> col <span class="keyword">in</span> df2.columns])</span><br><span class="line"><span class="comment"># 查看该字典，会发现每一个 具体的 col，都对应了一个新的值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;准备要替换为:  \n&quot;</span> , new_cols)</span><br><span class="line"><span class="comment"># 使用rename进行修改，axis设置为1, 表示修改 columns 的内容</span></span><br><span class="line">df3 = df2.rename(new_cols, axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n修改后的 columns.values 信息 \n&quot;</span>, df3.columns.values)</span><br><span class="line"><span class="built_in">print</span>(df3)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_2_2_5.png" width="65%"></p></li><li><p><b>set_axis</b>   </p><p> 官方文档链接：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.set_axis.html">set_axis</a> </p><p> 用法和 rename 很相似，只不过不用传入字典，可以传入一个列表，然后依次分配即可。下面以修改列名为例子：  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new_cols2 = [<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;EW&#x27;</span>, <span class="string">&#x27;NS&#x27;</span>, <span class="string">&#x27;Ang&#x27;</span>, <span class="string">&#x27;Pos&#x27;</span>,  <span class="string">&#x27;Vel&#x27;</span>] <span class="comment"># 列表形式</span></span><br><span class="line">df3 = df2.set_axis(new_cols2, axis=<span class="number">1</span>) <span class="comment"># 指定 axis=1</span></span><br><span class="line"><span class="built_in">print</span>(df3)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_2_2_6.png" width="52%"></p><p> 但要注意，set_axis方法会删除原有轴标签的名称(name)，如果希望要有名称，只需要重新指定一下即可。</p></li></ol><h2 id="5-3-数据的增删改查操作"><a href="#5-3-数据的增删改查操作" class="headerlink" title="5.3 数据的增删改查操作"></a>5.3 数据的增删改查操作</h2><p>在使用 pandas 处理数据时，基本都是通过 DataFrame 对象来装载数据的，所以下面将介绍如何使用 DataFrame 数据对象自带的一些方法，对于数据的一些基础性的增删改查操作。</p><h3 id="5-3-1-查询"><a href="#5-3-1-查询" class="headerlink" title="5.3.1 查询"></a>5.3.1 查询</h3><p>本小节以机器学习领域的公开数据集 wine dataset (葡萄酒数据集) 为例介绍如何对DataFrame数据进行查询。以下实例虽然是针对 DataFrame 对象，但是大部分操作同样适用于 Series 对象。   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里使用一个公开的机器学习数据集: wine dataset (葡萄酒质量)</span></span><br><span class="line"><span class="comment">#  nrows=5 表示仅仅读取前5行</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./datasets/wine&#x27;</span>, nrows=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 由于在读取时, 没有设置 Index, 所以这里使用 rename 来修改一下</span></span><br><span class="line">df.rename(<span class="built_in">dict</span>([(i, <span class="string">f&#x27;第<span class="subst">&#123;i&#125;</span>行&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> df.index]), inplace=<span class="literal">True</span>)</span><br><span class="line">df</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1.png">   </p><h4 id="5-3-1-1-简单信息查询"><a href="#5-3-1-1-简单信息查询" class="headerlink" title="5.3.1.1 简单信息查询"></a>5.3.1.1 简单信息查询</h4><ol><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.info.html">DataFrame.info()</a>   </p><p> 查看该对象的类型，以及有多少行，多少列，每列的名称、类型，占用的内存等等信息，相当于是对于该 DataFrame 的一个宏观上的描述。  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.info()</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_1.png" width="50%">  </p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.shape.html">DataFrame.shape</a>   </p><p> 查看该 DataFrame 对象有多少行，多少列，返回一个元组: （行数，列数）  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.shape</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_1_2.png" width="60">  </p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.head.html">DataFrame.head(n=5)</a>  </p><p> 查看前 n 行的数据，n默认值为5。  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.head(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_1_3.png">   </p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.tail.html">DataFrame.tail(n=5)</a>  </p><p> 查看倒数 n 行的数据，n默认值为5。  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.tail(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_1_4.png">   </p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.dtypes.html">DataFrame.dtypes</a>  </p><p> 查看该 DataFrame 对象每一列的数据类型。  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dtypes</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_1_6.png" width="30%">  </p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.values.html">DataFrame.values</a>  </p><p> 返回一个 numpy array，存放的是 DataFrame 的数据部分；<br> 更推荐使用 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_numpy.html">DataFrame.to_numpy()</a>   </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.values</span><br><span class="line"><span class="comment"># 更推荐使用 df.to_numpy()</span></span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_1_7.png" width="65%">  </p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sample.html">DataFrame.sample()</a>   </p><p> 从数据中随机采样出 n 条数据。可接收参数有：<br> <code>n</code>: 指定采样的行数，默认为1。<br> <code>frac</code>: 指定采样比例，默认为1。(n 和 frac 二选一，一个是指定多少条，一个是指定采多少比例)<br> <code>replace</code>: 是否放回，默认为False。<br> <code>weights</code>: 指定权重，默认为None。<br> <code>random_state</code>: 随机数种子，默认为None。<br> <code>axis: 指定轴</code>，默认为0，即抽样行数据；axis=1 时 抽样列数据。<br> <code>ignore_index</code>: 是否忽略原来的索引，默认为False。</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># axis 默认为0，表示采样行数据</span></span><br><span class="line">df.sample(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_1_5.png">  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># axis 为1，表示采样列数据</span></span><br><span class="line"> df.sample(<span class="number">2</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_1_5_b.png" width="18%">  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 采用 比例 采样</span></span><br><span class="line">df.sample(frac=<span class="number">0.2</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_1_5_c.png" width="22%"></p></li></ol><p>此外，还有一些查看 DataFrame 其它基本信息的方法或者属性，举例如下：  </p><div class="table-container"><table><thead><tr><th>方法或属性</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.axes.html">DataFrame.axes</a></td><td>返回一个列表，列表内容为 [列名, 行名]</td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.index.html">DataFrame.index</a></td><td>返回一个 Index 对象，内容为行名</td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.columns.html">DataFrame.columns</a></td><td>返回一个 Index 对象，内容为列名</td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.keys.html">DataFrame.keys()</a></td><td>返回一个 Index 对象，内容为行名(对于Series) 或者 列名(对于DataFrame)</td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.size.html">DataFrame.size</a></td><td>返回元素的总个数(行数*列数)</td></tr><tr><td><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.ndim.html">DataFrame.ndim</a></td><td>返回数据的维度</td></tr></tbody></table></div><h4 id="5-3-1-2-数据查询"><a href="#5-3-1-2-数据查询" class="headerlink" title="5.3.1.2 数据查询"></a>5.3.1.2 数据查询</h4><p>本小节介绍如何对 DataFrame 中的数据进行查询 ，包括行、列的查询，以及数据值的查询。  </p><ol><li><p><b>列索引查询</b>  </p><ul><li>采用 <code>df[列名]</code> 的方式，可以查询 DataFrame 中的某一列，返回的是一个 <b>Series 对象</b>。  </li><li><p>采用 <code>df.列名</code> 的方式，可以查询 DataFrame 中的某一列，返回的是一个 <b>Series 对象</b>。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照索引取数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;方法一\n&#x27;</span>, df[<span class="string">&#x27;pH&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n方法二\n&#x27;</span>,df.pH)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_2_1.png" width="30%">  </p></li></ul></li><li><p><b>多列数据查询</b>  </p><ul><li><p>采用 <code>df[[列名1, 列名2, ...]]</code> 的方式，可以查询 DataFrame 中的多列，返回的是一个<b>DataFrame 对象</b>。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取多列数据</span></span><br><span class="line"><span class="built_in">print</span>(df[[<span class="string">&#x27;pH&#x27;</span>,<span class="string">&#x27;alcohol&#x27;</span>]])</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_2_2.png" width="25%">   </p><p>要注意，df[列名]返回的是 Series对象，因为这个操作就是在取列数据；<br>df[[列名]] 返回的是 DataFrame对象，就算只填一个列名，那也是看作一个只有一列的 DataFrame.  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意这两种情况的区别：</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df[<span class="string">&#x27;pH&#x27;</span>]))   <span class="comment"># 返回的是一个 Series 对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df[[<span class="string">&#x27;pH&#x27;</span>]])) <span class="comment"># 返回的是一个 DataFrame 对象</span></span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_2_2_b.png" width="35%">  </p></li></ul></li><li><p><b>按照 python 切片逻辑取多行数据</b>  </p><p> 这种切片操作是将每一行数据视为一个元素来取  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照python 切片逻辑取多行数据</span></span><br><span class="line">df[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_2_3.png"></p></li><li><p><b>使用<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html">loc</a>轴<font color="orangered">标签</font>取数据</b>  </p><ul><li><p>取列数据：<code>df.loc[:, 列名]</code><br>  返回一个 Series 对象   </p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 轴标签取数据</span></span><br><span class="line"><span class="comment"># 1.取列数据-&gt; Series</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;1.按照轴标签 loc 取列数据:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.loc[:, <span class="string">&#x27;pH&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df.loc[:, <span class="string">&#x27;pH&#x27;</span>]))</span><br></pre></td></tr></table></figure><p>  <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_2_4_a.png" width="35%"></p></li><li><p>取行数据：<code>df.loc[ 行名 ]</code>  </p><p>  返回行数据，但是也会转化成一个 Series 对象  </p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2.取行数据-&gt; Series</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n\n2.按照轴标签 loc 取行数据:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="string">&#x27;第1行&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df.loc[<span class="string">&#x27;第1行&#x27;</span>]))</span><br></pre></td></tr></table></figure><p>  <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_2_4_b.png" width="35%"></p></li><li><p>取单个数据：<code>df.loc[行名, 列名]</code>  </p><p>  返回具体的数据  </p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3.取单个元素-&gt; </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n\n3.按照轴标签 loc 取单个数据:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="string">&#x27;第1行&#x27;</span>, <span class="string">&#x27;pH&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df.loc[<span class="string">&#x27;第1行&#x27;</span>, <span class="string">&#x27;pH&#x27;</span>]))</span><br></pre></td></tr></table></figure><p>  <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_2_4_c.png" width="32%"></p></li><li><p>取一行多列数据：<code>df.loc[行名, [列名1, 列名2, ...]]</code><br>  返回一个 Series 对象  </p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4.取某一行的多列数据-&gt; Series</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n\n4.按照轴标签 loc取多列的某一行数据:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="string">&#x27;第1行&#x27;</span>, [<span class="string">&#x27;pH&#x27;</span>, <span class="string">&#x27;alcohol&#x27;</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df.loc[<span class="string">&#x27;第1行&#x27;</span>, [<span class="string">&#x27;pH&#x27;</span>, <span class="string">&#x27;alcohol&#x27;</span>]]))</span><br></pre></td></tr></table></figure><p>  <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_2_4_d.png" width="35%"></p></li><li><p>取多行一列数据：<code>df.loc[[行名1, 行名2, ...], 列名]</code><br>  返回一个 Series 对象  </p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 5.取多行的某一列数据-&gt; Series</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n\n5.按照轴标签 loc取多行的某一列数据:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.loc[[<span class="string">&#x27;第1行&#x27;</span>, <span class="string">&#x27;第2行&#x27;</span>], <span class="string">&#x27;pH&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df.loc[[<span class="string">&#x27;第1行&#x27;</span>, <span class="string">&#x27;第2行&#x27;</span>], <span class="string">&#x27;pH&#x27;</span>]))</span><br></pre></td></tr></table></figure><p>  <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_2_4_e.png" width="35%"></p></li><li><p>取多行多列数据：<code>df.loc[ [ 行名1, 行名2, ...], [列名1, 列名2, ...] ]</code><br>  返回一个 DataFrame 对象（相当于原DataFrame的一个子集）  </p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 6.取多行的多列数据-&gt; DataFrame</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n\n6.按照轴标签 loc取多行多列数据:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.loc[[<span class="string">&#x27;第1行&#x27;</span>, <span class="string">&#x27;第2行&#x27;</span>], [<span class="string">&#x27;pH&#x27;</span>, <span class="string">&#x27;alcohol&#x27;</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df.loc[[<span class="string">&#x27;第1行&#x27;</span>, <span class="string">&#x27;第2行&#x27;</span>], [<span class="string">&#x27;pH&#x27;</span>, <span class="string">&#x27;alcohol&#x27;</span>]]))</span><br></pre></td></tr></table></figure><p>  <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_2_4_f.png" width="35%"></p></li></ul></li><li><p><b>使用<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html">iloc</a>轴<font color="orangered">序号</font>取数据</b>  </p><ul><li><p>取列数据：<code>df.iloc[:, col_j]</code><br>  返回一个 Series 对象  </p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.取列数据-&gt; Series</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;1.按照轴序号 iloc 取列数据:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.iloc[:,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df.iloc[:, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p>  <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_2_5_a.png" width="35%"></p></li><li><p>取行数据：<code>df.iloc[ row_i ]</code>  </p><p>  返回行数据，但是也会转化成一个 Series 对象  </p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2.取行数据-&gt; Series</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n\n2.按照轴序号 iloc 取行数据:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.iloc[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df.iloc[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p>  <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_2_5_b.png" width="35%"></p></li><li><p>取单个数据：<code>df.iloc[row_i, col_j]</code>  </p><p>  返回具体的数据  </p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3.取单个元素-&gt; </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n\n3.按照轴序号 iloc 取单个数据:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.iloc[<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df.iloc[<span class="number">1</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p>  <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_2_5_c.png" width="30%"></p></li><li><p>取一行多列数据：<code>df.iloc[row_i, [col_j1, col_j2, ...]]</code>  </p><p>  返回一个 Series 对象；<br>  实际上，<font color="navy">列序号部分也可以用python切片方式表达 [col_m : col_n]</font>     </p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4.取某一行的多列数据-&gt; Series</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n\n4.按照轴序号 iloc 取多列的某一行数据:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.iloc[<span class="number">1</span>, [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]) <span class="comment"># 也可以写为 df.iloc[1, 3:7] </span></span><br><span class="line"><span class="comment"># print(df.iloc[1, 3:7]) # 注意右边界不取</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df.iloc[<span class="number">1</span>, [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]))</span><br></pre></td></tr></table></figure><p>  <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_2_5_d.png" width="35%">  </p></li><li><p>取多行一列数据：<code>df.iloc[[row_i1, row_i2, ...], col_j]</code>  </p><p>  返回一个 Series 对象;<br>  实际上，<font color="navy">行序号部分也可以用python切片方式表达 [row_m : row_n]</font>    </p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 5.取多行的某一列数据-&gt; Series</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n\n5.按照轴序号 iloc 取多行的某一列数据:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.iloc[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="number">3</span>]) <span class="comment"># 也可以写为 df.iloc[1:4, 3] </span></span><br><span class="line"><span class="comment"># print(df.iloc[1:4, 3]) # 注意右边界不取</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df.iloc[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p>  <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_2_5_e.png" width="35%">  </p></li><li><p>取多行多列数据：<code>df.iloc[ [row_i1, row_i2, ...], [col_j1, col_j2, ...]]</code>  </p><p>  返回一个 DataFrame 对象   </p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 6.取多行多列数据-&gt; DataFrame</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n\n6.按照轴序号 iloc 取多行多列数据:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.iloc[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  <span class="comment"># 也可以写为 df.iloc[1:4, 3:7] </span></span><br><span class="line"><span class="comment"># print(df.iloc[1:4, 3:7]) # 注意右边界不取</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df.iloc[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]))</span><br></pre></td></tr></table></figure><p>  <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_2_5_f.png" width="70%">  </p></li></ul></li><li><p><b>使用 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.at.html">at</a> / <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iat.html">iat</a> 取具体数据</b>  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 at + 标签 取具体值</span></span><br><span class="line"><span class="built_in">print</span>(df.at[<span class="string">&#x27;第1行&#x27;</span>, <span class="string">&#x27;pH&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 iat + 序号 取具体值</span></span><br><span class="line"><span class="built_in">print</span>(df.iat[<span class="number">1</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure></li><li><p><b>使用 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.get.html">get</a> 取列数据</b>  </p><p> 这是将 DataFrame 视为一个元素为 列数据的字典，上面也讲过，使用 <code>df.keys()</code> 可以获得列名，所以这里如果将列名视为字典的 key，则 字典的值就是对应的 Series 值。  </p><p> 此外，该方法还能设置 默认值，即如果 get 找不到对应的列名，就返回默认值。</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.get(<span class="string">&#x27;pH&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><b>使用 <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.truncate.html">truncate</a> 截取中间的数据。</b>  </p><p> 前面提到，<code>head</code>方法是取头部数据，  <code>tail</code>方法是取尾部数据， <code>truncate</code> 可以用来取中间数据。  </p><p> 但是要注意，它要求 行排列，或者 列排列 是有序的</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 截取中间的 行数据</span></span><br><span class="line">df.truncate(before=<span class="string">&#x27;第1行&#x27;</span>, after=<span class="string">&#x27;第3行&#x27;</span>,axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_2_8.png">  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 尝试截取中间的列数据  </span></span><br><span class="line">df.truncate(before=<span class="string">&#x27;fixed acidity&#x27;</span>, after=<span class="string">&#x27;residual sugar&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 会报错  </span></span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_1_2_8_b.png" width="40%">  </p><p> 因为数据的列名其实看不出啥顺序出来。  </p></li></ol><h3 id="5-3-2-新增"><a href="#5-3-2-新增" class="headerlink" title="5.3.2 新增"></a>5.3.2 新增</h3><p>在这一部分，主要讲一下如何执行新增列数据和新增行数据的简单操作，示例数据仍采用上面的 wine dataset，只不过不用取全部的列数据，少取一点便于展示。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  nrows=6 表示仅仅读取前6行, 并且只使用 usecols 来限定只取部分列数据</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./datasets/wine&#x27;</span>, nrows=<span class="number">6</span>, usecols=[<span class="string">&#x27;density&#x27;</span>, <span class="string">&#x27;pH&#x27;</span>, <span class="string">&#x27;alcohol&#x27;</span>, <span class="string">&#x27;quality&#x27;</span>])</span><br><span class="line"><span class="comment"># 由于在读取时, 没有设置 Index, 所以这里使用 rename 来修改一下</span></span><br><span class="line">df.rename(<span class="built_in">dict</span>([(i, <span class="string">f&#x27;第<span class="subst">&#123;i&#125;</span>行&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> df.index]), inplace=<span class="literal">True</span>)</span><br><span class="line">df</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_2.png" width="35%">  </p><h4 id="5-3-2-1-新增列数据"><a href="#5-3-2-1-新增列数据" class="headerlink" title="5.3.2.1 新增列数据"></a>5.3.2.1 新增列数据</h4><ol><li><p><b>df[新列名]</b>   </p><p>对于一个已经存在的DataFrame对象df，可以直接使用<code>df[新列名]</code>来创建一个新列，新列可以是一个常量值，所有行都为此值；也可以是一个同等长度的序列数据。  </p><font color="navy"> <i>要注意的是，这种操作相当于 inplace=True ，即会对原始数据 df 进行修改。  同时，如果已经存在该列名，则会覆盖原始列数据。</i></font>    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加一个同等长度的序列数据</span></span><br><span class="line"> df[<span class="string">&#x27;No.&#x27;</span>] = [ i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(df))]</span><br><span class="line"> <span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_2_1_1.png" width="38%">  </p></li><li><p><b>df.loc[:,新列名]</b>   </p><p> 和上面的方法类似，本质上就是通过访问列名的方式来创建新列。  </p> <font color="navy"><i>要注意的是，这种操作相当于 inplace=True ，即会对原始数据 df 进行修改。   同时，如果已经存在该列名，则会覆盖原始列数据。</i></font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以一个常数值作为新列</span></span><br><span class="line">df.loc[:,<span class="string">&#x27;DataSet&#x27;</span>] = <span class="string">&#x27;WineData&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_2_1_2.png" width="40%"></p></li><li><p><b>df.insert(位置, 新列名, 新列值)</b>   </p><p> 官网文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.insert.html">insert</a>  </p> <font color="navy"><i>要注意的是，这种操作相当于 inplace=True ，即会对原始数据 df 进行修改。   一般是不允许出现同名列，除非改动参数 allow_duplicates=True，但一般不建议这么搞。</i></font>     <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在序号0位置添加新的一列</span></span><br><span class="line">df.insert(<span class="number">0</span>,<span class="string">&#x27;New_0_col&#x27;</span>, <span class="number">2023</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_2_1_3.png" width="43%"></p></li><li><p><b>df.assign(新列名=新列值)</b>   </p><p> 官网文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.assign.html">assign</a>   </p><p> 参数中的新列名不需要写成字符串格式，直接写列名即可；<br> 参数中的新列值是一个与原数据同索引的Series，不然会报错。  </p> <font color="navy"><i>要注意的是，这种操作相当<b>并不会</b>对原始数据 df 进行修改，它返回的是一个新的 DateFrame 对象。   同时，如果已经存在该列名，则会覆盖原始列数据。</i></font>    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定的 value 一定要是一个与原df的index相同的 Series</span></span><br><span class="line"><span class="built_in">print</span>(df.assign(assign_col=pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], index=df.index)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n原始df未变化：\n&#x27;</span>,df)  </span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_2_1_4.png" width="58%"></p></li><li><p><b>df.eval()</b>  </p><p> 官网文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.eval.html">eval</a>   </p><p> eval()可以接受一个表达式，用来创建一个新列，<font color="navy"><i>但是也不会对原数数据进行修改，它返回的是一个新的 DateFrame 对象。</i></font>   </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 eval 加上表达式示例</span></span><br><span class="line"><span class="built_in">print</span>(df.<span class="built_in">eval</span>(<span class="string">&#x27;eval_test = density + pH&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n原始df未变化：\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_2_1_5.png" width="58%"></p></li></ol><h4 id="5-3-2-2-新增行数据"><a href="#5-3-2-2-新增行数据" class="headerlink" title="5.3.2.2 新增行数据"></a>5.3.2.2 新增行数据</h4><ol><li><p><b>df.loc[序号]=新行数据</b>  </p><p> 这个本质也是使用访问数据的方式，在访问时直接进行修改，所以，设原始df一共有N行数据：  </p><ul><li>如果序号取 0~N-1 之间的值，则相当于在原数据上进行修改；  </li><li>如果序号取 N ，则相当于在原数据上进行新增一行；  </li><li><p>如果序号取 大于N，就会报错。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 df.loc[序号] 来增加新行  </span></span><br><span class="line"><span class="comment"># 使用常数值来充当新行数据</span></span><br><span class="line">df.loc[df.shape[<span class="number">0</span>]] = <span class="number">2</span></span><br><span class="line"><span class="comment"># 使用与列名对应的字典来充当新行数据</span></span><br><span class="line">df.loc[<span class="built_in">len</span>(df)] = &#123;<span class="string">&#x27;0_col&#x27;</span>:<span class="number">11</span>, <span class="string">&#x27;density&#x27;</span>:<span class="number">22</span>, <span class="string">&#x27;pH&#x27;</span>:<span class="number">33</span>, <span class="string">&#x27;alcohol&#x27;</span>:<span class="number">44</span>, <span class="string">&#x27;quality&#x27;</span>:<span class="number">55</span>, <span class="string">&#x27;No.&#x27;</span>:<span class="number">66</span>, <span class="string">&#x27;DataSet&#x27;</span>:<span class="number">77</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_2_2_1.png" width="50%"></p></li></ul></li><li><p><b>df.append(新行数据)</b>  </p><p> 官网文档：<a href="https://pandas.pydata.org/pandas-docs/version/1.4/reference/api/pandas.DataFrame.append.html">append</a>    </p><p> <font color="red">这个方法在 pandas 1.4 版本后就被废弃了</font>，但是考虑到有些环境下用的并不是最新版本的pandas，所以这里还是讲一下。  </p><p> append 可以接受字典类型的数据，字典中应为 {列名1:列值1,…} 这样的形式，表示新的一行每个列的位置应该填充什么数据（缺失列名会填充NAN），这样就可以在尾部新增一行数据了。  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 df.append() 来增加新行</span></span><br><span class="line">df.append(&#123;<span class="string">&#x27;0_col&#x27;</span>:<span class="number">11</span>, <span class="string">&#x27;density&#x27;</span>:<span class="number">22</span>, <span class="string">&#x27;pH&#x27;</span>:<span class="number">33</span>, <span class="string">&#x27;alcohol&#x27;</span>:<span class="number">44</span>, <span class="string">&#x27;quality&#x27;</span>:<span class="number">55</span>, <span class="string">&#x27;No.&#x27;</span>:<span class="number">66</span>, <span class="string">&#x27;DataSet&#x27;</span>:<span class="number">77</span>&#125;)</span><br></pre></td></tr></table></figure><p> <code>append()</code> 也可以接收一个DataFrame 对象，这样就可以在尾部新增多行数据了。  </p><ul><li>如果该 DataFrame 对象中没有与df中列名相同的列，则新增加的列名会自动填充为NAN；  </li><li>如果该 DataFrame 对象中有与df中列名相同的列，则新增加的列会填充为该列的数据。  </li><li><p>如果该 DataFrame 对象的列名全部不一样，但是列数是一样的，且列的左右顺序也一样，就可以设置 ignore_index=False ，这样就不会考虑列名对应，而是从左往右的顺序依次填充即可。  </p><p>由于我使用的 pandas 的版本已经没有这个 <code>append</code> 方法了，所以就不在这里展示示例结果。</p></li></ul></li><li><p><b>pandas.concat([df1,df2,…])</b>  </p><p> 官网文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.concat.html">concat</a>   </p><p> <code>concat()</code> 方法可以接收一个或多个 DataFrame 对象，然后将多个 DataFrame 对象拼接在一起。但是它不像 <code>append()</code> 那样可以接收字典类型的数据，所以如果我们想要增加行，就得先使用行数据创建一个新的 DataFrame 对象，再使用 <code>concat()</code> 方法拼接。  </p> <font color="navy">拼接操作并不在原始数据上进行修改，而是返回一个新的 DataFrame 对象。</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new_row = pd.DataFrame([[<span class="number">22</span>, <span class="number">35</span>, <span class="string">&#x27;WineData&#x27;</span>]] ,columns=[<span class="string">&#x27;density&#x27;</span>, <span class="string">&#x27;pH&#x27;</span>, <span class="string">&#x27;DataSet&#x27;</span>], index=[<span class="string">&#x27;new_row&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(new_row)</span><br><span class="line"><span class="comment"># axis 默认为 0, 表示竖着按行连接</span></span><br><span class="line">pd.concat([df,new_row])</span><br></pre></td></tr></table></figure><p> 没找到对应的列名就填充 NAN  </p><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_2_2_3.png" width="50%"></p></li></ol><h3 id="5-3-3-删除"><a href="#5-3-3-删除" class="headerlink" title="5.3.3 删除"></a>5.3.3 删除</h3><ol><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.pop.html">pop(列名)</a>  </p><p> <code>pop()</code> 方法可以删除指定列，并返回该列的数据。<font color="navy">且会修改原数据。</font>  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.pop(<span class="string">&#x27;0_col&#x27;</span>))</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_3_1.png" width="30%"></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.drop.html">drop()</a>  </p><p> <code>drop()</code> 方法可以删除指定列或者行（配合对应的axis），并返回删除后的 DataFrame 对象。  </p><p> inplace默认为False，即不修改原始数据，当其设置为True时就会修改原始数据。</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除 index 为 6, 7 的两行</span></span><br><span class="line">df.drop([<span class="number">6</span>,<span class="number">7</span>], inplace=<span class="literal">True</span>) <span class="comment"># axis 默认为0</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_3_2_a.png" width="43%">   </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除 columns 为 No.  DataSet 的两列</span></span><br><span class="line">df.drop([<span class="string">&#x27;No.&#x27;</span>,<span class="string">&#x27;DataSet&#x27;</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_3_2_b.png" width="30%">   </p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.dropna.html">dropna()</a></p><p> 该方法是用来删除有空值、有缺失的数据。<br> 参数说明：  </p><ul><li><code>axis</code>：默认为 0，表示删除有空值的行；  设置为 1 表示删除有空值的列。  </li><li><code>how</code>：默认为 ‘any’，表示只要出现一个空值，就删除含有空值的行或列；设置为’all’ 表示只有当一行/一列全部为空值的时候才删除该行/列。 </li><li><code>thresh</code>：默认为 None，表示删除含有空值的行或列的数量大于等于 thresh 的行或列；不与 <code>how</code> 参数 同时使用。  </li><li><code>subset</code>：默认为 None，表示删除含有空值的行或列时，只考虑指定的范围。  </li><li><code>inplace</code>：默认为 False，表示不修改原始数据，当其设置为 True 时，表示修改原始数据。  </li><li><code>ignore</code></li></ul></li></ol><h3 id="5-3-4-修改"><a href="#5-3-4-修改" class="headerlink" title="5.3.4 修改"></a>5.3.4 修改</h3><p>创建一个新的示例 DataFrame  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 再新创建一个示例 DataFrame</span></span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>), <span class="string">&#x27;B&#x27;</span>: <span class="built_in">range</span>(<span class="number">10</span>, <span class="number">0</span>, -<span class="number">2</span>),</span><br><span class="line">                    <span class="string">&#x27;C&#x27;</span>: <span class="built_in">range</span>(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>), <span class="string">&#x27;D&#x27;</span>: [<span class="built_in">round</span>(np.random.rand(),<span class="number">2</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]&#125;,</span><br><span class="line">                   index = [<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>_row&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)])</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_4.png" width="20%"></p><h4 id="5-3-4-1-按照查询的方式修改"><a href="#5-3-4-1-按照查询的方式修改" class="headerlink" title="5.3.4.1 按照查询的方式修改"></a>5.3.4.1 按照查询的方式修改</h4><ol><li><p><code>df.loc[行索引,列索引]</code> 方式  </p><p> 上面介绍过，通过这种<code>loc</code>取轴标签的形式可以访问 DataFrame 的数据；<br> 如果在访问时赋值，则就会修改原始数据：  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># df.loc[行索引,列索引] 方式进行修改</span></span><br><span class="line">df2.loc[<span class="string">&#x27;0_row&#x27;</span>,<span class="string">&#x27;A&#x27;</span>] = <span class="number">10</span> <span class="comment"># 将 (0_row, A) 位置的值改为 10</span></span><br><span class="line">df2.loc[<span class="string">&#x27;1_row&#x27;</span>] = <span class="number">1</span>      <span class="comment"># 将 1_row 这一行的所有值改为1</span></span><br><span class="line">df2.loc[:, <span class="string">&#x27;D&#x27;</span>] = <span class="number">4</span>       <span class="comment"># 将 D 列的所有值改为 4</span></span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_4_1_1.png" width="25%">  </p></li><li><p><code>df.iloc[行序号,列序号]</code> 方式   </p><p> 上面介绍过，通过这种<code>loc</code>取轴序号的形式可以访问 DataFrame 的数据；<br> 如果在访问时赋值，则就会修改原始数据：</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># df.loc[行序号,列序号] 方式进行修改</span></span><br><span class="line">df2.iloc[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">99</span>     <span class="comment"># 将 (0, 0) 位置的值改为 99</span></span><br><span class="line">df2.iloc[<span class="number">1</span>] = <span class="number">100</span>      <span class="comment"># 将 序号为1 这一行的所有值改为100</span></span><br><span class="line">df2.iloc[:, <span class="number">3</span>] = -<span class="number">1</span>     <span class="comment"># 将 序号为3 列的所有值改为 -1</span></span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_4_1_2.png" width="25%"></p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.eval.html">eval()</a>  </p><p> 上面介绍过，使用 eval 可以添加新的列数据，同样，eval 也可以用来修改数据，即在eval 的表达式中出现已经存在的列名，并设置 inplace=True 就会修改原始列的数据：  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df2.<span class="built_in">eval</span>(<span class="string">&#x27;A = A*D&#x27;</span>, inplace=<span class="literal">True</span>) <span class="comment"># 要修改原始数据时，要设置 inplace=True</span></span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_4_1_3.png" width="25%"></p></li></ol><h4 id="5-3-4-2-批量替换"><a href="#5-3-4-2-批量替换" class="headerlink" title="5.3.4.2 批量替换"></a>5.3.4.2 批量替换</h4><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.replace.html">df.replace()</a>  </p><p>可以将 DataFrame 中的数据批量替换，<code>df.replace(old, new, inplace=False)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要修改原始数据时，要设置 inplace=True</span></span><br><span class="line">df2.replace(<span class="number">100</span>, <span class="number">50</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_4_2.png" width="25%"></p><h4 id="5-3-4-3-填充空值"><a href="#5-3-4-3-填充空值" class="headerlink" title="5.3.4.3 填充空值"></a>5.3.4.3 填充空值</h4><p>先在 df2 中添加几个空值作为示例 ：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 先填充4个空值</span><br><span class="line">for k in range(4):</span><br><span class="line">    df2.iloc[k,k] = np.NAN </span><br><span class="line">df2</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_4_3.png" width="25%">  </p><ol><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.fillna.html">df.fillna()</a>  </p><p> fillna 使用传入的值对空值进行填充，inplace默认为False，即不修改原始数据</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df3 = df2.fillna(<span class="number">2.1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;对所有空值用 2.1 填充: \n&#x27;</span>, df3)</span><br><span class="line"></span><br><span class="line">df4 = df2.fillna(<span class="number">2.1</span>, limit=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n对靠前的2个空值用 2.1 填充: \n&#x27;</span>, df4)</span><br><span class="line"></span><br><span class="line">df5 = df2.fillna(&#123;<span class="string">&#x27;A&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;B&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;C&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;D&#x27;</span>:<span class="number">4</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n对每个列的空值单独设置不同的填充值: \n&#x27;</span>, df5)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_4_3_1.png" width="58%">  </p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.bfill.html">df.bfill()</a>  </p><p> bfill 表示向后填充，即从后往前填充，inplace默认为False，即不修改原始数据  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n填充前的数据: \n&#x27;</span>, df2)</span><br><span class="line"></span><br><span class="line">df6=df2.bfill()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n对所有空值使用后一行的值填充: \n&#x27;</span>, df6)</span><br><span class="line"></span><br><span class="line">df7=df2.bfill(axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n对所有空值使用后一列的值填充: \n&#x27;</span>, df7)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最后一列没有后一列，所以最后一列无法得到填充，仍然是 NAN&#x27;</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_4_3_2.png" width="55%">  </p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.ffill.html">df.ffill()</a>    </p><p> ffill 表示向前填充，即从前往后填充，inplace默认为False，即不修改原始数据  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n填充前的数据: \n&#x27;</span>, df2)</span><br><span class="line"></span><br><span class="line">df6=df2.ffill()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n对所有空值使用前一行的值填充: \n&#x27;</span>, df6)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一行没有前一行，所以第一行无法得到填充，仍然是 NAN&#x27;</span>)</span><br><span class="line"></span><br><span class="line">df7=df2.ffill(axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n对所有空值使用前一列的值填充: \n&#x27;</span>, df7)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一列没有前一列，所以第一列无法得到填充，仍然是 NAN&#x27;</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_4_3_3.png" width="50%">  </p></li><li><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.interpolate.html">df.interpolate()</a>  </p><p> interpolate 表示使用插值的方法来填充空值，inplace默认为False，即不修改原始数据。  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n填充前的数据: \n&#x27;</span>, df2)</span><br><span class="line"></span><br><span class="line">df8=df2.interpolate()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n对所有空值使用 前后行的数据进行差值计算 填充: \n&#x27;</span>, df8)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一行没有前一行，所以无法计算插值，仍然是 NAN&#x27;</span>)</span><br><span class="line"></span><br><span class="line">df9=df2.interpolate(axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n对所有空值使用 前后列的数据进行差值计算 填充: \n&#x27;</span>, df9)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一列没有前一列，所以无法计算插值 ，仍然是 NAN&#x27;</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_3_4_3_4.png" width="50%">  </p><p> 默认的差值方法为 method=’linear’，即线性插值，还可以使用其它多种插值方法，可以参考官方文档。  </p><p> 在使用插值时，建议设置 axis=1, 即用列数据进行插值，因为同一列是属于同一类数据的，而不同列之间往往是不同的数据（比如实际含义不同，或数据类型不同），所以不同列之间(行数据)插值往往不符合实际逻辑。当然如果数据情况允许，那么也可以用行数据进行插值。</p></li></ol><p>至此，对于 DataFrame 对象的数据的简单操作就介绍完了，还有一些进阶操作，将在后面的篇章讲解。</p>]]></content>
      
      
      <categories>
          
          <category> Pandas基础入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4-Pandas读取和保存数据文件</title>
      <link href="/Pandas-Base/PD_04_Pandas_Read_file.html"/>
      <url>/Pandas-Base/PD_04_Pandas_Read_file.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%"></p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="4-Pandas读取和保存数据文件"><a href="#4-Pandas读取和保存数据文件" class="headerlink" title="4.Pandas读取和保存数据文件"></a>4.Pandas读取和保存数据文件</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p>Pandas 主要是用来进行数据处理的，在日常使用时，我们更多的是从文件中读取数据，Pandas 提供了非常多的方法，可以非常方便的读取不同格式的数据文件。</p><h2 id="4-1-读写接口概览览"><a href="#4-1-读写接口概览览" class="headerlink" title="4.1 读写接口概览览"></a>4.1 读写接口概览览</h2><p>Pandas I/O API 提供了一组顶层的读取写方法，使用如 pandas.read_csv(文件名)会返回一个 DataFrame 对象，而使用如 DataFrame.to_csv(文件名) 这样的对象方法，则将 DataFrame 对象保存到文件中。 </p><p>一些常用的数据格式和读写方式罗列在此：  </p><div class="table-container"><table><thead><tr><th>存储格式</th><th>文件类型</th><th>读取方法</th><th>输出(保存)方法</th></tr></thead><tbody><tr><td>text</td><td>CSV</td><td>read_csv</td><td>to_csv</td></tr><tr><td>text</td><td>JSON</td><td>read_json</td><td>to_json</td></tr><tr><td>text</td><td>HTML</td><td>read_html</td><td>to_html</td></tr><tr><td>text</td><td>Local clipboard</td><td>read_clipboard</td><td>to_clipboard</td></tr><tr><td>binary</td><td>MS Excel</td><td>read_excel</td><td>to_excel</td></tr><tr><td>binary</td><td>HDF5</td><td>read_hdf</td><td>to_hdf</td></tr><tr><td>binary</td><td>ORC</td><td>read_orc</td><td>to_orc</td></tr><tr><td>binary</td><td>Parquet</td><td>read_parquet</td><td>to_parquet</td></tr><tr><td>SQL</td><td>SQL</td><td>read_sql</td><td>to_sql</td></tr></tbody></table></div><p>官网提供了读写各种数据的接口，如果想要查看更详细的内容，地址如下：<br><a href="https://pandas.pydata.org/docs/user_guide/io.html">Pandas I/O API</a>  </p><h2 id="4-2-读写CSV文件"><a href="#4-2-读写CSV文件" class="headerlink" title="4.2 读写CSV文件"></a>4.2 读写CSV文件</h2><p>CSV 文件是一种非常常见的文件格式，几乎所有编程语言都有读写 CSV 文件的函数，这里详细介绍下 pandas.read_csv() 和 DataFrame.to_csv() 函数。   </p><h3 id="4-2-1-pandas-read-csv"><a href="#4-2-1-pandas-read-csv" class="headerlink" title="4.2.1 pandas.read_csv()"></a>4.2.1 pandas.read_csv()</h3><p>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html">https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html</a><br>pandas.read_csv() 函数用于从 CSV 文件中读取数据，并生成一个 DataFrame 对象。它可以接受的参数如下：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/4_2_1_read_csv.png" width="80%">  </p><p>下面挑选一些常用的来解释一下：  </p><h4 id="4-2-1-1-基础参数"><a href="#4-2-1-1-基础参数" class="headerlink" title="4.2.1.1 基础参数"></a>4.2.1.1 基础参数</h4><ol><li><p><code>filepath_or_buffer</code><br>文件名(路径)(str)或者文件对象（如已经打开的文件）。 </p></li><li><p><code>sep</code><br>分隔符(str)，默认为逗号(‘,’)。<br>即每一行数据是以什么符号分隔为不同列的，常见的分隔符还有：’|’,  ‘\t’, ‘ ‘ 等。</p></li><li><p><code>delimiter</code><br>定界符(str)，默认为None，是sep的别名，效果和sep一样。如果使用该参数，则sep参数失效。  </p></li></ol><h4 id="4-2-1-2-索引类参数"><a href="#4-2-1-2-索引类参数" class="headerlink" title="4.2.1.2 索引类参数"></a>4.2.1.2 索引类参数</h4><ol><li><p><code>header</code><br> 表头，即DataFrame的列名，接收整数或者整型列表(int or list of ints), 当输入整数k时，会使用序号 k 行的数据作为列名。<br> 默认是通过第一行数据来推理其列名(default ‘infer’)  </p></li><li><p><code>names</code><br> 也是指定列名，接收列表(list of strings)，当header参数设置为None时，使用该参数来指定列名。  </p></li><li><p><code>index_col</code><br> 指定行索引名，接收 int、str、int序列、str序列、False；<br> 默认为None，即不设置index名，会使用 0,1,2, … 等序号作为行索引名。<br> 当index_col参数为整数序列时，表示使用该序列作为行索引名，而当index_col参数为整数时，表示使用该列作为行索引名。  </p></li><li><p><code>usecols</code><br> 读取数据的指定列，即可以不用加载全部列；接收正整数序列或者列名列表；<br> 默认为None，即读取全部数据。 </p></li></ol><h4 id="4-2-1-3-通用的解析类型参数"><a href="#4-2-1-3-通用的解析类型参数" class="headerlink" title="4.2.1.3 通用的解析类型参数"></a>4.2.1.3 通用的解析类型参数</h4><ol><li><p><code>dtype</code><br> 指定数据类型，接收字典或者列表；<br> 默认为None，即自动推断数据类型。<br> 字典格式为 {列名：数据类型}，列表格式为 [(列名，数据类型)]。  </p></li><li><p><code>engine</code><br> 解析引擎，接收’c’或者’python’，默认为’python’。  </p></li><li><p><code>converters</code><br> 列转换函数，接收字典格式，{列名: 转换函数} 或 {列索引: 转换函数}。  </p></li><li><p><code>true_values</code><br> 指定将某些值设置为 True ，接收列表格式，默认为 None。</p></li><li><p><code>false_values</code><br> 指定将某些值设置为 False ，接收列表格式，默认为 None。  </p></li><li><p><code>skipinitialspace</code><br> 是否跳过 delimiter 初始空白字符，默认为False。  </p></li><li><p><code>skiprows</code><br> 指定跳过指定行数，默认为None。<br> 接收列表格式（表示跳过哪些行），或者整数格式（表示从开头算起，跳过前面的多少行）。  </p></li><li><p><code>skipfooter</code><br> 指定跳过尾部行数，接收整数格式，默认为0。</p></li><li><p><code>nrows</code><br> 指定读取的行数，接收整数格式（表示读取前n行），默认为None。  </p></li><li><p><code>memory_map</code><br>布尔值，默认为 False；<br>如果为 filepath_or_buffer 提供了一个文件路径，则将文件对象直接映射到内存中，并从那里直接访问数据。使用此选项可以提高性能，因为不再有任何I/O开销。  </p></li></ol><h4 id="4-1-1-4-缺失值处理"><a href="#4-1-1-4-缺失值处理" class="headerlink" title="4.1.1.4 缺失值处理"></a>4.1.1.4 缺失值处理</h4><ol><li><p><code>na_values</code><br> 指定哪些值应该被视为 NA/NaN，接收列表格式，默认为None。  </p></li><li><p><code>keep_default_na</code><br> 布尔值，默认为True<br> 在解析数据时是否包含默认的NaN值。根据是否传入na_values，行为如下:</p><ul><li><p>如果keep_default_na为True，并且指定了na_values，则将na_values添加到用于解析的默认NaN值之后。</p></li><li><p>如果keep_default_na为True，并且没有指定na_values，则只使用默认的NaN值进行解析。</p></li><li><p>如果keep_default_na为False，并且指定了na_values，则只使用na_values指定的NaN值进行解析。</p></li><li><p>如果keep_default_na为False，并且没有指定na_values，则不会将任何字符串解析为NaN。</p><p>注意，如果na_filter作为False传入，keep_default_na和na_values参数将被忽略。</p></li></ul></li><li><p><code>na_filter</code><br> 布尔值，默认为 True；<br> 检测缺失的值标记(空字符串和na_values的值)。对于没有NAs的数据，设置na_filter=False可以提高读取大文件的性能。</p></li><li><p><code>verbose</code><br> 布尔值，默认为False；<br> 用于指示在非数字列中插入的 NA 值数量，即如果数据包含非数字列，并且这些列中包含缺失值（例如 NaN 或 NA），则可以通过设置 verbose 参数为 True 来获取有关缺失值的数量信息。 </p></li><li><p><code>skip_blank_lines</code><br> 布尔值，默认为True；<br> 如果为 True，则跳过空行。  </p></li></ol><h4 id="4-1-1-5-迭代器"><a href="#4-1-1-5-迭代器" class="headerlink" title="4.1.1.5 迭代器"></a>4.1.1.5 迭代器</h4><p>官方用法指导：<a href="https://pandas.pydata.org/docs/user_guide/io.html#iterating-through-files-chunk-by-chunk">https://pandas.pydata.org/docs/user_guide/io.html#iterating-through-files-chunk-by-chunk</a></p><ol><li><p><code>iterator</code><br> 布尔值，默认为False；<br> 如果为 True，则返回一个迭代器对象：TextFileReader，进行分块处理。  </p></li><li><p><code>chunksize</code><br> 整数，默认为None；<br> 如果chunksize为一个整数，则返回一个迭代器对象，该对象每次返回chunksize行。  </p></li></ol><p>一些平常能用的基本就是这些， 如果想要更详细和更全面的参数介绍，建议还是查阅<a href="https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html">官方文档</a>。  </p><h3 id="4-2-2-DataFrame-to-csv"><a href="#4-2-2-DataFrame-to-csv" class="headerlink" title="4.2.2 DataFrame.to_csv()"></a>4.2.2 DataFrame.to_csv()</h3><p>官方文档：<br><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_csv.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_csv.html</a>  </p><p>对于一个 DataFrame 对象，可以使用 DataFrame.to_csv() 方法将数据保存到本地文件。它可接受的参数如下：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/4_2_2_to_csv.png" width="80%">  </p><p>其实完全可以对照 read_csv() 方法来看，大部分都是通用的。</p><h4 id="4-2-2-1-基本参数"><a href="#4-2-2-1-基本参数" class="headerlink" title="4.2.2.1 基本参数"></a>4.2.2.1 基本参数</h4><ol><li><p><code>path_or_buf</code><br> 要保存的文件路径或文件对象；  </p></li><li><p><code>sep</code><br> 分隔符，默认为逗号；</p></li><li><p><code>delimiter</code><br> <code>sep</code>的别名，默认为None；  </p></li></ol><h4 id="4-2-2-2-索引类参数"><a href="#4-2-2-2-索引类参数" class="headerlink" title="4.2.2.2 索引类参数"></a>4.2.2.2 索引类参数</h4><ol><li><p><code>header</code><br> 表头参数，表示是否保存表头行，布尔值，默认为True；  </p></li><li><p><code>names</code><br> 也是指定列名，接收列表(list of strings)，当header参数设置为None时，使用该参数来指定列名。  </p></li><li><p><code>index_col</code><br> 索引参数，表示是否保存索引列，布尔值，默认为True。  </p></li><li><p><code>usecols</code><br> 读取数据的指定列，即可以不用保存全部列；接收正整数序列或者列名列表；<br> 默认为None，即保存全部数据。 </p></li></ol><p>… 大部分都可以参考 read_csv()方法中的参数，这里就不再重复赘述了。 </p><h2 id="4-3-读写Excel文件"><a href="#4-3-读写Excel文件" class="headerlink" title="4.3 读写Excel文件"></a>4.3 读写Excel文件</h2><p>MS Excel文件也是日常工作中最常用的存储数据的文件之一，而Pandas也提供了读写Excel文件的方法。  </p><h3 id="4-3-1-pandas-read-excel"><a href="#4-3-1-pandas-read-excel" class="headerlink" title="4.3.1 pandas.read_excel()"></a>4.3.1 pandas.read_excel()</h3><p>官方文档链接<br><a href="https://pandas.pydata.org/docs/reference/api/pandas.read_excel.html">https://pandas.pydata.org/docs/reference/api/pandas.read_excel.html</a>  </p><p>pandas.read_excel()用于读取Excel文件，它可接受的参数如下：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/4_3_1_read_ex.png" width="80%">  </p><h4 id="4-3-1-1-基本参数"><a href="#4-3-1-1-基本参数" class="headerlink" title="4.3.1.1 基本参数"></a>4.3.1.1 基本参数</h4><ol><li><p><code>io</code><br> Excel文件路径或Excel文件对象；  </p></li><li><p><code>sheet_name</code><br> 指定读取的sheet名，接收字符串、字符串序列、整数、整数序列；<br> 默认为0，即读取第一个sheet；  </p></li><li><p><code>header</code><br> 指定表头行，接收整数、整数序列、布尔值；<br> 默认为0，即第一行作为表头；  </p></li></ol><p>其余的很多参数也就和 read_csv()方法中的参数类似了，这里就不再重复赘述了。想具体了解的可以参考官方文档。  </p><h3 id="4-3-2-DataFrame-to-excel"><a href="#4-3-2-DataFrame-to-excel" class="headerlink" title="4.3.2 DataFrame.to_excel()"></a>4.3.2 DataFrame.to_excel()</h3><p>官方文档链接<br><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_excel.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_excel.html</a>  </p><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/4_3_2_to_ex.png" width="80%"></p><ol><li><p><code>excel_writer</code><br> Excel文件路径或Excel文件对象；  </p></li><li><p><code>sheet_name</code><br> 指定写入的sheet名，接收字符串、字符串序列、整数、整数序列；<br> 默认为0，即写入第一个sheet；  </p></li><li><p><code>na_rep</code><br> 缺失值表示，接收字符串；<br> 默认为空字符串；  </p></li><li><p><code>float_format</code><br> 浮点数格式，接收字符串；<br> 比如 float_format=”%.2f”  </p></li><li><p><code>startrow</code><br> 起始行，接收整数； 默认为0  </p></li><li><p><code>startcol</code><br> 起始列，接收整数； 默认为0  </p></li></ol><p>其他的一些参数也和 read_excel()的参数类似，这里就不再赘述了。想具体了解的可以参考官方文档。  </p>]]></content>
      
      
      <categories>
          
          <category> Pandas基础入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3-Pandas基础知识</title>
      <link href="/Pandas-Base/PD_03_Pandas_base_knowledge.html"/>
      <url>/Pandas-Base/PD_03_Pandas_base_knowledge.html</url>
      
        <content type="html"><![CDATA[<!-- <img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width=70%>   --><p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%"></p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="3-Pandas基础知识"><a href="#3-Pandas基础知识" class="headerlink" title="3.Pandas基础知识"></a>3.Pandas基础知识</h1><hr style="border:solid; height:1px; color=#000000 size=1"> <p><font color="navy">注：本教程使用 <b>pandas 2.1.1</b>版本作为示例，不同版本有一些方法可能存在不同，检查pandas版本</font> ：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line"><span class="built_in">print</span>(pandas.__version__)</span><br></pre></td></tr></table></figure><h2 id="3-1-pandas-数据结构"><a href="#3-1-pandas-数据结构" class="headerlink" title="3.1 pandas 数据结构"></a>3.1 pandas 数据结构</h2><ol><li><B>Series</B>    <p> <a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.html#pandas.Series">Series</a> 是Pandas库中的<b>一维数据</b>结构，类似于Python中的列表和Numpy中的Ndarray对象。<b>在具体实践中，我们往往视Series为一列数据</b>。Series可以保存任何类型的数据，如整数、浮点数、字符串、Python对象等。如下图所示：  </p><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/3_1_1_1.png" width="55%">   </p><ul><li><font color="red">左边红色框中是Series的索引（标签）</font>，称为index，可以理解为这个Series列数据中，某一行代表的意义；</li><li><p><font color="skyblue">右边蓝色框是Series的值</font>，可见里面的数据类型可以是各种。<br><b>注意：索引只是起到定位，解释数据的作用，而Series的值才是真正存储的数据。如果没有索引，一般会默认从0开始生成整数索引。</b>   </p><p><br><br>Series的索引可以通过 Series.index 属性获取，而Series对应的值可以通过 Series.loc[index名] 或者 Series.iloc[数字]方法获取。<br><br><br></p><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/3_1_1_2.png" width="55%"> </p></li></ul></li><li><B>DataFrame</B>  <p> <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html#pandas-dataframe">DataFrame</a> 是Pandas库中的 <b> 二维数据结构</b> ，类似于Excel表格，可以保存多种数据类型。如下图所示：  </p><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/3_1_2_1.png" width="55%">  </p><p> <img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/3_1_2_2.png" width="55%"></p><p> DataFrame的索引包括：<font color="red">红框中所示<b>行索引（index）</b></font>和<font color="green">绿框中所示<b>列索引（columns）</b></font>，行索引和列索引都是标签。<font color="skyblue">蓝色框中才是DataFrame的<b>数据</b></font>，可见里面的数据类型可以是各种类型。</p><ul><li><p>DataFrame的<b>行索引</b>同样可以通过<b> DataFrame.index </b>属性获取，<br><b>行数据通过 DataFrame.loc[行索引名] 和 DataFrame.iloc[行序号] 方法获取</b>：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/3_1_2_3.png" width="40%">  </p><p><br></p></li><li><p>DataFrame的<b>列名</b>可以通过<b> DataFrame.columns </b>属性获取，<br><b>列数据可以通过<font color="orangered"> DataFrame[列名] </font>或者<font color="orangered"> DataFrame.列名 </font><br>或者<font color="orangered"> DataFrame.loc[: , 列名] </font>或者<font color="orangered"> DataFrame.iloc[: , 列序号] </font>方法获取</b>：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/3_1_2_4.png" width="55%"> </p></li></ul></li><li><p><b>Index</b>  </p><p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.html">Index</a> 是 pandas 中的索引对象，上面在介绍 Series 和 DataFrame 时，已经多次提到了索引对象。  </p><p><b>它是一种特殊的序列，用于标记数据集中的行(index)和列(columns)</b>。在没有特别指定的情况下，一般都是默认 从 0 开始取整数序号。</p><p>常见的 Index 类型有如下几种，<font color="navy">不用全部掌握，遇到不会的只需要去查官方文档即可</font>：</p><ul><li><p><b>RangeIndex</b>：<br>单调整数范围的索引<br>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.RangeIndex.html">RangeIndex</a>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.RangeIndex(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/3_1_3_1.png" width="40%">  </p></li><li><p><b>Int64Index</b>：<br>整数索引<br>注意，这个方法可能会在未来被舍弃，应尽量使用 pandas.Index 方法代替：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.RangeIndex(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/3_1_3_2_1.png" width="70%">  </p><p>使用 pandas.Index 替代：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.Index([-<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], dtype=<span class="string">&#x27;int64&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/3_1_3_2_2.png" width="40%"> </p></li><li><p><b>UInt64Index</b>：<br>非负数整数索引<br>注意，这个方法可能会在未来被舍弃，应尽量使用 pandas.Index 方法代替：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.UInt64Index([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/3_1_3_3_1.png" width="70%">  </p><p>使用 pandas.Index 替代：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.Index([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], dtype=<span class="string">&#x27;uint64&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/3_1_3_3_2.png" width="40%"></p></li><li><p><b>Float64Index</b>：<br>浮点数索引<br>注意，这个方法可能会在未来被舍弃，应尽量使用 pandas.Index 方法代替：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.Float64Index([<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>,<span class="number">4.0</span>])</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/3_1_3_4_1.png" width="70%">  </p><p>使用 pandas.Index 替代：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.Index([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>], dtype=<span class="string">&#x27;float64&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/3_1_3_4_2.png" width="45%">  </p></li><li><p><b>MultiIndex</b>：<br>多个层次且有归属关系的索引。<br>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.MultiIndex.html">MultiIndex</a>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arrays = [[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]]</span><br><span class="line">pd.MultiIndex.from_arrays(arrays, names=(<span class="string">&#x27;number&#x27;</span>, <span class="string">&#x27;color&#x27;</span>))</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/3_1_3_4_5.png" width="55%">  </p></li><li><p><b>CategoricalIndex</b>：<br>类别索引，可以理解为其他语言中的枚举类型。<br>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.CategoricalIndex.html">CategoricalIndex</a>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.CategoricalIndex([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>])</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/3_1_3_4_6.png" width="66%">  </p></li><li><p><b>IntervalIndex</b><br>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.IntervalIndex.html">IntervalIndex</a><br>间隔索引，代表数值or时间的区间，一般应用于分箱(桶)数据。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.IntervalIndex.from_arrays([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/3_1_3_4_7.png" width="66%">  </p></li><li><p><b>DatetimeIndex</b><br>时间索引，标注时序数据的时间，时序数据是算是一种较为特殊的数据吧，因为要求数据带有时间戳，比如股票的数据；所以这个时间索引基本上也就在处理这种数据的时候用到。<br>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.DatetimeIndex.html">DatetimeIndex</a>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.DatetimeIndex([<span class="string">&quot;1/1/2020 10:00:00+00:00&quot;</span>, </span><br><span class="line">             <span class="string">&quot;2/1/2020 11:00:00+00:00&quot;</span>])</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/3_1_3_4_8.png" width="66%">  </p></li><li><p><b>TimedeltaIndex</b><br>时间差索引，时间长度的数据。<br>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.TimedeltaIndex.html">TimedeltaIndex</a>  </p><p>不太常用，可以自行参考官方文档。</p></li><li><p><b>PeriodIndex</b><br>周期索引，表示一定周期的时间点。<br>官方文档：<a href="https://pandas.pydata.org/docs/reference/api/pandas.PeriodIndex.html">PeriodIndex</a>  </p><p>不太常用，可以自行参考官方文档。</p></li></ul></li></ol><h2 id="3-2-pandas-数据类型"><a href="#3-2-pandas-数据类型" class="headerlink" title="3.2 pandas 数据类型"></a>3.2 pandas 数据类型</h2><p>在Pandas中，存储的数据支持的数据类型主要有以下几种：</p><div class="table-container"><table><thead><tr><th>名称</th><th>释义</th><th>例子</th></tr></thead><tbody><tr><td>浮点数（float）</td><td>用于存储浮点实数。</td><td>1.0、2.234、3.4E-6</td></tr><tr><td>整数（int）</td><td>用于存储整数。</td><td>1、2、3、4</td></tr><tr><td>布尔值（bool）</td><td>用于存储真假值。</td><td>True、False</td></tr><tr><td>时间和日期类型（timedelta[ns], datetime64[ns]）</td><td>用于存储时间间隔和日期时间。</td><td>2019-01-01 12:00:00</td></tr><tr><td>字符串（object）</td><td>pandas用object存储字符串。 当一列中含多种类型的数据时，该列的数据类型通常为object。</td><td>‘hello’、’world’</td></tr><tr><td>复合数据类型（object）</td><td>pandas也用object存储复杂的数据结构，如（list, dict, tuple）。</td><td>[1, 2, 3]、{‘a’: 1, ‘b’: 2}、(1, 2, 3)</td></tr></tbody></table></div><p>关于数据类型，大概知道以上表格内容基本就能应付大多数情况了，如果想要知道更多的细节内容，可以点此参考<a href="https://pandas.pydata.org/docs/user_guide/basics.html#dtypes">官方文档</a>。  </p><p>假设有 DataFrame 对象 dft，可以通过 <b>dft.dtypes</b> 属性获取 df 中所有列的数据类型。如下所示：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/3_2.png" width="50%">  </p><p>延伸阅读: <a href="https://pbpython.com/pandas_dtypes.html">https://pbpython.com/pandas_dtypes.html</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Pandas基础入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2-Pandas与Jupyter环境安装</title>
      <link href="/Pandas-Base/PD_02_Pandas_Jupyter_installation.html"/>
      <url>/Pandas-Base/PD_02_Pandas_Jupyter_installation.html</url>
      
        <content type="html"><![CDATA[<!-- <img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width=70%>   --><p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%"></p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="2-Pandas与Jupyter环境安装"><a href="#2-Pandas与Jupyter环境安装" class="headerlink" title="2.Pandas与Jupyter环境安装"></a>2.Pandas与Jupyter环境安装</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="2-1-安装Pandas"><a href="#2-1-安装Pandas" class="headerlink" title="2.1 安装Pandas"></a>2.1 安装Pandas</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install pandas</span><br></pre></td></tr></table></figure><p>但是更加推荐直接安装 Anaconda 包。<br>Anaconda 是一个用于科学计算的 Python 发行版，支持 Linux, Mac, Windows等系统，官网下载<a href="https://www.anaconda.com/download">https://www.anaconda.com/download</a>。  </p><p>Anaconda这个包本身就包含 Python, IPython, numpy, scipy, pandas, matplotlib 等常用科学计算库，等于说下载这个包就省了后面再去单独安装各个模块的功夫了。  </p><p>假设下载后将其解压到 D:\anaconda3 下，在安装时可以勾选直接将其添加到环境变量中：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/2_anaconda_1.png">  </p><p>这样在环境变量中就会自动配置如下：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/2_anaconda_env.png">  </p><p>以后在使用python的时候，只需要导入 pandas 库即可：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 习惯上一般都将其重命名为pd，并非硬性规定，只是一种通用习惯</span></span><br></pre></td></tr></table></figure><h2 id="2-2-安装-Jupyter-Notebook"><a href="#2-2-安装-Jupyter-Notebook" class="headerlink" title="2.2 安装 Jupyter Notebook"></a>2.2 安装 Jupyter Notebook</h2><p>Jupyter 是一个交互式Web应用程序，允许用户创建和共享包含实时代码，方程式，可视化和文本的文档。其实pandas本身并不依赖 Jupyter，在程序脚本里使用pandas就行，使用Jupyter Notebook主要是方便可视化，能够比较直观的看到数据。  </p><p>如果是安装了 Anaconda 包，那么 Jupyter 就已经安装好了，可以直接使用。只需要在命令行输入：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Jupyter Notebook</span><br></pre></td></tr></table></figure><p>即可启动 Jupyter Notebook，然后就会在浏览器中弹出一个页面。  </p><p>至于 Jupyter Notebook 的使用，并非本教程的范围，本教程主要是集中在pandas的基本使用上，这里就不赘述。  </p>]]></content>
      
      
      <categories>
          
          <category> Pandas基础入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1-Pandas教程简介</title>
      <link href="/Pandas-Base/PD_01_Introduction.html"/>
      <url>/Pandas-Base/PD_01_Introduction.html</url>
      
        <content type="html"><![CDATA[<!-- <img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width=70%>   --><p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%"></p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="1-教程简介"><a href="#1-教程简介" class="headerlink" title="1.教程简介"></a>1.教程简介</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h2><p>本教程是快速了解如何使用Pandas库对数据进行处理，限于时间和精力，仅仅作为一个入门级教程。学习本教程要求会基本python语法。  </p><h2 id="1-2-章节内容介绍"><a href="#1-2-章节内容介绍" class="headerlink" title="1.2 章节内容介绍"></a>1.2 章节内容介绍</h2><h3 id="Chapter2-Pandas与Jupyter环境安装"><a href="#Chapter2-Pandas与Jupyter环境安装" class="headerlink" title="Chapter2 Pandas与Jupyter环境安装"></a>Chapter2 Pandas与Jupyter环境安装</h3><p>安装Jupyter Notebook 和 pandas 库  </p><h3 id="Chapter3-Pandas基础知识"><a href="#Chapter3-Pandas基础知识" class="headerlink" title="Chapter3 Pandas基础知识"></a>Chapter3 Pandas基础知识</h3><ul><li>pandas 数据结构介绍</li><li>pandas 数据类型介绍</li></ul><h3 id="Chapter4-Pandas读取和保存数据文件"><a href="#Chapter4-Pandas读取和保存数据文件" class="headerlink" title="Chapter4 Pandas读取和保存数据文件"></a>Chapter4 Pandas读取和保存数据文件</h3><p>读取 txt、csv、xlsx、json、html 格式的数据文件</p><h3 id="Chapter5-pandas数据基础操作"><a href="#Chapter5-pandas数据基础操作" class="headerlink" title="Chapter5 pandas数据基础操作"></a>Chapter5 pandas数据基础操作</h3><ul><li>如何创建数据表</li><li>如何对数据表进行基础的增、删、改、查</li><li>如何对数据表进行基础的统计分析</li></ul><h3 id="Chapter6-pandas数据进阶操作"><a href="#Chapter6-pandas数据进阶操作" class="headerlink" title="Chapter6 pandas数据进阶操作"></a>Chapter6 pandas数据进阶操作</h3><ul><li>数据过滤</li><li>数据迭代</li><li>函数应用</li></ul><h3 id="Chapter7-pandas数据分组聚合合并"><a href="#Chapter7-pandas数据分组聚合合并" class="headerlink" title="Chapter7 pandas数据分组聚合合并"></a>Chapter7 pandas数据分组聚合合并</h3><ul><li>分组与聚合</li><li>合并与分裂</li></ul>]]></content>
      
      
      <categories>
          
          <category> Pandas基础入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5-感知机</title>
      <link href="/Machine-Learning/ML_05_Perceptron.html"/>
      <url>/Machine-Learning/ML_05_Perceptron.html</url>
      
        <content type="html"><![CDATA[<!-- <img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width=70%>   --><p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%"></p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="5-感知机"><a href="#5-感知机" class="headerlink" title="5 感知机"></a>5 感知机</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="5-1-感知机模型"><a href="#5-1-感知机模型" class="headerlink" title="5.1 感知机模型"></a>5.1 感知机模型</h2><p>感知机(perceptron)是一种用于<b>二分类</b>的<b>线性分类</b>模型：输入为实例的特征向量，输出为实例的类别，取<b>+1和-1</b>二值。  </p><p>感知机是1957年提出的，比较早的一个模型，但是它算是SVM和神经网络模型的基础。如果之前已经了解过逻辑回归(logistic regression)，其实就比较容易理解感知机了，硬要说的话，逻辑回归其实是从感知机发展而来的。  </p><p>感知机模型可以用下面的公式来表示：  </p><script type="math/tex; mode=display">f(x) = sign(w \cdot x + b) \tag {5-1}</script><p>其中，$w \cdot x + b$ 是线性方程，$w$是权值(weight)，$b$是偏置(bias)，$sign$是符号函数。<br>符号函数的定义如下：    </p><script type="math/tex; mode=display">sign(x) = \begin{cases}+1, & x \ge 0 \\-1, & x < 0\end{cases}\tag {5-2}</script><p>其图像示例为：<br><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C5_1_sign.jpg" width="40%">  </p><p>即，符号函数对大于0的值，映射为1；对小于等于0的值，映射为-1。    </p><p>对于线性部分 $w \cdot x + b$ 的结果施加的函数，可以称为<b>激活函数(activation function)</b>。所以，当激活函数为 $sign$ 函数时，模型就是感知机；激活函数为 $sigmoid$ 函数时，模型就成了逻辑回归。二者的图像画在一起如下：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C5_2_perceptron_logsitc.jpg" width="80%">  </p><p>可知，<b>感知机的结果就是1或者-1，而逻辑回归的结果是0到1之间的连续值</b>，所以逻辑回归依然用的是“回归”名字，只不过可以通过取阈值 threshold 来做进一步的二分类。</p><p>在深度学习领域，还有更多的激活函数，比如 ReLU、Leaky ReLU、ELU 等，这里不做赘述。  </p><p><b>一个线性加权和经过激活函数，这样的结构被称为 M-P神经元</b>，它是 1943 年Minsky和Papert 模拟神经元的工作原理而提出的。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C5_2_1_neuron.jpg"></p><h3 id="5-1-1-感知机的目的"><a href="#5-1-1-感知机的目的" class="headerlink" title="5.1.1 感知机的目的"></a>5.1.1 感知机的目的</h3><p>感知机模型的目的，就是<b>找到一个最优的分类边界，使得分类结果尽可能的好</b>。也就是说，最终目标就是使得<b> $w \cdot x + b=0$ </b>形成的<b>线性超平面</b>（二维的情况就是一根线，三维的情况就是一个面，多维的情况就是超平面），能够将样本分割为正、负两部分，如下图所示。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C5_3_separating_hyperplane.jpg" width="50%"></p><p>如果一个数据集能够找到至少一个超平面将样本点正确地分割开，就称该数据集为线性可分的。如果一个数据集无法找到一个超平面将其分割开，就称该数据集为线性不可分的。  </p><h3 id="5-1-2-感知机的学习策略"><a href="#5-1-2-感知机的学习策略" class="headerlink" title="5.1.2 感知机的学习策略"></a>5.1.2 感知机的学习策略</h3><p>上面提到，感知机就是期望找到一个线性超平面将数据集分为两部分，所以要确定超平面 $w \cdot x + b=0$  就是要确定其法向量 $w$ 和截距 $b$ 这两个参数，所以就需要确定一个损失函数，并将损失函数极小化来获取对  $w$ 和  $b$ 的估计。  </p><p>损失函数的一种想法是，统计误分类点的个数，然后用误分类点的个数来作为损失函数。但是，这样的损失函数不是参数 $w$ 和 $b$ 的连续可导函数，所以无法使用梯度下降法来求解。  </p><p>另一种想法是，<b>统计误分类点到超平面的距离，来作为损失函数</b>。这样，损失函数就是参数 $w$ 和 $b$ 的连续可导函数，就可以使用梯度下降法来求解。  </p><p>点 $x_0$ 到平面的距离公式为：  </p><script type="math/tex; mode=display">\frac{1}{||w||} |w \cdot x_0 + b|  \tag{5-3}</script><p>其中，$||w||$ 表示法向量 $w$ 的模，也就是 L2 范数。  </p><p>对于误分类点 $(x_i, y_i)$ ，有两种情况：  </p><ol><li>点 $x_i$ 在超平面的左侧，即 $w \cdot x_0 + b &lt; 0$ ，分类结果为-1，但标签却为 $y_i=1$ ，那么点 $x_i$ 到超平面的距离为：  <script type="math/tex; mode=display">\frac{1}{||w||} |w \cdot x_0 + b| = \frac{1}{||w||} \cdot -y_i(w \cdot x_0 + b)  \tag{5-4-1}</script></li><li>点 $x_i$ 在超平面的右侧，即 $w \cdot x_0 + b &gt; 0$ ，分类结果为 1，但标签却为 $y_i=-1$ ，那么点 $x_i$ 到超平面的距离为：<script type="math/tex; mode=display">\frac{1}{||w||} |w \cdot x_0 + b| = \frac{1}{||w||} \cdot -y_i(w \cdot x_0 + b)  \tag{5-4-2}</script></li></ol><p>所以会发现，误分类点到超平面的距离，去掉绝对值符号后都可以统一写为：  </p><script type="math/tex; mode=display">\frac{1}{||w||} \cdot -y_i(w \cdot x_0 + b)  \tag{5-4-3}</script><p>则假设误分类点的集合为 M，则损失函数为：  </p><script type="math/tex; mode=display">L(w, b) = -\frac{1}{||w||} \sum_{x_i \in M}{y_i(w \cdot x_i + b)}  \tag{5-5-1}</script><p><font color="orangered">对于感知机来说，损失函数可以不考虑 $||w||$ 部分，直接将损失函数写为</font>：  </p><script type="math/tex; mode=display">L(w, b) = - \sum_{x_i \in M}{y_i(w \cdot x_i + b)}  \tag{5-5-2}</script><p><b>思考的角度不是说直接去掉 $||w||$ 部分，而是假设 $||w||$ = 1。</b> 因为任何一个 超平面都可以将其改写为 $||w||$ = 1 的形式，即对每个系数都除以 $||w||$ 即可，同时超平面本身不会变化。比如对于一个超平面：  </p><script type="math/tex; mode=display">3\cdot x_1 + 4 \cdot x_2 + b = 0 \tag{5-6-1}</script><p>将其改写为:  </p><script type="math/tex; mode=display">\frac{3}{5} \cdot x_1 + \frac{4}{5} \cdot x_2 + \frac{b}{5} = 0</script><p>其实超平面还是原来那个超平面，但是改写后的 $||w||$ = 1 。  </p><h3 id="5-1-3-参数更新方法"><a href="#5-1-3-参数更新方法" class="headerlink" title="5.1.3 参数更新方法"></a>5.1.3 参数更新方法</h3><p>采用随机梯度下降的方法，对损失函数求梯度：  </p><script type="math/tex; mode=display">\begin{aligned}\nabla_wL(w,b) & = -\sum_{x_i \in M}{y_ix_i} \\\nabla_bL(w,b)  & = -\sum_{x_i \in M}{y_i} \\\end{aligned}  \tag{5-7}</script><p>则更新公式为：  </p><script type="math/tex; mode=display">\begin{aligned}w & := w - \eta \cdot \nabla_wL(w,b) \\b & := b - \eta \cdot \nabla_bL(w,b) \\\end{aligned}  \tag{5-8}</script><p>其中 $\eta$ 为学习率。每一次选取一个误分类点即可。这样通过不断迭代就能使得损失函数 $L(w, b)$ 不断减小，直到为0，就说明没有误分类点了。 </p><h3 id="5-1-4-算法收敛性"><a href="#5-1-4-算法收敛性" class="headerlink" title="5.1.4 算法收敛性"></a>5.1.4 算法收敛性</h3><p>根据 Novikoff定律，当训练集数据线性可分时，感知机算法是收敛的。如果训练集数据线性不可分，则感知机算法不收敛，迭代结果发生震荡。  </p><p>需要注意的是，感知机学习算法对训练数据集的元素顺序敏感，即误分类点选取的顺序不同，可能导致学习结果的不同。同时，感知机算法对于参数初始值也比较敏感，如果初始值设置不当，可能会导致学习失败。  </p><h2 id="5-2-多层感知机"><a href="#5-2-多层感知机" class="headerlink" title="5.2 多层感知机"></a>5.2 多层感知机</h2><h3 id="5-2-1-感知机的局限性"><a href="#5-2-1-感知机的局限性" class="headerlink" title="5.2.1 感知机的局限性"></a>5.2.1 感知机的局限性</h3><p>感知机的局限性：感知机不能解决异或问题。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C5_4_xor.jpg" width="50%">  </p><p>如果所示，用一个超平面是无法将异或问题划分的，它是属于<b>线性不可分问题</b>，一般有两个思路：  </p><ol><li><p>对输入数据做处理，看看能否<b>将输入数据映射到高维度空间中，在高维空间或许能找到一个线性超平面</b>，将其分开。这其实就是 SVM 算法中的核方法。  </p></li><li><p><b>用多个感知机，每个感知机负责将一部分数据分开</b>，最后将分开的数据合并起来。这其实就是多层感知机。  </p></li></ol><p>多层感知机能解决异或问题：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C5_5_MLP.jpg" width="50%">  </p><p>如果所示的多层神经网络，第一层用了两个神经元，一个神经元用来实现与非门，一个神经元用来实现或门；第二层用了一个神经元，用来实现与门。最终整个多层感知机，实现了异或门的功能。</p><h3 id="5-2-2-多层感知机的发展"><a href="#5-2-2-多层感知机的发展" class="headerlink" title="5.2.2 多层感知机的发展"></a>5.2.2 多层感知机的发展</h3><p>由于多层感知机可以解决异或问题的启发，可以想到，如果增加神经元的层数，是可以解决更复杂的问题的。<br>如图所示： </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C5_6_MLP_2.jpg" width="40%">  </p><p>多层感知机中，每一个神经元的输出，都输入到下一层所有的神经元中；除第一层外，每个神经元的输入都是上一层所有神经元的输出，按照现在深度学习的叫法，这种连接方式称之为“全连接(Fully-Connected)”， 从数学角度看就是在做矩阵乘法。  </p><p><b>Hornik 等人在1989年证明，只要多层感知机中的神经元个数和层数足够多，那么多层感知机就能以任意精度逼近任何连续函数</b>，足见其强大的表示能力。同时，BP(反向传播)算法的提出，使得多层感知机能够以较简单的方式训练。到现在，得益于计算力和数据的飞速爆炸，脱胎于多层感知机的深度学习，已经成了人工智能领域的主流技术。   </p><p>目前神经网络和深度学习已然成为了一门单独的学科，但是它的发展历程和理论基础，都和多层感知机有着千丝万缕的关系。所以深度学习其实可以被看作是多层感知机的一个延伸和扩展，是机器学习算法的一个分支。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4-线性模型--(下)</title>
      <link href="/Machine-Learning/ML_04_Linear_Model_3.html"/>
      <url>/Machine-Learning/ML_04_Linear_Model_3.html</url>
      
        <content type="html"><![CDATA[<!-- <img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width=70%>   --><p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%"></p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="4-线性模型—-下"><a href="#4-线性模型—-下" class="headerlink" title="4 线性模型—(下)"></a>4 线性模型—(下)</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="4-5-逻辑回归-Logistic-Regression"><a href="#4-5-逻辑回归-Logistic-Regression" class="headerlink" title="4.5 逻辑回归(Logistic Regression)"></a>4.5 逻辑回归(Logistic Regression)</h2><p><b>逻辑回归(Logistic Regression) 也被称为对数几率回归（Logit Regression）</b>，它是在线性回归的基础之上做了改进，输出值依然是连续值，所以称“回归(Regression)”。虽然名字依然是回归，<b>但它主要是用来处理二分类问题的。</b>  </p><p>这是因为它的输出值依然是连续值，但是它是将线性回归的输出结果通过<a href="https://en.wikipedia.org/wiki/Sigmoid_function">Sigmoid</a>函数转换为0~1之间的概率值，然后通过概率值来判断分类。 </p><p><b>至于为何 Sigmoid 函数的输出值能够视为概率值，是可以通过<font color="orangered">广义线性模型(GLM) 和 指数分布族</font>推导出来的，后面有介绍。</b></p><h3 id="4-5-1-Logistic-Function"><a href="#4-5-1-Logistic-Function" class="headerlink" title="4.5.1 Logistic Function"></a>4.5.1 Logistic Function</h3><p><b>Logstic Function，也被称为 Sigmoid Function</b>，它的公式如下:    </p><script type="math/tex; mode=display">g(z) = \frac{1}{1+e^{-z}} \tag{4-22}</script><p>它的图像如下:  </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_sigmoid.jpg" width="35%">  </p><p>由图像可知，<font color="navy"><b>Sigmoid 函数可以将一个实数映射到(0,1)的区间</b></font>。  </p><p>Sigmoid函数的导数有一个很好的性质：  </p><script type="math/tex; mode=display">\begin{aligned}g'(z) &=  \frac{d}{dz} (\frac{1}{1+e^{-z}} )\\&= \frac{1}{(1+e^{-z})^2} \cdot (-e^{-z}) \\&= \frac{1}{1+e^{-z}} \cdot \frac{e^{-z}}{1+e^{-z}} \\&= \frac{1}{1+e^{-z}} \cdot (1-\frac{1}{1+e^{-z}} )\\&= g(z) \cdot (1-g(z))\end{aligned}</script><p>即 <script type="math/tex">g'(z) = g(z) \cdot (1-g(z))  \tag{4-23}</script> </p><h3 id="4-5-2-逻辑回归的预测函数"><a href="#4-5-2-逻辑回归的预测函数" class="headerlink" title="4.5.2 逻辑回归的预测函数"></a>4.5.2 逻辑回归的预测函数</h3><p>我们知道，线性回归的预测函数可以表示为：  </p><script type="math/tex; mode=display">\hat{y} = h_w(x)= \vec{w} \vec{x}+b \tag{4-24}</script><p>此时预测值 $y$ 的值域范围是 $ (-\infty,+\infty) $，如果我们再在此基础之上，<b>外套一个Logistic(Sigmoid)函数，那么此时的预测函数的值域范围就变成了 $(0,1) $ </b>，即：</p><script type="math/tex; mode=display">\hat{y} = g( h_w(x)) = g(\vec{w} \vec{x}+b)= \frac{1}{1+e^{-\vec{w} \vec{x}+b}} \tag{4-25}</script><p><b>这就是 Logistic Regression 名字的由来</b>！  </p><p>如果将该预测函数运用于二分类问题，那么 $\hat{y}$ 就可以用来代表样本 $x$ 属于正例的概率值，则 $1-\hat{y}$ 就可以用来代表样本 $x$ 属于负例的概率值。那么就可以自己设定一个阈值 $thresh$ (通常默认就是0.5)， $\hat{y}&gt;thresh$ 就可以认为样本 $x$ 属于正例， $\hat{y}&lt;thresh$ 就可以认为样本 $x$ 属于负例；由此，就能够实现二分类！</p><p>如果将上式恢复成线性回归的形式，只需要化简两边同时取 $ln$ ：  </p><script type="math/tex; mode=display">ln \frac{\hat{y}}{1-\hat{y}} =  \vec{w} \vec{x}+b \tag{4-26}</script><p>若  $y$ 代表样本属于正例的概率值， $ 1-y $ 代表样本属于负例的概率值，则二者的比值在统计学中就称为<a href="https://en.wikipedia.org/wiki/Odds">几率(odds)</a> ：</p><script type="math/tex; mode=display">odds = \frac{\hat{y}}{1-\hat{y}} \tag{4-27}</script><p>那么对几率求对数就是<b>对数几率(log-odds)，也作 logit</b>，故式子可以继续改写 ：  </p><script type="math/tex; mode=display">\vec{w} \vec{x}+b = ln \frac{\hat{y}}{1-\hat{y}} = logit(\hat{y})\tag{4-28}</script><p>即逻辑回归的预测函数，可以转化为普通线性回归的形式，就可以理解为<b><font color="navy">在对“对数几率(log-odds)”进行线性回归预测，预测值是 $\hat{y}$ 的对数几率值；</font> 因此，Logistic Regression 又被称为 Logit Regression，即“对数几率回归”</b>。  </p><h3 id="4-5-3-逻辑回归的损失函数"><a href="#4-5-3-逻辑回归的损失函数" class="headerlink" title="4.5.3 逻辑回归的损失函数"></a>4.5.3 逻辑回归的损失函数</h3><p>讨论损失函数，就是在讨论如何衡量预测值和真实值之间的差距，从而决定如何调整参数，即机器学习三要素的<b>策略</b>。   </p><p>为了同之前讲的线性回归统一起来，假设仍使用 $h(·)$ 来表示预测函数，则逻辑回归的预测函数可以写为:  </p><script type="math/tex; mode=display">h_w(x) = \frac{1}{1+e^{-\vec{w}\vec{x}}} \tag{4-29}</script><p>逻辑回归的损失函数被称为<b>交叉熵损失函数(Cross-Entropy Loss)</b>:  </p><script type="math/tex; mode=display">J(w) = -\frac{1}{m} \sum_{i=1}^m \left[ y^{(i)} \ln h_w(x^{(i)}) + (1-y^{(i)}) \ln (1-h_w(x^{(i)})) \right] \tag{4-30}</script><p> 其中 ，$m$ 表示样本个数，$y^{(i)}$ 表示第 $i$ 个样本的真实标签，$h_w(x^{(i)})$ 表示第 $i$ 个样本的预测值。  </p><p>我们可以从下面三个方向来理解这个损失函数：  </p><ol><li><p><b>交叉熵(Cross Entropy)</b>  </p><ul><li><p><b>熵</b><br>熵表示的是随机变量不确定性的度量，熵越大，随机变量的不确定性就越大。 其计算公式如下：  </p><script type="math/tex; mode=display">H(X) = -\sum_{x \in X} p(x) \ln p(x) \tag{4-31}</script><p>其中，$X$ 表示随机变量，$p(x)$ 表示随机变量取值为 $x$ 的概率。<br><br>  </p></li><li><p><b>交叉熵</b><br>交叉熵表示的是两个概率分布之间的距离，交叉熵越大，两个概率分布就越相似。 其计算公式如下：  </p><script type="math/tex; mode=display">H(p,q) = -\sum_{x \in X} p(x) \ln q(x) \tag{4-32}</script><p>在机器学习问题中，可以将 <b> $p(x)$ 表示真实分布，$q(x)$ 表示预测分布</b>，这样真实分布与预测分布之间的交叉熵，即能表示模型从数据中学得的概率分布 $q(x)$ 与数据的真实分布 $p(x)$ 有多接近，进而衡量模型的好坏。<br><br>   </p></li></ul></li></ol><ol><li><p><b>极大似然估计</b>  </p><p>在上面我们提到，逻辑回归的预测值 $\hat{y}$ 是可以被视为二分类问题中样本 $x$ 属于正例的概率值，那么样本为负例的概率值就可以写为 $1-\hat{y}$。 所以将两种类别的概率表达式写出：  </p><script type="math/tex; mode=display">\begin{aligned} P(y=1 |x; w) &= h_w(x)  \\P(y=0 | x; w) &= 1-h_w(x) \end{aligned} \tag {4-33}</script><p>这两个情况可以整合成一个统一的式子：  </p><script type="math/tex; mode=display">P(y| x; w) = \left[h_w(x) \right]^y  \left[1-h_w(x)\right]^{1-y} \tag {4-34}</script><p>假设 m 个样本都是相互独立的，那么写出参数 $w$ 的似然函数：  </p><script type="math/tex; mode=display">L(w) = \prod_{i=1}^m P(y^{(i)}|x^{(i)}, w) = \prod_{i=1}^m  \left[h_w(x^{(i)}) \right]^{y^{(i)}} \left[1-h_w(x^{(i)}) \right]^{1-y^{(i)}} \tag {4-35}</script><p>关于似然函数的相关知识，属于概率论与数理统计中的一个常用且经典的知识点，这里就不展开讨论了。  </p><p>写出上式的对数似然函数：  </p><script type="math/tex; mode=display">\ln L(w) = \sum_{i=1}^m y^{(i)} \ln h_w(x^{(i)}) + (1-y^{(i)}) \ln (1-h_w(x^{(i)})) \tag {4-36}</script><p>极大似然估计就是希望获得参数的估计值，能够使极大似然函数值取得最大。  </p><p>所以，逻辑回归的损失函数可以写为如下所示，相当于是在似然函数前面多了负号，则该损失函数取得极小值时，对应似然函数就取到极大值：  </p><script type="math/tex; mode=display">J(w) = -\frac{1}{m} \sum_{i=1}^m \left[ y^{(i)} \ln h_w(x^{(i)}) + (1-y^{(i)}) \ln (1-h_w(x^{(i)})) \right] \tag {4-37}</script><p>这个其实就是<b>交叉熵</b>的形式，所以该损失函数被称为<b>交叉熵损失函数</b>。<br>真实分布$p(x)$ 的取值为 $y^{(i)}$ 或者 $1-y^{(i)}$；<br>预测分布$q(x)$ 的取值为 $\ln h_w(x^{(i)})$ 或者 $1- \ln h_w(x^{(i)})$。<br><b><font color="orangered">总结：逻辑回归的损失函数 — 交叉熵损失函数，是可以通过极大似然估计来推导出的。</font></b><br> <br></p></li><li><p><b>相对熵(relative entropy)</b>    </p><p> 相对熵也叫 KL 散度，用来衡量两个概率分布之间的相似程度。  </p><p> 相对熵定义为： </p><script type="math/tex; mode=display">D_{KL}(p||q) = \sum_{x\in X} p(x) \ln \frac{p(x)}{q(x)}  \tag {4-38}</script><p> 将以上公式进行推导：  </p><script type="math/tex; mode=display">\begin{aligned} D_{KL}(p||q) &= \sum_{x\in X} p(x) \ln p(x) - \sum_{x\in X} p(x) \ln q(x) \\&= -H(p) + H(p,q)\end{aligned}  \tag {4-39}</script><p> 由于在当前问题中，$p$ 是真实分布（即训练样本的分布），<b>所以其熵 $H(p)$ 是一个确定的常量</b>，所以 $p$ 和 $q$ 之间的相对熵 $ D_{KL}(p||q) $ 其实仅取决于二者之间交叉熵 $H(p,q)$ 的大小，<b> 所以可以用交叉熵作为损失函数来衡量 训练样本的真实分布 与 模型输出的分布之间的差异大小</b>。  </p></li></ol><h2 id="4-6-多分类逻辑回归-Multinomial-Logistic-Regression"><a href="#4-6-多分类逻辑回归-Multinomial-Logistic-Regression" class="headerlink" title="4.6 多分类逻辑回归(Multinomial Logistic Regression)"></a>4.6 多分类逻辑回归(Multinomial Logistic Regression)</h2><p>传统的逻辑回归只能解决二分类问题，如果要解决多分类问题，就需要对逻辑回归进行改造，使其能够处理多分类问题。 </p><h3 id="4-6-1-One-Vs-All-OvA"><a href="#4-6-1-One-Vs-All-OvA" class="headerlink" title="4.6.1 One-Vs-All(OvA)"></a>4.6.1 One-Vs-All(OvA)</h3><p><b>One-Vs-All</b> 方法是解决多分类问题的一个常用方法，也被称为 <b>“一对多”</b> ，也有叫它 <b>One-vs-Rest(OVR) </b>的，总之是表达这么一个思路：  </p><p><b>对于每一个类别，都单独训练一个二分类的逻辑回归分类器</b>，这个分类器只能处理这个类别，它的功能是判断输入样本（是属于这个类别，还是不属于这个类别） 这个二分类问题。</p><p>假设现在有一个问题是要将数据分为 A、B、C、D 四个类别，那么我们可以训练四个二分类的逻辑回归分类器，每个分类器只能处理一个类别，即：</p><ul><li>第一个分类器 L_a，它只判断样本是否属于 A 类别；</li><li>第二个分类器 L_b，它只判断样本是否属于 B 类别；  </li><li>第三个分类器 L_c，它只判断样本是否属于 C 类别；  </li><li>第四个分类器 L_d，它只判断样本是否属于 D 类别；  </li></ul><p>在训练时，每个训练样本都要并行的进入这四个分类器去拟合其参数；<br>在测试时，每个测试样本也都并行的进入这四个分类器，去获得四个不同的sigmoid输出，一般挑选输出最大的那个分类器代表的类别来作为预测类别。  </p><p>总结起来，如果有N个类别，那这种 OVA 思路就要建立 N 个不同的二分类逻辑回归模型，每个模型只能处理一个类别。</p><h3 id="4-6-2-One-Vs-One-OvO"><a href="#4-6-2-One-Vs-One-OvO" class="headerlink" title="4.6.2 One-Vs-One(OvO)"></a>4.6.2 One-Vs-One(OvO)</h3><p><b>One-Vs-One(OvO)是指的 “一对一”</b>，会针对类别两两组合建立二分类器，依然用分 A、B、C、D 四个类别的数据举例：  </p><ul><li>第一个分类器 L_a_b，它只判断样本是否属于 AB 类别；</li><li>第二个分类器 L_a_c，它只判断样本是否属于 AC 类别；  </li><li>第三个分类器 L_a_d，它只判断样本是否属于 AD 类别；  </li><li>第四个分类器 L_b_c，它只判断样本是否属于 BC 类别；  </li><li>第五个分类器 L_b_d，它只判断样本是否属于 BD 类别；  </li><li>第六个分类器 L_c_d，它只判断样本是否属于 CD 类别；  </li></ul><p>所以一共建立了六个二分类模型，每个模型只能处理两个类别，<br><b>在训练时，每个分类器仅仅只需要用到两种类别的训练样例；</b><br>在测试时，每个测试样本是需要并行的进入这六个分类器，每个分类器会做出一个类别预测，相当于是投票，最后投票数最多的类别就是预测类别。  </p><p>总结起来，如果有N个类别，那这种 OvO 思路就要建立 N(N-1)/2 个不同的二分类逻辑回归模型，每个模型只能处理两个类别。</p><h3 id="4-6-3-Multi-nomial"><a href="#4-6-3-Multi-nomial" class="headerlink" title="4.6.3 Multi-nomial"></a>4.6.3 Multi-nomial</h3><p><b>Multi-nomial</b> 是指的 “多分类”，从宏观的角度上来看，可以理解为只建立了一个逻辑回归模型，但是要注意这个逻辑回归模型的<b>权重参数的维度</b>已经发生了变化。  </p><ul><li><p>二分类情况<br>回顾在做二分类时，假设输入样本的特征维度是 K(假设已经将截距b考虑进去了)，可以将输入表示为一个 K 维的向量：  </p><script type="math/tex; mode=display">\vec{x}= \{x_1, x_2, ..., x_k\} ^ T</script><p>线性函数的参数也表示为一个  K 维向量：  </p><script type="math/tex; mode=display">\vec{w }= \{w_1, w_2, ..., w_k\}^T</script><p>两者的向量积  $\vec{w}^T\vec{x}$ 是一个 $1*1$ 维的实数，然后再将该实数通过Sigmoid函数做映射。  </p></li><li>多分类情况<br>如果是多分类，假设输入样本的特征维度是 K，<b><font color="red">则线性函数的参数可以表示为一个</font> $C*K$ <font color="red">的矩阵</font></b>，其中 $C$ 表示类别数目：  <script type="math/tex; mode=display">W =   \left[  \begin{matrix}  w_{11} & w_{12} & ... & w_{1k} \\  w_{21} & w_{22} & ... & w_{2k} \\  ... & ... & ... & ... \\  w_{C1} & w_{C2} & ... & w_{Ck}   \end{matrix}   \right]  \tag {4-40}</script>所以二者相乘的结果 $ W \vec{x} $ 是一个 $C*1$ 的<font color="red">向量</font>：  </li></ul><script type="math/tex; mode=display">\vec{z} = \{ z_1, z_2, ..., z_C \} \tag {4-41}</script><p>到这里很容易就产生一个想法，<b>只要对这个 C 维的列向量做一次处理，那是不是就能让列向量中的每个值，代表它属于各个类别的概率了呢？</b>然后从中挑选出概率值最大的那个维度代表的类别，就可以得到预测类别的结果了。</p><ol><li><p><b>Softmax function</b>  </p><p> <b>Softmax function</b> 将一个含任意实数的 K 维向量 z “压缩” 到另一个 K 维实向量 σ(z) 中，<b>使得每一个元素的范围都在(0,1)之间，并且所有元素的和为1</b>。它的表达式如下：  </p><script type="math/tex; mode=display">softmax(z) = \frac{e^{z_j}}{\sum_{j=1}^K e^{z_j}} \tag {4-42}</script><p> 那么如果对上面得到的那个向量 $\vec{z} = \{ z_1, z_2, …, z_C \}  $ 做softmax处理，就可以得到一个新的向量：  </p><script type="math/tex; mode=display">\vec{\hat{y}} = softmax(\vec{z}) = \{ \frac{e^{z_1}}{\sum_{j=1}^K e^{z_j}},                  \frac{e^{z_2}}{\sum_{j=1}^K e^{z_j}},                 ...,                  \frac{e^{z_C}}{\sum_{j=1}^K e^{z_j}} \} ^T \tag {4-43}</script><p> 向量 $\vec{\hat{y}}$ 中的每一个元素都是 0 到 1 之间的实数，并且它们的和为1，所以可以将该向量作为对于样本 $\vec{x}$ 的类别预测向量，<b>其中的分量 $\hat{y_j}$ 表示样本 $\vec{x}$ 属于类别 j 的概率（也是可以由广义线性模型和指数分布族推导出来的）</b>。<br> <br>  </p></li><li><p><b>Softmax loss</b>  </p><p> 二分类逻辑回归的损失函数是使用的交叉熵损失函数，多分类的逻辑回归的损失函数也用的是交叉熵损失函数：<br> 假设有 K 个类别，则单样本x 的交叉熵为：  </p><script type="math/tex; mode=display">H(p,q) = - \sum_{j=1}^K y_j \ln(\hat{y_j}) =  - \sum_{j=1}^K y_j \ln(\frac{e^{z_j}}{\sum_{j=1}^K e^{z_j}}) \tag {4-44}</script><p> $y_j$ 是真实分布 $p$  中第 j 个类别的概率，$\hat{y_j}$ 也即 $\frac{e^{z_j}}{\sum_{j=1}^K e^{z_j}}$ 是预测分布 $q$ 中第 j 个类别的概率。 </p><p> 则对于m个训练样本，多分类逻辑回归的交叉熵损失函数为：  </p><script type="math/tex; mode=display">J(W) = - \frac{1}{m} \sum_{i=1}^m \sum_{j=1}^K y_{mj} \ln(\frac{e^{z_{mj}}}{\sum_{j=1}^K e^{z_{mj}}}) \tag {4-45}</script><p> 考虑到一个情况，那就是训练时，作为 label一般会进行 onehot 编码处理，比如若样本属于 A,B,C,D 四个分类中的 B 类，则 label 可以用如下 onehot 向量表示：  </p><script type="math/tex; mode=display">\vec{y} = [ 0, 1, 0, 0 ]</script><p> 即只在表示 B 的维度上的标签是1，而表示其它类别的维度上的标签是0。  </p><p> 所以在上面的损失函数中，并不需要对单样本的K个分量求和，因为其中只有一个分量$y_j$是1，其它分量都是0，所以可以简化为：  </p><script type="math/tex; mode=display">J(W) = - \frac{1}{m} \sum_{i=1}^m \frac{e^{z_{mj}}}{\sum_{j=1}^K e^{z_{mj}}}  \quad, \qquad (y_{mj}=1) \tag {4-46}</script><p> 其中 $z_{mj} = \vec{w_j} \vec{x}+b $</p><p> 这种交叉熵损失和softmax函数组合的形式，也被称为 softmax loss。</p></li></ol><h2 id="4-7-广义线性模型-Generalized-Linear-Model"><a href="#4-7-广义线性模型-Generalized-Linear-Model" class="headerlink" title="4.7 广义线性模型(Generalized Linear Model)"></a>4.7 广义线性模型(Generalized Linear Model)</h2><p>在统计学中，广义线性模型（GLM）是普通线性回归的灵活推广。在前面提到的普通线性回归、逻辑回归、多元逻辑回归等模型，其实可以看作广义线性模型的一种情况。  </p><h3 id="4-7-1-指数分布族-Exponential-Family"><a href="#4-7-1-指数分布族-Exponential-Family" class="headerlink" title="4.7.1 指数分布族(Exponential Family)"></a>4.7.1 指数分布族(Exponential Family)</h3><p>因为广义线性模型用到了指数分布族的相关知识，所以需要先了解 <a href="https://en.wikipedia.org/wiki/Exponential_family">指数分布族(Exponential Family)</a> 的相关概念。    </p><p>指数分布族指的是，概率函数可以表示为如下形式的概率分布集合：  </p><script type="math/tex; mode=display">\begin{aligned}p(y;\eta) &= b(y) \exp(\eta^T T(y) - \alpha(\eta)) \\&= b(y) e^{\eta^T T(y) - \alpha(\eta)}\end{aligned} \tag {4-47}</script><p>其中：  </p><ul><li>$\eta$ 被称为自然参数(natural parameter)  </li><li>$T(y)$ 被称为是充分统计量(sufficient statistic)（一般情况下可以将$T(y)=y$）</li><li>$\alpha(\eta)$ 被称为是对数划分函数(log partition function) ($e^{-\alpha(\eta)}$本质上起着归一化常数的作用，确保$p(y;\eta)$在$y$上求和/积分 为 1)  </li></ul><p>确定 $T$、$\alpha$、$b$ 三个函数后，就可以得到一个以 $\eta$ 为参数的概率分布 $p(y;\eta)$。 </p><h3 id="4-7-2-指数分布族示例"><a href="#4-7-2-指数分布族示例" class="headerlink" title="4.7.2 指数分布族示例"></a>4.7.2 指数分布族示例</h3><ol><li><p><b>高斯分布</b>  </p><p> 高斯分布的概率密度函数为：  </p><script type="math/tex; mode=display">p(y;\mu,\sigma^2) = \frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{(y-\mu)^2}{2\sigma^2}} \tag {4-48}</script><p> 为了简化问题，假设其方差为 $\sigma^2=1$，则其概率密度函数简化为：  </p><script type="math/tex; mode=display">p(y;\mu) = \frac{1}{\sqrt{2\pi}} e^{-\frac{(y-\mu)^2}{2}} \tag {4-49}</script><p> 将其向着指数分布族的形式转化：  </p><script type="math/tex; mode=display">\begin{aligned} p(y;\mu) &= \frac{1}{\sqrt{2\pi}} e^{-\frac{(y-\mu)^2}{2}}\\ &= \frac{1}{\sqrt{2\pi}} \exp{-\frac{(y^2-2 \mu y+ \mu^2)}{2}} \\ &= \frac{1}{\sqrt{2\pi}} e^{-\frac{y^2}{2}} \exp({\eta y-\frac{\mu^2}{2}}) \\ &= \frac{1}{\sqrt{2\pi}} e^{-\frac{y^2}{2}} e^{({\mu y} -\frac{\mu^2}{2} )} \\ \end{aligned} \tag {4-50}</script><p> 如果令：  </p><script type="math/tex; mode=display">\begin{aligned} b(y) &= \frac{1}{\sqrt{2\pi}} e^{-\frac{y^2}{2}} \\ \eta &= \mu \\ T(y) &= y \\ \alpha(\eta) &= \frac{\mu^2}{2} =  \frac{\eta^2}{2} \\ \end{aligned} \tag {4-51}</script><p> 则<b>高斯分布的概率密度函数就能表示为指数分布族的形式</b>，所以高斯分布可以认为是指数分布族中的一种情况。<br> <br>  </p></li><li><p><b>伯努利分布</b><br> 伯努利分布又名两点分布或者0-1分布，概率函数为：  </p><script type="math/tex; mode=display">p(y;\mu) = \mu^y (1-\mu)^{1-y} \tag {4-52}</script><p> 其中 $\mu$ 表示成功概率，$y$ 表示实验结果。  </p><p> <b>伯努利分布也可以表示为指数分布族的形式</b>：  </p><script type="math/tex; mode=display">\begin{aligned} p(y;\mu) &= \mu^y (1-\mu)^{1-y} \\ &= \exp (yln\mu + (1-y)ln(1-\mu) ) \\ &= \exp (yln(\frac{\mu}{1-\mu} )+ ln(1-\mu) ) \\ &= e^{yln(\frac{\mu}{1-\mu} )+ ln(1-\mu)} \end{aligned} \tag {4-53}</script><p> 其中：  </p><script type="math/tex; mode=display">\begin{aligned} b(y) &= 1 \\ \eta &= ln(\frac{\mu}{1-\mu} ) \\ T(y) &= y \\ \alpha(\eta) &= -\ln(1-\mu) = \ln(1+e^{\eta}) \\  \end{aligned} \tag {4-54}</script></li></ol><h3 id="4-7-2-广义线性模型"><a href="#4-7-2-广义线性模型" class="headerlink" title="4.7.2 广义线性模型"></a>4.7.2 广义线性模型</h3><p>广义线性模型建立在3个前提假设上：  </p><ul><li><p>自然参数 $\eta$ 与 $x$ 是线性相关： $ \eta = X\beta + \epsilon $,<br>此时称 $\eta$ 为线性预测子；</p></li><li><p>$y$ 的估计值就是 $P(y|x,\beta)$ 的期望值。<br>如果用 $h(x,\beta)$ 表示 $y$ 的估计值，这一假设写作 $h(x,\beta) = E[y|x,\beta]$<br>也可以用所谓的链接函数 $g(\cdot)$ 表示： $ E[y|x,\beta] = \mu = g^{-1}(\eta) = g^{-1}(X\beta) $， 链接函数解释了线性预测子与分布期望值的关系；</p></li><li><p>$y$ 的概率密度函数 $Pr(y|x,\beta)$ 满足指数分布族的条件。  </p></li></ul><ol><li><p>推导线性回归<br>对于普通线性回归模型，我们认为 $y$ 服从正态分布，则</p><script type="math/tex; mode=display">\begin{aligned} h(x,\beta) &= E[y|x,\beta] \\ &= \mu \\ &= \eta \\ &= X\beta \end{aligned}</script></li><li><p>推导逻辑回归<br>对于逻辑回归模型，我们认为 $y$ 服从伯努利分布，则</p><script type="math/tex; mode=display">\begin{aligned} h(x,\beta) &= E[y|x,\beta] \\ &= \mu \\ &= \frac{1}{1+e^{-\eta}} \\ &= \frac{1}{1+e^{-(X\beta)}} \\ \end{aligned}</script><p> 而且对于伯努利分布, 其期望就是等于事件发生的概率，即  </p><script type="math/tex; mode=display">E[y|x,\beta] = \mu = P(y=1|x,\beta)</script><p> 所以用Sigmoid函数映射后的输出，就是可以用来作为二分类时为正样本的概率。<br> <br></p></li><li><p>更多的线性回归推导 </p><p> 这里截图了 Wikipedia 的广义线性模型的页面，可以参考:<a href="https://en.wikipedia.org/wiki/Generalized_linear_model">Generalized_linear_model</a>  </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4-线性模型--(中)</title>
      <link href="/Machine-Learning/ML_04_Linear_Model_2.html"/>
      <url>/Machine-Learning/ML_04_Linear_Model_2.html</url>
      
        <content type="html"><![CDATA[<!-- <img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width=70%>   --><p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%"></p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="4-线性模型—-中"><a href="#4-线性模型—-中" class="headerlink" title="4 线性模型—(中)"></a>4 线性模型—(中)</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="4-2-局部加权线性回归-Locally-Weighted-Linear-Regression"><a href="#4-2-局部加权线性回归-Locally-Weighted-Linear-Regression" class="headerlink" title="4.2 局部加权线性回归(Locally Weighted Linear Regression)"></a>4.2 局部加权线性回归(Locally Weighted Linear Regression)</h2><h3 id="4-2-1-局部加权线性回归的引入"><a href="#4-2-1-局部加权线性回归的引入" class="headerlink" title="4.2.1 局部加权线性回归的引入"></a>4.2.1 局部加权线性回归的引入</h3><p>上一篇引入线性回归问题时，示例数据 “外卖配送时间” 的散点图如下所示：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_result_1.jpg" width="80%">  </p><p>从图中的数据分布来看，使用线性回归模型基本上是没太大问题的，因为数据大致还是呈现线性分布的；虽然并不能保证所有的点都落在最后的拟合直线上，但是<b>整体的趋势还是对的</b>。  </p><p>那么如果数据的分布并不是呈现完美的线性分布， 如下图所示，用线性回归(Linear Regression)拟合出的直线，<b>虽然依然在大趋势上是符合数据分布的，但是与上图中相比，下图中有些区域的点与拟合直线之间存在的偏差就有点明显的大了</b>。 </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_result_2.jpg" width="80%">  </p><p>那么，有没有一种方法，<b>能够对数据分布不规则的地方，其对应的线性回归参数能稍微有些变化</b>，使得拟合结果能够更贴近训练数据呢？ </p><p>局部加权线性回归就是解决此类，线性回归模型在训练集上欠拟合的情况。</p><h3 id="4-2-2-局部加权线性回归的原理"><a href="#4-2-2-局部加权线性回归的原理" class="headerlink" title="4.2.2 局部加权线性回归的原理"></a>4.2.2 局部加权线性回归的原理</h3><p>因为在局部加权线性回归中涉及到权重的计算，所以为了与上一节讲到的线性回归的参数作区分，将权重记为 $\alpha $。   </p><p>则<b>普通线性回归，或者说标准线性回归</b>的函数定义以及 损失函数如下：  </p><script type="math/tex; mode=display">h_w(x)  = \sum_{i=0}^n w_i x_i = w^Tx \quad OR \quad x^Tw, \tag{4-9}</script><script type="math/tex; mode=display">J(w) = \sum_{i=1}^m(h_w(x^{(i)})-y^{(i)})^2, \tag{4-10}</script><p><b>在局部加权线性回归中，额外学习一个权重的参数 $\alpha $ </b>,  即每个样本 $x^{(i)}$ 都有一个与其对应的权重 $\alpha^{(i)}$，设 $\alpha $ 是一个对角线矩阵：  </p><script type="math/tex; mode=display">\alpha = \begin{bmatrix}\alpha^{(1)} \quad  \quad  \quad \quad \quad \\\quad  \alpha^{(2)} \quad  \quad  \quad \quad \\\quad  \quad  \cdots \quad  \quad  \quad \\\quad  \quad  \quad  \alpha^{(i)} \quad \quad \\\quad  \quad  \quad  \quad  \cdots \quad \\\quad  \quad   \quad  \quad  \quad \alpha^{(m)} \\\end{bmatrix}</script><p><b>用这个权重值 $\alpha$ 来控制各个样本对于拟合模型参数 $w$ 时的贡献度</b>。那么我们就可以在线性回归的<b>损失函数中加入 $\alpha$ </b>，这样一来，就意味着<b>不同的样本，对于损失函数的贡献程度是不一样的</b>，进而对于参数的贡献度就是不一样的：  </p><script type="math/tex; mode=display">J(w) = \sum_{i=1}^m \alpha^{(i)} (h_w(x^{(i)})-y^{(i)})^2, \tag{4-11}</script><p>将其写成矩阵形式：</p><script type="math/tex; mode=display">J(w) = \alpha ||Xw-\vec{y}||^2 = (Xw-\vec{y})^T \alpha (Xw-\vec{y}), \tag{4-12}</script><p>同样令其导数为0时，得到的等式为：</p><script type="math/tex; mode=display">X^T \alpha Xw = X^T \alpha \vec{y} \tag{4-13}</script><p>最终参数$w$的值可以表示为：</p><script type="math/tex; mode=display">w = (X^T \alpha X)^{-1} X^T \alpha \vec{y} \tag{4-14}</script><p>由此可见，参数 $w$ 的值与 $\alpha$ 有关。  </p><p>那么如何来定义每个样本 $x^{(i)}$ 对应的权重 $\alpha^{(i)}$ 呢？我们使用该权重的目的是控制<b>每个样本对参数 $w$ 的影响程度</b>。  </p><p>显然当<font color="orangered"> $ \alpha^{(i)} $   取值较大时，该样本 $x^{(i)}$ 对参数 $w$ 的影响程度较大，反之亦然</font>（因为影响了该样本的损失函数值）。  </p><p>那么什么时候该让样本 $x^{(i)}$ 的影响度大一点呢？试想，如果此时有一个待预测样本 $x^{(new)}$，如果它离样本 $x^{(p)}$ 较近，而离样本 $x^{(q)}$ 较远，那么显然应该让 $x^{(p)}$ 产生更大的贡献，来拟合参数 $w$，进而来预测 $x^{(new)}$ 的输出值。  </p><p>所以，<font color="orangered"><b>对于待预测样本，离它最近的样本 $x^{(i)}$ 产生的贡献度应该最大，而离它最远的样本 $x^{(i)}$ 产生的贡献度应该最小</b></font>。 这也正是<b>局部加权</b>四个字想表达的意思，即对于一个待预测样本，只让距离其较近的（局部）一些训练样本对其施加多一点的影响。可以用以下公式来描述这种关系：</p><script type="math/tex; mode=display">\alpha^{(i)} = \exp{ (\frac{|x^{(i)}-x|}{-2k^2} )}\tag{4-15}</script><p>该函数是<b>高斯核函数</b>，其中 $k$ 为超参数，$x$ 为待预测样本，$x^{(i)}$ 为训练样本；$k$ 为超参数，可以手动调整，用来控制权重的缩放程度。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_result_3.jpg" width="100%">   </p><p>如上图所示，采用不同的 $k$ 值，对权重的影响程度不同: </p><ul><li>$k$ 值越小，远处的点权重缩小幅度较大，趋近于0，所以数据点受近处局部影响更大，容易过拟合。</li><li>$k$ 值适中，远处的点权重缩小幅度合适，能够较好的拟合数据。</li><li>$k$ 值越大，远处的点权重缩小有限，趋近于1，接近LS。  </li></ul><h3 id="4-2-3-非参数化模型"><a href="#4-2-3-非参数化模型" class="headerlink" title="4.2.3 非参数化模型"></a>4.2.3 非参数化模型</h3><p>局部加权线性回归，是非参数化模型，也就是说，参数 $w$ 并不是一直固定的。</p><ul><li>普通线性回归，利用训练数据训练完成之后，参数 $w$ 就不会再改变，所以是参数化模型；</li><li>局部加权线性回归，对于每一个待预测样本，因为并不知道其和训练数据各个样本的距离，所以都会重新计算样本权重 $\alpha$。也就是每一次都要遍历所有的样本 $x^{(i)}$ 计算 对应的 $\alpha^{(i)}$，所以局部加权线性回归的计算量会比普通线性回归要大很多。  </li></ul><h2 id="4-3-岭回归-Ridge-Regression"><a href="#4-3-岭回归-Ridge-Regression" class="headerlink" title="4.3 岭回归(Ridge Regression)"></a>4.3 岭回归(Ridge Regression)</h2><h3 id="4-3-1-岭回归的提出"><a href="#4-3-1-岭回归的提出" class="headerlink" title="4.3.1 岭回归的提出"></a>4.3.1 岭回归的提出</h3><p>之前讲过使用<b>最小二乘法(LS)</b>来拟合线性回归模型时，使用<b>正规方程组</b>来求解的。当时说过，要使用正规方程组来求解参数，需要保证所有的<b>样本是线性无关的，即不存在多重共线性</b>。如此才能满足<b>正规矩阵（格拉姆矩阵）可逆</b>的条件，从而得到唯一解。<br>但是，在实际应用中，样本往往存在多重共线性，即存在线性相关的情况，并不能很好地保证正规矩阵可逆，所以此时使用最小二乘法进行拟合的模型，可能就会不太合适。</p><h3 id="4-3-2-岭回归的原理"><a href="#4-3-2-岭回归的原理" class="headerlink" title="4.3.2 岭回归的原理"></a>4.3.2 岭回归的原理</h3><p>样本存在多重共线性时，正规矩阵 $ (X^TX) $ 不可逆，我们现在来将正规矩阵 $ (X^TX) $ 进行改造：<br>对于正规矩阵 $ (X^TX) $ ，<font color="orangered">在其对角线上的元素都加上一个正实数 $\lambda$ ，即 $ (X^TX) + \lambda I$。得到的这个矩阵 $ (X^TX + \lambda I) $ 一定是可逆的！</font><br>简单的说一下为什么：  </p><ul><li>首先， $ (X^TX) $ 是实对称矩阵，这个很容易理解；</li><li>实对称矩阵的性质如下，可以查询百度百科的词条【半正定矩阵】：<img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_positive_semidefinite_matrix.jpg" width="65%"></li><li>关于特征值非负的证明：<img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_eigenvalue.jpg" width="85%"></li><li>然后，实对称矩阵也必定可以相似对角化，可以查询百度百科词条【实对称矩阵】： <img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_symmetric.jpg" width="85%"></li><li>所以，给一个实对称矩阵，在对角元素上加上一个正实数 $ \lambda $，它仍然是一个实对称矩阵（因为除对角线外的元素并未变化，所以依然以对角线对称）：<br>则其最小特征值就至少是 $ \lambda $，<b>若 $ \lambda &gt; 0 $ 就说明该实对称矩阵的最小特征值大于0</b>；</li><li>故：特征值大于0的n阶实对称矩阵，是正定矩阵，即矩阵可逆。可以查询百度百科词条【正定矩阵】：<img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_positive_definite_matrix.jpg" width="65%">  </li></ul><p>综上：<font color="orangered"> <b> 矩阵 $ (X^TX + \lambda I) $ 一定是可逆的！</b></font>   </p><font color="orangered"> 而岭回归名字的由来其实就是因为在正规矩阵的基础上加了一个<b> $\lambda I $</b>矩阵，<b>“岭”就是指的这个对角线。</b></font>  <script type="math/tex; mode=display">\lambda I = \begin{bmatrix}\lambda \quad  \quad  \quad \quad \quad \\\quad  \lambda \quad  \quad  \quad \quad \\\quad  \quad  \cdots \quad  \quad  \quad \\\quad  \quad  \quad  \lambda \quad \quad \\\quad  \quad  \quad  \quad  \cdots \quad \\\quad  \quad   \quad  \quad  \quad \lambda \\\end{bmatrix}</script><h3 id="4-3-3-岭回归的优化策略"><a href="#4-3-3-岭回归的优化策略" class="headerlink" title="4.3.3 岭回归的优化策略"></a>4.3.3 岭回归的优化策略</h3><p>故对正规矩阵做修改之后，依然可以沿用最小二乘法的思想，来求解修改后的方程组，得到唯一解。<br>正规方程组式（4-4-4）可以改为：  </p><script type="math/tex; mode=display">X^T \vec{y} = (X^TX + \lambda I) w, \tag{4-16}</script><p>而这个式子本身应当是对损失函数求 $ w $ 的导数，令导数为0 得到的等式，所以可以得到其导数的改写形式：  </p><script type="math/tex; mode=display">\frac{\partial J(w)}{\partial w} = (X^TX + \lambda I) w - X^T \vec{y} \tag{4-17}</script><p>事实上，我们只需要将损失函数写为以下形式，就能得到上面的导数形式：  </p><script type="math/tex; mode=display">J(w) = ||Xw-\vec{y}||^2  + \frac{\lambda}{2}||w||^2 \tag{4-18-1}</script><p>可以将 $\frac{1}{2} $ 去掉，或者说融合进 $ \lambda $ 中，得到：  </p><script type="math/tex; mode=display">J(w) = ||Xw-\vec{y}||^2  + \lambda||w||^2 \tag{4-18-2}</script><p><b>式（4-18-2）就是岭回归(Ridge Regression)的损失函数 </b>。   </p><p>再此基础之上，可以像普通线性回归那样有两种优化策略求解 $ w $：</p><ul><li>直接解正规方程组：  </li></ul><script type="math/tex; mode=display">w = (X^TX + \lambda I)^{-1} X^T \vec{y} \tag{4-19}</script><ul><li>使用梯度下降法：  </li></ul><script type="math/tex; mode=display">w = w - \alpha \frac{\partial J(w)}{\partial w} \tag{4-20}</script><h3 id="4-3-3-岭回归的另一种理解"><a href="#4-3-3-岭回归的另一种理解" class="headerlink" title="4.3.3 岭回归的另一种理解"></a>4.3.3 岭回归的另一种理解</h3><p>我们看到，岭回归的损失函数是：  </p><script type="math/tex; mode=display">J(w) = ||Xw-\vec{y}||^2  + \lambda||w||^2 \tag{4-18-2}</script><p>其实就是在最小二乘损失函数后面<b>多了一个惩罚项</b>，它的目的是希望参数 $w$ 的 L2 范数小，这其实就是<b>正则化</b>。  </p><p><b>正则化</b>：<font color="navy"> 一种防止模型过拟合的策略，在损失函数后面加入一个正则化项，使得模型在训练的时候更加健壮，防止过拟合。</font>  </p><p>L2范数的定义：  </p><script type="math/tex; mode=display">||w||_2 = \sum_{i=1}^n |w_i|^2 \tag{4-21}</script><p>所以它会防止 $w_i$ 的平方值过大，那么因变量 $y$ 的变化幅度就会比较缓慢，从而使得模型更加稳定。  </p><p>在平时，一般不是很好判断训练样本是否具有多重共线性；<b>其实只要发现训练样本的规模不是很大，那么就可以考虑使用岭回归。<font color="orangered"> 因为训练样本较小时，普通线性回归容易对训练样本产生过拟合</font>，而岭回归因为使用了正则化，可以避免过拟合</b>。  </p><p>下面的示例，我们<b>故意只使用几个样本点来进行训练</b>（<font color="green">绿色的点是训练样本</font>），<font color="navy">蓝色的点是测试样本</font>（相对于训练样本的规模来说，测试样本规模更大），分别使用普通线性回归和岭回归，对结果进行对比；会发现岭回归的拟合曲线更加贴合测试集样本。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_result_4.jpg" width="80%">   </p><h2 id="4-4-拉索回归-Lasso-Regression"><a href="#4-4-拉索回归-Lasso-Regression" class="headerlink" title="4.4 拉索回归(Lasso Regression)"></a>4.4 拉索回归(Lasso Regression)</h2><h3 id="4-4-1-拉索回归的原理"><a href="#4-4-1-拉索回归的原理" class="headerlink" title="4.4.1 拉索回归的原理"></a>4.4.1 拉索回归的原理</h3><p>Lasso回归的全称是 <b>Least Absolute Shrinkage and Selection Operator</b> 回归，中文名是<b>最小绝对值收缩和选择算子</b>回归。这个名字乍一听有点复杂，但是了解了它的原理和作用之后就容易理解了。  </p><p>Lasso回归的损失函数是：  </p><script type="math/tex; mode=display">J(w) = ||Xw-\vec{y}||^2  + \lambda||w||   \tag{4-22}</script><p>和岭回归相似，同样是在最小二乘损失函数后面<b>多了一个惩罚项，只不过该惩罚项是 $ \lambda||w|| $ ，它的目的是希望参数 $w$ 的 L1 范数尽量小。</b> L1 范数就是绝对值，<b>所以 Lasso 回归就是对系数进行绝对值压缩</b>。  </p><p>L1 范数定义：  </p><script type="math/tex; mode=display">||w||_1 = \sum_{i=1}^n |w_i| \tag{4-23}</script><p>这就是其名字中 <b>最小绝对值收缩(Least Absolute Shrinkage)</b> 的含义。  </p><h3 id="4-4-2-拉索回归的优化策略"><a href="#4-4-2-拉索回归的优化策略" class="headerlink" title="4.4.2 拉索回归的优化策略"></a>4.4.2 拉索回归的优化策略</h3><p>Lasso回归的损失函数中有绝对值项，所以其导函数并不是在所有位置连续可导的，所以之前的通过求导的方法来解最优参数的方法都不使用。<br>使用 <b>坐标下降(Coordinate Descent)</b> 算法 和 <b>最小角回归法</b>。  </p><p>挖坑、待填。  </p><h3 id="4-4-3-拉索回归和岭回归的区别"><a href="#4-4-3-拉索回归和岭回归的区别" class="headerlink" title="4.4.3 拉索回归和岭回归的区别"></a>4.4.3 拉索回归和岭回归的区别</h3><p><b>Ridge 回归和 Lasso 回归都是正则化，但是岭回归是 L2 正则化，Lasso 回归是 L1 正则化。</b> 这就决定了一个很重要的特性：  </p><ul><li><b><font color="orangered">如果最小化Lasso回归的损失函数，最后得到损失函数极小值时，参数</font> $w$ <font color="orangered">的一些分量是可以被压缩至0的;</font></b></li><li><b>如果最小化Ridge回归的损失函数，最后得到损失函数极小值时，参数 $w$ 的各个分量都接近于0，但是不能被压缩至0。</b>（这里注意不要误解，不是说 $w$ 的分量不能在优化过程中取0，而是取0的时候，一定还达不到极小值；当到达极小值的时候，$w$ 的所有分量是取不到0的。） </li></ul><p>以上这个特性主要是由于L1范数和L2范数的不同决定的，网上有很多资料，一般都是从<b>损失函数等高线</b>的角度去解释的，如下图<sup><a href="#fn_1" id="reffn_1">1</a></sup>所示，在这里不赘述。推荐这一系列文章<sup><a href="#fn_2" id="reffn_2">2</a></sup> <sup><a href="#fn_3" id="reffn_3">3</a></sup>。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_2_L1_L2.jpg" width="60%">  </p><p>如果真的想深入探究一下L1正则化和L2正则化的一些应用，可以看一下吴恩达的这篇论文<sup><a href="#fn_4" id="reffn_4">4</a></sup>，不过这篇文章没有图片，很多数学公式，符合吴老师的风格。</p><p>所以，<b>Lasso 回归能够将参数中一些不重要的参数压缩至0，表示对应样本那个维度的特征不重要，也就是说在拟合模型的过程中，可以剔除样本的一些不重要特征，<font color="navy">起到了特征筛选的作用</font></b>。这就是名字中<b>选择(Selection)</b>的含义。  </p><h2 id="4-5-弹性网络回归-Elastic-Net-Regression"><a href="#4-5-弹性网络回归-Elastic-Net-Regression" class="headerlink" title="4.5 弹性网络回归(Elastic Net Regression)"></a>4.5 弹性网络回归(Elastic Net Regression)</h2><h3 id="4-5-1-弹性网络回归的损失函数"><a href="#4-5-1-弹性网络回归的损失函数" class="headerlink" title="4.5.1 弹性网络回归的损失函数"></a>4.5.1 弹性网络回归的损失函数</h3><p>就是同时考虑 L1正则化 和 L2正则化，其损失函数定义如下：</p><script type="math/tex; mode=display">\mathcal{L}(w) = ||Xw-y||^2 + \rho \alpha ||w|| + (1-\rho) \alpha||w||^2 \tag{4-24}</script><p>其中，</p><ul><li>$\rho$ 被称为 $L1_ratio$，且 $0 &lt;= L1_ratio &lt;= 1$ ，该参数用来控制模型是更侧重于 L1 正则化 还是 L2 正则化。$\rho=1$ 时就只考虑L1正则化，相当于Lasso回归；$\rho=0$ 时就只考虑L2正则化，相当于Ridge回归。</li><li>$\alpha$ 是正则化系数，控制正则化的惩罚力度；如果 $\alpha=0$ 则不进行正则化，退化为普通的线性回归。</li></ul><h3 id="4-5-2-弹性网络回归优化策略"><a href="#4-5-2-弹性网络回归优化策略" class="headerlink" title="4.5.2 弹性网络回归优化策略"></a>4.5.2 弹性网络回归优化策略</h3><p>其损失函数中同样有绝对值项，故优化策略可使用和 Lasso 回归一样的方法，如坐标下降法。  </p><p><sup><a href="#fn_1" id="reffn_1">1</a></sup>:<a href="https://www.phei.com.cn/module/goods/wssd_content.jsp?bookid=55455">王喆. 深度学习推荐系统[M]. 电子工业出版社, 2020.</a><br><sup><a href="#fn_2" id="reffn_2">2</a></sup>:<a href="https://explained.ai/regularization/L1vsL2.html">The difference between L1 and L2 regularization.</a><br><sup><a href="#fn_3" id="reffn_3">3</a></sup>:<a href="https://explained.ai/regularization/index.html">A visual explanation for regularization of linear models.</a><br><sup><a href="#fn_4" id="reffn_4">4</a></sup>:<a href="http://www.robotics.stanford.edu/~ang/papers/icml04-l1l2.pdf">Ng, A. Y. (2004, July). Feature selection, L 1 vs. L 2 regularization, and rotational invariance. In Proceedings of the twenty-first international conference on Machine learning (p. 78).</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4-线性模型--(上)</title>
      <link href="/Machine-Learning/ML_04_Linear_Model_1.html"/>
      <url>/Machine-Learning/ML_04_Linear_Model_1.html</url>
      
        <content type="html"><![CDATA[<!-- <img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width=70%>   --><p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%"></p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="4-线性模型—-上"><a href="#4-线性模型—-上" class="headerlink" title="4 线性模型—(上)"></a>4 线性模型—(上)</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p>之前讲过，<b>如果因变量可以被表示为自变量的线性组合，就能够用线性模型来拟合。</b>线性关系算是日常生活中最常见的关系，比如身高和体重之间，收入和存款之间，年龄和身高之间，等等。所以可从线性模型入手，来学习机器学习。</p><h2 id="4-1-线性回归-Linear-Regression"><a href="#4-1-线性回归-Linear-Regression" class="headerlink" title="4.1 线性回归(Linear Regression)"></a>4.1 线性回归(Linear Regression)</h2><h3 id="4-1-1-线性回归模型的引入"><a href="#4-1-1-线性回归模型的引入" class="headerlink" title="4.1.1 线性回归模型的引入"></a>4.1.1 线性回归模型的引入</h3><p>上一章已经介绍了回归任务，目标是预测连续型的数值目标，比如温度、价格等等。而线性回归，就是希望用线性模型，来拟合因变量为连续值的数据，如：儿童的年龄与身高之间的关系、外卖商家的到家的距离和送餐所需时间之间的关系、出租车收费与行驶路程之间的关系…  </p><p>我们这里给出一个范例，【外卖配送时间和商家距离】的示例数据：  </p><blockquote><p><strong>距离</strong>：1.0, 0.0, 2.0, 2.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 9.0, 10.0, 13.0, 14.0, 13.0, 15.0, 16.0, 17.0, 18.0, 18.0, 21.0, 21.0, 21.0, 24.0, 25.0, 24.0, 25.0, 26.0, 27.0, 30.0<br><strong>时间</strong>：20.0, 6.0, 19.0, 25.0, 29.0, 25.0, 33.0, 41.0, 44.0, 44.0, 40.0, 35.0, 52.0, 55.0, 42.0, 53.0, 56.0, 61.0, 67.0, 67.0, 74.0, 71.0, 69.0, 85.0, 90.0, 86.0, 88.0, 86.0, 101.0, 98.0  </p></blockquote><p>可以画出其散点图：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">dis = [<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>, <span class="number">9.0</span>, <span class="number">10.0</span>, <span class="number">9.0</span>, <span class="number">10.0</span>, <span class="number">13.0</span>, <span class="number">14.0</span>, <span class="number">13.0</span>, <span class="number">15.0</span>, <span class="number">16.0</span>, <span class="number">17.0</span>, <span class="number">18.0</span>, <span class="number">18.0</span>, <span class="number">21.0</span>, <span class="number">21.0</span>, <span class="number">21.0</span>, <span class="number">24.0</span>, <span class="number">25.0</span>, <span class="number">24.0</span>, <span class="number">25.0</span>, <span class="number">26.0</span>, <span class="number">27.0</span>, <span class="number">30.0</span>]</span><br><span class="line">t = [<span class="number">20.0</span>, <span class="number">6.0</span>, <span class="number">19.0</span>, <span class="number">25.0</span>, <span class="number">29.0</span>, <span class="number">25.0</span>, <span class="number">33.0</span>, <span class="number">41.0</span>, <span class="number">44.0</span>, <span class="number">44.0</span>, <span class="number">40.0</span>, <span class="number">35.0</span>, <span class="number">52.0</span>, <span class="number">55.0</span>, <span class="number">42.0</span>, <span class="number">53.0</span>, <span class="number">56.0</span>, <span class="number">61.0</span>, <span class="number">67.0</span>, <span class="number">67.0</span>, <span class="number">74.0</span>, <span class="number">71.0</span>, <span class="number">69.0</span>, <span class="number">85.0</span>, <span class="number">90.0</span>, <span class="number">86.0</span>, <span class="number">88.0</span>, <span class="number">86.0</span>, <span class="number">101.0</span>, <span class="number">98.0</span>]</span><br><span class="line">plt.figure(figsize=(<span class="number">4</span>, <span class="number">3</span>))</span><br><span class="line">plt.plot(dis,t,<span class="string">&#x27;bo&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;distance/ Km&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;time / min&#x27;</span>)</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.title(<span class="string">&#x27;外卖配送时间与商家距离的关系&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_distance_time.jpeg" width="60%"></p><p>可以看到，二者的关系近似线性，我们可以尝试用一个如下的线性模型来刻画这样一种线性关系:  </p><script type="math/tex; mode=display">\begin{equation} \tag{4-1-1} h_w(x)  = w x + b  \end{equation}</script><p>其中：</p><ul><li>$x$ 是输入数据，也称为输入样本；</li><li>$h_w(x)$ 是预测值，也称为输出样本，有时也用 $y$ 表示；</li><li>$w$ 和 $b$ 是模型参数;<br>$w$ 一般被称为<b>权重(weight)</b>或者<b>系数(coefficient)</b>，$b$ 一般被称为<b>偏置(bias)</b>或者<b>截距(intercept)</b>。  </li></ul><p>关于输入数据 $x$:</p><ul><li>$x$ 可以是一个实数，比如在本示例中， $x$ 就代表距离，是一个实数。</li><li>$x$ 也可以<b><font color="orangered">是一个多维向量</font></b>(机器学习中说到向量一般都<strong>默认为列向量</strong>): <script type="math/tex">\vec{x}=\{ x_1, x_2, \cdots, x_n\}^T</script> <strong>其中下标代表的是 $x$ 的维度</strong>。这代表着还有其他维度的因素会影响到回归值，比如在实际生活中，除了距离，还有天气、路况、配送时段等等因素，也可能会影响到外卖的配送时间。  </li><li>如果 $x$ 是一个向量，那对应的<strong>权重</strong> $w$ 就也为向量：<script type="math/tex">\vec{w} = \{w_1, w_2, \cdots ,w_n\}^T</script> 此时有 <script type="math/tex; mode=display">h_w(\vec{x})=\vec{w}^T\vec{x} + b = w_1x_1 + \cdots + w_n x_n + b  \tag{4-1-2}</script>此时被称为<b><font color="orangered">多元线性回归</font></b>。  </li></ul><p>对于多元线性回归，我们对于输入变量 $x$ 增设一个维度 $x_0 = 1$，去与截距 $b$ 相乘，并令 $b=w_0$，即 $\vec{x}=\{ 1, x_1, x_2, \cdots, x_n\}^T$，$\vec{w} = \{b, w_1, w_2, \cdots ,w_n\}^T$，这样就能将式(4-1-1)和(4-1-2) 统一为如下形式：  </p><script type="math/tex; mode=display">h_w(\vec{x})  = \sum_{i=0}^n w_i x_i = \vec{w}^T\vec{x} \quad OR \quad \vec{x}^T\vec{w}  \tag{4-2}</script><p>线性回归最终的目标就是希望能够学习到最合适的 $w$ 参数，来刻画 $y$ 和 $x$ 之间的线性关系。<strong>如果是二维空间的情况，就是希望找到一条直线，使得二维空间中的点，都尽可能的靠近这条直线</strong>。  </p><p>回忆<b><font color="orangered">统计学习三要素：模型、策略、算法。</font></b>至此，我们确定了线性回归问题三要素中的<b>模型空间（假设空间）<font color="orangered">$h_w(x)$</font></b>。  </p><h3 id="4-1-2-最小二乘法"><a href="#4-1-2-最小二乘法" class="headerlink" title="4.1.2 最小二乘法"></a>4.1.2 最小二乘法</h3><p><b><font color="orangered">最小二乘法</font></b>（<font face="Timese" new roman><a href="https://en.wikipedia.org/wiki/Least_squares">Least Squares Method</a></font>，简写为 <b>LS，所以也叫最小平方算法</b>），是一种数学优化建模方法。<b>它通过<font color="orangered">最小化误差的平方和</font> 来寻找数据的最佳函数匹配。</b>利用最小二乘法可以简便的求得未知的数据，并使得预测的数据与实际数据之间误差的平方和为最小。  </p><p>依据最小二乘法的策略，就可以使用 <a href="https://en.wikipedia.org/wiki/Residual_sum_of_squares">平方损失 (<font face="Timese" new roman> Residual Sum of Squares,RSS)</font></a> 作为模型的损失函数，（有时候也被叫做最小二乘损失函数:Least Square Error）:  </p><script type="math/tex; mode=display">J(\vec{w}) = \sum_{i=1}^m(h_w(\vec{x}^{(i)})-y^{(i)})^2  \tag{4-3}</script><p>上式中的右上标 $i$ 指的是第 $i$ 个输入数据，$m$ 代表训练数据的规模，即总共有多少个输入样本。  </p><p>下图截取自 Wikipedia：</p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_LSE.jpg" width="80%">  </p><p>当所有输入数据预测值与真实值的残差是线性相关的时候，称为<a href="https://en.wikipedia.org/wiki/Ordinary_least_squares">普通最小二乘（ordinary least squares, OLS）</a>，维基百科截图如下。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_OLS_1.jpg" width="80%">  </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_OLS_2.jpg" width="80%">  </p><p>这里，我们就确定了线性回归问题的三要素中的<strong>策略：<font color="orangered">最小二乘法</font></strong>。  </p><h3 id="4-1-3-求解正规方程组"><a href="#4-1-3-求解正规方程组" class="headerlink" title="4.1.3 求解正规方程组"></a>4.1.3 求解正规方程组</h3><p>当面对普通最小二乘问题时，我们<b>采用线性代数的方法，对参数值进行直接求解估算</b>。这里用到的就是：<strong>正规方程组</strong> <a href="https://en.wikipedia.org/wiki/Ordinary_least_squares#Normal_equations"><font face="Times" new roman>Normal Equations</font></a>。  </p><p>首先，将 $m$ 个输入数据 $x$ 合在一起用矩阵 $X$ 表达, 并且将对应的 $m$ 个标签 $y$ 值合在一起用向量 $\vec{y}$ 表示：  </p><script type="math/tex; mode=display">X=\begin{bmatrix}-(\vec{x}^{(1)})^T-  \\-(\vec{x}^{(2)})^T-  \\\vdots      \\-(\vec{x}^{(m)})^T- \end{bmatrix},\quad\quad\quad\vec{y} = \begin{bmatrix}y^{(1)} \\y^{(2)} \\\vdots \\y^{(m)}\end{bmatrix}, \tag{4-4-1}</script><p>注意，$ \vec{x}^{(i)} $ 本身是列向量，所以 $ (\vec{x}^{(i)})^T $ 是行向量。  </p><p>$w$ 仍为：  $\vec{w} = \{w_0, w_1, w_2, \cdots ,w_n\}^T$</p><p>损失函数(4-3)就可以写为：  </p><script type="math/tex; mode=display">J(\vec{w}) = ||X\vec{w}-\vec{y}||^2 = (X\vec{w}-\vec{y})^T(X\vec{w}-\vec{y})  \tag{4-4-2}</script><p>当式(4-4-2)的损失函数最小的时候，$ \vec{w} $ 就是最优的参数值。那么令损失函数的导数 $\frac{\partial J(\vec{w})}{\partial \vec{w}}=0 $ 时，损失函数就能取得极值，此时：</p><script type="math/tex; mode=display">\frac{\partial J(\vec{w})}{\partial \vec{w}}=X^TX\vec{w}-X^T\vec{y} =0  \tag{4-4-3}</script><p>得 :  </p><script type="math/tex; mode=display">X^T \vec{y} = X^T X\vec{w}  \tag{4-4-4}</script><p>式(4-4-4)就被称为<b><font color="orangered">正规方程组</font></b>。之所以要这么变换，是因为 $ (X^T X)$一定是方阵，要求逆矩阵，必要条件是方阵。 </p><p>$ (X^T X)$ 被称为<b>正规矩阵（normal matrix）</b>或者<a href="https://en.wikipedia.org/wiki/Gram_matrix">格拉姆矩阵（Gram matrix）</a>。<b>如果 $X$ 中的行向量彼此线性独立，能够推出格拉姆矩阵行列式不为0，即存在逆矩阵。<font color="navy"> 即训练样本彼此线性独立的话，（<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%87%8D%E5%85%B1%E7%BA%BF%E6%80%A7">不存在多重共线性</a>），其特征向量构成的格拉姆矩阵就是可逆的。</font></b></p><p>等式两边同时左乘以 $ (X^T X)$ 的逆 $ (X X^T)^{-1} $ 得:</p><script type="math/tex; mode=display">\vec{w} = \begin{bmatrix}w_0 \\w_1 \\\vdots \\w_n\end{bmatrix}=(XX^T)^{-1}X^T\vec{y}  \tag{4-5}</script><p>至此，机器学习三要素中的最后一个<b>算法</b>也确定了，<b><font color="orangered">用正规方程组求解参数</font>。</b>   </p><p>使用线性回归模型对示例数据进行拟合后，结果如下图所示：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_result_1.jpg" width="80%">  </p><h3 id="4-1-4-最小均方算法"><a href="#4-1-4-最小均方算法" class="headerlink" title="4.1.4 最小均方算法"></a>4.1.4 最小均方算法</h3><h4 id="4-1-4-1-最小均方算法的定义"><a href="#4-1-4-1-最小均方算法的定义" class="headerlink" title="4.1.4.1 最小均方算法的定义"></a>4.1.4.1 最小均方算法的定义</h4><p><b>最小均方算法（Least Mean Square，简称为LMS）</b>在互联网上经常和 <b>最小平方算法（即最小二乘法，Least Square，简称为LS）</b>混为一谈，其实它们是两个不同的算法，但是确实又在某些方面很相似，极容易混淆。所以这里补充讲解一下，简单的来说一下二者的联系和区别。  </p><p>首先要明确的一点，是<b>LMS</b>方法和<b>LS</b>方法都是属于机器学习三要素中的<b>策略</b>这一部分，即<b>依据怎样的准则选择最优的参数</b>。 </p><p><font color="orangered">最小均方算法的起源是1960年代，由Widrow和Hoff在<b>自适应滤波器领域</b>提出的一种优化算法<sup><a href="#fn_1" id="reffn_1">1</a></sup>，他们希望找到一种可以<b>自动调整权重以最小化输出误差的方法</b>。他们提出的最小均方滤波器(Least Mean Square Filter)如下所示</font>：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_LMS_1.jpg" width="50%">  </p><p>图中变量说明：  </p><ul><li>$ x(n)$ 是输入信号脉冲</li><li>$ h(n)$ 一个未知的滤波系统（就是待求解的滤波器）</li><li>$ y(n)$ 是未知滤波系统的输出信号脉冲</li><li>$ v(n)$ 是噪音</li><li>$ d(n) = y(n) + v(n) $</li><li>$ \hat{h}(n)$ 是自适应滤波器（目的就是期望通过这个自适应滤波器来模拟待求解滤波器</li><li>$ \hat{y}(n)$ 是自适应滤波器的输出</li><li>$ e(n) = d(n) - \hat{y}(n)$ 两个滤波器的输出差异   </li></ul><p>以机器学习的角度来看，$ x(n) $ 就是输入样本，$ y(n) $ 就是输入对应的真实标签(label);  现在希望能够构建一个模型 $ \hat{h}(n) $ 来拟合这个真实的未知系统 $ h(n) $，然后 $ \hat{y}(n) $ 就是模型的预测输出。  </p><p><font color="orangered">而学习的策略就是使得对于每一个输入信号脉冲 $ x(n) $，预测输出脉冲 $ \hat{y}(n) $ 与 真实系统输出脉冲 $ y(n) $  的误差平方值最小</font>。  </p><p><b>而显然，仅仅输入一次信号，是无法准确的拟合一个未知滤波系统，所以需要多次输入信号，然后不断调整自适应滤波器的参数，使得输出的误差平方值最小。</b>  </p><p><b>所以，如果对于这个系统，<font color="OrangeRed">后续每一次的输入信号，都使得这一次输出的误差平方值最小，就说明自适应滤波器 $ \hat{h}(n) $ 已经能够较好的拟合未知系统 $ h(n) $ 了</font>。这就是最小均方算法（Least Mean Square）</b>。  </p><p>从这里就能知道，<font color="OrangeRed">最小均方算法 (Least Mean Square) 中的 <b>均</b>本来指的是<b>期望</b>，而不是简单的算术平均值</font>。  </p><ul><li>图一：<a href="https://en.wikipedia.org/wiki/Least_mean_squares_filter#Derivation">LMS filter</a> 定义(from Wikipedia)  </li></ul><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_LMS_2.jpg" width="100%"><br>  </p><ul><li>图二：<a href="https://en.wikipedia.org/wiki/Expected_value">Expected Value</a>定义(from Wikipedia)<br><b>在统计学中，期望(Expected Value)有时候也会被称为均值(Mean)</b>。  </li></ul><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_LMS_3.jpg" width="85%">  </p><p>从现实情况入手分析，因为输入脉冲信号是一个接一个出现并通过滤波器的，在输入信号到来之前，是不知道该输入信号具体的情况的！所以只能通过<b>一次又一次的迭代调整参数</b>，最小化<b>期望平均误差</b>。 即希望 预测输出信号与滤波器实际输出 之差 的平方值，每一次都达到最小，<font color="orangered">从统计学的角度来看，就是误差平方变量 $ |e(n)|^2 $ 的期望值越小越好</font>。  </p><h4 id="4-1-4-2-随机梯度下降-Stochastic-Gradient-Descent"><a href="#4-1-4-2-随机梯度下降-Stochastic-Gradient-Descent" class="headerlink" title="4.1.4.2 随机梯度下降(Stochastic Gradient Descent)"></a>4.1.4.2 随机梯度下降(Stochastic Gradient Descent)</h4><p>对于LMS优化算法，其每一次都只处理一个样本，所以损失函数在<b>对于一个具体的样本而言</b>，形式为：  </p><script type="math/tex; mode=display">J(\vec{w}) = \frac{1}{2}(h_w(\vec{x}^{(i)})-y^{(i)})^2  \tag{4-6}</script><p>即计算当<b>前预测输出和标签的差值的平方</b>，之所以在前方多了一个 $\frac{1}{2}$ 是为了后续求导时方便计算，<b>这里多乘一个常量系数，只会缩放损失值的幅度，是不会对模型参数的优化结果产生影响的</b>。  </p><p>对于这个损失函数，如何来选择参数 $ w $ 来使得损失函数值最小呢？  </p><p>在高等数学的微积分中我们已经学过：<b>函数在一点<font color="orangered">沿梯度方向的变化率最大</font>，最大值为该梯度的模。<font color="orangered">也就是说，顺着梯度方向，函数值增加的最快；逆着梯度方向，函数值减小的最快。</font></b>  </p><p>如图所示，假设我们从一个山坡的顶部想要下降到山底，那么根本不需要四处去试探，只需要沿着山体的最陡峭的方向往下走，我们下降的速度是最快的。而对于函数而言，其梯度方向就是陡的方向。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_SGD_1.jpg" width="85%">  </p><p>只要将参数 $ w $ 沿着<font color="orangered">负梯度</font>方向进行更新，即<b>每一次使得 $ w $ 向损失函数<font color="orangered">负梯度</font>方向变化一小点，那么损失函数值也就能一点一点的变小</b>，最终到达一个局部极小值。<br>这个局部极小值可能并不是全局最小值，如下图所示另一个局部极小值情况。但是基本上也是一个很小的值了，这一点就不是本节要探讨的问题了。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_SGD_3.jpg" width="50%">   </p><p>这种优化参数的算法，被称为梯度下降算法(Gradient Descent)，附录中有对其更为详细的描述：<a href>梯度下降算法</a> 。  </p><p><b>如果每一次更新参数时，<font color="orangered">只考虑一个样本</font>，就被更具体的称为随机梯度下降算法(Stochastic Gradient Descent)</b>。<b>而LMS算法（策略），其参数优化算法就是采用的随机梯度下降算法(SGD)</b>，具体操作如下：  </p><p>先对损失函数求导  </p><script type="math/tex; mode=display">\begin{aligned} \frac{\partial J(\vec{w})}{\partial \vec{w}} &= \frac{\partial \frac{1}{2}(h_w(\vec{x}^{(i)})-y^{(i)})^2}{\partial \vec{w}} \\ &= (h_w(\vec{x}^{(i)})-y^{(i)}) \frac{\partial(h_w(\vec{x}^{(i)})-y^{(i)})}{\partial \vec{w}} \\ &= (h_w(\vec{x}^{(i)})-y^{(i)}) \frac{\partial(\sum_{j=1}^n w_j x_j^{(i)} - y^{(i)})}{\partial \vec{w}} \end{aligned} \tag{4-7-1}</script><p>其中 $x_j^{(i)}$ 为第 $i$ 个样本的第 $j$ 个特征值， $y^{(i)}$ 表示第 $i$ 个样本的标签值。<br><b>另外，LMS自适应滤波器是一个线性滤波器，所以可以用上面提到的线性模型 $h_w(\vec{x}^{(i)}) = \vec{w}^T\vec{x}^{(i)}$ 表示</b>。  </p><p>所以对于参数 $\vec{w} = \{w_1, w_2, \cdots , w_j ,\cdots， w_n\}^T$ 而言，其各个维度 $w_j$ 具体的梯度分量表达式就为： </p><script type="math/tex; mode=display">\begin{aligned} \frac{\partial J(\vec{w})}{\partial w_j} &= (h_w(\vec{x}^{(i)})-y^{(i)}) \frac{\partial(\sum_{j=1}^n w_j x_j^{(i)} - y^{(i)})}{\partial w_j} \\&= (h_w(\vec{x}^{(i)})-y^{(i)}) x_j^{(i)}\end{aligned}  \tag{4-7-2}</script><p>所以，每一次对于该权重参数分量 $ w_j $ 的更新公式就为：  </p><script type="math/tex; mode=display">\begin{aligned} w_j &:= w_j - \alpha \frac{\partial J(\vec{w})}{\partial w_j} \\ &:= w_j - \alpha (h_w(\vec{x}^{(i)})-y^{(i)}) x_j^{(i)}  \end{aligned}  \tag{4-8}</script><p><b>其中 $\alpha$ 为学习率，是一个超参数，控制每一次迭代更新参数的一个幅度</b>；也就是理解为下坡的时候，一步跨多远的距离，所以也被称为“步长”。 学习率过小的话，则需要迭代很多次才能收敛，学习率过大，则可能出现震荡，甚至发散。  </p><p><b>总结起来，最小均方算法(LMS)就是利用随机梯度下降(SGD)算法，每次都利用当前一个样本的数据，来更新参数</b>。  </p><h3 id="4-1-5-最小均方算法-LMS-和最小平方算法-LS-的联系"><a href="#4-1-5-最小均方算法-LMS-和最小平方算法-LS-的联系" class="headerlink" title="4.1.5 最小均方算法(LMS)和最小平方算法(LS)的联系"></a>4.1.5 最小均方算法(LMS)和最小平方算法(LS)的联系</h3><p><font color="orangered">从机器学习三要素（模型、策略、算法）这三个角度来分析LS和LMS算法的异同点</font>：</p><ol><li><b>模型</b><br>LS和LMS都是可以用来拟合线性模型的，在解决线性回归问题时，假设空间都可以表示为<script type="math/tex; mode=display">h_w(x)  = \sum_{i=0}^n w_i x_i = \vec{w}^T\vec{x} \quad OR \quad \vec{x}^T\vec{w} \quad ,\tag{4-9}</script></li><li><p><b>策略</b><br>二者的损失函数都要计算残差平方：  </p><script type="math/tex; mode=display">(h_w(\vec{x}^{(i)})-y^{(i)})^2   \tag{4-10}</script><ul><li>LS 算法用的是<font color="orangered">平方误差(Residual Sum of Squares, RSS)</font>：<script type="math/tex; mode=display">\begin{aligned}J(\vec{w}) &= \sum_{i=1}^m (h_w(\vec{x}^{(i)})-y^{(i)})^2 \\&= \sum_{i=1}^m (\vec{w}^T\vec{x}^{(i)}-y^{(i)})^2\end{aligned}  \tag{4-11}</script>是对于<b>所有训练样本</b>而言，每个样本对应的预测输出值与标签的<b>误差的平方的<font color="orangered">总和</font></b> 最小，是典型的<b>离线学习</b>：将所有的数据收集齐后，再进行一次性训练。<br><br></li><li><p>LMS 算法用的是<font color="orangered">均方误差(Mean Squared Error, MSE)</font>：</p><script type="math/tex; mode=display">\begin{aligned}J(\vec{w}) &= E[(h_w(\vec{x}^{(i)})-y^{(i)})^2] \end{aligned}  \tag{4-12-1}</script><p>维基百科中对 <a href="https://en.wikipedia.org/wiki/Mean_squared_error">均方误差(MSE)</a> 的定义：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_MSE_1.jpg" width="100%">  </p><p>重点看一下这两句话：  </p><blockquote><p>“MSE is a risk function, corresponding to the expected value of the squared error loss.”<br>MSE是一个风险函数，对应于误差损失平方的期望值。  </p><p>“In machine learning, specifically empirical risk minimization, MSE may refer to the empirical risk (the average loss on an observed data set), as an estimate of the true MSE (the true risk: the average loss on the actual population distribution).”<br>在机器学习中，特别是经验风险最小化，MSE可以将经验风险(观察数据集上的平均损失)作为真MSE(真风险:实际总体分布上的平均损失)的估计。</p></blockquote><p>也就是说，<font color="orangered">均方误差(MSE)的原始定义就是：误差的平方的<b>期望值</b></font>。 事实上，维基百科对于该词条的中文介绍也写明了，只不过中文介绍一般内容比较简略，所以我通常直接引用的是如上的英文版。<br><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_MSE_2.jpg" width="100%">   </p><p>但是，期望值一般都是一个统计学上的概念，它是想表达对于任何的输入而言的一种统计考量，但是实际的训练数据是有限的，<b>所以一般也可以用基于整个训练集的误差平方和的算数平均值来近似代替。</b><br>所以在很多地方通常都能看到用如下表达式来表示均方误差(MSE)：  </p><script type="math/tex; mode=display">\begin{aligned}J(\vec{w}) &= E[(h_w(\vec{x}^{(i)})-y^{(i)})^2] \\&= \frac{1}{m}\sum_{i=1}^m(h_w(\vec{x}^{(i)})-y^{(i)})^2\end{aligned}  \tag{4-12-2}</script><p>即平方误差(式4-11)的基础上多了一个求平均 $\frac{1}{m}$ 而已。<b><font color="orangered">但是一定要注意，这只是在确定能够全部获得m个样本的情况下才能用</font></b>。<br>Wikipedia也有这种表述情况：<br><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_MSE_3.jpg" width="100%"> <br>  </p><p>它称其为<b>样本内均方误差(within-sample MSE)</b>。<br><font color="orangered">所以当训练集的样本是<b>有限的、且确定、且样本规模足够大</b>(辛钦大数定律)的情况下，均方误差(MSE)的确实可以写成式（4-12-2）的形式</font>。<br><i><font color="navy"><b>辛钦大数定律</b>，当样本个数足够大时，样本 $(X_1, X_2, \cdots, X_n)$ 的<b>算术平均值</b>依概率收敛于总体<b>数学期望</b>$ E(X)$</font></i><br><br><br>如果是在线学习(online learning)的情况下，则一般用如下形式来表示均方误差：</p><script type="math/tex; mode=display">\begin{aligned}J(\vec{w}) &= E[(h_w(\vec{x}^{(i)})-y^{(i)})^2] \\&= \frac{1}{2}(h_w(\vec{x}^{(i)})-y^{(i)})^2\end{aligned} \tag{4-12-3}</script><p>即一次只能得到一个样本的情况。</p><p>另外还有一个不容易注意到的点，那就是英文中的 <b>mean</b> 一词，它既可以表示 <a href="https://en.wikipedia.org/wiki/Arithmetic_mean">算术平均值(Arithmetic_Mean)</a> ，也可以表示<a href="https://en.wikipedia.org/wiki/Statistical_population#Mean">总体均值 or 期望(Population mean or Expected value)</a>, 所以这也是很多中文机器学习书籍中容易引起混淆的原因。  </p><p><font color="orangered">总结：依据最小均方算法(LMS)的起源，均方误差(MSE)原始定义是<b>误差的平方的期望值</b>，在机器学习里，通常用<b>样本内均方误差(within-sample MSE)或者说误差平方和的平均值来近似代替该期望值，但是这要求训练样本集的规模足够大</b></font>。</p></li></ul></li><li><b>算法</b><ul><li>LS算法后续一般通过解正规方程组来求解参数。</li><li>LMS算法后续一般通过随机梯度下降来求解参数。</li></ul></li><li><b>总结</b><br><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C4_1_LS_LMS.jpg" width="75%"></li></ol><p>本文其余参考资料<sup><a href="#fn_2" id="reffn_2">2</a></sup>  </p><p><sup><a href="#fn_1" id="reffn_1">1</a></sup>:<a href="https://www-isl.stanford.edu/~widrow/papers/c1960adaptiveswitching.pdf">Widrow, B., &amp; Hoff, M. E. (1960, August). Adaptive switching circuits. In IRE WESCON convention record (Vol. 4, No. 1, pp. 96-104).</a><br><sup><a href="#fn_2" id="reffn_2">2</a></sup>:<a href="https://cs229.stanford.edu/main_notes.pdf">Andrew Ng. CS229: Machine Learning. (Lecture notes Chapter1)</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3-监督学习简述</title>
      <link href="/Machine-Learning/ML_03_Supervised_Learning_Introduction.html"/>
      <url>/Machine-Learning/ML_03_Supervised_Learning_Introduction.html</url>
      
        <content type="html"><![CDATA[<!-- <img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width=70%>   --><p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%"></p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="3-监督学习简述"><a href="#3-监督学习简述" class="headerlink" title="3 监督学习简述"></a>3 监督学习简述</h1><hr style="border:solid; height:1px; color=#000000 size=1">   <h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h2><p>第1章已经提及，监督学习是 <b>从有标记的训练数据</b> 中学习模式和关系，算法的目标是通过<b>输入特征与其相应的标签之间</b>的关联性，构建一个能够准确<b>预测新数据的标签</b>的模型。  </p><p>监督学习算法可以分为：<b>分类问题</b>、<b>回归问题</b>和<b>序列标注</b>问题。  </p><h2 id="3-2-分类问题-Classification"><a href="#3-2-分类问题-Classification" class="headerlink" title="3.2 分类问题(Classification)"></a>3.2 分类问题(Classification)</h2><p>分类问题是机器学习中很经典的一类问题，它要做的事情是：<br><b>所有可能的数据可以被划分为有限个确定的类别，通过监督学习来从数据中学习一个<font color="orange">分类模型或分类决策函数</font>，会根据输入数据的特征，<font color="orange">预测输入数据属于哪个具体的类别。</font></b><br>这样的模型也被称为<b>分类器</b>。  </p><font color="navy"><i>在现实生活中，很多问题都是可以被视为分类问题，比如：是或否、好或坏、正或负、有或无、To be or Not to be 等等。所以分类问题值得细说一下。</i> </font>   <p>从上面的定义可以得知，分类器 Y=f(X) 的<b>输出一定是类别，即输出变量 Y 一定是离散值</b>。<br>而<b>输入变量 X 则没有限制，可以是连续值，也可以是离散值</b>。  </p><p>机器学习中常见的分类模型有：<br>&gt;</p><blockquote><ul><li>逻辑回归(Logistic Regression)  </li><li>决策树(Decision Tree)  </li><li>支持向量机(Support Vector Machine)  </li><li>神经网络(Neural Network)  </li><li>朴素贝叶斯(Naive Bayes)  </li></ul></blockquote><h3 id="3-2-1-常见的分类任务"><a href="#3-2-1-常见的分类任务" class="headerlink" title="3.2.1 常见的分类任务"></a>3.2.1 常见的分类任务</h3><ul><li><p><b>二分类任务</b><br>二分类任务是指的分类的可选类别只有两个，二分类的典型任务有：  </p><ul><li>垃圾邮件识别  </li><li>疾病检测  </li><li>信用卡欺诈检测  </li></ul></li><li><p><b>多分类任务</b><br>多分类任务是指的分类的可选类别有多个(但是确定的分类结果只有一个)，多分类的典型任务有：  </p><ul><li>手写数字识别  </li><li>文本分类  </li></ul></li><li><p><b>多标签问题</b><br>多标签问题是一种特殊的分类问题，与单标签问题不同，它的每个样本可以有多个标签。<br>在多标签问题中，每个样本与多个类别标签相关联，而不仅仅是一个单一的类别标签。多标签问题的典型应用：  </p><ul><li>商品推荐</li><li>情感分析</li><li>网页分类  </li></ul></li></ul><h3 id="3-2-2-分类问题的评价指标（性能度量）"><a href="#3-2-2-分类问题的评价指标（性能度量）" class="headerlink" title="3.2.2 分类问题的评价指标（性能度量）"></a>3.2.2 分类问题的评价指标（性能度量）</h3><p>分类问题的评价指标主要有：  </p><h4 id="3-2-2-1-准确率-Accuracy"><a href="#3-2-2-1-准确率-Accuracy" class="headerlink" title="3.2.2.1 准确率(Accuracy)"></a>3.2.2.1 准确率(Accuracy)</h4><p>准确率是指分类器<b>分类正确的样本数占总样本数的比例</b>。假设对于 N 个样本，分类器正确分类的样本数为 P ，则准确率为：</p><script type="math/tex; mode=display">Accuracy=\frac{P}{N}</script><h4 id="3-2-2-2-错误率-Error-Rate"><a href="#3-2-2-2-错误率-Error-Rate" class="headerlink" title="3.2.2.2 错误率(Error Rate)"></a>3.2.2.2 错误率(Error Rate)</h4><p>错误率是指分类器<b>分类错误的样本数占总样本数的比例</b>。假设对于 N 个样本，分类器错误分类的样本数为 F ，则错误率：  </p><script type="math/tex; mode=display">ErrorRate=\frac{F}{N}</script><script type="math/tex; mode=display">ErrorRate=1-Accuracy</script><h4 id="3-2-2-3-混淆矩阵-Confusion-Matrix"><a href="#3-2-2-3-混淆矩阵-Confusion-Matrix" class="headerlink" title="3.2.2.3 混淆矩阵(Confusion Matrix)"></a>3.2.2.3 混淆矩阵(Confusion Matrix)</h4><p>混淆矩阵也称误差矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵形式来表示。  </p><p>混淆矩阵的<b>每一列</b>代表了<b>预测类别</b>，每一列的总数表示预测为该类别的数据的数目；<br><b>每一行</b>代表了数据的<b>真实归属类别</b>，每一行的数据总数表示该类别的数据实例的数目。  </p><p><b>二分类的混淆矩阵</b>如下图所示：<br><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C3_Confusion_Matrix.jpg" width="70%">  </p><p><b>多分类的混淆矩阵</b>如下图所示：<br><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C3_Confusion_Matrix_n.jpg" width="70%">  </p><h4 id="3-2-2-4-精确率-Precision-、召回率-Recall-和-F1得分"><a href="#3-2-2-4-精确率-Precision-、召回率-Recall-和-F1得分" class="headerlink" title="3.2.2.4 精确率(Precision)、召回率(Recall) 和 F1得分"></a>3.2.2.4 精确率(Precision)、召回率(Recall) 和 F1得分</h4><p>对于二分类问题，由上面提及的二维混淆矩阵可知分类的情况会有以下四种：  </p><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>真阳性</td><td>(True Positive, TP)</td><td>预测为正，实际为正。</td></tr><tr><td>假阳性</td><td>(False Positive, FP)</td><td>预测为正，实际为负。</td></tr><tr><td>真阴性</td><td>(True Negative, TN)</td><td>预测为负，实际为负。</td></tr><tr><td>假阴性</td><td>(False Negative, FN)</td><td>预测为负，实际为正。</td></tr></tbody></table></div><p>进而可得以下指标：  </p><p><b><font color="red">精确率(Precision)</font></b>: 预测为正的样本中，实际为正的样本所占的比例。</p><script type="math/tex; mode=display">Precision=\frac{TP}{TP+FP}</script><p><b><font color="red">召回率(Recall)</font></b>: 实际为正的样本中，正确被预测为正的样本所占的比例（正确被预测为正的样本，除以 实际为正的样本）。</p><script type="math/tex; mode=display">Recall=\frac{TP}{TP+FN}</script><p><b><font color="red">精确率也被称为查准率</font></b>，即检索到的信息中，有多少比例是真正需要的文件。<br><b><font color="red">召回率也被称为查全率</font></b>，即需要的信息中有多少比例被检索出来了的。 </p><p><b>在有些场景下，会提到灵敏度(sensitivity)和特异性(specificity)</b>:  </p><p><b><font color="red">特异性(specificity)</font></b>：实际为负的样本中，正确被预测为负的样本所占的比例（正确被预测为负的样本， 除以 实际为负的样本）。与召回率是对偶关系，可以看为“负样本的召回率”。  </p><script type="math/tex; mode=display">Specificity=\frac{TN}{TN+FP}</script><p><b><font color="red">敏感度(sensitivity)</font></b>：实际为正的样本中，正确被预测为正的样本所占的比例（正确被预测为正的样本，除以 实际为正的样本）。<b>其实和上面的 召回率(recall) 是一个值</b>。  </p><script type="math/tex; mode=display">Sensitivity=\frac{TP}{TP+FN}</script><p><b>对于精确率和召回率，<font color="orange">二者其实是一对充满矛盾的度量，它们之间存在一种此消彼长的关系</font></b>:  </p><ul><li>一个分类器如果只把可能性大的样本预测为正样本，那么会漏掉很多可能性相对不大但依旧满足的正样本，从而导致召回率降低。  </li><li>如果分类器过于宽松，将很多负样本预测为正样本，那么精确率就会降低。  </li></ul><p>因此， 可以采用F1得分，是精确率和召回率的调和均值：  </p><p><b><font color="orange">F1得分</font></b>：</p><script type="math/tex; mode=display">F1=\frac{2}{\frac{1}{Precision}+\frac{1}{Recall}} =\frac{2*Precision*Recall}{Precision+Recall}</script><p>将这几个得分指标画在混淆矩阵上如下(<b>图源wikipedia</b>)：<br><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C3_wiki_confusion_matrix_1.jpg" width="90%"></p><h4 id="3-2-2-5-P-R曲线-Precision-Recall-Curve"><a href="#3-2-2-5-P-R曲线-Precision-Recall-Curve" class="headerlink" title="3.2.2.5 P-R曲线(Precision-Recall Curve)"></a>3.2.2.5 P-R曲线(Precision-Recall Curve)</h4><p>上面提到精确率(Precision)和召回率(Recall)存在此消彼长的关系，对于一个分类器，可以画出这两个指标之间关系的曲线图，称为P-R曲线。  </p><p>对于许多分类器而言，对于每个输入样本，模型都会产生一个输出，<b>这个输出通常表现为一个概率值或得分。<font color="orange">这个概率值或得分表示了模型对于这个样本属于某个特定类别的置信度。</font></b>  </p><p>例如，在二元分类器中，模型可能会输出一个介于0和1之间的概率值，表示样本属于正类的置信度。在多类分类器中，模型可能会输出一个概率分布，即每个类别的概率值，以便于我们根据这些概率值来决定样本最可能属于的类别。大致情况如下图所示  </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C3_classifier_score.jpg" width="600" height="300">  </p><p>我们可以依据这个分数对样本进行排序，排在越前面的属于正类别的可能性越大，排在后面的属于正类别的可能性越小。此时可以设置一个阈值(Treshhold)，当样本的得分大于或等于这个阈值时，就判定样本属于正类别，否则就判定样本属于负类别。  </p><p>那么，通过不断改变阈值，就可以得到不同的TP、FP、TN、FN，从而得到不同的精确率、召回率；<b>在实际操作时，我们往往直接依次使用样本排序后的得分作为阈值，这样阈值从高到低，得到不同的精确率、召回率</b>，将其画在图中，就可以得到P-R曲线。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C3_P-R_Curve.jpg" width="50%">  </p><p>P-R 曲线中，<b>横轴表示召回率，纵轴表示精确率，<font color="orange">其曲线所围的面积称为 Average Precision(AP)</font></b>。<br><b><font color="red">AP值是衡量一个模型在所有阈值下的平均精确率。也就是说，对于同一个数据集，P-R曲线下面积越大的分类器，效果越好</font></b>。  </p><p>如果懒得计算P-R曲线所围面积，可以使用BEP点；图中，当Precision = Recall 的点，称为 <b>平衡点(Break-Event Point)。一般来说，BEP点越大，P-R 曲线越凸，则AP值越大，则分类器效果越好。</b>  </p><h4 id="3-2-2-5-ROC曲线-与-AUC"><a href="#3-2-2-5-ROC曲线-与-AUC" class="headerlink" title="3.2.2.5 ROC曲线 与 AUC"></a>3.2.2.5 ROC曲线 与 AUC</h4><p>ROC曲线是P-R曲线的一种变形形式,全称为“<b>(Receiver Operating Characteristic Curve - 接收器工作特征曲线</b>”)，（Receiver本意指的是雷达接收器，ROC曲线最早就是应用于雷达目标检测领域），其<b>横轴代表假正例率(False Positive Rate, FPR)，纵轴代表真正例率(True Positive Rate, TPR)</b>，即：</p><script type="math/tex; mode=display">FPR=\frac{FP}{FP+TN}</script><script type="math/tex; mode=display">TPR=\frac{TP}{TP+FN}</script><p><b>注：在有的地方，横轴用的是 1-specifity, 事实上，1-specifity = FPR，从上面大的混淆矩阵示意图中就能看到。</b>    </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C3_ROC_Curve.jpg" width="40%">  </p><p><b>ROC曲线所围的面积称为AUC(Area Under Curve)。<font color="orange">AUC值越大，说明分类器效果越好。</font></b></p><p><b>对于一个二分类器，<font color="orange">可以取其ROC曲线最左上角的点对应的阈值为该分类器的阈值，该点一般称为CUT-OFF点。</font>一般就是所有数据点中，TPR/FPR(或者TPR-FPR)最大的那个数据点。</b></p><h2 id="3-3-回归问题-Regression"><a href="#3-3-回归问题-Regression" class="headerlink" title="3.3 回归问题(Regression)"></a>3.3 回归问题(Regression)</h2><p>在机器学习中，回归是一个预测性的建模任务，其目标是<b>根据给定的一组输入变量（特征）预测一个<font color="orange">连续的目标变量（也称为因变量）</font></b>。  </p><p>回归模型通常用于<b><font color="orange">预测一个具体的数值或连续的结果，而不是对数据进行分类</font></b>。例如:</p><blockquote><ul><li>回归模型可以用于预测<font color="orange">连续的输出变量</font>,如房价、股票价格、温度等。  </li><li>回归模型也可以用于预测<font color="orange">非连续的输出变量</font>，例如点击率、转化率等，这时通常会结合一些特定的损失函数（例如二元交叉熵）来进行优化。  </li></ul></blockquote><h3 id="3-3-1-回归问题的划分"><a href="#3-3-1-回归问题的划分" class="headerlink" title="3.3.1 回归问题的划分"></a>3.3.1 回归问题的划分</h3><ul><li>回归问题按照输入变量的个数，可分为一元回归和多元回归;</li><li>回归问题按照输入变量和输出变量之间关系的类型，可分为线性回归和非线性回归，对应的模型可分为线性模型和非线性模型。  </li></ul><h3 id="3-3-2-机器学习中常见的回归任务"><a href="#3-3-2-机器学习中常见的回归任务" class="headerlink" title="3.3.2 机器学习中常见的回归任务"></a>3.3.2 机器学习中常见的回归任务</h3><blockquote><ul><li>线性回归</li><li>多项式回归</li><li>岭回归</li><li>Lasso回归</li><li>……  </li></ul></blockquote><h3 id="3-3-3-回归问题的评价指标"><a href="#3-3-3-回归问题的评价指标" class="headerlink" title="3.3.3 回归问题的评价指标"></a>3.3.3 回归问题的评价指标</h3><p>回归问题常用的评价指标有：</p><ul><li><b>平均绝对误差（Mean Absolute Error, MAE）</b>：<script type="math/tex">MAE=\frac{1}{N}\sum_{i=1}^N|y_i-\hat{y}_i|</script></li><li><b>均方误差（Mean Squared Error, MSE）</b>：<script type="math/tex">MSE=\frac{1}{N}\sum_{i=1}^N(y_i-\hat{y}_i)^2</script></li><li><b>均方根误差（Root Mean Squared Error, RMSE）</b>：<script type="math/tex">RMSE=\sqrt{\frac{1}{N}\sum_{i=1}^N(y_i-\hat{y}_i)^2}</script></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2-模型评估和选择方法</title>
      <link href="/Machine-Learning/ML_02_Model_Selection_and_Evaluation.html"/>
      <url>/Machine-Learning/ML_02_Model_Selection_and_Evaluation.html</url>
      
        <content type="html"><![CDATA[<!-- <img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width=70%>   --><p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%"></p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="2-模型评估和选择方法"><a href="#2-模型评估和选择方法" class="headerlink" title="2 模型评估和选择方法"></a>2 模型评估和选择方法</h1><hr style="border:solid; height:1px; color=#000000 size=1"> <p><b>在上一节中，提到过统计机器学习三要素：模型、策略和算法，其中的<font color="orange">策略</font>就是本节要详细阐述的<font color="orange">模型评估和选择方法</font>。</b>    </p><h2 id="2-1-模型的性能评估方法"><a href="#2-1-模型的性能评估方法" class="headerlink" title="2.1 模型的性能评估方法"></a>2.1 模型的性能评估方法</h2><h3 id="2-1-1-损失函数-Loss-Function"><a href="#2-1-1-损失函数-Loss-Function" class="headerlink" title="2.1.1 损失函数(Loss Function)"></a>2.1.1 损失函数(Loss Function)</h3><p><b>损失函数(loss function)</b>也被称为<b>代价函数(cost function)</b>，一般来说，它用来<font color="orange"><b>衡量模型输出的预测结果与真实结果之间差异的函数</b></font>。这种差异也被称为<b>损失(loss)</b>。  </p><p><b>对于监督学习来说很好理解</b>，训练数据输入模型后会得到预测的输出，<b>计算该输出与输入数据原本对应的标注(label)信息之间的差异</b>，就是损失函数要做的事情。  </p><p><b>但损失函数并不是只有监督学习才有，无监督学习也可以使用损失函数。</b>在无监督学习中，虽然不存在标签数据，但是可以通过损失函数来评估模型的性能。<br>这些损失函数通常是通过衡量模型预测结果与原始数据之间的差异来定义的，比如：  </p><ul><li>在聚类算法中，簇内误差是衡量同一个簇内的数据点与该簇的质心之间的平均距离，而簇间误差是衡量不同簇之间的数据点的平均距离。<br>这些误差可以被视为一种衡量模型预测结果与原始数据之间的差异的损失函数。<br><br>  </li><li>降维算法可以将高维数据转化为低维表示，这种低维表示可以用于可视化或进一步分析。<br>在这种情况下，损失函数可以被定义为原始数据与降维后的数据之间的差异，而不需要真实的标签结果。  </li></ul><p>因此，损失函数不管是在监督学习还是在无监督学习中，都有广泛的应用。 </p><p>常见的损失函数如下所示：    </p><ol><li>0-1损失函数  <script type="math/tex; mode=display">   L(Y,f(X)) =    \begin{cases}   1, \quad Y \neq f(X) \\   0, \quad Y = f(X) \\   \end{cases}</script></li><li>平方损失函数  <script type="math/tex; mode=display">L(Y,f(X)) = (Y-f(X))^2</script></li><li>绝对损失函数  <script type="math/tex; mode=display">L(Y,f(X)) = |Y-f(X)|</script></li><li>对数损失函数  <script type="math/tex; mode=display">L(Y, f(X)) = -log{P(Y|X)}</script></li></ol><h3 id="2-1-2-经验风险-损失-Empirical-Risk-Loss"><a href="#2-1-2-经验风险-损失-Empirical-Risk-Loss" class="headerlink" title="2.1.2 经验风险/损失(Empirical Risk/Loss)"></a>2.1.2 经验风险/损失(Empirical Risk/Loss)</h3><p>通俗来讲，<b>经验风险（也叫经验损失）就是对训练数据集损失函数值求平均值</b>；因此，损失函数是计算经验风险的基础。<br>（相对损失函数而言，一般就是输入一次数据，就会计算一次损失函数值，<b>所以损失函数值是针对某一次输入数据而言的</b>。比如：一次输入一个样本，或者一个小批次的样本进行训练，所以损失函数通常都是计算的很小一部分数据的损失值。<b>经验风险考虑的是全体训练数据。</b>）  </p><script type="math/tex; mode=display">R_{emp}(f) = \frac{1}{N} \sum^{N}_{i}{L(y_i, f(x_i))}</script><p><b><font color="red">经验风险最小化（Empirical Risk Minimization，ERM）</font>准则是传统机器学习理论中的一个基本原则。它将机器学习问题转化为一个优化问题，其基于的假设是：<font color="orange">如果一个模型训练数据集上的经验风险（平均损失函数）越小，那么该模型面对新的未知数据的预测能力就越好。</font></b>    </p><script type="math/tex; mode=display">\qquad \qquad \qquad \qquad \qquad \underset{f \in F}{min} \frac{1}{N} \sum^{N}_{i=1}{L(y_i, f(x_i))}, \qquad F: hypothesis\_space</script><ul><li>在监督学习中，训练数据集包含了输入特征和相应的标签，ERM原则通过对训练数据集上的损失函数进行最小化，来选择最优的模型参数。    </li><li>在无监督学习中，训练数据集只包含输入特征，没有对应的标签，ERM原则通过对训练数据集上的损失函数进行最小化，来学习数据的内在结构和模式。  </li></ul><p>ERM原则也存在一些局限性，例如它可能会陷入局部最优解，或者在面对不平衡数据集时表现不佳。为了克服这些局限性，人们提出了各种改进的ERM原则，例如加权ERM、正则化ERM等。  </p><h3 id="2-1-3-期望风险-Expected-Risk"><a href="#2-1-3-期望风险-Expected-Risk" class="headerlink" title="2.1.3 期望风险(Expected Risk)"></a>2.1.3 期望风险(Expected Risk)</h3><p>期望风险是<b>根据概率分布来描述所有可能情况下的损失的平均值</b>。  </p><p>通俗来讲是指<b>模型在所有可能的数据上平均意义的预测误差，也就是<font color="orange">全局风险</font></b>。与经验风险不同，期望风险是针对<b>所有可能的样本，而不仅仅是训练集中的样本</b>。  </p><script type="math/tex; mode=display">R_{exp}(f) = E_P[L(Y,f(X))]</script><p>但是很明显，我们在训练模型的时候是无法做到考虑所有可能的数据的，训练数据集必定是有限的。<b>所以虽然理论上来说，期望风险才能更好地刻画模型的预测误差，但是基于有限的训练数据集，我们只好用经验风险，（即基于可用的训练数据集）的平均预测误差，来评估模型的预测能力</b>。  </p><font color="orange"><b>只有当训练数据集的规模趋近于无穷大的时候，经验风险才会无限趋近于期望风险。</b></font>  <h3 id="2-1-4-结构风险-Structural-Risk"><a href="#2-1-4-结构风险-Structural-Risk" class="headerlink" title="2.1.4 结构风险(Structural Risk)"></a>2.1.4 结构风险(Structural Risk)</h3><p>上面提到，训练数据集趋于无穷大的时候，经验风险会无限趋近于期望风险。但是在实际实践中，训练数据集是有限的，甚至<b>有时候由于条件所限，训练数据集的规模是很小的，那么这个时候的经验风险就不能够很好地去代表期望风险了</b>。所以当样本容量较小时，通常会引入结构风险。  </p><p>结构风险考虑了 <b>模型的复杂度</b> 和 <b>模型在训练数据上的拟合程度</b> 之间的平衡，通过<b>在经验风险中引入惩罚项(penalty term)来实现，这些惩罚项可以基于模型参数的大小或其他复杂度度量</b>。<br><b><font color="red">结构风险对于模型的复杂度进行限制，以避免模型过度拟合训练数据，从而提高模型的泛化能力(泛化能力在下文提到)</font></b>。  </p><p>所以在训练模型时，往往不只考虑经验风险最小化，也会考虑<b><font color="red">结构风险最小化(Structural Risk Minimization, SRM)准则</font></b>。  </p><script type="math/tex; mode=display">R_{srm}(f) =  \frac{1}{N} \sum^{N}_{i=1} {L(y_i, f(x_i))} + \lambda J(f)</script><ul><li>惩罚项 $\lambda J(f)$ 也被称为<b>正则项(regularizer)，结构风险最小化也就是常说的 <font color="red">正则化(Regularization)</font></b>。  </li></ul><h3 id="2-1-5-训练误差-training-error"><a href="#2-1-5-训练误差-training-error" class="headerlink" title="2.1.5 训练误差(training error)"></a>2.1.5 训练误差(training error)</h3><p>训练误差（Training Error）是指在训练过程中，模型对于<b>训练数据集</b>的预测<b>错误程度</b>，它通常被用来衡量模型在训练数据上的拟合程度。<br>一般来说训练误差越小，说明模型在训练数据上的拟合程度越好。 </p><ul><li><b>训练误差 vs 损失值</b>：  <ul><li>相同点：都是涉及模型预测值与正确值之间的偏差；</li><li>不同点：输入一次数据，就会通过损失函数计算出一次损失值；上面也提到过，损失值是针对单次输入的那一小部分数据的而言的；<b>而训练误差考虑的是整个训练数据集</b>。  </li></ul></li><li><b>训练误差 vs 经验风险</b>：  <ul><li>相同点：都是涉及模型预测值与正确值之间的偏差、都是考虑的整个训练数据集；</li><li>不同点：经验风险是模型在全体训练数据上的损失平均值，可以看做平均下来每个样本的损失值是多少；而训练误差是衡量对于训练数据，模型预测错误的程度；<b>是一个程度，即一般是一个小数或者百分数来表示</b>。</li></ul></li></ul><h3 id="2-1-6-测试误差-testing-error"><a href="#2-1-6-测试误差-testing-error" class="headerlink" title="2.1.6 测试误差(testing error)"></a>2.1.6 测试误差(testing error)</h3><p>测试误差指的是在测试数据集上评估已经训练好的模型时，模型对<b>测试数据</b>的预测<b>错误程度</b>。测试误差通常用来衡量模型对新数据的预测能力，即模型的泛化能力（泛化能力在下下文提到）。<br><b>测试误差越小，说明模型对新数据的预测能力越强，泛化性能越好。</b>   </p><p><img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C2_train_test_error.jpg" width="60%"></p><h3 id="2-1-7-过拟合-over-fitting"><a href="#2-1-7-过拟合-over-fitting" class="headerlink" title="2.1.7 过拟合(over-fitting)"></a>2.1.7 过拟合(over-fitting)</h3><p>上文谈及了过拟合，所谓过拟合现象，是指在模型训练过程中，<b>模型对训练数据集的拟合过于完美</b>，通常模型的复杂度也会变高，<b>导致在新的、未见过的数据上的表现反而不如在训练数据集上的表现。</b>  </p><p>通俗的来讲，就是模型“死记硬背”住了训练集，但是对于没见过的测试集却表现很差，使得模型的训练误差很小，但是测试误差很大。  </p><p>所以上面提到的结构风险，就是<b>引入正则项，使得惩罚函数的值正比于模型复杂度，限制了模型过于复杂精妙，使其无法对训练集数据拟合的过于完美</b>；除了引入正则项，还有其它方法能够避免模型的过拟合：  </p><ul><li>补充训练数据集，增大其规模；</li><li>调整模型本身的结构，使其复杂度降低；</li><li>“早停法”，即在训练过程中，当模型在测试数据集上的表现不再提升时，停止训练；</li><li>……  </li></ul><h3 id="2-1-8-欠拟合-under-fitting"><a href="#2-1-8-欠拟合-under-fitting" class="headerlink" title="2.1.8 欠拟合(under-fitting)"></a>2.1.8 欠拟合(under-fitting)</h3><p>模型欠拟合是指模型在<b>训练集上的表现不佳</b>，不能很好地反映训练数据集的真实分布，同时其在新数据上的预测性能也会较差。  </p><p>通俗来讲，就是模型还没有学到位。通常有以下办法来避免模型欠拟合：  </p><ul><li>引入组合特征、高阶特征等；</li><li>调整模型本身的结构，使其复杂度增加；</li><li>……</li></ul><h3 id="2-1-9-模型泛化能力-Genralization-Ability"><a href="#2-1-9-模型泛化能力-Genralization-Ability" class="headerlink" title="2.1.9 模型泛化能力(Genralization Ability)"></a>2.1.9 模型泛化能力(Genralization Ability)</h3><p>模型的泛化能力是指<b>模型在新的<font color="orange">未知数据</font>上的表现能力</b>。  </p><p>我们期望模型训练完成后不只是在训练集、验证集上有较好的预测能力，在面对各种测试集时也能有较好的预测能力。通俗来讲，就是<b>“举一反三”</b>的能力。  </p><h3 id="2-1-10-泛化误差-generalization-error"><a href="#2-1-10-泛化误差-generalization-error" class="headerlink" title="2.1.10 泛化误差(generalization error)"></a>2.1.10 泛化误差(generalization error)</h3><p>上文讲测试误差时，说过如果测试误差越小，就能认为模型的泛化能力越好。那么这里的泛化误差又是指的什么呢？  </p><p>泛化误差指的是在<b>所有可能的输入数据上</b>评估已经训练好的模型时，模型对<b>所有可能数据的预测错误程度</b>。<b>泛化误差是一个理论上的概念，无法直接计算</b>，但可以通过其他两个误差进行估计。<br>通常来说，泛化误差被看作是模型在未知数据上的预测能力的平均表现。  </p><h2 id="2-2-常见的模型选择方法"><a href="#2-2-常见的模型选择方法" class="headerlink" title="2.2 常见的模型选择方法"></a>2.2 常见的模型选择方法</h2><h2 id="2-2-1-留出法-Hold-Out"><a href="#2-2-1-留出法-Hold-Out" class="headerlink" title="2.2.1 留出法(Hold-Out)"></a>2.2.1 留出法(Hold-Out)</h2><p>将数据集划分为两个互斥的集合：一个训练集和一个验证集（测试集）；训练集用于训练模型，验证集（测试集）用于评估模型的预测能力。<br><i>一般可参考7：3的比例进行划分。</i></p><h2 id="2-2-2-交叉验证法-Cross-Validation"><a href="#2-2-2-交叉验证法-Cross-Validation" class="headerlink" title="2.2.2 交叉验证法(Cross-Validation)"></a>2.2.2 交叉验证法(Cross-Validation)</h2><ul><li><p><b>k 折交叉验证法</b><br>  将原始数据集随机划分为互斥的、规模差不多的K份子集；其中K-1份作为训练集，剩下的1份作为验证集（测试集）。<br><br>  这样，由于验证集（测试集）可以从K份当中任选一份，所以按照这种方法，就可以组成 k 组不同的 训练集、验证集（测试集）的组合。<br><br>  这样可以得到K次训练和验证的结果，最后通过对这K次结果的平均或选择最优的结果来评估模型的性能。<br><br>  以下是 k=10时，10折交叉验证法举例：<br>  <img src="https://teeyohuang.github.io/pic_bed/Machine_Learning/C2_cross_validation.jpg" width="70%"></p><p><br></p></li><li><b>留一法</b><br>留一法是交叉验证的一种极端情况，它<b>每一次都只用一个样本作为验证集，其余的样本作为训练集</b>。比如训练集如果共有N个样本，则每一次只选1个样本作为验证集，其余的N-1个样本作为训练集；直到N个样本都作为验证集，得到N次训练的结果，然后对这N次结果进行平均或选择最优的结果来评估模型的性能。  <font color="navy"> 留一法一般是在训练集规模，即N较小的时候采用的方法。</font></li></ul><h2 id="2-2-3-自助法-Bootstrap"><a href="#2-2-3-自助法-Bootstrap" class="headerlink" title="2.2.3 自助法(Bootstrap)"></a>2.2.3 自助法(Bootstrap)</h2><p>在可用的数据集规模较小时，可以采用自助法。这是一种<b><font color="orange">有放回</font>的随机采样方法</b>。其操作如下：  </p><blockquote><p>1.从数据集中D随机采样出一个样本，将其记录；<br>  2.将取出的样本放回数据集D中；<br>  3.重复步骤1和2 m 次，就有 m 个样本被采样记录到，将这份记录作为 D’ ，作为训练集；<br>  4.将D中除开D’的数据作为验证集（测试集）。  </p></blockquote><p>很明显，由于是有放回的抽样，每一次抽取时，每个样本都有机会被抽到；所以有的样本会被多次抽到，有的可能一次都无法被抽样到。<br>对于样本而言，每一次采样时，被采到的概率是  $\frac{1}{m}$ ，没采到的概率就是 $1-\frac{1}{m}$ ；<br>则在 m 次采样中，一直不会被抽到的概率为 $ {(1-\frac{1}{m})}^m $ ，求极限为：  </p><script type="math/tex; mode=display">\lim_{m->\infty}{(1-\frac{1}{m})}^m  = \frac{1}{e}\approx 0.368</script><h2 id="2-2-4-正则化"><a href="#2-2-4-正则化" class="headerlink" title="2.2.4 正则化"></a>2.2.4 正则化</h2><p>上面2.1.4提到过<b>结构风险(Structural Risk)</b>，即衡量模型复杂度的指标。而结构风险最小化(SRM)策略的一般实现，就是正则化，即在经验风险加上一个正则项(regularizer)或者叫惩罚项(penalty)。  </p><p>正则项一般是模型复杂度的单调递增函数，模型复杂度越高，正则项的值就越大。  </p><p>正则化的理论支持是奥卡姆剃刀(Occam’s Razor)原理：<b>如无必要，勿增实体</b>；对模型而言即<b>简单模型更有效</b>。  </p><p>本篇文章中涉及的参考资料<sup><a href="#fn_1" id="reffn_1">1</a></sup><sup><a href="#fn_2" id="reffn_2">2</a></sup>。</p><p><sup><a href="#fn_1" id="reffn_1">1</a></sup>:<a href="http://www.tup.tsinghua.edu.cn/booksCenter/book_08132901.html">李航. 统计学习方法[M]. 清华大学出版社, 2019.</a><br><sup><a href="#fn_2" id="reffn_2">2</a></sup>:<a href="http://www.tup.tsinghua.edu.cn/bookscenter/book_06402702.html">周志华. 机器学习[M]. 清华大学出版社, 2016.</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1-机器学习概念和相关术语介绍</title>
      <link href="/Machine-Learning/ML_01_Basic_Concepts_and_Terms.html"/>
      <url>/Machine-Learning/ML_01_Basic_Concepts_and_Terms.html</url>
      
        <content type="html"><![CDATA[<!-- <img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width=70%>   --><p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%"></p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="1-机器学习概念和相关术语介绍"><a href="#1-机器学习概念和相关术语介绍" class="headerlink" title="1 机器学习概念和相关术语介绍"></a>1 机器学习概念和相关术语介绍</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><h3 id="1-1-统计学习"><a href="#1-1-统计学习" class="headerlink" title="1.1 统计学习"></a>1.1 统计学习</h3><ul><li><p><strong>概念</strong>  </p><blockquote><p>统计学习是关于计算机基于<strong>数据</strong>构建<strong>概率统计模型</strong>，并运用模型对数据进行<strong>预测与分析</strong>的一门学科，<strong>统计学习也称为统计机器学习</strong>。</p></blockquote></li><li><p><strong>对象</strong>  </p><blockquote><p>统计学习研究的对象是<strong>数据</strong>。它从数据出发，提取数据的<strong>特征</strong>，抽象出数据的<strong>模型</strong>，发现数据中的知识，又回到对数据的<strong>分析</strong>与<strong>预测</strong>中去。 </p><p>统计学习关于数据的基本假设是<strong>同类数据具有一定的统计规律性</strong>，这是统计学习的前提。</p></blockquote></li><li><p><strong>目的</strong>  </p><blockquote><p>统计学习用于<strong>对数据的预测与分析</strong>，特别是对未知新数据的预测与分析；而对数据的预测与分析是<strong>通过构建概率统计模型</strong>实现的。  </p><p>统计学习总的目标就是考虑<strong>学习什么样的模型 和 如何学习模型</strong>，以使模型能对数据进行准确的预测与分析，同时也要考虑尽可能地提高学习效率。</p></blockquote></li><li><p><strong>方法</strong>  </p><blockquote><p>统计学习方法可以概括如下:从给定的、有限的、用于学习的<strong>训练数据集合</strong>出发，假设数据是<strong>独立同分布</strong>产生的;并且假设要<strong>学习的模型属于某个函数的集合</strong>，称为假设空间；应用某个<strong>评价准则</strong>，从假设空间中选取一个<strong>最优模型</strong>，使它对已知的训练数据及未知的测试数据在给定的评价准则下有最优的预测；最优模型的选取由<strong>算法</strong>实现。</p><p>这样统计学习方法包括模型的<strong>假设空间、模型选择的准则以及模型学习的算法</strong>。称其为<strong>统计学习方法的三要素</strong>，简称为<b>模型(model)、策略(strategy)和算法(algorithm)</b></p></blockquote><p><font color="orange">实现统计学习方法的步骤如下: </font>  </p><ul><li>(1)确定训练数据集;  </li><li>(2)确定学习模型的集合，(即包含所有可能的模型的假设空间);  </li><li>(3)确定模型选择的准则，(即学习的策略)；  </li><li>(4)实现求解最优模型的算法，(即学习的算法)；  </li><li>(5)通过学习方法选择最优模型;  </li><li>(6)对新数据进行预测或分析。  </li></ul></li></ul><h2 id="1-2-机器学习分类"><a href="#1-2-机器学习分类" class="headerlink" title="1.2 机器学习分类"></a>1.2 机器学习分类</h2><h3 id="1-2-1-基本分类"><a href="#1-2-1-基本分类" class="headerlink" title="1.2.1 基本分类"></a>1.2.1 基本分类</h3><h4 id="1-2-1-1-监督学习-Supervised-Learning"><a href="#1-2-1-1-监督学习-Supervised-Learning" class="headerlink" title="1.2.1.1 监督学习(Supervised Learning)"></a>1.2.1.1 监督学习(Supervised Learning)</h4><p>监督学习是 从<b>有标记的训练数据</b> 中学习模式和关系，算法的目标是通过<b>输入特征与其相应的标签之间</b>的关联性，构建一个能够<b>准确预测新数据的标签</b>的模型。  </p><font color="navy"><b>监督学习的典型任务包括分类和回归问题。</b></font><h4 id="1-2-1-2-无监督学习-Unsupervised-Learning"><a href="#1-2-1-2-无监督学习-Unsupervised-Learning" class="headerlink" title="1.2.1.2 无监督学习(Unsupervised Learning)"></a>1.2.1.2 无监督学习(Unsupervised Learning)</h4><p>无监督学习算法从<b>没有标记的训练数据</b>中学习预测模型。与监督学习不同，无监督学习<b>不依赖于预先标记的标签</b>，而是尝试从输入数据中提取<b>统计规律或潜在结构</b>，这对于许多实际应用来说是非常有价值的信息。  </p><font color="navy"><b>无监督学习的典型任务包括聚类、降维和异常检测。</b></font><h4 id="1-2-1-3-强化学习-Reinforcement-Learning"><a href="#1-2-1-3-强化学习-Reinforcement-Learning" class="headerlink" title="1.2.1.3 强化学习(Reinforcement Learning)"></a>1.2.1.3 强化学习(Reinforcement Learning)</h4><p>强化学习是指智能<b>系统通过与环境互动</b>并基于其表现<b>获得奖励或惩罚</b>，以学习如何<b>在特定环境中采取最优行动</b>。 </p><p>强化学习的目标是使得<b>智能系统能够最大化其所获得的奖励</b>，并在长期和短期之间找到一个平衡。<br>与监督学习和无监督学习不同，<b>强化学习是一个试错的过程</b>，其中智能体通过尝试不同的行动来学习如何在环境中获得最佳结果。  </p><font color="navy"><b>强化学习的典型应用包括游戏策略、自动驾驶、机器人控制和其他决策制定问题。</b></font>  <p>在强化学习中，关键的要素包括智能体(系统)、环境、行动、奖励和策略。智能体是执行任务的实体，环境是智能体执行行动的场所，行动是智能体在环境中可以采取的行动，奖励是智能体在执行特定行动后从环境中获得的反馈，策略是智能体根据当前状态选择最优行动的方法。  </p><p>强化学习算法通常采用动态规划、蒙特卡洛方法、时序差分等方法来学习最优策略。  </p><h4 id="1-2-1-4-半监督学习-Semi-supervised-Learning"><a href="#1-2-1-4-半监督学习-Semi-supervised-Learning" class="headerlink" title="1.2.1.4 半监督学习(Semi-supervised Learning)"></a>1.2.1.4 半监督学习(Semi-supervised Learning)</h4><p>半监督学习结合了监督学习和无监督学习的特点。算法使用<b>大量的未标记数据</b>和<b>少量的标记数据</b>来进行模式识别工作。  </p><p>半监督学习往往利用未标记数据中的信息，辅助标记数据进行学习。但同时也可以利用标记数据来辅助未标记数据，以更好地理解数据的结构和统计关系。  </p><h4 id="1-2-1-5-主动学习-Active-Learning"><a href="#1-2-1-5-主动学习-Active-Learning" class="headerlink" title="1.2.1.5 主动学习(Active Learning)"></a>1.2.1.5 主动学习(Active Learning)</h4><p>主动学习允许算法通过<b>主动询问用户的反馈</b>来优化模型。主动学习通过<b>选择最有信息量的样本</b>来提高学习模型的性能。这些最有信息量的样本通常是难以分类的、存在噪声的或者新的数据点。主动学习算法在训练过程中主动选择这些样本来获取更多的信息，从而优化模型的准确性。  </p><p>与监督学习和无监督学习不同，主动学习需要用户的反馈，并且选择哪些样本进行反馈是由算法自动完成的。    </p><font color="navy"><b>主动学习的典型应用包括垃圾邮件识别、疾病诊断和语音识别等领域。</b></font>    <p>一些常见的主动学习算法包括查询最优划分、熵最大化和不确定采样等。  </p><h3 id="1-2-2-按照模型分类"><a href="#1-2-2-按照模型分类" class="headerlink" title="1.2.2 按照模型分类"></a>1.2.2 按照模型分类</h3><h4 id="1-2-2-1-概率模型与非概率模型"><a href="#1-2-2-1-概率模型与非概率模型" class="headerlink" title="1.2.2.1 概率模型与非概率模型"></a>1.2.2.1 概率模型与非概率模型</h4><ol><li><p><b>概率模型</b></p><blockquote><p>机器学习中的概率模型指的是一种<b>建立概率分布关系</b>的模型，它由一组概率定义，描述了<b>模型中各个随机变量的概率分布</b>，如 p(y|x)  or p(x|y)。<b>概率模型可以用来表示不确定性，建立输入和输出之间的概率关系</b>，并通过统计方法进行预测和决策。  </p></blockquote><font color="navy"><b>常见的概率模型包括朴素贝叶斯模型、最大熵模型、多项式分布模型等。</b></font>   </li><li><p><b>非概率模型</b>  </p><blockquote><p>非概率模型则<b>不直接涉及概率的概念</b>，而是通过建立决策函数或模型来<b>描述输入和输出之间的关系</b>，如 y=f(x) or z=g(x);<br>非概率模型不提供概率分布或不确定性估计，而是通过拟合数据集的方式进行预测和决策。  </p></blockquote><font color="navy"><b>常见的非概率模型包括决策树、支持向量机、K-近邻算法、神经网络等。</b></font>  </li></ol><h4 id="1-2-2-2-线性模型与非线性模型"><a href="#1-2-2-2-线性模型与非线性模型" class="headerlink" title="1.2.2.2 线性模型与非线性模型"></a>1.2.2.2 线性模型与非线性模型</h4><ol><li><p><b>线性模型</b>  </p><blockquote><p>如果因变量和自变量之间存在线性关系，即模型 y=f(x) 可以表示为线性函数，就是线性模型。  </p><font color="navy"><b>常见的线性模型有： 线性回归（Linear Regression）、对数几率回归（Logistic Regression） 、 线性判别分析（Linear Discriminant Analysis） 等</b></font>  </blockquote></li><li><p><b>非线性模型</b>  </p><blockquote><p>如果因变量和自变量之间是非线性关系，即模型 y=f(x) 是非线性函数，就是非线性模型。    </p><font color="navy"><b>常见的非线性模型：  决策树（Decision Tree） 、 支持向量机（Support Vector Machine，SVM）、 神经网络（Neural Network） 等</b></font>  </blockquote></li></ol><h4 id="1-2-2-3-参数化模型与非参数化模型"><a href="#1-2-2-3-参数化模型与非参数化模型" class="headerlink" title="1.2.2.3 参数化模型与非参数化模型"></a>1.2.2.3 参数化模型与非参数化模型</h4><ol><li><p><b>参数化模型</b>  </p><blockquote><p>参数化模型通常假设总体(population)服从某个分布，这个分布由一些参数确定；而且假设模型的参数的维度是固定的，数目是有限的。   </p><font color="navy"><b>常见的参数化模型有 线性回归模型、神经网络模型。</b></font> </blockquote></li><li><p><b>非参数化模型</b>  </p><blockquote><p>非参数化模型则不指定总体的分布(population)，只通过非参数统计的方法进行推断。非参数模型对于总体的分布不做任何假设或限制，只根据数据本身的特征进行学习和预测。因此，非参数化模型无法得到明确的参数形式，而是通过拟合数据集的方式进行预测和决策。<br>虽然非参数化模型本身没有明确的参数形式，但在实际应用中仍然存在一些可调的参数需要进行调整和优化，比如一些超参数、或者偏置等等，又或者其参数的维度不固定，或者数目无穷大（随着输入增大而变多）。  </p><font color="navy"><b>常见的非参数化模型有 决策树、KNN、随机森林等。</b></font> <p>(注：支持向量机可以被视作参数化模型，也可以视作非参数化模型。感兴趣的可以去网上搜索相关资料，在此不赘述。)</p></blockquote></li></ol><h3 id="1-2-3-按数据选择的不同方式"><a href="#1-2-3-按数据选择的不同方式" class="headerlink" title="1.2.3 按数据选择的不同方式"></a>1.2.3 按数据选择的不同方式</h3><h4 id="1-2-3-1-在线学习"><a href="#1-2-3-1-在线学习" class="headerlink" title="1.2.3.1 在线学习"></a>1.2.3.1 在线学习</h4><blockquote><p>在线学习是指每当一份新的样本数据到来时就进行一次训练，而不需要等到所有的数据都集齐后再统一进行训练。这种方法在处理大量数据时非常有效，因为每次只需要处理一部分数据，而不是等待所有的数据都集齐。因此，在线学习可以节省时间和计算资源。</p></blockquote><h4 id="1-2-3-2-离线学习"><a href="#1-2-3-2-离线学习" class="headerlink" title="1.2.3.2 离线学习"></a>1.2.3.2 离线学习</h4><blockquote><p>离线学习是指将所有的数据收集齐后，再进行一次性训练。这种方法通常需要更多的时间和计算资源，因为需要等待所有的数据都集齐后才能开始训练。然而离线可以更准确地反映数据的整体分布，从而得到更精确的模型。</p><ul><li>通常，一次性将数据全部用于训练，也被称为 批量训练（Batch Learning）。Offline Learning是一种广义的概念，Batch Learning可以被视为Offline Learning的一种具体实现方式。<br><br></li><li>小批量学习（Mini-batch Learning）学习是介于在线学习（Online Learning）和批量学习（Batch Learning）之间的一种方法,每次从整个数据集中选择一小部分数据（称为mini-batch）进行训练，而不是使用整个数据集进行训练，也不是每次只处理一个数据样本。<br> 严格来讲，小批量学习也是属于离线学习中的一类。<br> Mini-batch Learning 在神经网络训练中非常常见，因为它可以有效地利用GPU的并行计算能力，同时也可以减少内存占用</li></ul></blockquote><h2 id="1-3-统计学习三要素"><a href="#1-3-统计学习三要素" class="headerlink" title="1.3 统计学习三要素"></a>1.3 统计学习三要素</h2><h3 id="1-3-1-模型"><a href="#1-3-1-模型" class="headerlink" title="1.3.1 模型"></a>1.3.1 模型</h3><p>   <b><font color="orangered">模型是所要学习的条件概率分布或决策函数，能够将输入数据映射到预测输出。</font></b>模型通过对数据集进行训练，学习其拟合数据的特性，从而对未知数据进行预测。  </p><h3 id="1-3-2-策略"><a href="#1-3-2-策略" class="headerlink" title="1.3.2 策略"></a>1.3.2 策略</h3><p>   <b><font color="orangered">简单来讲就是度量一个模型好坏的评价标准或选择最优模型的方法。</font></b><br>   同时会在学习过程中应用该方法来指导模型的训练，以期望最终得到的模型将来对未知的数据具有最好的预测准确度。<br>   （<font color="navy">损失函数可以理解为一种具体的策略，策略是一种更广义的定义，比如结构风险、经验风险等</font>）  </p><h3 id="1-3-3-算法"><a href="#1-3-3-算法" class="headerlink" title="1.3.3 算法"></a>1.3.3 算法</h3><p>   算法是指学习模型的<b><font color="orangered">具体计算方法</font></b>。统计机器学习问题通常会被归结为最优化问题，所以一般情况下可以理解成最优化问题的算法，<font color="navy">比如牛顿法、梯度下降法、最小二乘法、动态规划等等</font>。  </p><h2 id="1-4-基础性术语"><a href="#1-4-基础性术语" class="headerlink" title="1.4 基础性术语"></a>1.4 基础性术语</h2><h3 id="1-4-1-数据集-dataset"><a href="#1-4-1-数据集-dataset" class="headerlink" title="1.4.1 数据集(dataset)"></a>1.4.1 数据集(dataset)</h3><p>就是数据组成的一个集合；比如：</p><ul><li>CV领域经典的 <a href="http://yann.lecun.com/exdb/mnist/">MNIST</a>、<a href="https://www.image-net.org/">ImageNet</a>、<a href="http://host.robots.ox.ac.uk/pascal/VOC/">PASCAL VOC</a> 数据集;</li><li>NLP领域经典的 <a href="http://nlpprogress.com/english/sentiment_analysis.html">IMDb Movie Reviews</a>、<a href="https://gluebenchmark.com/">GLUE</a> 数据集;</li><li>Recommendation领域经典的 <a href="https://grouplens.org/datasets/movielens/">MovieLens</a>、<a href="https://paperswithcode.com/dataset/netflix-prize">Netflix Prize</a> 数据集;</li></ul><p>这里推荐两个下载数据集的链接 <a href="https://www.kaggle.com/datasets">kaggle</a> 、<a href="https://paperswithcode.com/datasets">paperswithcode</a>.  </p><h3 id="1-4-2-样本-sample-instance"><a href="#1-4-2-样本-sample-instance" class="headerlink" title="1.4.2 样本(sample/instance)"></a>1.4.2 样本(sample/instance)</h3><p>可以理解为一部分数据（即数据集的一个采样）; 也可以理解成数据集中的一个具体事件、对象、记录。<br>具体是复数还是单数，要看具体的语境。  </p><h3 id="1-4-3-特征-feature"><a href="#1-4-3-特征-feature" class="headerlink" title="1.4.3 特征(feature)"></a>1.4.3 特征(feature)</h3><p>描述数据的基本属性或者指标；特征通常由向量来表示，称为<b>特征向量(featrue vector)</b><br>比如一个记录医院患者情况的数据集，那么每个患者的一些身体指标（血压、血糖、血脂等等）就可以作为患者的特征；<br>又比如购物网站中商品数据集，商品的价格、品牌、用途、种类等等属性就可以作为商品特征。  </p><h3 id="1-4-4-标签-标注-label"><a href="#1-4-4-标签-标注-label" class="headerlink" title="1.4.4 标签/标注(label)"></a>1.4.4 标签/标注(label)</h3><p>在监督学习中，标签是指的<b>记录数据正确的（或者说应有的）输出或者类别</b>，这个信息可作为“监督信息”来指导模型的训练，因为这个信息就是监督学习训练的目标，所以有时候也被成为<b>目标(target)</b>；  </p><p>对于一个训练得较好的模型来讲，在输入相应的样本时，理论上模型的输出，就应该和这个样本的标注信息一致。  </p><p>（用更为通俗的话来讲，标签就是我们学生时代做练习题时的“参考答案”，我们可以在做题时或做完后，观看参考答案来对自己掌握的知识、做题方法进行校正，以便之后遇到同样的题目或者类似的题目时，能够写出正确答案。）  </p><p>无监督学习问题中，数据集一般就是没有标签的。  </p><p><i>这里多提一句，标注信息并不一定100%准确，有可能会有少量样本对应的标注是错误的，这种可以理解为脏数据。脏数据是否会对模型造成很大的影响，要具体问题具体分析。</i>  </p><h3 id="1-4-5-真相-真实-Ground-Truth"><a href="#1-4-5-真相-真实-Ground-Truth" class="headerlink" title="1.4.5 真相/真实(Ground-Truth)"></a>1.4.5 真相/真实(Ground-Truth)</h3><p>Ground-Truth一般是数据的某种潜在规律，或者说是一种更为准确和精细的参考标准；用于评估机器学习模型的表现。<br>在有些场合，是认为<b>标注中正确的标注</b>就叫做ground truth，错误的标注则不是；<br>在有些不严格的场合，ground truth 和 label 往往混用。  </p><h3 id="1-4-6-训练集-training-set"><a href="#1-4-6-训练集-training-set" class="headerlink" title="1.4.6 训练集(training set)"></a>1.4.6 训练集(training set)</h3><p>用于训练和学习的数据集，通常是从原始的大数据集中选择的一部分；<br>包含了输入特征和对应的输出标签（无监督学习任务可能没有标签这一部分），模型就是基于这些数据来训练，以获得预测位置数据的能力。  </p><h3 id="1-4-7-验证集-validation-set"><a href="#1-4-7-验证集-validation-set" class="headerlink" title="1.4.7 验证集(validation set)"></a>1.4.7 验证集(validation set)</h3><p>是在训练过程中（或完成后）用来评估模型的性能和效果的数据集；根据模型在验证集上的表现，来调整对于模型后续的优化、训练思路。 </p><p>验证集一般也是从原始的大数据集中选取。通常来讲，一个原始大数据集会被分为训练集和验证集两部分，来供我们训练模型使用。  </p><p>需要注意的是，验证集不会被直接用来更新模型，即只关心输入验证集后得到的输出。<br>换句话说，模型不会从验证集中学习知识，只用它来检验效果；如果后续对模型进行迭代和优化，还是要回到训练集上去学习。  </p><h3 id="1-4-8-测试集-test-set"><a href="#1-4-8-测试集-test-set" class="headerlink" title="1.4.8 测试集(test set)"></a>1.4.8 测试集(test set)</h3><p>测试集和验证集的作用比较类似，也是用来评估模型的性能和效果的数据集，有些不严格的场合是将二者混用；  </p><p>然而，<b>二者从本质上来讲还是有区别的</b>：<br>测试集是在训练集和验证集之外单独抽取的数据集，用于评估模型<b>在未知数据上</b>的性能，比如：  </p><ul><li>对于一些应用于实际生活中的机器学习模型，其面对的真实世界中的数据，就是属于 testing set;  </li><li>对于一些机器学习竞赛，我们提交模型后，主办方用于评估我们模型的数据，就是属于 testing set。  </li></ul><p>所以从严格意义上来讲，一般情况下，我们在训练自己的模型的时候，是不会接触到 testing set 的；我们在训练和优化模型时用来做测试，做所谓 “test” 的数据，其实准确的说法是<b>验证集(validation set)</b>，只不过日常口语化的表达会把它称为“测试集”，但一定要理解这二者本质上的差异，在书写论文的时候要严格规范用语。  </p><h3 id="1-4-9-输入空间-input-space"><a href="#1-4-9-输入空间-input-space" class="headerlink" title="1.4.9 输入空间(input space)"></a>1.4.9 输入空间(input space)</h3><p>输入数据所有可能的取值的集合。  </p><h3 id="1-4-10-特征空间-feature-space"><a href="#1-4-10-特征空间-feature-space" class="headerlink" title="1.4.10 特征空间(feature space)"></a>1.4.10 特征空间(feature space)</h3><p>所有特征向量存在的空间；特征空间的大小由特征向量的维度决定。  </p><h3 id="1-4-11-输出空间-output-space"><a href="#1-4-11-输出空间-output-space" class="headerlink" title="1.4.11 输出空间(output space)"></a>1.4.11 输出空间(output space)</h3><p>输出所有可能的取值的集合。  </p><h3 id="1-4-12-假设空间-hypothesis-space"><a href="#1-4-12-假设空间-hypothesis-space" class="headerlink" title="1.4.12 假设空间(hypothesis space)"></a>1.4.12 假设空间(hypothesis space)</h3><p><b>所有能够将输入映射到输出的预测函数（或模型）所组成的函数空间（或者说集合）</b>。假设空间的确定意味着学习范围的确定。<br>比如，假设因变量 y 和 自变量 x 成正比例关系，则 假设空间就是 y = kx, (k&gt;0)。这个表达式就包含了所有可能的正比例函数。  </p><p>本篇文章中涉及的参考资料<sup><a href="#fn_1" id="reffn_1">1</a></sup><sup><a href="#fn_2" id="reffn_2">2</a></sup>。</p><p><sup><a href="#fn_1" id="reffn_1">1</a></sup>:<a href="http://www.tup.tsinghua.edu.cn/booksCenter/book_08132901.html">李航. 统计学习方法[M]. 清华大学出版社, 2019.</a><br><sup><a href="#fn_2" id="reffn_2">2</a></sup>:<a href="http://www.tup.tsinghua.edu.cn/bookscenter/book_06402702.html">周志华. 机器学习[M]. 清华大学出版社, 2016.</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习系列</title>
      <link href="/Machine-Learning/ML_00_Introduction.html"/>
      <url>/Machine-Learning/ML_00_Introduction.html</url>
      
        <content type="html"><![CDATA[<!-- <img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width=70%>   --><p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%"></p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="1-机器学习系列简介"><a href="#1-机器学习系列简介" class="headerlink" title="1.机器学习系列简介"></a>1.机器学习系列简介</h1><hr style="border:solid; height:1px; color=#000000 size=1">    <div class="table-container"><table><thead><tr><th>目录</th></tr></thead><tbody><tr><td><a href="https://teeyohuang.github.io/Machine-Learning/ML_00_Introduction.html">0-机器学习系列</a></td></tr><tr><td><a href="https://teeyohuang.github.io/Machine-Learning/ML_01_Basic_Concepts_and_Terms.html">1-机器学习概念和相关术语介绍</a></td></tr><tr><td><a href="https://teeyohuang.github.io/Machine-Learning/ML_02_Model_Selection_and_Evaluation.html">2-模型评估和选择方法</a></td></tr><tr><td><a href="https://teeyohuang.github.io/Machine-Learning/ML_03_Supervised_Learning_Introduction.html">3-监督学习简述</a></td></tr><tr><td><a href="https://teeyohuang.github.io/Machine-Learning/ML_04_Linear_Model_1.html">4-线性模型—(上)</a></td></tr><tr><td><a href="https://teeyohuang.github.io/Machine-Learning/ML_04_Linear_Model_2.html">4-线性模型—(中)</a></td></tr><tr><td><a href="https://teeyohuang.github.io/Machine-Learning/ML_04_Linear_Model_3.html">4-线性模型—(下)</a></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5 随机失活</title>
      <link href="/Deep-Learning/DL_05_dropout.html"/>
      <url>/Deep-Learning/DL_05_dropout.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1">  <p><a href="https://teeyohuang.github.io/Deep-Learning/DL_00_introduction.html">深度学习系列博文目录一览</a><br>————————————————</p><h1 id="5-随机失活"><a href="#5-随机失活" class="headerlink" title="5 随机失活"></a>5 随机失活</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="5-1-模型平均"><a href="#5-1-模型平均" class="headerlink" title="5.1 模型平均"></a>5.1 模型平均</h2><p>如果对传统机器学习有所了解的话，会知道有一种称之为集成学习的方法。<br>而神经网络中的<b>随机失活-dropout</b>其实就是借鉴了集成学习的思想，更具体地，是<b>集成学习中的bagging</b>方法，<b>即模型平均思想</b>的一种运用。  </p><p>因为模型平均要对训练集有放回的采样，得到多个不同的训练集，再训练多个不同的模型，<br>在测试阶段由多个不同的模型投票表决或者平均 来做出最终预测。<br>但是对于深度神经网络而言，<b>训练多个不同的模型 可能不切实际，会耗费大量时间和计算力。</b></p><h2 id="5-2-dropout作用关于模型平均的解释"><a href="#5-2-dropout作用关于模型平均的解释" class="headerlink" title="5.2 dropout作用关于模型平均的解释"></a>5.2 dropout作用关于模型平均的解释</h2><p>dropout 对<b>神经元随机失活</b>，也就是说<b><font color="red">前传的过程中可能这个神经元以及它后面的路径并不会被使用，相当于前传的路径只是整个大神经网络的一个子网络。</font></b>&lt;/font&gt;<br>所以训练的时候，相当于是在并行训练很多个子网络（模型）；<br>预测的时候，随机失活不产生作用，这样使用 的就是整个大网络模型，得到的结果相当于是综合考虑子网络得到的平均结果。<br>这样就相当于实现了bagging训练。</p><p><img src="https://teeyohuang.github.io/pic_bed/Deep_Learning/5_1.webp" width="70%">   </p><p>Dropout训练与Bagging训练的一些区别。</p><ul><li>①<br> 在Bagging的情况下，所有模型都是独立；<br> 在Dropout的情况下，所有模型共享参数，其中每个模型继承父神经网络参数的不同子集。其中每个参数共享使得在有限可用的内存下表示指数级数量的模型变得可能。</li></ul><ul><li><p>②<br> 在Bagging的情况下，每一个模型在其相应训练集上训练到收敛。</p><p> 在Dropout的情况下，通常大部分模型都没有显式地被训练，因为通常父神经网络会很大，以致于到宇宙毁灭都不可能采样完所有的子网络。取而代之的是，在单个步骤中我们训练一小部分的子网络，参数共享会使得剩余的子网络也能有好的参数设定。</p></li></ul><p>这些是仅有的区别。除了这些，Dropout与Bagging算法一样。</p><p>每一个随机失活的单元都可以设置一个失活概率P，是超参数，控制前向传播的时候，dropout是否发生作用。</p><h2 id="5-2-dropout作用关于正则化的解释"><a href="#5-2-dropout作用关于正则化的解释" class="headerlink" title="5.2 dropout作用关于正则化的解释"></a>5.2 dropout作用关于正则化的解释</h2><p>在后续的研究中，研究者发现dropout可能不是Hinton认为的那样是类似于bagging训练，也就是说我们上面的解释可能只是Hinton当时的一种初级解释。现在学界普遍认为，dropout是引入了噪音，相当于对网络引入了正则项。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4 激活函数</title>
      <link href="/Deep-Learning/DL_04_activation_func.html"/>
      <url>/Deep-Learning/DL_04_activation_func.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1">  <p><a href="https://teeyohuang.github.io/Deep-Learning/DL_00_introduction.html">深度学习系列博文目录一览</a><br>————————————————</p><h1 id="4-激活函数"><a href="#4-激活函数" class="headerlink" title="4 激活函数"></a>4 激活函数</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p>激活函数也就是一些<b>非线性单元</b>，如果不用激活函数，每一层输出都是上层输入的线性函数，无论神经网络有多少层，输出都是输入的线性组合。如果使用激活函数的话，<b>激活函数给神经元引入了非线性因素，使得神经网络可以任意逼近任何非线性函数，这样神经网络就可以应用到众多的非线性模型中</b>。 </p><p>对于激活函数的使用，可以追溯到多层感知机解决异或(XOR)问题。</p><p>参考资料：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/25110450">知乎</a></li></ol><h2 id="4-1-sigmoid"><a href="#4-1-sigmoid" class="headerlink" title="4.1 sigmoid"></a>4.1 sigmoid</h2><p><img src="https://teeyohuang.github.io/pic_bed/Deep_Learning/4_1.webp" width="90%">  </p><p><b>sigmoid作激活函数的优点</b>:</p><ul><li><p>梯度计算较为方便  </p><p>  <img src="https://teeyohuang.github.io/pic_bed/Deep_Learning/4_1_1.webp" width="90%">  </p></li><li><p>能够控制数值的幅度</p><p>  （即能压缩数据，在深层网络中可以保持数据幅度不会出现大的变化，保证数据幅度不会有问题）  </p></li></ul><p><b>sigmoid缺点</b>：</p><ul><li><p><b>容易出现梯度消失（gradient  vanishing）的现象</b>：<br>  当激活函数的输入值接近饱和区（两边)时，变化太缓慢，导数接近0；</p><p>  根据反向传播的数学依据是微积分求导的链式法则，当前导数需要之前各层导数的乘积，几个比较小的数相乘，导数结果很接近0，从而无法完成深层网络的训练。</p></li><li><p><b>Sigmoid的输出不是0均值（zero-centered）的</b>：<br>  <b><font color="red">输出值恒大于0，这会导致模型训练的收敛速度变慢</font></b>。比如上一级 经过 sigmoid之后，输出的一定是个正数x，那么希望更新这一级的参数的时候，wx+b，w的梯度是x，但是x恒为正，那么我这一级的w（w是个向量，里面会有很多分量）的所有分量都只能往正向移动，不能各个分量朝不同的方向移动，所以收敛速度变慢。 </p></li><li><p><b>幂运算相对来讲比较耗时。</b>  </p></li></ul><h2 id="4-2-tanh"><a href="#4-2-tanh" class="headerlink" title="4.2 tanh"></a>4.2 tanh</h2><p>tanh读作 Hyperbolic Tangent  </p><p><img src="https://teeyohuang.github.io/pic_bed/Deep_Learning/4_2.webp" width="90%">  </p><p>它的输出是0均值的了，解决了上面sigmoid的（2问题），但是梯度消失 和 幂运算费时的问题依然存在。</p><h2 id="4-3-ReLU"><a href="#4-3-ReLU" class="headerlink" title="4.3 ReLU"></a>4.3 ReLU</h2><p>ReLU（Rectified Linear Unit）：整流线性单元</p><p><img src="https://teeyohuang.github.io/pic_bed/Deep_Learning/4_3.webp" width="90%">  </p><p>ReLU函数其实就是一个取最大值函数，注意这并不是全区间可导的(0点不连续)，但是我们可以取sub-gradient，如上图所示。ReLU虽然简单，但却是近几年的重要成果，有以下几大优点：  </p><ul><li>解决了gradient vanishing问题 (在正区间)</li><li>计算速度非常快，只需要判断输入是否大于0</li><li>收敛速度远快于sigmoid和tanh</li></ul><p>ReLU也有几个需要特别注意的问题：</p><ul><li><p>ReLU的输出不是zero-centered  </p></li><li><p>Dead ReLU Problem<br>  <b><font color="red">指的是某些神经元可能永远不会被激活，导致相应的参数永远不能被更新</font></b>。有两个主要原因可能导致这种情况产生:<br>   (1) 非常不幸的参数初始化，这种情况比较少见 ；  </p><p>  (2) <b>learning rate太高导致在训练过程中<font color="red"> 参数更新太大</font></b>，使得<b>输入发生巨大变化</b>后越过0界，则前向传播为0，相当于这个单元被关闭了，反向传播的时候也为0 ，这个关掉的单元就跳不出来了。解决方法是<b>可以采用Xavier初始化方法，以及避免将learning rate设置太大或使用adagrad等自动调节learning rate的算法</b>。</p></li></ul><p>尽管存在这两个问题，ReLU目前仍是最常用的activation function，在搭建人工神经网络的时候推荐优先尝试！</p><h2 id="4-4-Leaky-ReLU"><a href="#4-4-Leaky-ReLU" class="headerlink" title="4.4 Leaky ReLU"></a>4.4 Leaky ReLU</h2><p>中文称作：渗漏整流线性单元  </p><p><img src="https://teeyohuang.github.io/pic_bed/Deep_Learning/4_4.webp" width="90%"> </p><p>为了解决Dead ReLU Problem，提出了将ReLU的前半段设为0.01x而非0. </p><h2 id="4-5-ELU"><a href="#4-5-ELU" class="headerlink" title="4.5 ELU"></a>4.5 ELU</h2><p>ELU (Exponential Linear Units)：指数化线性单元</p><p><img src="https://teeyohuang.github.io/pic_bed/Deep_Learning/4_5.webp" width="90%">  </p><p>ELU也是为解决ReLU存在的问题而提出，显然，ELU有ReLU的基本所有优点，以及：</p><p>（1）不会有Dead ReLU问题</p><p>（2）输出的均值接近0，zero-centered</p><p>它的一个小问题在于计算量稍大。类似于Leaky ReLU，理论上虽然好于ReLU，但在实际使用中目前并没有好的证据ELU总是优于ReLU。</p><h2 id="4-6-PReLU"><a href="#4-6-PReLU" class="headerlink" title="4.6 PReLU"></a>4.6 PReLU</h2><p>PReLU ( Parameterized ReLU） 参数整流线性单元</p><p><img src="https://teeyohuang.github.io/pic_bed/Deep_Learning/4_6.webp" width="40%"></p><p>从形式上看，很像Leaky ReLU，但是区别在于将 PReLU 输入为负半轴部分映射为 <b>一个可学习参数 α </b>和输入的乘积; Leaky ReLU 而负半轴的参数是一个固定值。</p><p>.</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2 卷积与池化</title>
      <link href="/Deep-Learning/DL_02_convolution_and_pool_layer.html"/>
      <url>/Deep-Learning/DL_02_convolution_and_pool_layer.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1">  <p><a href="https://teeyohuang.github.io/Deep-Learning/DL_00_introduction.html">深度学习系列博文目录一览</a><br>————————————————</p><h1 id="2-卷积与池化"><a href="#2-卷积与池化" class="headerlink" title="2 卷积与池化"></a>2 卷积与池化</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p>这里暂时不介绍卷积操作具体是如何进行的，关于这点，很多文章都有介绍。</p><p>本文主要介绍一下 <b>为何会广泛使用卷积操作</b>？</p><p>参考资料：</p><ol><li><p>《Deep Learning》</p></li><li><p><a href="https://mooc.study.163.com/learn/2001281004?tid=2001392030#/learn/content?type=detail&amp;id=2001728690">deeplearning.ai</a></p></li></ol><p>卷积运算 主要通过三个重要的思想来帮助改进机器学习系统：</p><ul><li><p>稀疏交互 sparse interactions</p></li><li><p>参数共享 parameter sharing</p></li><li><p>等变表示 equivariant representations</p></li></ul><h2 id="2-1-稀疏交互"><a href="#2-1-稀疏交互" class="headerlink" title="2.1 稀疏交互"></a>2.1 稀疏交互</h2><p>卷积网络的<b>稀疏交互 - sparse interactions</b>（也叫稀疏连接 或者 稀疏权重），是通过使<b>卷积核的大小远小于输入的大小</b>来达到的。这就区别于全连接层的 矩阵相乘运算，</p><p><b><font color="red">卷积核的话就只接受有限个输入，使得参数量减小。</font></b>&lt;/font&gt;比如3x3大小的卷积核，就只接受9个像素点上的输入。这块儿大小有个更专业的术语，叫做 <b>感受野（receptive field）</b>，或者<b>FOV（field of view）.</b>但是这样说明<b>卷积核主要是在学习局部相关性。</b></p><p>CNN中的卷积操作在对图像进行处理时，主要是为了获得图片局部特征，在计算机视觉里，我们将这样的操作叫做滤波，都是为了获得局部领域的输出。常用的卷积操作本质上就是加权平均，这样的线性运算是获取局部特征最简单的操作，利用BP算法也显得特别直接。  </p><p>CNN同样可以处理时间序列和文本数据，因为CNN利用的就是数据的局部相关性，语音和文本具备局部相关性。</p><h2 id="2-2-参数共享"><a href="#2-2-参数共享" class="headerlink" title="2.2 参数共享"></a>2.2 参数共享</h2><p>参数共享 - parameter sharing ，是指 在一个模型的多个函数中使用相同的参数。卷积网络中，一般情况下一个卷积核会作用在输入的每一个位置，这种参数共享保证了我们只需要学习一个参数集合，而不是对每一个输入位置都需要学习一个单独的参数。</p><p>通俗来讲，就是我们在运用卷积操作时，通常情况（因为也有一些特殊情况）下，是用一个卷积核 从左往右、从上到下  按照步长stride，去遍历完特征图的所有位置。</p><h2 id="2-3-等变表示"><a href="#2-3-等变表示" class="headerlink" title="2.3 等变表示"></a>2.3 等变表示</h2><p>参数共享使得神经网络层对<b>平移</b>具有等变性质。</p><p><b>所谓等变，即对其输入施加的变换也会同样反应在输出上。<br>即如果对输入进行轻微的平移，卷积运算得到的结果在忽略位置的时候，是一样的。</b><br>比如若图像上的一个特征本来位于图像左侧，现在将该区域平移到右侧，卷积网络依然能够检测到该特征，只不过探测到的位置会发生变化而已。更具体一点，如果一个图像上有一只小狗位于左侧，现在将小狗的区域平移到图像右侧去，卷积网络依然能够检测到这个区域的特征，并且判定该特征是一只小狗。</p><p>但是卷积对其他的一些变换并不是天然等变的，例如对于图像的放缩或者旋转变换，需要其他的一些机制来处理这些变换。</p><h2 id="2-4-常规卷积与其他卷积的对比"><a href="#2-4-常规卷积与其他卷积的对比" class="headerlink" title="2.4 常规卷积与其他卷积的对比"></a>2.4 常规卷积与其他卷积的对比</h2><h3 id="①常规卷积"><a href="#①常规卷积" class="headerlink" title="①常规卷积"></a>①常规卷积</h3><p>可以看作只有一个核，且被应用到各个位置。<br>相当于每个位置对应的卷积核的参数都是一样的，这就是前面说到的参数共享。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Deep_Learning/2_1.webp" width="70%">  </p><p><i>图中S为卷积核；x为特征值；每个卷积核接受2个位置的输入，</i></p><p>但是参数a，b一直在重复使用，相当于是同一个卷积核在从左往右遍历&lt;/i&gt;  </p><h3 id="②局部连接"><a href="#②局部连接" class="headerlink" title="②局部连接"></a>②局部连接</h3><p><i><font color="red">注意：有些地方提及的局部连接，是指的本篇博文中的第1点，稀疏交互，<br>本篇博文的名称规则是依据DeepLearning这本花书来的，这里讲的局部连接是指的非共享卷积。</font></i></p><p>局部连接有时候也称为非共享卷积，因为它和具有一个小核的离散卷积运算很像，<b>但并不横跨位置来共享参数，</b>也就是说，并不是一个卷积核 作用于所有的输入位置，而是<b>不同的输入位置所对应的卷积核 拥有不同的参数。</b>  </p><p><img src="https://teeyohuang.github.io/pic_bed/Deep_Learning/2_2.webp" width="70%">  </p><p><i>图中S为卷积核；x为特征值；每个卷积核都有各自的参数。</i>  </p><h3 id="③平铺卷积"><a href="#③平铺卷积" class="headerlink" title="③平铺卷积"></a>③平铺卷积</h3><p>是介于局部卷积 和 标准卷积之间，与局部卷积相同的地方在于，<b>相邻的单元具有不同的参数</b>，与其区别在于， 会有 <b>t</b> 个不同的卷积核循环使用，也就是说<b>相隔为 t 的卷积核，就会共享参数。</b>    </p><p><img src="https://teeyohuang.github.io/pic_bed/Deep_Learning/2_3.webp" width="70%">   </p><p><i>图中S为卷积核；x为特征值；相邻的卷积核都有各自的参数；</i></p><p>但每隔 t 个（图中 t=2）卷积核，参数就会重复使用。&lt;/i&gt;  </p><h3 id="④全连接层"><a href="#④全连接层" class="headerlink" title="④全连接层"></a>④全连接层</h3><p><img src="https://teeyohuang.github.io/pic_bed/Deep_Learning/2_4.webp" width="70%">  </p><p><i>图中S为卷积核；x为特征值；每条边都有各自的参数，但是它的感受野是全部的x特征，并不是局部的连接。</i></p><h2 id="2-5-池化操作"><a href="#2-5-池化操作" class="headerlink" title="2.5 池化操作"></a>2.5 池化操作</h2><p>池化函数使用<b>某一位置的相邻输出的总体统计特征</b>来代替网络在该位置的输出。比如最大池化、平均池化等等。</p><p>不管采用什么样的池化函数，当输入作出少量平移时，池化能够帮助输入的表示近似不变（invariant）。</p><p><b>对于平移的不变性</b>是指当我们对输入进行<b>少量平移</b>时，经过池化函数后的大多数输出并不会发生改变。</p><p>池化对于不同大小的输入具有重要作用。例如我们想对不同大小的图像进行分类时，分类层的输入必须是固定的大小，而这通常通过调整池化区域的偏置大小来实现，这样分类层总是能接收到相同数量的统计特征。以便于后面的全连接层进行处理</p><h2 id="2-6-卷积与池化作为一种无限强的先验"><a href="#2-6-卷积与池化作为一种无限强的先验" class="headerlink" title="2.6 卷积与池化作为一种无限强的先验"></a>2.6 卷积与池化作为一种无限强的先验</h2><p>可以把卷积的使用当作是对网络中一层的参数引入了一个<b>无限强的先验概率分布</b>。</p><p><b>这个先验说明了该层应该学得的函数只包含局部连接关系并且对平移具有等变性。<br>类似的，使用池化 也是一个无限强的先验：每一个单元都具有对少量平移的不变性</b>。</p><p>.</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1 权重初始化</title>
      <link href="/Deep-Learning/DL_01_weight_init.html"/>
      <url>/Deep-Learning/DL_01_weight_init.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1"> <p><a href="https://teeyohuang.github.io/Deep-Learning/DL_00_introduction.html">深度学习系列博文目录一览</a><br>———————————————— </p><h1 id="1-权重初始化"><a href="#1-权重初始化" class="headerlink" title="1 权重初始化"></a>1 权重初始化</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="1-1-为什么需要权重初始化"><a href="#1-1-为什么需要权重初始化" class="headerlink" title="1.1 为什么需要权重初始化"></a>1.1 为什么需要权重初始化</h2><ul><li><p>① 为了使神经网络在<b>合理的时间内收敛</b>.</p></li><li><p>② 为了尽量避免在深度神经网络的正向（前向）传播过程中层激活函数的<b>输出梯度出现爆炸或消失</b>。  </p></li></ul><h2 id="1-2-如何进行初始化"><a href="#1-2-如何进行初始化" class="headerlink" title="1.2 如何进行初始化"></a>1.2 如何进行初始化</h2><p>① <b>如果将每个隐藏单元的参数都初始化为0.</b></p><p>那么在正向传播时每个隐藏单元将<b>对于相同的输入会计算出相同的值</b>，并传递至输出层。在<b>反向传播中，每个隐藏单元的参数梯度值相等</b>。因此，这些参数在使用基于梯度的优化算法迭代后值依然相等。这样所有隐层的单元都是对称的了，很难学到什么有效的信息，之后的迭代也是如此。</p><p><b><font color="red">所以权重初始化不能将权重参数全部初始化为0，应打破这种对称性。</font></b></p><p>② <b>如果将参数都初始化为0周围极小的值</b></p><p><b>也不好</b>，比如 如果用 sigmoid 做激活函数，它在0周围是近似线性的，如果我们的参数都初始化为0附近，那么可能数据经过神经元之后，输出值也在0附近，这样<b>大部分都落在激活函数线性区，那么激活函数引入非线性的作用将被削减。</b></p><p>③ <b>如果参数都初始化为较大的值，很显然容易使得输出落入饱和区。</b></p><p><b><font color="red">所以合理的初始化时比较重要的，一般采用随机的初始化。</font></b></p><h2 id="1-3-常见的几种初始化方式"><a href="#1-3-常见的几种初始化方式" class="headerlink" title="1.3 常见的几种初始化方式"></a>1.3 常见的几种初始化方式</h2><p>① <b>均匀分布初始化：</b><br>将参数初始化为 <b><font color="red">均匀分布U(a,b) </font></b>上的随机值，pytorch的实现方案：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.uniform_(tensor, a=<span class="number">0</span>, b=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>② <b>高斯初始化：</b><br>将参数初始化为 <b><font color="red">高斯分布N(0,1)</font></b> 上的随机值，pytorch的实现方案：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.normal_(tensor, mean=<span class="number">0</span>, std=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>③ <b>常数初始化：</b><br>将参数初始化为一个 <b><font color="red">固定的常数val</font></b>, pytorch实现方案为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.constant_(tensor, val)</span><br></pre></td></tr></table></figure><p>上面三种初始化方法其实并不是十分理想的初始化方案，因为如果网络层数过深的话，依然会导致 <b>梯度爆炸</b> 或者 <b>梯度弥散</b>的 情况出现，<br>一般在使用中，可能就是神经网络中的某一两层可能会用到上述初始化方案，比如自己写的某几层,并不建议对所有的参数都使用上述初始化方案。<b>对于一些较为普及的模型，比如VGG、ResNet等，往往会加载官方提供的预训练模型的参数值，对大网络进行参数初始化</b>。 </p><h2 id="1-4-Xavier-初始化方案"><a href="#1-4-Xavier-初始化方案" class="headerlink" title="1.4 Xavier 初始化方案"></a>1.4 Xavier 初始化方案</h2><p>Xavier 初始化的基本思想是，若<b><font color="red">对于一层网络的输入和输出的方差尽量不变</font>，这样就可以避免输出趋向于0，从而避免梯度弥散情况。</b>   </p><p>参考资料：<br><a href="https://prateekvjoshi.com/2016/03/29/understanding-xavier-initialization-in-deep-neural-networks/">链接1</a><br><a href="http://proceedings.mlr.press/v9/glorot10a/glorot10a.pdf">链接2</a><br><a href="https://zhuanlan.zhihu.com/p/40175178">链接3</a>  </p><p>对于 $y=wx$ , 根据假设有：</p><script type="math/tex; mode=display">Var(Y) = Var(w_iX) = Var(w_i)*Var(X) + E^2(X)Var(w_i) + E^2(w_i)Var(X);</script><p>当 $X, w_i$ 都符合均值为 0 的正态分布时，其期望 $E(X), E(w_i)$ 均为0, 则上式可以简化为: </p><script type="math/tex; mode=display">Var(Y) = Var(w_i)*Var(X)</script><p>若该层共有$n_i$个神经元，则有：</p><script type="math/tex; mode=display">Var(Y) = n_i * Vaar(w_i) * Var(X)</script><p>要使得$Var(Y) = Var(X)$， 则需要 $n_i * Var(W_i) = 1$, 则 $ Var(w_i) = 1/n_i$;</p><p>同理，当反向传播时, $Var(w_i) = 1/n_{i+1}$  </p><p>因此，综合正向和反向传播考虑，最终取 $Var(w_i) = 1 / \frac{(n_i+n_{i+1})}{2} = 2/(n_i+n_{i+1})$ </p><p>如果使用<b><font color="red">均匀分布U(a,b) </font></b>为基础进行初始化，则：</p><script type="math/tex; mode=display">\begin{aligned} E &= (a+b)/2 = 0  \\\\Var &= (b-a)^2/12 = 2/(n_i+n_{i+1}) \end{aligned}</script><p>解得： $ a= -b = -\sqrt{6/(n_i+n_{i+1})} $  </p><p>即$w_i$ 初始化为 $ U(-\sqrt{\frac{6}{(n_i+n_{i+1})}}, \sqrt{\frac{6}{(n_i+n_{i+1})}}) $  </p><p><b>pytorch的实现方案①, 以均匀分布为基础</b>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.xavier_uniform_(tensor, gain=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>将参数初始化为均匀分布 $U(-\alpha, \alpha) $上的随机值，其中 $\alpha$ 取值为：$ \alpha = gain * \sqrt{\frac{6}{(fan_{in} + fan_{out})}}$  </p><ul><li>fan_in 指输入端神经元的个数， fan_out 指输出端神经元的个数，pytorch它会自己根据网络计算。</li><li>gain 是一个增益， 默认为1；</li></ul><p><b>pytorch的实现方案②, 以高斯分布为基础</b>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.xavier_normal_(tensor, gain=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>将参数初始化为高斯分布 $N(0, std^2)$上的随机值，而 std 的取值是：$std = gain * \sqrt{\frac{2}{(fan_{in} + fan_{out})}}$ </p><h2 id="1-5-Kaiming初始化"><a href="#1-5-Kaiming初始化" class="headerlink" title="1.5 Kaiming初始化"></a>1.5 Kaiming初始化</h2><p>Kaiming初始化基本思想是，当使用<code>ReLU</code>做为激活函数时，<code>Xavier</code>的效果不好。<br>原因在于：<b>当ReLU的输入小于0时，其输出为0，影响了输出的分布模式。也就是激活函数输出均值不为0，我们上面的推导中是有假设E(X)=0的。</b>  </p><p>因此Kaiming He初始化，在Xavier的基础上，<b>假设每层网络有一半的神经元被关闭，于是其分布的方差也会变小。所以提出一个新的假设，那就是前向传播中，如果采用Xiaver，方差会缩小为原来一半</b>。那么为了修正这个缩减，就使得参数初始化的范围比原来扩大一倍。  </p><p><b>pytorch的实现方案①, 以均匀分布为基础</b>：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.kaiming_uniform_(tensor, a=<span class="number">0</span>, mode=<span class="string">&#x27;fan_in&#x27;</span>, nonlinearity=<span class="string">&#x27;leaky_relu&#x27;</span>)</span><br></pre></td></tr></table></figure><p>将参数初始化为均匀分布 $U(-bound, bound)$上的随机值，其中 bound 取值为</p><p> $bound = \sqrt{\frac{6}{(1+\alpha^2)*fan_{in} }}$</p><ul><li>$\alpha$ : 该层后面一层的激活函数中负的斜率 (0 for ReLU by default)</li><li>使用 mode = fan_in 保持 weights 的方差在<b>前向传播</b>中不变；</li><li>使用 mode = fan_out 保持weights 的方差在<b>反向传播</b>中不变。  </li></ul><p><b>pytorch的实现方案②, 以高斯分布为基础</b>：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.kaiming_normal_(tensor, a=<span class="number">0</span>, mode=<span class="string">&#x27;fan_in&#x27;</span>, nonlinearity=<span class="string">&#x27;leaky_relu&#x27;</span>)</span><br></pre></td></tr></table></figure><p>将参数初始化为高斯分布 $N(0, std^2)$上的随机值，而std的取值是：$std = \sqrt{\frac{2}{(1+\alpha^2)*fan_{in} }}$  </p><h2 id="1-6-pytorch常见的-权重初始化-操作方法"><a href="#1-6-pytorch常见的-权重初始化-操作方法" class="headerlink" title="1.6 pytorch常见的 权重初始化 操作方法"></a>1.6 pytorch常见的 权重初始化 操作方法</h2><ul><li>方案一：直接对某层的data进行赋值</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.conv1.weight.data.normal_(<span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">self.conv1.bias.data.zero_()</span><br></pre></td></tr></table></figure><ul><li>方案二：调用nn初始化模块：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.normal_(self.conv1.weight, std=<span class="number">0.01</span>)</span><br><span class="line">torch.nn.init.constant_(self.conv1.bias, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>可搭配for循环使用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> self.children():</span><br><span class="line">    torch.nn.init.normal_(layer.weight, std=<span class="number">0.01</span>)</span><br><span class="line">    torch.nn.init.constant_(layer.bias, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>方案三： 定义一个自己的小函数</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_weight_init</span>(<span class="params">m</span>):</span><br><span class="line">    classname = m.__class__.__name__</span><br><span class="line">    <span class="keyword">if</span> classname.find(<span class="string">&#x27;Conv&#x27;</span>) != -<span class="number">1</span>:</span><br><span class="line">        torch.nn.init.xavier_(m.weight)</span><br><span class="line">        torch.nn.init.xavier_(m.bias)</span><br><span class="line">    <span class="keyword">if</span> classname.find(<span class="string">&#x27;Linear&#x27;</span>) != -<span class="number">1</span>:</span><br><span class="line">        torch.nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line">        torch.nn.init.constant_(m.bias, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#或者不读取下划线，直接看是不是某个类,这种方法相对来说更安全一些</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_weights_init</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, torch.nn.Conv2d):</span><br><span class="line">        torch.nn.xavier_(m.weight)</span><br><span class="line">        torch.nn.xavier_(m.bias)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, torch.nn.Linear):</span><br><span class="line">        torch.nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line">        torch.nn.init.constant_(m.bias, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 然后对某个Net应用：</span></span><br><span class="line">Net.apply(_weight_init)</span><br></pre></td></tr></table></figure><p><b><font color="red">以上三个均为示例，具体使用情况请依据自己的网络和具体的代码，请勿生搬硬套。</font></b>&lt;/font&gt;<br>.</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度学习导论</title>
      <link href="/Deep-Learning/DL_00_introduction.html"/>
      <url>/Deep-Learning/DL_00_introduction.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">    </p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="深度学习导论"><a href="#深度学习导论" class="headerlink" title="深度学习导论"></a>深度学习导论</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p>深度学习算是机器学习的一个子领域，其和机器学习的关系如下图所示:  </p><p><img src="https://teeyohuang.github.io/pic_bed/Deep_Learning/AI_ML_DL.webp" width="40%">   </p><p>本系列文章简要介绍深度学习的一些基础性、常见性知识，内容源于我早期所写<a href="https://blog.csdn.net/Teeyohuang/article/details/104120242">旧博客</a>，或许其中有所纰漏或者过时之处，权当参考而已。</p><h2 id="1-权重初始化"><a href="#1-权重初始化" class="headerlink" title="1 权重初始化"></a><a href="https://teeyohuang.github.io/Deep-Learning/DL_01_weight_init.html">1 权重初始化</a></h2><h2 id="2-卷积网络与池化操作"><a href="#2-卷积网络与池化操作" class="headerlink" title="2 卷积网络与池化操作"></a><a href="https://teeyohuang.github.io/Deep-Learning/DS_02_convolution_and_pool_layer.html">2 卷积网络与池化操作</a></h2><h2 id="3-规范化操作"><a href="#3-规范化操作" class="headerlink" title="3 规范化操作"></a><a href="https://teeyohuang.github.io/Deep-Learning/DS_22_array_exercises.html">3 规范化操作</a></h2><h2 id="4-激活操作"><a href="#4-激活操作" class="headerlink" title="4 激活操作"></a><a href="https://teeyohuang.github.io/Deep-Learning/DL_04_activation_func.html">4 激活操作</a></h2><h2 id="5-随机失活"><a href="#5-随机失活" class="headerlink" title="5 随机失活"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_23_array_double_pointer_exercises.html">5 随机失活</a></h2><h2 id="6-损失函数"><a href="#6-损失函数" class="headerlink" title="6 损失函数"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_23_array_double_pointer_exercises.html">6 损失函数</a></h2><h2 id="7-优化方法"><a href="#7-优化方法" class="headerlink" title="7 优化方法"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_23_array_double_pointer_exercises.html">7 优化方法</a></h2>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8-1 图</title>
      <link href="/Data-Structure/DS_81_graph.html"/>
      <url>/Data-Structure/DS_81_graph.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1"> <h1 id="8-1-图"><a href="#8-1-图" class="headerlink" title="8-1 图"></a>8-1 图</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>8.1.1</td><td><a href="#8.1.1">图的定义</a></td></tr><tr><td>8.1.2</td><td><a href="#8.1.2">图的分类</a></td></tr><tr><td>8.1.3</td><td><a href="#8.1.3">图的存储结构</a></td></tr><tr><td>8.1.4</td><td><a href="#8.1.4">邻接矩阵</a></td></tr></tbody></table></div><p><span id="8.1.1"></span> </p><h2 id="8-1-1-图的定义"><a href="#8-1-1-图的定义" class="headerlink" title="8.1.1 图的定义"></a>8.1.1 图的定义</h2><p>前面已经讲了 “一对一” 的线性存储结构、”一对多”的树结构 ， 而图结构（Graph）是一种  “<strong>多对多</strong>“ 的结构；  </p><p>图G由两个集合 V 和 E 组成， 记为 <strong>G=(V, E)</strong> ，  其中:<br> <strong>V</strong> 是 <strong>顶点（Vertex）</strong> 的<b>有穷 非空 集合</b>，而顶点通常就是<b>数据结点</b>；<br> <strong>E</strong> 是指<b>边</b> <strong>（Edge）</strong> 的<b>有穷集合</b>， 边指的是顶点之间的<b>连接关系</b>。 </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/8_1_1.webp" width="50%"> </p><p><span id="8.1.2"></span>  </p><h2 id="8-1-2-图的分类"><a href="#8-1-2-图的分类" class="headerlink" title="8.1.2 图的分类"></a>8.1.2 图的分类</h2><p>图结构可细分两种表现类型，<strong>无向图</strong> （Undirected Graph）和 <strong>有向图</strong>（Directed Graph）。<br>若图G的<strong>边没有表示方向</strong>，则就称为无向图，这样的边用<strong>圆括号</strong>表示 <strong>（Vi, Vj）</strong> ；<br>如果图G中的<strong>每条边都是有方向</strong>的，就称为有向图，边用<strong>尖括号</strong>表示 <strong>&lt; Vi, Vj&gt;</strong> ， 表示从 Vi 指向 Vj。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/8_1_2.webp" width="70%"> </p><div class="table-container"><table><thead><tr><th>术语</th><th>定义</th></tr></thead><tbody><tr><td><b>邻接点</b></td><td>对于无向图，每条边的两个端点互为邻接点；<br>对于有向图， 有向边的<strong>终点</strong>是 起点的 邻接点，<font color="red">反之不成立！</font><br> 比如 <strong>&lt; u, v&gt;</strong> 表示 u指向v， 所以<strong>v是u的邻接点， 但 u不是v的邻接点!</strong></td></tr><tr><td><b>弧头和弧尾</b></td><td><strong>有向边</strong>也被称为 <strong>弧</strong> ，无箭头一端即<b>“起点”</b>称”<strong>弧尾</strong>“，<br>有箭头一端, 即<b>“端点”</b>或”<strong>弧头</strong>“。</td></tr><tr><td><b>度</b></td><td>常用<b>D(V)</b>来表示，在无向图中，顶点的度 就是 以该顶点为端点的边的条数；<br>在有向图中，指向该顶点的弧的数目 称为 <b>入度ID(V)</b>，  从该顶点出发的 弧 的数目 称为 <b>出度OD(V)</b>。<br>有向图的顶点的度是二者之和 D(V) = ID(V) + OD(V).<br>重要结论： <strong>无论是有向图还是无向图，顶点数n、边数e、和度数之间有关系：所有顶点的度数之和  等于 边数的2倍</strong>。</td></tr><tr><td><b>路径和回路</b></td><td>从一个顶点到另一顶点途径的所有顶点组成的序列（包含这两个顶点），称为一条路径。<br>如果路径中第一个顶点和最后一个顶点相同，则此路径称为”<strong>回路</strong>“（或”<strong>环</strong>“）。<br>若路径 / 回路 中各顶点都不重复，此路径又被称为”简单路径” / “简单回路”</td></tr><tr><td><b>权和网</b></td><td>若图中的每条边（或弧）被赋予一个实数来表示一定的含义，这种与边（或弧）相匹配的实数被称为”权”，而带权的图通常称为网。</td></tr></tbody></table></div><h3 id="8-1-2-1-细分种类"><a href="#8-1-2-1-细分种类" class="headerlink" title="8.1.2.1 细分种类"></a>8.1.2.1 细分种类</h3><p>图又可分为完全图，连通图、稀疏图和稠密图；</p><div class="table-container"><table><thead><tr><th>名称</th><th>定义</th></tr></thead><tbody><tr><td><b>完全图</b></td><td>若图中各个顶点都与除自身外的其他顶点有关系，这样的无向图称为完全图。同时，满足此条件的有向图则称为有向完全图。<br><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/8_1_2_1_n.webp" width="80%"></td></tr><tr><td><b>稀疏图和稠密图</b></td><td>这两种图是相对存在的，即如果图中具有很少的边（或弧），此图就称为”稀疏图”；反之，则称此图为”稠密图”。<br>稀疏和稠密的判断条件是：e &lt; nlogn，其中 e 表示图中边（或弧）的数量，n 表示图中顶点的数量。如果式子成立，则为稀疏图；反之为稠密图。<br><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/8_1_2_2.webp" width="100%"></td></tr><tr><td><b>连通图</b></td><td>在无向图中，若每一对顶点 u和v之间都能找到一条<strong>路径</strong>，则此图称为 连通图；<br>若无向图不是连通图，但图中存储某个子图符合连通图的性质，则称该子图为连通分量。（这里的子图指的是图中”最大”的连通子图）<br>在有向图中，若每一对顶点u和v之间都存在 u到v 以及 从 v到u的<strong>路径</strong>，则成为强连通图。<br>若有向图本身不是<b>强</b>连通图，但其包含的最大连通子图具有强连通图的性质，则称该子图为强连通分量。<br><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/8_1_2_3.webp" width="100%"></td></tr><tr><td><b>加权图</b></td><td>图中的边带有权值：<br><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/8_1_2_4.webp" width="80%"></td></tr></tbody></table></div><p><span id="8.1.3"></span>  </p><h2 id="8-1-3-图的存储结构"><a href="#8-1-3-图的存储结构" class="headerlink" title="8.1.3 图的存储结构"></a>8.1.3 图的存储结构</h2><h3 id="8-1-3-1-邻接矩阵"><a href="#8-1-3-1-邻接矩阵" class="headerlink" title="8.1.3.1 邻接矩阵"></a>8.1.3.1 邻接矩阵</h3><p>图结构的元素之间虽然具有“多对多”的关系，但是同样可以采用<strong>顺序存储</strong>，即使用数组有效地存储图。  </p><p><b>集合V</b>中所有的顶点可以利用一个<b>一维</b>数组存储；<br>而<b>集合E</b>中所有的边可以用一个<b>二维数组</b>来存储，此二维数组就称为 <strong>邻接矩阵</strong>！<br>如下图所示, 点与点之间如果有边存在, 那矩阵中对应位置的值就为 1；反之为 0.  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/8_1_3_1.webp" width="80%"> |</p><p>设 $G=(V,E)$ 是有 n 个（n&gt;=1）顶点的 ==<strong>有向图</strong>== ，则G的邻接矩阵是具有如下性质的 n x n 矩阵： </p><script type="math/tex; mode=display">A[ i, j ] = \begin{cases} 1 & <Vi, Vj> \quad \in E \\0 & <Vi, Vj> \quad \notin E\end{cases}</script><p>设 $G=(V,E)$ 是有n个（n&gt;=1）顶点的 ==<strong>无向图</strong>==，则G的邻接矩阵是具有如下性质的 n x n 矩阵：  </p><script type="math/tex; mode=display">A[ i, j ] = A[j, i] =\begin{cases} 1 & (Vi, Vj) \quad \in E \\0 & (Vi, Vj) \quad \notin E\end{cases}</script><ul><li>对于无向图，邻接矩阵第 i 行（或第 i 列）的元素之和是 顶点 $V_i$ 的度；</li><li>对于有向图，邻接矩阵第 i 行 元素之和为 顶点Vi的<strong>出度</strong>， 邻接矩阵第 i 列 的 元素之和 为顶点 $V_i$ 的<strong>入度</strong>。<br>比如上图的有向图的邻接矩阵中，第3行的和为1：表示顶点3的出度为1；第3列的和为2：表示顶点3的入度为2.</li><li>对于带权图，也就是 <strong>网</strong> 来说， 只需要把上面的 等于 1 的情况改为 权重 $W_{ij}$， 把等于 0 的情况 改为 $ \infty $。  </li><li>容易得出，无向图的邻接矩阵是按矩阵主对角线对称的。</li></ul><h3 id="8-1-3-2-邻接表"><a href="#8-1-3-2-邻接表" class="headerlink" title="8.1.3.2 邻接表"></a>8.1.3.2 邻接表</h3><p>邻接表既适用于存储无向图，也适用于存储有向图。邻接表存储图的实现方式是，给图中的每个顶点独自建立一个链表，第 i 个单链表中的结点包含顶点 i 的所有邻接点。  </p><p>为了便于管理这些链表，通常会将所有链表的头结点存储到数组中（也可以用链表存储）。<br>也正因为各个链表的头结点存储的是各个顶点，因此各链表在存储邻接点数据时，仅需存储该邻接顶点位于数组中的位置下标即可，不用存储完整的顶点数据，降低了空间复杂度；同时知道点的下标，就能以O(1)的时间复杂度从数组中获得顶点数据。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/8_1_3_2.webp" width="80%"> </p><p>假设该图是 G(n, m) 。这里 G 是图， n 是结点数， m 是图 G 中存在的边的总数 。<br>在无向图的情况下，链表的结点总数将为 <strong>2m</strong> （因为连接是双向的）；使用的总空间为 O(n + 2m)。<br>在有向图的情况下，使用的总空间为 O(n + m)。  </p><p><b><br>对于稀疏图，推荐使用邻接表，因为稀疏矩阵会浪费大量内存；<br>对于稠密图，可以使用邻接矩阵。</b></p><p><span id="8.1.4"></span></p><h2 id="8-1-4-图的遍历"><a href="#8-1-4-图的遍历" class="headerlink" title="8.1.4 图的遍历"></a>8.1.4 图的遍历</h2><p>图的遍历可以分为<b>深度优先遍历</b>和<b>广度优先遍历</b>，和树的深度优先遍历和广度优先遍历十分相似。</p><p>我在 BiliBili 上看到一个讲解视频，讲得十分详尽，所以这里直接引用该视频的链接，已获得原视频up主：<a href="https://space.bilibili.com/627875426">码农论坛</a> 的授权，同时原视频地址也备注在下方。</p><h3 id="8-1-4-1-图的深度优先遍历"><a href="#8-1-4-1-图的深度优先遍历" class="headerlink" title="8.1.4.1 图的深度优先遍历"></a>8.1.4.1 图的深度优先遍历</h3><p>原视频地址：<a href="https://www.bilibili.com/video/BV1JU4y1p7Ue?p=2">link</a></p><iframe src="https://player.bilibili.com/player.html?aid=672031208&bvid=BV1JU4y1p7Ue&cid=310040941&page=2&autoplay=0" scrolling="no" width="800px" height="500px" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>  <p>下面用一个例子演示深度优先遍历的 code，假设有图结构如下：</p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/8_1_4_1.webp" width="40%"> </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;上图中的graph用列表表示如下</span></span><br><span class="line"><span class="string">索引代表结点, </span></span><br><span class="line"><span class="string">列表中的子列表代表当前结点的邻接点&#x27;&#x27;&#x27;</span></span><br><span class="line">graph = [</span><br><span class="line">    [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>],</span><br><span class="line">    [<span class="number">2</span>],</span><br><span class="line">    [<span class="number">2</span>,<span class="number">7</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">6</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">4</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 深度优先遍历的code如下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="comment"># 终止条件：当前结点已经被访问过</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">in</span> visited:</span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将当前结点加入结果中</span></span><br><span class="line">    res.append(node)</span><br><span class="line">    <span class="comment"># 同时记录当前结点已经被访问的状态</span></span><br><span class="line">    visited[node] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历当前结点的邻接点</span></span><br><span class="line">    <span class="keyword">for</span> neighbour <span class="keyword">in</span> graph[node]:</span><br><span class="line">        <span class="comment"># 假设这里 graph[node] 存储的是 node 的邻接点</span></span><br><span class="line">        <span class="comment"># 具体的题目中这里的写法可能稍有不同</span></span><br><span class="line">        DFS(neighbour)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">visited = &#123;&#125; <span class="comment"># 记录哪些结点已经被访问的哈希表</span></span><br><span class="line">res = [] <span class="comment"># 存储遍历结果的list</span></span><br><span class="line">DFS(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实<b>图的深度优先遍历，和树的深度优先遍历中的【先序遍历】是很相似的</b>，他们的核心流程基本一致；用伪代码表示如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="comment"># step 1. 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> End_Condition:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step 2. 访问当前结点</span></span><br><span class="line">    visit(node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 3. 利用递归操作，访问当前结点的相关结点</span></span><br><span class="line">    DFS(node_relations)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><p>这里再贴上二叉树的先序遍历的code用于对照理解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 对每棵子树的结构，都先访问根结点的值</span></span><br><span class="line">    res.append(root.val)</span><br><span class="line">    <span class="comment"># 然后递归地分别处理左右子结点</span></span><br><span class="line">    preorder(root.left)</span><br><span class="line">    preorder(root.right)</span><br><span class="line"></span><br><span class="line">res =[]</span><br><span class="line">preorder(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th></th><th>二叉树先序遍历</th><th>图的深度优先遍历</th></tr></thead><tbody><tr><td>step 1</td><td>终止条件为node为空</td><td>当前结点已经被遍历</td></tr><tr><td>step 2</td><td>访问当前结点</td><td>访问当前结点</td></tr><tr><td>step 3</td><td>利用递归, 访问当前结点的子结点</td><td>利用递归，访问当前结点的邻接点</td></tr></tbody></table></div><p><b>需要注意的有几点</b></p><ul><li><p>树的遍历一定是从root结点开始，所以用同一种方法遍历得到的list是唯一确定的；<br>而图的遍历，起始位置不确定，通常可以从任何一个点开始遍历，所以即便用同一种方法，如果选取不同的起始点，得到的遍历结果的顺序也不一样；</p></li><li><p>上面的例子只是比较简单的情况，它是一个连通图；<br>还有非连通的情况，比如两棵不同的树就是一个非连通图，对于每一个连通分量的遍历，依然可以使用上面的code示范的方法，只不过对于不同的连通分量的切换，还需要额外处理，可以自己思考一下，此处不再赘述。</p></li></ul><h3 id="8-1-4-2-图的广度优先遍历"><a href="#8-1-4-2-图的广度优先遍历" class="headerlink" title="8.1.4.2 图的广度优先遍历"></a>8.1.4.2 图的广度优先遍历</h3><p>原视频地址：<a href="https://www.bilibili.com/video/BV1JU4y1p7Ue?p=1">link</a></p><iframe src="https://player.bilibili.com/player.html?aid=672031208&bvid=BV1JU4y1p7Ue&cid=310040937&page=1&autoplay=0" scrolling="no" width="800px" height="500px" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>  <p>下面用一个例子演示深度优先遍历的 code，假设有图结构如下：</p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/8_1_4_1.webp" width="40%"> </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>(<span class="params">graph, node</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(graph) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将初始结点先入队</span></span><br><span class="line">    q, res = [node], []</span><br><span class="line">    <span class="comment"># 凡是入队的结点, 就要标记为访问过</span></span><br><span class="line">    visited = &#123;node:<span class="literal">True</span>&#125;</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        layer = []</span><br><span class="line">        <span class="comment"># 这个 n 其实就是在求要遍历的那一层的宽度</span></span><br><span class="line">        n = <span class="built_in">len</span>(q)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            node = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 队列中弹出的元素直接放入该层的list中</span></span><br><span class="line">            layer.append(node)</span><br><span class="line">            <span class="comment"># 对该结点的邻接点进行入队操作</span></span><br><span class="line">            <span class="keyword">for</span> neighbour <span class="keyword">in</span> graph[node]: </span><br><span class="line">                <span class="comment"># 要判断邻接点是否已经被访问过</span></span><br><span class="line">                <span class="keyword">if</span> neighbour <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="comment"># 没被访问过的邻接点： 入队 + 标记状态</span></span><br><span class="line">                    q.append(neighbour)</span><br><span class="line">                    visited[neighbour] = <span class="literal">True</span></span><br><span class="line">        res.append(layer)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(BFS(graph, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(BFS(graph, <span class="number">9</span>))</span><br></pre></td></tr></table></figure><p>关于层次遍历，<b>其实就是看结点距离起始点的路径有几段</b>，<br>以起始点为9 为例：<br>第一层就是 [9]；<br>第二层就是距离9的路径为1段的 [4]<br>第三层就是距离9的路径为2段的 [1, 3, 8]<br>第四层就是距离9的路径为3段的 [0, 2, 7]<br>第五层就是距离9的路径为4段的 [5, 6]</p><p>图的知识点其实还有很多，但是作为基础的算法结构来讲，了解到图的遍历就基本可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7-2 树相关的题目</title>
      <link href="/Data-Structure/DS_72_tree_exercises.html"/>
      <url>/Data-Structure/DS_72_tree_exercises.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="7-2-树相关的题目"><a href="#7-2-树相关的题目" class="headerlink" title="7-2 树相关的题目"></a>7-2 树相关的题目</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p><b>版权声明：以下题目均来自 <a href="https://leetcode.cn">LeetCode</a>， 仅仅提供跳转到力扣官网的链接，不在本页面出现题目内容，本文章内容禁止商业用途。</b></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>7.2.1</td><td><a href="#7.2.1">二叉树的遍历</a></td></tr><tr><td>7.2.2</td><td><a href="#7.2.2">二叉树反序列化（还原）</a></td></tr><tr><td>7.2.3</td><td><a href="#7.2.3">路径问题</a></td></tr><tr><td>7.2.4</td><td><a href="#7.2.4">验证各种树</a></td></tr><tr><td>7.2.5</td><td><a href="#7.2.5">二叉查找树</a></td></tr><tr><td>7.2.6</td><td><a href="#7.2.6">前缀树</a></td></tr></tbody></table></div><p><span id="7.2.1"></span></p><h2 id="7-2-1-二叉树的遍历"><a href="#7-2-1-二叉树的遍历" class="headerlink" title="7.2.1 二叉树的遍历"></a>7.2.1 二叉树的遍历</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">LeetCode 144.二叉树的前序遍历</a></td><td><a href="#7.2.1.1.1">题解7.2.1.1.1</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">LeetCode 94.二叉树的中序遍历</a></td><td><a href="#7.2.1.1.2">题解7.2.1.1.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">LeetCode 145.二叉树的后序遍历</a></td><td><a href="#7.2.1.1.3">题解7.2.1.1.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">LeetCode 102.二叉树的层序遍历</a></td><td><a href="#7.2.1.2.1">题解7.2.1.2.1</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">LeetCode 107.二叉树的层序遍历 II</a></td><td><a href="#7.2.1.2.2">题解7.2.1.2.2</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">LeetCode 103.二叉树的锯齿形层序遍历</a></td><td><a href="#7.2.1.2.3">题解7.2.1.2.3</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">LeetCode 104.二叉树的最大深度</a></td><td><a href="#7.2.1.3">题解7.2.1.3</a></td></tr><tr><td>⑧</td><td><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">LeetCode 111.二叉树的最小深度</a></td><td><a href="#7.2.1.4">题解7.2.1.4</a></td></tr><tr><td>⑨</td><td><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">LeetCode 662.二叉树最大宽度</a></td><td><a href="#7.2.1.5">题解7.2.1.5</a></td></tr><tr><td>⑩</td><td><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">LeetCode 199.二叉树的右视图</a></td><td><a href="#7.2.1.6">题解7.2.1.6</a></td></tr><tr><td>⑪</td><td><a href="https://leetcode.cn/problems/symmetric-tree/">LeetCode 101.对称二叉树</a></td><td><a href="#7.2.1.7">题解7.2.1.7</a></td></tr><tr><td>⑫</td><td><a href="https://leetcode.cn/problems/invert-binary-tree/">LeetCode 226.翻转二叉树</a></td><td><a href="#7.2.1.8">题解7.2.1.8</a></td></tr><tr><td>⑬</td><td><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">LeetCode 116.填充每个节点的下一个右侧节点指针</a></td><td><a href="#7.2.1.9">题解7.2.1.9</a></td></tr><tr><td>⑭</td><td><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">LeetCode 117.填充每个节点的下一个右侧节点指针 II</a></td><td><a href="#7.2.1.10">题解7.2.1.10</a></td></tr><tr><td>⑮</td><td><a href="https://leetcode.cn/problems/same-tree/">LeetCode 100.相同的树</a></td><td><a href="#7.2.1.11">题解7.2.1.11</a></td></tr></tbody></table></div><h3 id="7-2-1-1-深度优先遍历-DFS"><a href="#7-2-1-1-深度优先遍历-DFS" class="headerlink" title="7.2.1.1 深度优先遍历-DFS"></a>7.2.1.1 深度优先遍历-DFS</h3><p><span id="7.2.1.1.1"></span>  </p><h4 id="7-2-1-1-1-二叉树的前序遍历"><a href="#7-2-1-1-1-二叉树的前序遍历" class="headerlink" title="7.2.1.1.1 二叉树的前序遍历"></a>7.2.1.1.1 二叉树的前序遍历</h4><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">LeetCode 144.二叉树的前序遍历</a> | |<a href="#7.2.1">返回目录7.2.1</a></p><p>思路：前序遍历就是根结点要先遍历到。中-左-右 的顺序    </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.递归方法&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 根结点在最开始处理</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            preorder(root.left)</span><br><span class="line">            preorder(root.right)</span><br><span class="line"></span><br><span class="line">        res =[]</span><br><span class="line">        preorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归方法之一&#x27;&#x27;&#x27;</span></span><br><span class="line">        cur = root</span><br><span class="line">        s, res = [], []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> <span class="built_in">len</span>(s)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 先遍历根结点及其左子树上的每一个子树的根结点</span></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="comment"># 左子树部分遍历完之后就可以遍历右边的子树部分了</span></span><br><span class="line">            cur = s.pop()</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归方法之二&#x27;&#x27;&#x27;</span></span><br><span class="line">        s, res = [], []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            s.append(root)</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span>:</span><br><span class="line">                cur = s.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                <span class="comment"># 注意这里是先将右子结点入栈，再将左子结点入栈</span></span><br><span class="line">                <span class="comment"># 这样出栈的时候，就是左子结点先出栈，右子结点后出栈</span></span><br><span class="line">                <span class="keyword">if</span> cur.right :</span><br><span class="line">                    s.append(cur.right)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    s.append(cur.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="7.2.1.1.2"></span>  </p><h4 id="7-2-1-1-2-二叉树的中序遍历"><a href="#7-2-1-1-2-二叉树的中序遍历" class="headerlink" title="7.2.1.1.2 二叉树的中序遍历"></a>7.2.1.1.2 二叉树的中序遍历</h4><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">LeetCode 94.二叉树的中序遍历</a>| | <a href="#7.2.1">返回目录7.2.1</a></p><p>思路：前序遍历就是左子结点要先遍历到。左-中-右 的顺序    </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.递归方法&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            inorder(root.left)</span><br><span class="line">            <span class="comment"># 根结点在中间处理</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            inorder(root.right)</span><br><span class="line"></span><br><span class="line">        res =[]</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归方法&#x27;&#x27;&#x27;</span></span><br><span class="line">        cur = root</span><br><span class="line">        s, res = [], []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> <span class="built_in">len</span>(s)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="comment"># 先将结点入栈而不是读取值</span></span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.left </span><br><span class="line">            </span><br><span class="line">            cur = s.pop()</span><br><span class="line">            <span class="comment"># 弹出的结点再读取值</span></span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="7.2.1.1.3"></span>  </p><h4 id="7-2-1-1-3-二叉树的后序遍历"><a href="#7-2-1-1-3-二叉树的后序遍历" class="headerlink" title="7.2.1.1.3 二叉树的后序遍历"></a>7.2.1.1.3 二叉树的后序遍历</h4><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">LeetCode 145.二叉树的后序遍历</a> | |<a href="#7.2.1">返回目录7.2.1</a></p><p>思路：后序就是按照 左-右-中 的顺序  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.递归法&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">posorder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            posorder(root.left)</span><br><span class="line">            posorder(root.right)</span><br><span class="line">            <span class="comment"># 根结点排在最后处理</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        posorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归方法之一&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;按照先序遍历，只不过是右结点先于左结点，构造成：中-右-左，最后逆序：</span></span><br><span class="line"><span class="string">        得到 左-右-中 的顺序&#x27;&#x27;&#x27;</span></span><br><span class="line">        cur = root</span><br><span class="line">        s, res = [], []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> <span class="built_in">len</span>(s)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                s.append(cur)</span><br><span class="line">                <span class="comment"># 这里就是先处理左右当中的右子结点</span></span><br><span class="line">                cur = cur.right</span><br><span class="line">            cur = s.pop()</span><br><span class="line">            <span class="comment"># 后处理左结点</span></span><br><span class="line">            cur = cur.left</span><br><span class="line">        <span class="comment"># 此时res是 中-右-左 的顺序，再逆序即可</span></span><br><span class="line">        res.reverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归方法之二&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;按照先序遍历，只不过是右结点先于左结点，构造成：中-右-左，最后逆序：</span></span><br><span class="line"><span class="string">        得到 左-右-中 的顺序&#x27;&#x27;&#x27;</span></span><br><span class="line">        s, res = [], []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            s.append(root)</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span>:</span><br><span class="line">                cur = s.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                <span class="comment"># 注意这里是先将左子结点入栈，再将右子结点入栈</span></span><br><span class="line">                <span class="comment"># 这样出栈的时候，就是右子结点先出栈，左子结点后出栈</span></span><br><span class="line">                <span class="keyword">if</span> cur.left :</span><br><span class="line">                    s.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    s.append(cur.right)</span><br><span class="line">        res.reverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归方法之三&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;不采用逆序的手段，直接按照需要的顺序求结果&#x27;&#x27;&#x27;</span></span><br><span class="line">        pre, cur = <span class="literal">None</span>, root</span><br><span class="line">        s, res = [], []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> <span class="built_in">len</span>(s)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            </span><br><span class="line">            cur = s.pop()</span><br><span class="line">            <span class="comment"># 如果当前结点没有右子结点，或者其右子结点上一轮已经处理过</span></span><br><span class="line">            <span class="comment"># 就说明应该处理当前结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.right <span class="keyword">or</span> cur.right == pre:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 如果不是，说明存在右子结点，且尚未处理过右子结点</span></span><br><span class="line">            <span class="comment"># 就先将当前结点放回栈，先处理其右子结点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="7-2-1-2-广度优先遍历-BFS"><a href="#7-2-1-2-广度优先遍历-BFS" class="headerlink" title="7.2.1.2 广度优先遍历-BFS"></a>7.2.1.2 广度优先遍历-BFS</h3><p><span id="7.2.1.2.1"></span>  </p><h4 id="7-2-1-2-1-二叉树的层序遍历"><a href="#7-2-1-2-1-二叉树的层序遍历" class="headerlink" title="7.2.1.2.1 二叉树的层序遍历"></a>7.2.1.2.1 二叉树的层序遍历</h4><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">LeetCode 102.二叉树的层序遍历</a> | | <a href="#7.2.1">返回目录7.2.1</a></p><p>思路：一层一层的遍历。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># q作为临时队列</span></span><br><span class="line">        q = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            layer = []</span><br><span class="line">            <span class="comment"># N 实际是当前要遍历的层的结点个数</span></span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="comment"># 模拟队列的处理方法，即先进的先出，</span></span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                layer.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">            res.append(layer)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="7.2.1.2.2"></span>  </p><h4 id="7-2-1-2-2-二叉树的层序遍历-II"><a href="#7-2-1-2-2-二叉树的层序遍历-II" class="headerlink" title="7.2.1.2.2 二叉树的层序遍历 II"></a>7.2.1.2.2 二叉树的层序遍历 II</h4><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">LeetCode 107.二叉树的层序遍历 II</a>| | <a href="#7.2.1">返回目录7.2.1</a></p><p>思路：普通的层序遍历再逆序。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrderBottom</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># q作为临时队列</span></span><br><span class="line">        q = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            layer = []</span><br><span class="line">            <span class="comment"># N 实际是当前要遍历的层的结点个数</span></span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="comment"># 模拟队列的处理方法，即先进的先出，</span></span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                layer.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">            res.append(layer)</span><br><span class="line">        res.reverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="7.2.1.2.3"></span>  </p><h4 id="7-2-1-2-3-二叉树的锯齿形层序遍历"><a href="#7-2-1-2-3-二叉树的锯齿形层序遍历" class="headerlink" title="7.2.1.2.3 二叉树的锯齿形层序遍历"></a>7.2.1.2.3 二叉树的锯齿形层序遍历</h4><p><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">LeetCode 103.二叉树的锯齿形层序遍历</a> | | <a href="#7.2.1">返回目录7.2.1</a></p><p>思路：普通的层序遍历,对于特定的层进行逆序。这个逆序操作可以在遍历完一层之后再做，也可以在遍历的时候就调整方向，手法是多种的。题解中选择遍历完一层之后再对整层做逆序，操作起来简单一些。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">zigzagLevelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># q作为临时队列</span></span><br><span class="line">        q = [root]</span><br><span class="line">        res = []</span><br><span class="line">        L = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            layer = []</span><br><span class="line">            <span class="comment"># N 实际是当前要遍历的层的结点个数</span></span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="comment"># 模拟队列的处理方法，即先进的先出，</span></span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                layer.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> L % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                res.append(layer)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(layer[::-<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 处理完当前层之后，层索引加一</span></span><br><span class="line">            L += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="7.2.1.3"></span>  </p><h3 id="7-2-1-3-二叉树的最大深度"><a href="#7-2-1-3-二叉树的最大深度" class="headerlink" title="7.2.1.3 二叉树的最大深度"></a>7.2.1.3 二叉树的最大深度</h3><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">LeetCode 104.二叉树的最大深度</a> | | <a href="#7.2.1">返回目录7.2.1</a></p><p>思路1：说白了就是求多少层，就可以考虑使用层序遍历的解法。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        q = [root]</span><br><span class="line">        h = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            n = <span class="built_in">len</span>(q)</span><br><span class="line">            h+=<span class="number">1</span> <span class="comment"># 思路很简单，每有一层，就给深度加上1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure><p>思路2：如果按照有多深这个角度来理解，使用深度优先遍历也是可以的。采用递归的方法，写起来也简单。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            left_height = self.maxDepth(root.left) </span><br><span class="line">            right_height = self.maxDepth(root.right) </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left_height, right_height) + <span class="number">1</span> </span><br></pre></td></tr></table></figure><p><span id="7.2.1.4"></span>  </p><h3 id="7-2-1-4-二叉树的最小深度"><a href="#7-2-1-4-二叉树的最小深度" class="headerlink" title="7.2.1.4 二叉树的最小深度"></a>7.2.1.4 二叉树的最小深度</h3><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">LeetCode 111.二叉树的最小深度</a>| | <a href="#7.2.1">返回目录7.2.1</a></p><p>思路1：说白了还是在求层数，就可以考虑使用层序遍历的解法，只不过不一定要遍历到最后一层才停止。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        q, h = [root], <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q :</span><br><span class="line">            n = <span class="built_in">len</span>(q)</span><br><span class="line">            h+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 知道终点条件就行，达到此条件，直接可以返回了，不用继续遍历下一层了</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">not</span> cur.left) <span class="keyword">and</span> (<span class="keyword">not</span> cur.right):</span><br><span class="line">                    <span class="keyword">return</span> h</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure><p>思路2：依然可以使用深度优先遍历的方法。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 递归的结束条件依然是判断当前结点是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        min_depth =  <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> root.left: <span class="comment"># 如果左子结点存在, 才去算其深度</span></span><br><span class="line">            min_depth = <span class="built_in">min</span>(self.minDepth(root.left), min_depth)</span><br><span class="line">        <span class="keyword">if</span> root.right: <span class="comment"># 如果右子结点存在, 才去算其深度</span></span><br><span class="line">            min_depth = <span class="built_in">min</span>(self.minDepth(root.right), min_depth)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="7.2.1.5"></span>  </p><h3 id="7-2-1-5-二叉树最大宽度"><a href="#7-2-1-5-二叉树最大宽度" class="headerlink" title="7.2.1.5 二叉树最大宽度"></a>7.2.1.5 二叉树最大宽度</h3><p><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">LeetCode 662.二叉树最大宽度</a> | | <a href="#7.2.1">返回目录7.2.1</a></p><p>思路1：比较直观的方法是求出每一层的宽度，然后求出最大值，这就可以考虑层次优先遍历。<br>求每一层的宽度时，因其实就是求最右侧的点到最左侧的点，的宽度是多少，<br>然而，此时要求将中间的null结点也算作有效的点，干脆就对结点进行编号。<br>编号方式为，假设其在对应的一个满二叉树中的位置索引编号！   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">widthOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        width = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> width </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化根节点和其序号      </span></span><br><span class="line">        q = [(root,<span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="comment"># 计算该层的最大宽度</span></span><br><span class="line">            width_of_layer = q[-<span class="number">1</span>][<span class="number">1</span>] - q[<span class="number">0</span>][<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 然后更新width</span></span><br><span class="line">            width = <span class="built_in">max</span>(width, width_of_layer)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur, index = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 对比原始的层序遍历，只是将入队的元素改为了(node, index)而已</span></span><br><span class="line">                <span class="comment"># index是对应满二叉树的位置索引</span></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append((cur.left, <span class="number">2</span>*index+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append((cur.right, <span class="number">2</span>*index+<span class="number">2</span>))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> width</span><br></pre></td></tr></table></figure><p>思路2：也可以使用递归方法采取深度优先的思路，直观上没有层次遍历方法那么容易理解。<br>说白了也是利用递归的时候，每次深入结点，就改变index，同时对每层设置了一个起始节点的index，固定在那里，便于计算宽度。直观上不太好理解   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">widthOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 这个是存储每一层的最左侧结点的index的哈希表</span></span><br><span class="line">        layerMin = &#123;&#125;</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode], depth: <span class="built_in">int</span>, index: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="comment"># 递归结束条件为当前结点为空</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> depth <span class="keyword">not</span> <span class="keyword">in</span> layerMin:</span><br><span class="line">                layerMin[depth] = index  <span class="comment"># 每一层最先访问到的节点会是最左边的节点，即每一层编号的最小值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(index - layerMin[depth] + <span class="number">1</span>,</span><br><span class="line">                       dfs(node.left, depth + <span class="number">1</span>, index * <span class="number">2</span> + <span class="number">1</span>),</span><br><span class="line">                       dfs(node.right, depth + <span class="number">1</span>, index * <span class="number">2</span> + <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><span id="7.2.1.6"></span>  </p><h3 id="7-2-1-6-二叉树的右视图"><a href="#7-2-1-6-二叉树的右视图" class="headerlink" title="7.2.1.6 二叉树的右视图"></a>7.2.1.6 二叉树的右视图</h3><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">LeetCode 199.二叉树的右视图</a> | | <a href="#7.2.1">返回目录7.2.1</a></p><p>思路1：采用层序遍历，每一层只取最右的结点。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.广度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        q=[root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(q) &gt; <span class="number">0</span>:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> i == N-<span class="number">1</span>:</span><br><span class="line">                    res.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>思路2：采用深度优先遍历，按照先序遍历的基础code进行修改，但是要先遍历右子树上的结点；<br>并且，我们记住已经遍历过的深度，对于每一深度（层）而言，遍历到这一深度时的第一个结点一定是最右侧的结点。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.深度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每一个元素由[结点, 深度]这样的二元数组构成</span></span><br><span class="line">        cur = [root,<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 用一个哈希表存储已经遍历过的层的序号</span></span><br><span class="line">        hash_d = &#123;&#125;</span><br><span class="line">        s, res = [], []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur[<span class="number">0</span>] <span class="keyword">or</span> s:</span><br><span class="line">            <span class="keyword">while</span> cur[<span class="number">0</span>]:</span><br><span class="line">                cur_node, cur_d = cur[<span class="number">0</span>], cur[<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 如果当前深度还没有遍历，那么该层遇到的第一个结点就一定是最右侧的结点</span></span><br><span class="line">                <span class="keyword">if</span> cur_d <span class="keyword">not</span> <span class="keyword">in</span> hash_d:</span><br><span class="line">                    res.append(cur_node.val)</span><br><span class="line">                    hash_d[cur_d] = cur_node</span><br><span class="line"></span><br><span class="line">                s.append(cur)</span><br><span class="line">                <span class="comment"># 记得往右子树的方向更新cur</span></span><br><span class="line">                cur = [cur_node.right, cur_d+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            cur = s.pop()</span><br><span class="line">            cur = [cur[<span class="number">0</span>].left, cur[<span class="number">1</span>]+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="7.2.1.7"></span>  </p><h3 id="7-2-1-7-对称二叉树"><a href="#7-2-1-7-对称二叉树" class="headerlink" title="7.2.1.7 对称二叉树"></a>7.2.1.7 对称二叉树</h3><p><a href="https://leetcode.cn/problems/symmetric-tree/">LeetCode 101.对称二叉树</a> | | <a href="#7.2.1">返回目录7.2.1</a>  </p><p>思路1：采用广度优先(层序)遍历，判断各层是否符合对称条件。<br>注意，这里对称不光是要值相等，还要让位置符合对称的条件   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.采用广度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line"></span><br><span class="line">        h = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 同时将结点，和其对应满二叉树的位置索引保存</span></span><br><span class="line">        q = [(root,<span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            h += <span class="number">1</span></span><br><span class="line">            layer = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                node, idx = cur</span><br><span class="line">                layer.append(cur)</span><br><span class="line">                <span class="comment"># 同时将结点，和其对应满二叉树的位置索引保存</span></span><br><span class="line">                <span class="keyword">if</span> node.left:   </span><br><span class="line">                    q.append((node.left, <span class="number">2</span>*idx+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    q.append((node.right, <span class="number">2</span>*idx+<span class="number">2</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 判断当前layer是否符合对称条件</span></span><br><span class="line">            L, R = <span class="number">0</span>, N-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt;= R:</span><br><span class="line">                left, right = layer[L], layer[R]</span><br><span class="line">                <span class="comment"># 要同时判断值是否相等，以及位置是否满足对称关系</span></span><br><span class="line">                <span class="comment"># 这里先求前几层的结点总数</span></span><br><span class="line">                front_node_cnts = <span class="number">2</span>**(h-<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> left[<span class="number">0</span>].val == right[<span class="number">0</span>].val <span class="keyword">and</span> \</span><br><span class="line">                    left[<span class="number">1</span>]-front_node_cnts  +  right[<span class="number">1</span>]-front_node_cnts == <span class="number">2</span>**(h-<span class="number">1</span>)-<span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 其中 left[1]-front_node_cnts 和 right[1]-front_node_cnts 代表的是当前结点索引，减去前几层的结点数</span></span><br><span class="line">                    <span class="comment"># 2**(h-1) 是假设当前层是满的情况时，应该有多少个结点</span></span><br><span class="line">                    L+=<span class="number">1</span></span><br><span class="line">                    R-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># print(left[0].val,right[0].val,left[1],right[1], front_node_cnts, N-1)</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>思路2：采用深度优先遍历。<br>注意，这里要注意，判断左右两个结点的值是否相等时，一定要保证这两个结点来自对称的位置，而未必是同一个结点的左右子结点。    </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.采用深度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 根结点本身为空，返回True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line"></span><br><span class="line">         <span class="comment"># 结点不为空，再来讨论其子树</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">left, right</span>):</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;注意: </span></span><br><span class="line"><span class="string">            DFS传入的两个结点，是对称位置的两个结点，而不一定是同一个结点的左右子结点 </span></span><br><span class="line"><span class="string">            只有对树的根结点而言，对称位置的两个结点，刚好是其左右子结点，再往下就不是左右子结点了！</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="comment"># 如果对称位置的结点都为空，满足对称</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">            <span class="keyword">elif</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="comment"># 如果左侧结点不为空，右侧结点为空，显然不对称</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> left <span class="keyword">and</span> right:</span><br><span class="line">                <span class="comment"># 如果左侧结点为空，右侧结点不为空，显然不对称</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果对称左右位置的结点都不为空，就要讨论两个条件：</span></span><br><span class="line">                <span class="comment"># 1.左右两个结点的值是否相等：</span></span><br><span class="line">                <span class="comment"># 2.左右两个结点下的子树本身是否满足对称条件</span></span><br><span class="line">                <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">                    <span class="comment"># 左右结点（即对称位置）的值不相等，显然不对称</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 一定要注意DFS传入的两个结点，是对称位置的两个结点，而非同一个结点的左右子结点</span></span><br><span class="line">                    <span class="keyword">return</span> DFS(left.left, right.right) <span class="keyword">and</span> DFS(left.right, right.left)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> DFS(root.left, root.right)</span><br></pre></td></tr></table></figure><p><span id="7.2.1.8"></span>  </p><h3 id="7-2-1-8-翻转二叉树"><a href="#7-2-1-8-翻转二叉树" class="headerlink" title="7.2.1.8 翻转二叉树"></a>7.2.1.8 翻转二叉树</h3><p><a href="https://leetcode.cn/problems/invert-binary-tree/">LeetCode 226.翻转二叉树</a> | | <a href="#7.2.1">返回目录7.2.1</a>  </p><p>思路1：采用深度优先遍历，递归地反转子树。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先递归处理该结点的左右子树，使其左右子树已经完成反转</span></span><br><span class="line">        new_left = self.invertTree(root.left)</span><br><span class="line">        new_right = self.invertTree(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 再将其左右子树交换即可</span></span><br><span class="line">        root.left, root.right = new_right, new_left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><span id="7.2.1.9"></span>  </p><h3 id="7-2-1-9-填充每个节点的下一个右侧节点指针"><a href="#7-2-1-9-填充每个节点的下一个右侧节点指针" class="headerlink" title="7.2.1.9 填充每个节点的下一个右侧节点指针"></a>7.2.1.9 填充每个节点的下一个右侧节点指针</h3><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">LeetCode 116.填充每个节点的下一个右侧节点指针</a> | | <a href="#7.2.1">返回目录7.2.1</a>  </p><p>思路1：最直接的思路就是采用广度优先遍历，对每一层进行连接即可。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="string">&#x27;Optional[Node]&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root </span><br><span class="line">        </span><br><span class="line">        q = [root]</span><br><span class="line">        cur = root </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N =<span class="built_in">len</span>(q)</span><br><span class="line">            pre = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 层内链接</span></span><br><span class="line">                <span class="keyword">if</span> pre:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur </span><br><span class="line">                pre = cur </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> root </span><br></pre></td></tr></table></figure><p>思路2：由于题目中说了这是满二叉树，所以每一层都是满的，每个父节点都有两个子节点。所以也可以利用这一特点来做，即对已经建立起来的next链接做横向移动。   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># 从根节点开始</span></span><br><span class="line">        leftmost = root</span><br><span class="line">        <span class="keyword">while</span> leftmost.left:</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 遍历这一层节点组织成的横向链表，为下一层的节点更新 next 指针</span></span><br><span class="line">            head = leftmost</span><br><span class="line">            <span class="keyword">while</span> head:</span><br><span class="line">                <span class="comment"># 1.同一个父节点内的左右子结点链接</span></span><br><span class="line">                head.left.<span class="built_in">next</span> = head.right</span><br><span class="line">                <span class="comment"># 2.将不同父节点之间的下一层右左子结点链接起来</span></span><br><span class="line">                <span class="keyword">if</span> head.<span class="built_in">next</span>:</span><br><span class="line">                    head.right.<span class="built_in">next</span> = head.<span class="built_in">next</span>.left</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 在本层内指针向后移动</span></span><br><span class="line">                head = head.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 去下一层的最左的节点</span></span><br><span class="line">            leftmost = leftmost.left</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root </span><br></pre></td></tr></table></figure><p><span id="7.2.1.10"></span>  </p><h3 id="7-2-1-10-填充每个节点的下一个右侧节点指针II"><a href="#7-2-1-10-填充每个节点的下一个右侧节点指针II" class="headerlink" title="7.2.1.10 填充每个节点的下一个右侧节点指针II"></a>7.2.1.10 填充每个节点的下一个右侧节点指针II</h3><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">LeetCode 117.填充每个节点的下一个右侧节点指针 II</a> | | <a href="#7.2.1">返回目录7.2.1</a>   </p><p>思路1：这个题和上一题的唯一区别就是，该题没有明确说明树是【完全二叉树】，但是依然能够用上一题的层次遍历的方法来做。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root </span><br><span class="line">        </span><br><span class="line">        q = [root]</span><br><span class="line">        cur = root </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N =<span class="built_in">len</span>(q)</span><br><span class="line">            pre = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> pre:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur </span><br><span class="line">                pre = cur </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> root </span><br></pre></td></tr></table></figure><p><span id="7.2.1.11"></span>  </p><h3 id="7-2-1-11-相同的树"><a href="#7-2-1-11-相同的树" class="headerlink" title="7.2.1.11 相同的树"></a>7.2.1.11 相同的树</h3><p><a href="https://leetcode.cn/problems/same-tree/">LeetCode 100.相同的树</a> | | <a href="#7.2.1">返回目录7.2.1</a>   </p><p>思路：如果采用深度优先遍历的思路，其实和【<a href="#7.2.1.7">对称二叉树</a>】那道题的思路几乎一致。都是对比对应位置的结点的值是否相等，只不过一个是在树的左右两侧寻找，一个是在两棵树之间寻找。<br>code的基本写法也是很相似的。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSameTree</span>(<span class="params">self, p: <span class="type">Optional</span>[TreeNode], q: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;注意：传入的两个结点，是对两个树对应位置的两个结点&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 如果两个结点都是空结点，满足相等</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">        <span class="comment"># 如果一个为空一个不为空，显然不相等</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> p <span class="keyword">and</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        <span class="comment"># 如果一个为空一个不为空，显然不相等</span></span><br><span class="line">        <span class="keyword">elif</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果两个结点都不为空，对比值的大小</span></span><br><span class="line">            <span class="keyword">if</span> p.val != q.val:</span><br><span class="line">                <span class="comment"># 值不想等，显然不符合</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 值相等的话，再看其左右子树是否满足</span></span><br><span class="line">                <span class="comment"># 传入的两个结点，是对两个树对应位置的两个结点</span></span><br><span class="line">                <span class="keyword">return</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br></pre></td></tr></table></figure><p><span id="7.2.2"></span></p><h2 id="7-2-2-二叉树反序列化（还原）"><a href="#7-2-2-二叉树反序列化（还原）" class="headerlink" title="7.2.2 二叉树反序列化（还原）"></a>7.2.2 二叉树反序列化（还原）</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LeetCode 105.从前序与中序遍历序列构造二叉树</a></td><td><a href="#7.2.2.1">题解7.2.2.1</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">LeetCode 106.从中序与后序遍历序列构造二叉树</a></td><td><a href="#7.2.2.2">题解7.2.2.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">LeetCode 889.根据前序和后序遍历构造二叉树</a></td><td><a href="#7.2.2.3">题解7.2.2.3</a></td></tr></tbody></table></div><p><span id="7.2.2.1"></span>  </p><h3 id="7-2-2-1-从前序与中序遍历序列构造二叉树"><a href="#7-2-2-1-从前序与中序遍历序列构造二叉树" class="headerlink" title="7.2.2.1 从前序与中序遍历序列构造二叉树"></a>7.2.2.1 从前序与中序遍历序列构造二叉树</h3><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LeetCode 105.从前序与中序遍历序列构造二叉树</a> | | <a href="#7.2.2">返回目录7.2.2</a></p><p>思路：核心在于，对于每一棵子树范围的结点，它的先序遍历的第一个元素，一定是该子树的根结点，即[ 根结点-[左子树结点]-[右子树结点] ]。而对于中序遍历,根结点能够将左右子树的结点分开，即[ [左子树结点]-根结点-[右子树结点] ] 。<br>而且该题强调了无重复元素，所以能够根据这两个遍历方式还原出原始二叉树。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:       </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getNode</span>(<span class="params">preorder_start, preorder_end, inorder_start, inorder_end</span>):</span><br><span class="line">            <span class="comment"># 如果传入的先序序列的开始索引已经大于了结束索引，就可以停止了</span></span><br><span class="line">            <span class="keyword">if</span> preorder_start &gt; preorder_end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当前考察的先序序列的第一个元素一定是根结点</span></span><br><span class="line">            root_val = preorder[preorder_start]</span><br><span class="line">            root_node = TreeNode(root_val)</span><br><span class="line">            <span class="comment"># 求出该元素在中序序列中的索引（题目中已经说了没有重复元素，所以可以直接在哈希表中找）</span></span><br><span class="line">            root_inorder_idx = inorder_index[root_val]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 根据中序遍历根结点的位置，我们可以将【中序】遍历分成左右两半，分别代表左右两个子树的【中序】序列</span></span><br><span class="line">            <span class="comment"># 注意，这里只是写了两个区域的端点索引</span></span><br><span class="line">            left_tree_inorder = [inorder_start, root_inorder_idx-<span class="number">1</span>]</span><br><span class="line">            right_tree_inorder = [root_inorder_idx+<span class="number">1</span>, inorder_end]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 还可以得到左子树的结点个数：</span></span><br><span class="line">            left_tree_node_cnts = root_inorder_idx - inorder_start</span><br><span class="line">            <span class="comment"># 根据这个数目，来求左右子树的【先序】序列的端点索引</span></span><br><span class="line">            left_tree_preorder = [preorder_start+<span class="number">1</span>, preorder_start + left_tree_node_cnts]</span><br><span class="line">            right_tree_preorder = [preorder_start + left_tree_node_cnts + <span class="number">1</span>, preorder_end]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 已经知道左右两个子树的，先序和中序的端点索引了，可以调用递归了</span></span><br><span class="line">            root_node.left = getNode(left_tree_preorder[<span class="number">0</span>], left_tree_preorder[<span class="number">1</span>], left_tree_inorder[<span class="number">0</span>], left_tree_inorder[<span class="number">1</span>])</span><br><span class="line">            root_node.right = getNode(right_tree_preorder[<span class="number">0</span>], right_tree_preorder[<span class="number">1</span>], right_tree_inorder[<span class="number">0</span>], right_tree_inorder[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root_node</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 用哈希表暂时将中序遍历的索引存储</span></span><br><span class="line">        inorder_index = &#123;val:i <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder)&#125;</span><br><span class="line">        N = <span class="built_in">len</span>(preorder)        </span><br><span class="line">        root = getNode(<span class="number">0</span>,N-<span class="number">1</span>, <span class="number">0</span>, N-<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>简化版代码：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:       </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment"># inorder 元素的序号先存起来</span></span><br><span class="line">        inorder_index = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder):</span><br><span class="line">            inorder_index[num] = i </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">buildNode</span>(<span class="params">L1, R1, L2, R2</span>):</span><br><span class="line">            <span class="comment"># 递归终止条件</span></span><br><span class="line">            <span class="keyword">if</span> L1&gt;R1 <span class="keyword">or</span> L2&gt;R2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line"></span><br><span class="line">            root_val = preorder[L1]</span><br><span class="line">            root = TreeNode(val=root_val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> L1==R1: <span class="comment"># 只够组成一个子结点</span></span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">            <span class="comment"># 划分 inorder 列表</span></span><br><span class="line">            root_index_in = inorder_index[preorder[L1]]</span><br><span class="line">            left_inorder = (L2, root_index_in-<span class="number">1</span>)</span><br><span class="line">            right_inorder = (root_index_in+<span class="number">1</span>,  R2)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 划分 preorder 列表</span></span><br><span class="line">            left_w = left_inorder[<span class="number">1</span>]-left_inorder[<span class="number">0</span>]+<span class="number">1</span></span><br><span class="line">            left_preorder = (L1+<span class="number">1</span>, L1+left_w)</span><br><span class="line">            right_preorder = (L1+left_w+<span class="number">1</span>, R1)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归调用函数构造左子结点 、右子结点</span></span><br><span class="line">            root.left = buildNode(left_preorder[<span class="number">0</span>], left_preorder[<span class="number">1</span>], left_inorder[<span class="number">0</span>], left_inorder[<span class="number">1</span>])</span><br><span class="line">            root.right = buildNode(right_preorder[<span class="number">0</span>], right_preorder[<span class="number">1</span>], right_inorder[<span class="number">0</span>], right_inorder[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buildNode(<span class="number">0</span>, <span class="built_in">len</span>(preorder)-<span class="number">1</span>, <span class="number">0</span>, <span class="built_in">len</span>(inorder)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><span id="7.2.2.2"></span>  </p><h3 id="7-2-2-2-从中序与后序遍历序列构造二叉树"><a href="#7-2-2-2-从中序与后序遍历序列构造二叉树" class="headerlink" title="7.2.2.2 从中序与后序遍历序列构造二叉树"></a>7.2.2.2 从中序与后序遍历序列构造二叉树</h3><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">LeetCode 106.从中序与后序遍历序列构造二叉树</a>| | <a href="#7.2.2">返回目录7.2.2</a></p><p>思路：和上一题的思路是一样的，甚至code都只需要改一点点。改动点是：后序遍历的顺序是根结点在最后一个位置，即[ [左子树结点]-[右子树结点]-根结点 ]</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getNode</span>(<span class="params">postorder_start, postorder_end, inorder_start, inorder_end</span>):</span><br><span class="line">            <span class="comment"># 如果传入的后序序列的开始索引已经大于了结束索引，就可以停止了</span></span><br><span class="line">            <span class="keyword">if</span> postorder_start &gt; postorder_end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当前考察的后序序列的【最后一个】元素一定是根结点</span></span><br><span class="line">            root_val = postorder[postorder_end]</span><br><span class="line">            root_node = TreeNode(root_val)</span><br><span class="line">            <span class="comment"># 求出该元素在中序序列中的索引（题目中已经说了没有重复元素，所以可以直接在哈希表中找）</span></span><br><span class="line">            root_inorder_idx = inorder_index[root_val]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 根据中序遍历根结点的位置，我们可以将【中序】遍历分成左右两半，分别代表左右两个子树的【中序】序列</span></span><br><span class="line">            <span class="comment"># 注意，这里只是写了两个区域的端点索引</span></span><br><span class="line">            left_tree_inorder = [inorder_start, root_inorder_idx-<span class="number">1</span>]</span><br><span class="line">            right_tree_inorder = [root_inorder_idx+<span class="number">1</span>, inorder_end]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 还可以得到左子树的结点个数：</span></span><br><span class="line">            left_tree_node_cnts = root_inorder_idx - inorder_start</span><br><span class="line">            <span class="comment"># 根据这个数目，来求左右子树的【后序】序列的端点索引</span></span><br><span class="line">            left_tree_postorder = [postorder_start, postorder_start + left_tree_node_cnts-<span class="number">1</span>]</span><br><span class="line">            right_tree_postorder = [postorder_start + left_tree_node_cnts, postorder_end-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 已经知道左右两个子树的，后序和中序的端点索引了，可以调用递归了</span></span><br><span class="line">            root_node.left = getNode(left_tree_postorder[<span class="number">0</span>], left_tree_postorder[<span class="number">1</span>], left_tree_inorder[<span class="number">0</span>], left_tree_inorder[<span class="number">1</span>])</span><br><span class="line">            root_node.right = getNode(right_tree_postorder[<span class="number">0</span>], right_tree_postorder[<span class="number">1</span>], right_tree_inorder[<span class="number">0</span>], right_tree_inorder[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root_node</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 用哈希表暂时将中序遍历的索引存储</span></span><br><span class="line">        inorder_index = &#123;val:i <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder)&#125;</span><br><span class="line">        N = <span class="built_in">len</span>(postorder)        </span><br><span class="line">        root = getNode(<span class="number">0</span>,N-<span class="number">1</span>, <span class="number">0</span>, N-<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>简化版代码：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(inorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># inorder 元素的序号先存起来</span></span><br><span class="line">        inorder_index = &#123;val:i <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder)&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">buildNode</span>(<span class="params">L1, R1, L2, R2</span>):</span><br><span class="line">            <span class="comment"># 递归终止条件</span></span><br><span class="line">            <span class="keyword">if</span> L1&gt;R1 <span class="keyword">or</span> L2&gt;R2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">            </span><br><span class="line">            root_val = postorder[R2]</span><br><span class="line">            root_node = TreeNode(root_val)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> L1==R1: <span class="comment"># 只够组成一个子结点</span></span><br><span class="line">                <span class="keyword">return</span> root_node</span><br><span class="line"></span><br><span class="line">            <span class="comment"># inorder subset</span></span><br><span class="line">            root_index_in = inorder_index[root_val]</span><br><span class="line">            left_inorder = (L1, root_index_in-<span class="number">1</span>)</span><br><span class="line">            right_inorder = (root_index_in+<span class="number">1</span>, R1)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># postorder subset </span></span><br><span class="line">            left_w = root_index_in - L1</span><br><span class="line">            left_postorder = (L2, L2+left_w-<span class="number">1</span>)</span><br><span class="line">            right_postorder = (L2+left_w, R2-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归调用函数构造左子结点 、右子结点</span></span><br><span class="line">            root_node.left = buildNode(left_inorder[<span class="number">0</span>], left_inorder[<span class="number">1</span>], left_postorder[<span class="number">0</span>], left_postorder[<span class="number">1</span>])</span><br><span class="line">            root_node.right = buildNode(right_inorder[<span class="number">0</span>], right_inorder[<span class="number">1</span>], right_postorder[<span class="number">0</span>], right_postorder[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root_node </span><br><span class="line"></span><br><span class="line">        N = <span class="built_in">len</span>(postorder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buildNode(<span class="number">0</span>, N-<span class="number">1</span>, <span class="number">0</span>,N-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><span id="7.2.2.3"></span>  </p><h3 id="7-2-2-3-根据前序和后序遍历构造二叉树"><a href="#7-2-2-3-根据前序和后序遍历构造二叉树" class="headerlink" title="7.2.2.3 根据前序和后序遍历构造二叉树"></a>7.2.2.3 根据前序和后序遍历构造二叉树</h3><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">LeetCode 889.根据前序和后序遍历构造二叉树</a> | | <a href="#7.2.2">返回目录7.2.2</a></p><p>思路：实际上，只靠先序遍历和后序遍历的结果，并不能唯一确定地还原二叉树的结构。<br>但是由于题目中说如果存在多个答案，可以返回任何一个，这样该题才能做。<br>同样是利用上面二题的思路进行code改写即可。    </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">constructFromPrePost</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getNode</span>(<span class="params">preorder_start, preorder_end, postorder_start, postorder_end</span>):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> preorder_start &gt; preorder_end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当前考察的先序序列的第一个元素一定是根结点</span></span><br><span class="line">            root_val = preorder[preorder_start]</span><br><span class="line">            root_node = TreeNode(root_val)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 说明没有子树了，只需要返回一个结点即可</span></span><br><span class="line">            <span class="keyword">if</span> preorder_start == preorder_end:</span><br><span class="line">                <span class="keyword">return</span> root_node</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果该条件成立，说明至少存在一个子树</span></span><br><span class="line">            <span class="keyword">if</span> preorder_start + <span class="number">1</span> &lt;= preorder_end:</span><br><span class="line">                <span class="comment"># 如果先序序列的第二个结点，等于后序遍历的倒数第二个结点，又由于结点的值不存在重复的情况</span></span><br><span class="line">                <span class="comment"># 说明只有一棵子树，题目中说如果有多个答案，可以返回其中任何一个，那么就直接将这种情况当作左子树来处理</span></span><br><span class="line">                <span class="keyword">if</span> preorder[preorder_start + <span class="number">1</span>] == postorder[postorder_end-<span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># 求出前序遍历的 左子树的 区间端点索引</span></span><br><span class="line">                    left_tree_preorder = [preorder_start + <span class="number">1</span>, preorder_end]</span><br><span class="line">                    <span class="comment"># 求出后序遍历的 左子树的 区间端点索引</span></span><br><span class="line">                    left_tree_postorder = [postorder_start, postorder_end-<span class="number">1</span>]</span><br><span class="line">                    <span class="comment"># 将端点值传入递归函数</span></span><br><span class="line">                    root_node.left = getNode(left_tree_preorder[<span class="number">0</span>], left_tree_preorder[<span class="number">1</span>], left_tree_postorder[<span class="number">0</span>], left_tree_postorder[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 上面的if如果不成立，说明一定同时存在左右两棵子树</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 左子树的根结点，就是先序遍历序列的第二个元素</span></span><br><span class="line">                    left_root = preorder[preorder_start + <span class="number">1</span>]</span><br><span class="line">                    <span class="comment"># 右子树的根结点，就是后序遍历序列的倒数第二个元素</span></span><br><span class="line">                    right_root = postorder[postorder_end-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                     <span class="comment"># 求出前序遍历的 左子树和右子树的 区间端点索引</span></span><br><span class="line">                    left_tree_preorder = [preorder_start + <span class="number">1</span>, preorder_index[right_root]-<span class="number">1</span>]</span><br><span class="line">                    right_tree_preorder = [preorder_index[right_root], preorder_end]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 求出后序遍历的 左子树和右子树的 区间端点索引</span></span><br><span class="line">                    left_tree_postorder = [postorder_start, postorder_index[left_root]]</span><br><span class="line">                    right_tree_postorder = [postorder_index[left_root]+<span class="number">1</span>, postorder_end-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 将区间端点索引传入递归函数</span></span><br><span class="line">                    root_node.left = getNode(left_tree_preorder[<span class="number">0</span>], left_tree_preorder[<span class="number">1</span>], left_tree_postorder[<span class="number">0</span>], left_tree_postorder[<span class="number">1</span>])</span><br><span class="line">                    root_node.right = getNode(right_tree_preorder[<span class="number">0</span>], right_tree_preorder[<span class="number">1</span>], right_tree_postorder[<span class="number">0</span>], right_tree_postorder[<span class="number">1</span>])</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> root_node</span><br><span class="line"></span><br><span class="line">        preorder_index = &#123;val:i <span class="keyword">for</span> (i,val) <span class="keyword">in</span> <span class="built_in">enumerate</span>(preorder)&#125;</span><br><span class="line">        postorder_index = &#123;val:i <span class="keyword">for</span> (i,val) <span class="keyword">in</span> <span class="built_in">enumerate</span>(postorder)&#125;</span><br><span class="line">        N = <span class="built_in">len</span>(preorder)</span><br><span class="line">        root = getNode(<span class="number">0</span>,N-<span class="number">1</span>, <span class="number">0</span>, N-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>简化版代码如下：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">constructFromPrePost</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 需要将两个数组的值和索引都存入哈希表</span></span><br><span class="line">        preorder_index = &#123;val:i <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">enumerate</span>(preorder)&#125;</span><br><span class="line">        postorder_index = &#123;val:i <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">enumerate</span>(postorder)&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">buildNode</span>(<span class="params">L1, R1, L2, R2</span>):</span><br><span class="line">            <span class="keyword">if</span> L1&gt;R1 <span class="keyword">or</span> L2&gt;R2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 以先序列表的最前的数作为根结点</span></span><br><span class="line">            root_val = preorder[L1]</span><br><span class="line">            root_node = TreeNode(val=root_val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> L1==R1: <span class="comment"># 只够组成一个结点</span></span><br><span class="line">                <span class="keyword">return</span> root_node</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 说明至少有一颗子树</span></span><br><span class="line">                <span class="keyword">if</span> preorder[L1+<span class="number">1</span>] == postorder[R2-<span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># 理论上左子树的根结点==理论上右子树的根结点，说明只有一棵树，就把它当做左子树即可</span></span><br><span class="line">                    left_preorder = (L1+<span class="number">1</span>, R1)</span><br><span class="line">                    left_postorder = (L2, R2-<span class="number">1</span>)</span><br><span class="line">                    root_node.left = buildNode(left_preorder[<span class="number">0</span>], left_preorder[<span class="number">1</span>], left_postorder[<span class="number">0</span>], left_postorder[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 不满足以上的条件说明有两棵树</span></span><br><span class="line"></span><br><span class="line">                    left_root_val = preorder[L1+<span class="number">1</span>]   <span class="comment"># 左子树根结点用先序部分剩下的最左侧点</span></span><br><span class="line">                    right_root_val = postorder[R2-<span class="number">1</span>] <span class="comment"># 右子树的根结点用后续部分倒数第二个</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 划分 preorder 列表</span></span><br><span class="line">                    <span class="comment"># 这里就会需要用到右子树根结点在 先序中的位置, 才能将先序的左右区分开</span></span><br><span class="line">                    left_preorder = (L1+<span class="number">1</span>, preorder_index[right_root_val]-<span class="number">1</span>)</span><br><span class="line">                    right_preorder = (preorder_index[right_root_val], R1)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 划分 postorder 列表</span></span><br><span class="line">                    <span class="comment"># 这里就会需要用到左子树的根结点 在后续中的部分, 才能将后序的左右区分开</span></span><br><span class="line">                    left_postorder = (L2, postorder_index[left_root_val])</span><br><span class="line">                    right_postorder = (postorder_index[left_root_val]+<span class="number">1</span>, R2-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 递归调用函数</span></span><br><span class="line">                    root_node.left = buildNode(left_preorder[<span class="number">0</span>], left_preorder[<span class="number">1</span>], left_postorder[<span class="number">0</span>], left_postorder[<span class="number">1</span>])</span><br><span class="line">                    root_node.right = buildNode(right_preorder[<span class="number">0</span>], right_preorder[<span class="number">1</span>], right_postorder[<span class="number">0</span>], right_postorder[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> root_node </span><br><span class="line">            </span><br><span class="line">        N = <span class="built_in">len</span>(preorder)</span><br><span class="line">        root = buildNode(<span class="number">0</span>,N-<span class="number">1</span>, <span class="number">0</span>, N-<span class="number">1</span>)  </span><br><span class="line">        <span class="keyword">return</span> root   </span><br></pre></td></tr></table></figure><p><span id="7.2.3"> </span></p><h2 id="7-2-3-路径问题"><a href="#7-2-3-路径问题" class="headerlink" title="7.2.3 路径问题"></a>7.2.3 路径问题</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/path-sum/">LeetCode 112.路径总和</a></td><td><a href="#7.2.3.1">题解7.2.3.1</a></td></tr><tr><td>①</td><td><a href="https://leetcode.cn/problems/path-sum-ii/">LeetCode 113.路径总和 II</a></td><td><a href="#7.2.3.2">题解7.2.3.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">LeetCode 124.二叉树中的最大路径和</a></td><td><a href="#7.2.3.3">题解7.2.3.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">LeetCode 236.二叉树的最近公共祖先</a></td><td><a href="#7.2.3.4">题解7.2.3.4</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/binary-tree-paths/">LeetCode 257.二叉树的所有路径</a></td><td><a href="#7.2.3.5">题解7.2.3.5</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/path-in-zigzag-labelled-binary-tree/">LeetCode 1104.二叉树寻路</a></td><td><a href="#7.2.3.6">题解7.2.3.6</a></td></tr></tbody></table></div><p><span id="7.2.3.1"></span>  </p><h3 id="7-2-3-1-路径总和"><a href="#7-2-3-1-路径总和" class="headerlink" title="7.2.3.1 路径总和"></a>7.2.3.1 路径总和</h3><p><a href="https://leetcode.cn/problems/path-sum/">LeetCode 112.路径总和</a> | | <a href="#7.2.3">返回目录7.2.3</a></p><p>思路 1：广度优先遍历。每一层的每个结点都计算其累积的路径和，直到计算完最后一层的结点的路径和。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.广度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#每一个元素是由 (结点, 之前路径上的路径和)</span></span><br><span class="line">        q = [(root, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                node, pathSum = q.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果当前结点已经是叶子结点了，就需要判断一下刚刚它计算得到的路径和</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> pathSum + node.val == targetSum:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果不是叶子结点，就继续添加下一层</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    q.append((node.left, pathSum + node.val))</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    q.append((node.right, pathSum + node.val))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>思路 2：深度优先遍历。每深入一个结点，就减去上面已经遍历过的路径上的结点值的和，相当于值看剩下的结点能否满足剩下的和。     </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;2.深度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node, restSum</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果本身就是叶子结点,就看剩下的 restSum 是不是等于结点值</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">        <span class="keyword">return</span> restSum == node.val</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果本身不是叶子结点，就继续向下深入</span></span><br><span class="line">    <span class="comment"># 只要左右子结点中有一条路能满足即可</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> DFS(node.left, restSum - node.val) <span class="keyword">or</span> DFS(node.right, restSum - node.val) </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> DFS(root, targetSum)</span><br></pre></td></tr></table></figure><p><span id="7.2.3.2"></span>  </p><h3 id="7-2-3-2-路径总和II"><a href="#7-2-3-2-路径总和II" class="headerlink" title="7.2.3.2 路径总和II"></a>7.2.3.2 路径总和II</h3><p><a href="https://leetcode.cn/problems/path-sum-ii/">LeetCode 113.路径总和 II</a> | | <a href="#7.2.3">返回目录7.2.3</a></p><p>思路 1：和上一题很类似，只不过上一题只是判断是否存在这样的路径，而该题还要确定出这样的路径，难度稍微提升了一点。<br>如果我们仍使用广度优先搜索，该如何才能在确定这样的路径存在时，知道前面路径上的所有结点是什么呢？<br>可以考虑用一个哈希表来记住所有结点的父结点。这样的话就能沿着路径反方向遍历完整条路径。<br>仅需在上一题的code的基础上做一些修改即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.广度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用一个哈希表来存储各个结点的父结点</span></span><br><span class="line">        hash_father = &#123;root:<span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getPath</span>(<span class="params">node</span>):</span><br><span class="line">            path = []</span><br><span class="line">            <span class="comment"># 按照哈希表记录的父结点，一直往上找，并将值添加到path中</span></span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                path.append(node.val)</span><br><span class="line">                node = hash_father[node]</span><br><span class="line">            <span class="comment"># 记得要反转一下path才是从上到下的顺序</span></span><br><span class="line">            path.reverse()</span><br><span class="line">            <span class="keyword">return</span> path</span><br><span class="line"></span><br><span class="line">        <span class="comment">#每一个元素是 (结点, 之前路径上的路径和)</span></span><br><span class="line">        q = [(root, <span class="number">0</span>)]</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            layer = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                node, pathSum = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 如果当前结点已经是叶子结点了，就需要判断一下刚刚它计算得到的路径和</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> pathSum + node.val == targetSum:</span><br><span class="line">                    <span class="comment">#return True</span></span><br><span class="line">                    <span class="comment"># 调用getPath向上寻找路径，并添加到结果res中</span></span><br><span class="line">                    res.append(getPath(node))</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果不是叶子结点，就继续添加下一层</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    q.append((node.left, pathSum + node.val))</span><br><span class="line">                    <span class="comment"># 记得更新左子结点的父结点关系</span></span><br><span class="line">                    hash_father[node.left] = node</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    q.append((node.right, pathSum + node.val))</span><br><span class="line">                    <span class="comment"># 记得更新右子结点的父结点关系</span></span><br><span class="line">                    hash_father[node.right] = node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>思路 2：也可以使用深度优先遍历，在深度优先遍历的过程中，用一个临时数组记住每个结点之前的路径，然后看加上当前结点后是否满足条件。   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.深度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        res, path = [], []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node, resSum</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="comment"># 当前结点不为空，就先将该结点值放入path中</span></span><br><span class="line">            path.append(node.val)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 然后判断当前结点是否是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="comment"># 如果是叶子结点，且当前结点的值刚好等于剩余的sum值，说明该路径满足条件</span></span><br><span class="line">                <span class="keyword">if</span> node.val == resSum:</span><br><span class="line">                    <span class="comment"># 满足条件的路径, 就往 res 中添加一次</span></span><br><span class="line">                    res.append(path[:]) <span class="comment"># 这里注意要用 path[:]来进行赋值操作，不然的话会进行浅拷贝</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果当前结点不是叶子结点，就继续向它的子结点进行延伸</span></span><br><span class="line">                DFS(node.left, resSum-node.val)</span><br><span class="line">                DFS(node.right,  resSum-node.val)</span><br><span class="line">            <span class="comment"># 当前结点处理完之后，要记得将当前结点从 path中移除，因为已经要跳出处理该结点的范围了</span></span><br><span class="line">            path.pop()</span><br><span class="line">                 </span><br><span class="line">        DFS(root, targetSum)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="7.2.3.3"></span>  </p><h3 id="7-2-3-3-二叉树中的最大路径和"><a href="#7-2-3-3-二叉树中的最大路径和" class="headerlink" title="7.2.3.3 二叉树中的最大路径和"></a>7.2.3.3 二叉树中的最大路径和</h3><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">LeetCode 124.二叉树中的最大路径和</a>| | <a href="#7.2.3">返回目录7.2.3</a></p><p>思路：这里的路径并不一定是指的从根结点出发到叶子结点的路径，而是从一个结点到另一个结点的任意路径。<br>考察二叉树最小的结构，即1个父结点连着两个子结点的情况：<br>&ensp;father<br>&ensp;/ &emsp;&emsp;\<br>left &emsp;right<br>如果我们的路径要经过father结点，那么路径一共就只有以下几种情况：<br>1.这一部分作为更大路径的子路径：<br>a. father;  b. father-left;  c. father-right<br>2.自己这一部分构成一个路径：<br>left-father-right  </p><p>而至于我们要不要经过 father 结点，那就是看上面这4种情况，能否产生更大的路径和，即：经过father点是否对更大的路径的总和有正向增益？  </p><p>将这个最小结构放入树当中，这里的左右子结点，可以视为左右子树的总贡献；而father结点的贡献，就视为father结点作为某个子结点时的贡献。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">maxGain</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 递归计算左右子节点的最大贡献值</span></span><br><span class="line">            <span class="comment"># 只有在最大贡献值大于 0 时，才会选取对应子节点</span></span><br><span class="line">            leftGain = <span class="built_in">max</span>(maxGain(node.left), <span class="number">0</span>)</span><br><span class="line">            rightGain = <span class="built_in">max</span>(maxGain(node.right), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 因为结点只能在路径序列中至多出现一次</span></span><br><span class="line">            <span class="comment"># 所以对于任一父结点与其左右子结点能够组成的一个子路径分别为：</span></span><br><span class="line">            <span class="comment"># 1.只取父结点入路径; 2.父结点-左子结点; 3.父结点-右子结点</span></span><br><span class="line">            local_path_gain = <span class="built_in">max</span>(node.val, node.val+leftGain, node.val+rightGain)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 另有一种情况就是 父结点和两个子结点自己组成大路径，不再作为其它大路径的子部分</span></span><br><span class="line">            global_path_gain = node.val + leftGain + rightGain</span><br><span class="line">            <span class="comment"># 如果是这种情况，我们直接将该路径和与总的结果比较，取较大者</span></span><br><span class="line">            res[<span class="number">0</span>] = <span class="built_in">max</span>(res[<span class="number">0</span>], global_path_gain)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果希望将父结点和任一子结点作为一个子路径参与大更大的路径中</span></span><br><span class="line">            <span class="comment"># 我们就把这个子路径的最大路径和返回出去即可</span></span><br><span class="line">            <span class="keyword">return</span> local_path_gain</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 题目中给的条件是 -1000 &lt;= Node.val &lt;= 1000</span></span><br><span class="line">        <span class="comment"># 借用列表来作为全局变量</span></span><br><span class="line">        res =[-<span class="number">1001</span>]</span><br><span class="line">        maxGain(root)</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><span id="7.2.3.4"></span>  </p><h3 id="7-2-3-4-二叉树的最近公共祖先"><a href="#7-2-3-4-二叉树的最近公共祖先" class="headerlink" title="7.2.3.4 二叉树的最近公共祖先"></a>7.2.3.4 二叉树的最近公共祖先</h3><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">LeetCode 236.二叉树的最近公共祖先</a> | | <a href="#7.2.3">返回目录7.2.3</a></p><p>思路1： 既然是找公共祖先，比较容易想到的是，上面的题目中 <a href="#7.2.3.2">题解7.2.3.2</a> 为了获取路径，将父结点都存入哈希表中的方法。这里确实可以用。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q: </span><br><span class="line">            <span class="keyword">return</span> root </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置一个哈希表来存储结点的父结点</span></span><br><span class="line">        hash_father = &#123;root:<span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 利用DFS先将各个结点和其父结点都存入hash_father</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node :</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                hash_father[node.left] = node </span><br><span class="line">                DFS(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                hash_father[node.right] = node </span><br><span class="line">                DFS(node.right)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        DFS(root)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这样对于 p, q 两个node，都能够一直往上追溯回树的根结点root</span></span><br><span class="line">        <span class="comment"># 这个问题就可以看成两个无环链表的相交问题了</span></span><br><span class="line">        <span class="comment"># 为了code简便起见，这里又用哈希表方法来解决相交问题</span></span><br><span class="line">        hash_p = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            hash_p[p] = <span class="number">1</span></span><br><span class="line">            p = hash_father[p]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="keyword">if</span> q <span class="keyword">in</span> hash_p:</span><br><span class="line">                <span class="keyword">return</span> q</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q = hash_father[q]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span> </span><br></pre></td></tr></table></figure><p>思路2：也可以用深度优先遍历，递归的方法找。<br>注意到题目中提示了，p和q互不相等，且一定位于树中，说明一定有公共祖先！<br>如果最近祖先是根结点，那么说明p和q一个位于左子树，一个位于右子树；<br>如果最近公共祖先不是根结点，那么要么位于左子树（说明p和q都位于左子树），要么位于右子树（说明p和q都位于右子树）。<br>这个概念可以递归推导于任一一个范围的子树。   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="comment"># 这个条件很关键, 意思是顺着根结点往下的路径探索, 如果这条路径上 出现p or q, 那么就会返回p or q</span></span><br><span class="line">        <span class="comment"># 如果该条路径上不存在p或者q, 则会返回 None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q: </span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># left的返回值，要么是None（即p和q都不在左子树中），要么是 p 或者q 或其最近公共祖先</span></span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="comment"># right的返回值，要么是None（即p和q都不在右子树中），要么是 p 或者q 或其最近公共祖先</span></span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left: </span><br><span class="line">            <span class="comment"># 如果left是None，则p和q都不在左子树中，则p和q都在右子树中，答案就是right返回值</span></span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right: </span><br><span class="line">            <span class="comment"># 如果right是None，则p和q都不在右子树中，则p和q都在左子树中，答案就是left 返回值</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 如果上面两个return都没有返回，说明left和right都不为空</span></span><br><span class="line">        <span class="comment"># 那么p和q分别位于 左、右子树中，最近公共祖先就应该是root</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><span id="7.2.3.5"></span>  </p><h3 id="7-2-3-5-二叉树的所有路径"><a href="#7-2-3-5-二叉树的所有路径" class="headerlink" title="7.2.3.5 二叉树的所有路径"></a>7.2.3.5 二叉树的所有路径</h3><p><a href="https://leetcode.cn/problems/binary-tree-paths/">LeetCode 257.二叉树的所有路径</a> | | <a href="#7.2.3">返回目录7.2.3</a></p><p>思路：采用深度优先遍历，这里的code的写法，也应用到上面的【<a href="#7.2.3.2">7.2.3.2 路径总和II</a>】同理，该题也可以用上面的那种拿哈希表存储父结点的思路。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node, path</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="comment"># 进入到该结点的处理环节，就先将该结点放入path中</span></span><br><span class="line">            path.append(<span class="built_in">str</span>(node.val))</span><br><span class="line">            <span class="comment"># 是叶子结点,说明已经找到一条路径</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="comment"># 往结果中形成一条路径</span></span><br><span class="line">                res.append(<span class="string">&#x27;-&gt;&#x27;</span>.join(path))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                DFS(node.left, path)</span><br><span class="line">                DFS(node.right, path)</span><br><span class="line">            <span class="comment"># 这一层处理完之后，需要将该结点弹出，不然会继续停留在path中</span></span><br><span class="line">            path.pop()</span><br><span class="line">        </span><br><span class="line">        res, path = [], []</span><br><span class="line">        DFS(root, path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="7.2.3.6"></span>  </p><h3 id="7-2-3-6-二叉树寻路"><a href="#7-2-3-6-二叉树寻路" class="headerlink" title="7.2.3.6 二叉树寻路"></a>7.2.3.6 二叉树寻路</h3><p><a href="https://leetcode.cn/problems/path-in-zigzag-labelled-binary-tree/">LeetCode 1104.二叉树寻路</a>| | <a href="#7.2.3">返回目录7.2.3</a></p><p>思路：只有偶数层的顺序逆序了，所以对于路径中位于偶数层的数字, 它的位置其实并不是对应原始完全二叉树的位置, 对其进行处理即可。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathInZigZagTree</span>(<span class="params">self, label: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_reverse_location</span>(<span class="params">label, H</span>):</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;该函数就是对于偶数层的label, 计算其位置对应原始满二叉树的位置的label&#x27;&#x27;&#x27;</span></span><br><span class="line">            start = <span class="number">2</span>**(H-<span class="number">1</span>) <span class="comment"># 第H层的起始结点</span></span><br><span class="line">            end = <span class="number">2</span>**H -<span class="number">1</span>  <span class="comment"># 第H层的结束结点:</span></span><br><span class="line">            new_label = end - label + start </span><br><span class="line">            <span class="keyword">return</span> new_label</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为后面会使用到label, 所以label的值可能发生变化, 这里先将其原始值保存</span></span><br><span class="line">        origin_label = label</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;因为如果当前label是偶数层, 则需要对其进行处理, 处理之后才能得到原始完全二叉树的位置的label&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 计算当前的label是第几层</span></span><br><span class="line">        H = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> label &gt; <span class="number">1</span>:</span><br><span class="line">            label = label // <span class="number">2</span></span><br><span class="line">            H += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> H % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            label = get_reverse_location(origin_label, H)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            label = origin_label</span><br><span class="line">        <span class="comment"># 此时label已经得到校正, 是对应的完全二叉树位置的label</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># label修正之后, 我们就先假设在原始完全二叉树中, 去回溯路径。</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 这个循环是从label开始, 依次向上回溯, 直到根结点1</span></span><br><span class="line">        <span class="keyword">while</span> label &gt;= <span class="number">1</span>:</span><br><span class="line">            res.append(label)</span><br><span class="line">            label = label // <span class="number">2</span></span><br><span class="line">        res.reverse() <span class="comment"># 逆序之后得到从1到label的路径</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="comment"># 此时的res路径是假设按照原始满二叉树来向下寻得的路径</span></span><br><span class="line">        <span class="comment"># 再对其中偶数层的数字进行转换即可</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res)):</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 偶数层</span></span><br><span class="line">                res[i] = get_reverse_location(res[i], i+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res       </span><br></pre></td></tr></table></figure><p><span id="7.2.4"></span>  </p><h2 id="7-2-4-验证各种树"><a href="#7-2-4-验证各种树" class="headerlink" title="7.2.4 验证各种树"></a>7.2.4 验证各种树</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/validate-binary-tree-nodes/">LeetCode 1361.验证二叉树</a></td><td><a href="#7.2.4.1">题解7.2.4.1</a></td></tr><tr><td>①</td><td><a href="https://leetcode.cn/problems/validate-binary-search-tree/">LeetCode 98.验证二叉搜索树</a></td><td><a href="#7.2.4.2">题解7.2.4.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">LeetCode 958.二叉树的完全性检验</a></td><td><a href="#7.2.4.3">题解7.2.4.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/balanced-binary-tree/">LeetCode 110.平衡二叉树</a></td><td><a href="#7.2.4.4">题解7.2.4.4</a></td></tr></tbody></table></div><p><span id="7.2.4.1"></span>  </p><h3 id="7-2-4-1-验证二叉树"><a href="#7-2-4-1-验证二叉树" class="headerlink" title="7.2.4.1 验证二叉树"></a>7.2.4.1 验证二叉树</h3><p><a href="https://leetcode.cn/problems/validate-binary-tree-nodes/">LeetCode 1361.验证二叉树</a> | | <a href="#7.2.4">返回目录7.2.4</a></p><p>思路：这个题乍一看可能不知道在说什么，其实给出的两个列表 leftChild 和 rightChild 的元素指的就是 第 i 个结点的左右指向。<br>示例1中，i=0的结点，左子结点是leftChild[0]-&gt;1，右子结点是rightChild[0]-&gt;2;<br>i=1的结点，左子结点是leftChild[1]-&gt;-1,表示没有，右子结点是rightChild[1]-&gt;-1,表示没有;<br>i=2的结点，左子结点是leftChild[2]-&gt;3，右子结点是rightChild[2]-&gt;-1,表示没有;<br>i=3的结点，左子结点是leftChild[3]-&gt;-1,表示没有，右子结点是rightChild[3]-&gt;-1,表示没有;<br><b>说白了，就是看每个结点的入度（指入的箭头）是否不超过1，且有且只有1个结点入度为0（即根结点），<br>以及出度（指出的箭头）是否不超过2，（但是此题每个点只会有left和right两个指向，所以这个条件是自然满足的，可以不用考虑）<br>以及箭头是否为单向的，比如如果 0指向1，但是1也指向0，那明显是不符合的。</b><br>比如示例2中，1和2都指向3，导致3的入度为2，就不符合条件了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validateBinaryTreeNodes</span>(<span class="params">self, n: <span class="built_in">int</span>, leftChild: <span class="type">List</span>[<span class="built_in">int</span>], rightChild: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 先建立一个入度的统计列表</span></span><br><span class="line">        indegree = [<span class="number">0</span>]*n</span><br><span class="line">        <span class="comment"># 将每个结点的入度数目进行统计</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> leftChild[i] != -<span class="number">1</span>: indegree[leftChild[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> rightChild[i] != -<span class="number">1</span>: indegree[rightChild[i]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先判断是否有且只有一个根结点</span></span><br><span class="line">        root = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 统计入度为0的结点的数目</span></span><br><span class="line">            <span class="keyword">if</span> indegree[i] == <span class="number">0</span>: </span><br><span class="line">                root.append(i)</span><br><span class="line">            <span class="comment"># 如果有发现入度超过 1 的结点，直接返回False</span></span><br><span class="line">            <span class="keyword">elif</span> indegree[i] &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 要求有且只有一个根结点，否则就不能满足树的条件！</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(root) != <span class="number">1</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确定存在根结点之后，来判断</span></span><br><span class="line">        <span class="comment"># 这里采用层次遍历的方法</span></span><br><span class="line">        res = []</span><br><span class="line">        q = [root[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            layer = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur_idx = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 检查cur_idx是否已经存在了，</span></span><br><span class="line">                <span class="comment"># 即判断这里cur_idx作为上一层的子结点，是否还指向了上面的层</span></span><br><span class="line">                <span class="keyword">if</span> cur_idx <span class="keyword">in</span> res:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    layer.append(cur_idx)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> leftChild[cur_idx] != -<span class="number">1</span>:</span><br><span class="line">                    q.append(leftChild[cur_idx])</span><br><span class="line">                <span class="keyword">if</span> rightChild[cur_idx] != -<span class="number">1</span>:</span><br><span class="line">                    q.append(rightChild[cur_idx])</span><br><span class="line"></span><br><span class="line">            res.extend(layer)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里的判断是检查连通性，即所有结点都被包含在树中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(res) == n</span><br></pre></td></tr></table></figure><p><span id="7.2.4.2"></span>  </p><h3 id="7-2-4-2-验证二叉搜索树"><a href="#7-2-4-2-验证二叉搜索树" class="headerlink" title="7.2.4.2 验证二叉搜索树"></a>7.2.4.2 验证二叉搜索树</h3><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">LeetCode 98.验证二叉搜索树</a> | | <a href="#7.2.4">返回目录7.2.4</a></p><p>思路1 ：二叉搜索树的重要特性，就是如果按中序遍历的话，其结果是一个递增数组！<br>利用这一点，稍微改动中序遍历的code，就能够实现二叉搜索树的判定  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        cur = root</span><br><span class="line">        res, s = [], []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> <span class="built_in">len</span>(s)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                s.append(cur) </span><br><span class="line">                cur = cur.left</span><br><span class="line">            cur = s.pop()</span><br><span class="line">            <span class="comment"># 在原始的中序遍历读值之前，先判断当前值，是否比前一个值大</span></span><br><span class="line">            <span class="comment"># 就多了这么个步骤</span></span><br><span class="line">            <span class="keyword">if</span> res:</span><br><span class="line">                <span class="keyword">if</span> cur.val &lt;= res[-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>思路2 ：二叉搜索树当中的每个子树，也都是二叉搜索树。<br>利用这一点，采用深度优先遍历，递归地判定每个子树都满足二叉搜索的条件，<br>并将子树部分的最大、最小值往上级传递，就能够实现二叉搜索树的判定  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node</span>)-&gt; (<span class="built_in">bool</span>, <span class="built_in">int</span>, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="comment"># 如果是空树，直接就满足条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>, <span class="literal">None</span>, <span class="literal">None</span>            </span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                <span class="comment"># 如果左子结点不为空，才往下递归</span></span><br><span class="line">                left_tree, left_min, left_max = DFS(node.left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 否则左子树直接就满足二叉搜索的条件,</span></span><br><span class="line">                <span class="comment"># 手动设置为 left_min = node.val，（这样该结点值能作为左部分的最小值向上传递，）</span></span><br><span class="line">                <span class="comment"># left_max = 无穷小，保证该结点值一定满足二叉搜索条件 </span></span><br><span class="line">                left_tree, left_min, left_max = <span class="literal">True</span>, node.val, -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                <span class="comment"># 如果右子结点不为空，才往下递归</span></span><br><span class="line">                right_tree, right_min, right_max = DFS(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 否则右子树直接就满足二叉搜索的条件,</span></span><br><span class="line">                <span class="comment"># 手动设置为 right_max = node.val（这样该结点值能作为右部分的最大值向上传递，）</span></span><br><span class="line">                <span class="comment"># right_min = 无穷大，保证该结点值一定满足二叉搜索条件 </span></span><br><span class="line">                right_tree, right_min, right_max = <span class="literal">True</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), node.val</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断左右子树是否满足二叉搜索条件，以及当前结点是否满足</span></span><br><span class="line">            <span class="keyword">if</span> left_tree <span class="keyword">and</span> right_tree <span class="keyword">and</span> left_max &lt; node.val  <span class="keyword">and</span> node.val &lt; right_min:</span><br><span class="line">                <span class="comment"># 左侧最小数，作为该部分子树最小数的代表：min = left_min</span></span><br><span class="line">                <span class="comment"># 右侧最大数，作为该部分子树最大数的代表：max = right_max</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>, left_min, right_max</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 当返回False的时候，后面两个min max值已经没有意义了，可以随便写</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span>, <span class="literal">None</span>, <span class="literal">None</span> </span><br><span class="line">        <span class="keyword">return</span> DFS(root)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><span id="7.2.4.3"></span>  </p><h3 id="7-2-4-3-二叉树的完全性检验"><a href="#7-2-4-3-二叉树的完全性检验" class="headerlink" title="7.2.4.3 二叉树的完全性检验"></a>7.2.4.3 二叉树的完全性检验</h3><p><a href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">LeetCode 958.二叉树的完全性检验</a> | | <a href="#7.2.4">返回目录7.2.4</a></p><p>思路：完全二叉树的一个性质就是，对于每一个结点，其序号应当与对应的满二叉树的结点序号对应一致，毕竟满二叉树就是一颗特殊的完全二叉树。<br>求最大宽度的那个例子里，遍历元素的时候，将其序号取到，而且这个序号，恰巧就是按照满二叉树的排列来取的。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isCompleteTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 将根节点的序号初始化为0</span></span><br><span class="line">        q = [(root,<span class="number">0</span>)]</span><br><span class="line">        i = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur, index = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 每遍历一个结点，就将其数组排列顺序 i 加上1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 比较两个序号是否相等</span></span><br><span class="line">                <span class="keyword">if</span> i != index:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 在队列入队时，同时搭上其在满二叉树中对应位置的序号</span></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append((cur.left, <span class="number">2</span>*index+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append((cur.right, <span class="number">2</span>*index+<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><span id="7.2.4.4"></span>  </p><h3 id="7-2-4-4-平衡二叉树"><a href="#7-2-4-4-平衡二叉树" class="headerlink" title="7.2.4.4 平衡二叉树"></a>7.2.4.4 平衡二叉树</h3><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">LeetCode 110.平衡二叉树</a> | | <a href="#7.2.4">返回目录7.2.4</a></p><p>思路1：对于每个结点，其左右子树的高度差不大于1。<br>所以可以用深度优先遍历，递归的检查每个子树是否平衡。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 第一个递归函数是用来求解结点的height</span></span><br><span class="line">    <span class="comment"># 这其实就是【7.2.1.3 二叉树的最大深度】的递归解法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.height(node.left), self.height(node.right)) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 要判断左右两个子树的高度差是否超过1, 以及左右子树是否都平衡</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(self.height(root.left) - self.height(root.right)) &lt;= <span class="number">1</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br></pre></td></tr></table></figure><p>思路2：上面的方案1思路是对的，但是在递归使用 isBalanced 函数的时候，对于每一个结点，都要调用一次 height 来求一次该结点的深度，实际上浪费了很多重复计算。<br>如果在递归的时候，能够不断的把结点的深度往上传递，就不用每次都用height函数去计算了。<br>因为父结点的深度 就是 子结点的最大深度+1    </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>, <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 分别获取左右子结点的最大深度 和 回传状态</span></span><br><span class="line">                left, left_status = DFS(node.left)</span><br><span class="line">                right, right_status = DFS(node.right)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 回传当前结点的最大深度 和 当前子树是否平衡的状态</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>, left_status <span class="keyword">and</span> right_status <span class="keyword">and</span> <span class="built_in">abs</span>(left-right) &lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> DFS(root)[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    其实这中code写法，和上一题7.2.4.3的思路2的解法是一致的，</span></span><br><span class="line"><span class="string">    都是在递归的时候，回传一个需要对比的值</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="7.2.5"></span></p><h2 id="7-2-5-二叉查找树"><a href="#7-2-5-二叉查找树" class="headerlink" title="7.2.5 二叉查找树"></a>7.2.5 二叉查找树</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">LeetCode 700.二叉搜索树中的搜索</a></td><td><a href="#7.2.5.1">题解7.2.5.1</a></td></tr><tr><td>①</td><td><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">LeetCode 701.二叉搜索树中的插入操作</a></td><td><a href="#7.2.5.2">题解7.2.5.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">LeetCode 450.删除二叉搜索树中的节点</a></td><td><a href="#7.2.5.3">题解7.2.5.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">LeetCode 230.二叉搜索树中第K小的元素</a></td><td><a href="#7.2.5.4">题解7.2.5.4</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指Offer 54.二叉搜索树的第k大节点</a></td><td><a href="#7.2.5.5">题解7.2.5.5</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">LeetCode 235.二叉搜索树的最近公共祖先</a></td><td><a href="#7.2.5.6">题解7.2.5.6</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">LeetCode 108.将有序数组转换为二叉搜索树</a></td><td><a href="#7.2.5.7">题解7.2.5.7</a></td></tr></tbody></table></div><p><span id="7.2.5.1"></span>  </p><h3 id="7-2-5-1-二叉搜索树中的搜索"><a href="#7-2-5-1-二叉搜索树中的搜索" class="headerlink" title="7.2.5.1 二叉搜索树中的搜索"></a>7.2.5.1 二叉搜索树中的搜索</h3><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">LeetCode 700.二叉搜索树中的搜索</a> | | <a href="#7.2.5">返回目录7.2.5</a></p><p>思路：较为简单，按照二叉树的性质：<br>如果当前结点比val大，就往去左子树找；如果当前结点比val小，就去右子树找。<br>本身就是一种二分查找。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># &#x27;&#x27;&#x27;递归&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># if not root or root.val == val:</span></span><br><span class="line">        <span class="comment">#     return root</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># if val &lt; root.val:</span></span><br><span class="line">        <span class="comment">#     # 在左子树里递归</span></span><br><span class="line">        <span class="comment">#     return self.searchBST(root.left, val)</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     # 在右子树里递归</span></span><br><span class="line">        <span class="comment">#     return self.searchBST(root.right, val) </span></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;迭代&#x27;&#x27;&#x27;</span></span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="keyword">if</span> val == node.val:</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">            <span class="keyword">elif</span>  val &lt; node.val:</span><br><span class="line">                node = node.left </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = node.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><span id="7.2.5.2"></span>  </p><h3 id="7-2-5-2-二叉搜索树中的插入操作"><a href="#7-2-5-2-二叉搜索树中的插入操作" class="headerlink" title="7.2.5.2 二叉搜索树中的插入操作"></a>7.2.5.2 二叉搜索树中的插入操作</h3><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">LeetCode 701.二叉搜索树中的插入操作</a> | | <a href="#7.2.5">返回目录7.2.5</a></p><p>思路：示例中给了两个满足条件的解决结果，会发现第二个解决方式，是对原有的树的根结点做了修改，这样操作起来可能会有点复杂；<br><b>其实可以尽量保持原来的树不动</b>，将新结点尽可能地插入到树的最后一层或者倒数第二层去。这样能保证上面的结点的关系是不变的。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertIntoBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 如果是空树，直接添加</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        </span><br><span class="line">        pos = root</span><br><span class="line">        <span class="comment"># 从根结点开始遍历</span></span><br><span class="line">        <span class="keyword">while</span> pos:</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;因为题目保证输入数据一定与原始二叉树中任一结点的值不同</span></span><br><span class="line"><span class="string">            所以只存在 大于 和 小于 两种情况， 不存在 等于 的情况</span></span><br><span class="line"><span class="string">            这里直接考虑新结点安排在某个叶子结点之后&#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> val &lt; pos.val:</span><br><span class="line">            <span class="comment"># 如果待插入的val, 小于当前结点的val, 就应该往左树上安排</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pos.left:</span><br><span class="line">                <span class="comment"># 如果左子结点为空, 刚好就放在左子结点</span></span><br><span class="line">                    pos.left = TreeNode(val)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果当前结点的左子结点不为空, 就继续向下遍历</span></span><br><span class="line">                    pos = pos.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pos.right:</span><br><span class="line">                    pos.right = TreeNode(val)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pos = pos.right</span><br><span class="line">        <span class="comment"># 可以看到code中一定是要找到某个点的 左/ 右子结点为空才插入，</span></span><br><span class="line">        <span class="comment"># 即不改变原来的结点的关系</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><span id="7.2.5.3"></span>  </p><h3 id="7-2-5-3-删除二叉搜索树中的节点"><a href="#7-2-5-3-删除二叉搜索树中的节点" class="headerlink" title="7.2.5.3 删除二叉搜索树中的节点"></a>7.2.5.3 删除二叉搜索树中的节点</h3><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">LeetCode 450.删除二叉搜索树中的节点</a>| | <a href="#7.2.5">返回目录7.2.5</a></p><p>思路：该题的每一个输入都会对应好几种不同的合理的输出，这主要取决于如何处理被删除的结点的子树。<br>这里选用一种比较简单的思路，即用右子树代替原来的子树部分，然后将原来的左子树整体搬迁的右子树的下面去；。<br>那么哪个位置合适呢？原来右子树的左下角的那个结点，将原来的左子树作为左下角结点的左子树，一定是合适的；<br>这是由BST 左 &lt; 中 &lt; 右 的性质决定的，可以在草稿上画一画。    </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root    </span><br><span class="line">        <span class="comment">######### 先查找值为 key 的结点 ##############        </span></span><br><span class="line">        node, father, tag = root, <span class="literal">None</span>, <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 在遍历的时候, 同时记录node的父结点, 以便等会儿进行新的链接操作, 如同删除链表结点那般</span></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="keyword">if</span> key == node.val:</span><br><span class="line">                <span class="comment"># 找到该结点, 退出循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span>  key &lt; node.val:</span><br><span class="line">                father = node </span><br><span class="line">                tag = <span class="string">&#x27;left&#x27;</span>    <span class="comment"># tag=left表示node是父结点的左子结点</span></span><br><span class="line">                node = node.left </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                father = node </span><br><span class="line">                tag = <span class="string">&#x27;right&#x27;</span>   <span class="comment"># tag=left表示node是父结点的右子结点</span></span><br><span class="line">                node = node.right</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="comment"># 没找到key相同的结点, 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="comment">######### 找到了值为 key 的结点 ##############</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;这里需要注意，若tag=&#x27;&#x27;，说明一上来就找到了该结点，即要删除的是root结点&#x27;&#x27;&#x27;</span>          </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="comment"># 当前结点没有子结点, 直接将该结点置空</span></span><br><span class="line">            <span class="keyword">if</span> tag == <span class="string">&#x27;&#x27;</span>:        root = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">elif</span> tag == <span class="string">&#x27;left&#x27;</span> : father.left = <span class="literal">None</span> </span><br><span class="line">            <span class="keyword">else</span>:                father.right = <span class="literal">None</span> </span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> node.left:</span><br><span class="line">            <span class="comment"># 当前结点无左子结点, 但有右子结点, 用右子结点替代当前结点即可</span></span><br><span class="line">            <span class="keyword">if</span> tag == <span class="string">&#x27;&#x27;</span>:        root = root.right</span><br><span class="line">            <span class="keyword">elif</span> tag == <span class="string">&#x27;left&#x27;</span> : father.left = node.right </span><br><span class="line">            <span class="keyword">else</span>:                father.right = node.right </span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="comment">#  当前结点无右子结点, 但有左子结点, 用左子结点替代当前结点即可</span></span><br><span class="line">            <span class="keyword">if</span> tag == <span class="string">&#x27;&#x27;</span>:        root = root.left</span><br><span class="line">            <span class="keyword">elif</span> tag == <span class="string">&#x27;left&#x27;</span> : father.left = node.left </span><br><span class="line">            <span class="keyword">else</span>:                father.right = node.left </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="comment"># 当前结点左右子结点都不为空, 就要来细节处理一下了</span></span><br><span class="line">            <span class="comment"># 本次code选择将该结点的左子树部分全部移动到右子树最下方</span></span><br><span class="line">            </span><br><span class="line">            left, right = node.left, node.right</span><br><span class="line">            <span class="comment"># 在右子树里进行遍历, 直到找到右子树里最下层的左侧结点</span></span><br><span class="line">            <span class="keyword">while</span> right.left:</span><br><span class="line">                right = right.left </span><br><span class="line">            <span class="comment"># 根据二叉搜索树的性质, 右子树部分的点的值, 一定是大于左子树部分的点的值</span></span><br><span class="line">            <span class="comment"># 所以这里直接将原来左子树, 接在右侧最下层的左边, 是一定能满足二叉搜索树的性质的</span></span><br><span class="line">            right.left = left </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 用右子树部分替代原有结点</span></span><br><span class="line">            <span class="keyword">if</span> tag == <span class="string">&#x27;&#x27;</span>:        root = root.right</span><br><span class="line">            <span class="keyword">elif</span> tag == <span class="string">&#x27;left&#x27;</span> : father.left = node.right </span><br><span class="line">            <span class="keyword">else</span>:                father.right = node.right </span><br><span class="line">        <span class="keyword">return</span> root </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>精简版代码  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root </span><br><span class="line">        </span><br><span class="line">        tag, father, node = <span class="string">&#x27;&#x27;</span>, <span class="literal">None</span>, root</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="keyword">if</span> key == node.val:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> key &lt; node.val:</span><br><span class="line">                father = node </span><br><span class="line">                tag = <span class="string">&#x27;L&#x27;</span></span><br><span class="line">                node = node.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                father = node </span><br><span class="line">                tag = <span class="string">&#x27;R&#x27;</span></span><br><span class="line">                node = node.right </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="comment"># 没有找到key对应的点</span></span><br><span class="line">            <span class="keyword">return</span> root </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">del_node</span>(<span class="params">tag, father, root, new_node</span>):</span><br><span class="line">            <span class="keyword">if</span> tag == <span class="string">&#x27;&#x27;</span>: </span><br><span class="line">                <span class="comment"># 说明是根结点要删除, 直接对根结点, 即node进行修改</span></span><br><span class="line">                root = new_node </span><br><span class="line">            <span class="keyword">elif</span> tag == <span class="string">&#x27;L&#x27;</span>: </span><br><span class="line">                <span class="comment"># node 是其父结点的左子结点</span></span><br><span class="line">                father.left = new_node</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># node 是其父结点的右子结点</span></span><br><span class="line">                father.right = new_node</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            new_node = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> node.right:</span><br><span class="line">            new_node = node.right</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">elif</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            new_node = node.left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left, right = node.left, node.right </span><br><span class="line">            <span class="keyword">while</span> right.left:</span><br><span class="line">                right = right.left  </span><br><span class="line">            right.left = left </span><br><span class="line"></span><br><span class="line">            new_node = node.right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> del_node(tag, father, root,  new_node)  </span><br><span class="line">        </span><br></pre></td></tr></table></figure><p><span id="7.2.5.4"></span>  </p><h3 id="7-2-5-4-二叉搜索树中第K小的元素"><a href="#7-2-5-4-二叉搜索树中第K小的元素" class="headerlink" title="7.2.5.4 二叉搜索树中第K小的元素"></a>7.2.5.4 二叉搜索树中第K小的元素</h3><p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指Offer 54.二叉搜索树的第k大节点</a>| | <a href="#7.2.5">返回目录7.2.5</a><br>思路：核心思想是 BST 的中序遍历是升序数列。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallest</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.最简单的思路：先求中序遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 1.1 递归</span></span><br><span class="line"><span class="string">        def inorder(node):</span></span><br><span class="line"><span class="string">            if not node:</span></span><br><span class="line"><span class="string">                return</span></span><br><span class="line"><span class="string">            inorder(node.left)</span></span><br><span class="line"><span class="string">            res.append(node.val)</span></span><br><span class="line"><span class="string">            inorder(node.right)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        res = []</span></span><br><span class="line"><span class="string">        inorder(root)</span></span><br><span class="line"><span class="string">        return res[k-1]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 1.2 迭代</span></span><br><span class="line"><span class="string">        s, res = [], [] </span></span><br><span class="line"><span class="string">        cur = root</span></span><br><span class="line"><span class="string">        while cur or s:</span></span><br><span class="line"><span class="string">            while cur:</span></span><br><span class="line"><span class="string">                s.append(cur)</span></span><br><span class="line"><span class="string">                cur = cur.left </span></span><br><span class="line"><span class="string">            cur = s.pop()</span></span><br><span class="line"><span class="string">            res.append(cur.val)</span></span><br><span class="line"><span class="string">            cur = cur.right </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return  res[k-1]</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.不用完成全部中序遍历，而在遍历的过程中计数&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 2.1 递归方案</span></span><br><span class="line"><span class="string">        def inorder(node):</span></span><br><span class="line"><span class="string">            if not node:</span></span><br><span class="line"><span class="string">                return </span></span><br><span class="line"><span class="string">            inorder(node.left)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            res[0] +=1</span></span><br><span class="line"><span class="string">            if res[0] == res[1]:</span></span><br><span class="line"><span class="string">                res.append(node.val)</span></span><br><span class="line"><span class="string">                return </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            inorder(node.right) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 用res[0]存放计数器, 用res[1]存放目标值k</span></span><br><span class="line"><span class="string">        res=[0,k]</span></span><br><span class="line"><span class="string">        inorder(root)</span></span><br><span class="line"><span class="string">        return res[-1]</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 2.2 迭代方案</span></span><br><span class="line">        s, i = [],<span class="number">0</span></span><br><span class="line">        cur = root </span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> s:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.left </span><br><span class="line">            cur= s.pop()</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == k:</span><br><span class="line">                <span class="keyword">return</span> cur.val </span><br><span class="line">            cur = cur.right </span><br></pre></td></tr></table></figure><p><span id="7.2.5.5"></span>  </p><h3 id="7-2-5-5-二叉搜索树的第k大节点"><a href="#7-2-5-5-二叉搜索树的第k大节点" class="headerlink" title="7.2.5.5 二叉搜索树的第k大节点"></a>7.2.5.5 二叉搜索树的第k大节点</h3><p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指Offer 54.二叉搜索树的第k大节点</a>| | <a href="#7.2.5">返回目录7.2.5</a></p><p>思路：上一题是求第k小，这一题是求第k大，核心原理是一样的：利用BST的中序遍历。<br>只不过这里要求第k大的话，稍微改一下中序遍历的code， 即改成 右-中-左 的形式。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthLargest</span>(<span class="params">self, root: TreeNode, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.递归方案&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># def DFS(node):</span></span><br><span class="line">        <span class="comment">#     if not node:</span></span><br><span class="line">        <span class="comment">#         return </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#     DFS(node.right)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#     res[0]+=1</span></span><br><span class="line">        <span class="comment">#     if res[0] == res[1]:</span></span><br><span class="line">        <span class="comment">#         res.append(node.val)</span></span><br><span class="line">        <span class="comment">#         return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#     DFS(node.left)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># res = [0, k]</span></span><br><span class="line">        <span class="comment"># DFS(root)</span></span><br><span class="line">        <span class="comment"># return res[-1]</span></span><br><span class="line">            </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.迭代方案&#x27;&#x27;&#x27;</span></span><br><span class="line">        s, i = [], <span class="number">0</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> s:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            cur = s.pop()</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == k:</span><br><span class="line">                <span class="keyword">return</span> cur.val </span><br><span class="line">            cur = cur.left </span><br></pre></td></tr></table></figure><p><span id="7.2.5.6"></span>  </p><h3 id="7-2-5-6-二叉搜索树的最近公共祖先"><a href="#7-2-5-6-二叉搜索树的最近公共祖先" class="headerlink" title="7.2.5.6  二叉搜索树的最近公共祖先"></a>7.2.5.6  二叉搜索树的最近公共祖先</h3><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">LeetCode 235.二叉搜索树的最近公共祖先</a>| | <a href="#7.2.5">返回目录7.2.5</a></p><p>思路：该题和 【<a href="#7.2.3.4">7.2.3.4 二叉树的最近公共祖先</a>】其实一样，所以可以直接用那道题的code；<br>但是一棵树是二叉搜索树BST时，有其特殊性，所以也有更快一点的方案。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 1.直接使用普通二叉树 最近公共祖先的code [236题]</span></span><br><span class="line"><span class="string">        if not root or root == p or root == q: </span></span><br><span class="line"><span class="string">            return root</span></span><br><span class="line"><span class="string">        # left的返回值，要么是None（即p和q都不在左子树中），要么是 p 或者q 或其最近公共祖先</span></span><br><span class="line"><span class="string">        left = self.lowestCommonAncestor(root.left, p, q)</span></span><br><span class="line"><span class="string">        # right的返回值，要么是None（即p和q都不在右子树中），要么是 p 或者q 或其最近公共祖先</span></span><br><span class="line"><span class="string">        right = self.lowestCommonAncestor(root.right, p, q)</span></span><br><span class="line"><span class="string">        if not left: </span></span><br><span class="line"><span class="string">            # 如果left是None，则p和q都不在左子树中，则p和q都在右子树中，答案就是right返回值</span></span><br><span class="line"><span class="string">            return right</span></span><br><span class="line"><span class="string">        if not right: </span></span><br><span class="line"><span class="string">            # 如果right是None，则p和q都不在右子树中，则p和q都在左子树中，答案就是left 返回值</span></span><br><span class="line"><span class="string">            return left</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">        # 如果上面两个return都没有返回，说明left和right都不为空</span></span><br><span class="line"><span class="string">        # 那么p和q分别位于 左、右子树中，最近公共祖先就应该是root</span></span><br><span class="line"><span class="string">        return root</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 依据BST自身的特性来做</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q: </span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># 如果两个点的值, 都比当前结点的值小, 那就去当前结点的左子树中寻找</span></span><br><span class="line">        <span class="keyword">if</span> p.val &lt; root.val <span class="keyword">and</span> q.val &lt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="comment"># 如果两个点的值, 都比当前结点的值大, 那就去当前结点的右子树中寻找</span></span><br><span class="line">        <span class="keyword">elif</span> p.val &gt; root.val <span class="keyword">and</span> q.val &gt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="comment"># 如果当前结点的值在p和q的值的中间, 那说明当前结点就是最近公共祖先</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><span id="7.2.5.7"></span>  </p><h3 id="7-2-5-7-将有序数组转换为二叉搜索树"><a href="#7-2-5-7-将有序数组转换为二叉搜索树" class="headerlink" title="7.2.5.7 将有序数组转换为二叉搜索树"></a>7.2.5.7 将有序数组转换为二叉搜索树</h3><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">LeetCode 108.将有序数组转换为二叉搜索树</a>| | <a href="#7.2.5">返回目录7.2.5</a></p><p>思路：BST本身就是利用二分查找思想来构建的树，所以这里直接用二分法。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;二分法的步骤&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">Bi</span>(<span class="params">L, R</span>):</span><br><span class="line">            <span class="keyword">if</span> L &gt; R:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            M = L + (R-L)//<span class="number">2</span></span><br><span class="line">            <span class="comment"># 每一次将区间 中间的数 作为当前子树的根结点</span></span><br><span class="line">            node = TreeNode(nums[M])</span><br><span class="line">            <span class="comment"># 中点左侧的数放在左子树处理</span></span><br><span class="line">            node.left = Bi(L,M-<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 中点右侧的数放在右子树处理</span></span><br><span class="line">            node.right = Bi(M+<span class="number">1</span>, R)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Bi(<span class="number">0</span>, N-<span class="number">1</span>) </span><br></pre></td></tr></table></figure><p><span id="7.2.6"></span></p><h2 id="7-2-6-前缀树"><a href="#7-2-6-前缀树" class="headerlink" title="7.2.6 前缀树"></a>7.2.6 前缀树</h2><p>前缀树即<code>Trie</code>树（发音类似 “try”），也被称为字典树，是一种树形结构。广泛应用于统计和排序大量的字符串（但不仅限于字符串）。它是根据树的路径来得到字符串，能节省存储空间，减少字符串比较，尽快地查询到需要的字符串，所以经常被用于文本词频统计。  </p><p>距离说明，现有 await, awake, award, awful, awfully 共5个单词（字符串），据此生成的前缀树如下图所示：  </p><blockquote><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/7_2_6.webp" width="50%"> </p></blockquote><p>可以观察到，对于重叠部分的子串，是可以公用树中的路径的，这样就减少了存储字符串的空间。<br>对于每一个字符串的结尾字母形成的结点，用绿色高亮表示，意味着从根结点出发的这条路径存在一个对应的字符串的，这样也就能提高查询效率。比如最右侧的路径中，第一个L和最后的Y都是高亮表示，说明该条路径存在以第一个L结尾，和Y结尾的单词。  </p><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">LeetCode 208.实现 Trie (前缀树)</a></td><td><a href="#7.2.6.1">题解7.2.6.1</a></td></tr><tr><td>①</td><td><a href="https://leetcode.cn/problems/longest-common-prefix/">LeetCode 14.最长公共前缀</a></td><td><a href="#7.2.6.2">题解7.2.6.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">LeetCode 211.添加与搜索单词 - 数据结构设计</a></td><td><a href="#7.2.6.3">题解7.2.6.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/prefix-and-suffix-search/">LeetCode 745.前缀和后缀搜索</a></td><td><a href="#7.2.6.4">题解7.2.6.4</a></td></tr></tbody></table></div><p><span id="7.2.6.1"></span>  </p><h3 id="7-2-6-1-实现-Trie-前缀树"><a href="#7-2-6-1-实现-Trie-前缀树" class="headerlink" title="7.2.6.1 实现 Trie (前缀树)"></a>7.2.6.1 实现 Trie (前缀树)</h3><p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">LeetCode 208.实现 Trie (前缀树)</a> | | <a href="#7.2.6">返回目录7.2.6</a>  </p><p>思路 1：利用链表结构来实现树，单独设计出存储字符的结点的结构：TrieNode。<br>这个结点包含两个基本属性，一个是它的子结点，另一个是它是否是结尾结点；<br>甚至还可以根据需要，增加结点的属性，比如路径权重，作为结尾的次数等等。<br>所以这个方法，从直观上来说，容易理解和接受。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 对于每个结点，一定要有子结点</span></span><br><span class="line">        <span class="comment"># 而子结点往往不像二叉树那样一般有左右两个，</span></span><br><span class="line">        <span class="comment"># 所以用一个字典来存储所有子结点</span></span><br><span class="line">        self.children = defaultdict(TrieNode)</span><br><span class="line">        <span class="comment"># 标记当且结点是否是某个字符串的结尾</span></span><br><span class="line">        self.word_tail = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 有多少个子串经过当前结点的路径</span></span><br><span class="line">        <span class="comment"># self.weight = 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 从根结点开始遍历</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="comment"># 按照子结点继续向下延伸路径</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="comment"># 因为children是用的 defaultdict 来构造</span></span><br><span class="line">            <span class="comment"># 所以不用判断cur.children中是否已存在c，如果不存在会默认构造一个TrieNode对象；详细可以参考defaultdict的用法</span></span><br><span class="line">            cur = cur.children[c]</span><br><span class="line">        <span class="comment"># 字符串最后的结点，要记得标记一下结尾</span></span><br><span class="line">        cur.is_word = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 从根结点开始遍历</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="comment"># 从子结点中尝试取得当前字符</span></span><br><span class="line">            cur = cur.children.get(c)</span><br><span class="line">            <span class="comment"># 如果子结点中没有该字符，说明不存在这样的字符串</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 如果前面的路径都存在，就要看最后的字符是否是一个结尾字符</span></span><br><span class="line">        <span class="comment"># 因为该函数是查找是否存在某个单词，而非查找前缀</span></span><br><span class="line">        <span class="comment"># 所以直接返回最后结点的“结尾状态”</span></span><br><span class="line">        <span class="keyword">return</span> cur.is_word</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 从根结点开始遍历</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="comment"># 注意这里是查找前缀，而非查找某个单词</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> prefix:</span><br><span class="line">            cur = cur.children.get(c)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 所以最后不用判断是否存在这样的单词，</span></span><br><span class="line">        <span class="comment"># 而是只要有这样的路径（前缀）即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>思路 2：利用哈希表来实现。<br>它是通过字典的嵌套来实现，即一个字符作为字典的key，而字典的value是一个新的子字典，里面包含后续的字符作为key的子字典。就是不断地在字典里面新建更深层的字典。<br>这种方法理解起来没有使用链表那么直观，但是更省内存，速度也更快。   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 初始化就是建立一个空的哈希表/字典</span></span><br><span class="line">        self.root = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word:<span class="built_in">str</span></span>)-&gt;<span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 依然是从根结点开始</span></span><br><span class="line">        <span class="comment"># 这里可以理解为从最外层往里进行深入</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">        <span class="comment"># 对于每一个来自word的字符，查看它是否已经是当前层的字典的一个key</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">            <span class="comment"># 如果当前层还没有ch这个key，那么就需要先建立一个以ch为key的子字典</span></span><br><span class="line">                cur[ch] = &#123;&#125;</span><br><span class="line">            <span class="comment"># 进入ch为key的子字典那一层</span></span><br><span class="line">            cur = cur[ch]</span><br><span class="line">        <span class="comment"># 对于最后一层字典的 &#x27;nd&#x27; 这个key，设置其value为 1，表示是一个word的结尾。</span></span><br><span class="line">        cur[<span class="string">&#x27;end&#x27;</span>] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word:<span class="built_in">str</span></span>)-&gt;<span class="built_in">bool</span>:</span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            cur = cur[ch]</span><br><span class="line">        <span class="comment"># 因为该函数是查找是否有一个word，所以要判断符合条件的路径的最后一层字典</span></span><br><span class="line">        <span class="comment"># 是否包含 end 这个key</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;end&#x27;</span> <span class="keyword">in</span> cur</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            cur  = cur[ch]</span><br><span class="line">        <span class="comment"># 因为该函数只需要判断是否存在这样的路径（前缀），所以只要中途不跳出，就一定存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><span id="7.2.6.2"></span>  </p><h3 id="7-2-6-2-最长公共前缀"><a href="#7-2-6-2-最长公共前缀" class="headerlink" title="7.2.6.2 最长公共前缀"></a>7.2.6.2 最长公共前缀</h3><p><a href="https://leetcode.cn/problems/longest-common-prefix/">LeetCode 14.最长公共前缀</a> | | <a href="#7.2.6">返回目录7.2.6</a><br>思路：找公共前缀，这里比较自然的就想到了前缀树的思路。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;使用前缀树的思路&#x27;&#x27;&#x27;</span></span><br><span class="line">        N = <span class="built_in">len</span>(strs)</span><br><span class="line">        <span class="comment"># 如果只有一个单词，那它本身就是自己的公共前缀</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        Trie = &#123;<span class="string">&quot;root&quot;</span>:&#123;&#125;&#125;</span><br><span class="line">        <span class="comment"># end_flag = &quot;#end&quot; # 该题只是判断前缀，不用查找单词，所以可以不设置结尾标识</span></span><br><span class="line">        </span><br><span class="line">        common_prefix = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> strs:</span><br><span class="line">            cur = Trie[<span class="string">&quot;root&quot;</span>]</span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="comment"># 如果原来没有这样的路径，就需要新建一个</span></span><br><span class="line">                    cur[ch] = &#123;&#125;</span><br><span class="line">                <span class="comment"># 进入ch为key的那一层</span></span><br><span class="line">                cur = cur[ch]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;weight&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="comment"># 如果当前层还没有设置过weight参数，说明是第一次到该层，初始化一下weight参数</span></span><br><span class="line">                    cur[<span class="string">&#x27;weight&#x27;</span>] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果当前层已经设置过weight参数，将ch这一层的路径权重加 1</span></span><br><span class="line">                    cur[<span class="string">&#x27;weight&#x27;</span>] += <span class="number">1</span></span><br><span class="line">                <span class="comment"># print(ch, cur[&#x27;weight&#x27;])</span></span><br><span class="line">                <span class="comment">#然后判断, 路径权重是否等于word的数目，等于的话才一定是所有word的公共路径</span></span><br><span class="line">                <span class="keyword">if</span> cur[<span class="string">&#x27;weight&#x27;</span>] == N:</span><br><span class="line">                    common_prefix += ch</span><br><span class="line">                </span><br><span class="line">            <span class="comment"># cur[end_flag] = True</span></span><br><span class="line">        <span class="keyword">return</span> common_prefix</span><br></pre></td></tr></table></figure><p><span id="7.2.6.3"></span>  </p><h3 id="7-2-6-1-添加与搜索单词-数据结构设计"><a href="#7-2-6-1-添加与搜索单词-数据结构设计" class="headerlink" title="7.2.6.1 添加与搜索单词 - 数据结构设计"></a>7.2.6.1 添加与搜索单词 - 数据结构设计</h3><p><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">LeetCode 211.添加与搜索单词 - 数据结构设计</a> | | <a href="#7.2.6">返回目录7.2.6</a></p><p>思路：利用前缀树的思路来解决。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = &#123;&#125;</span><br><span class="line">        self.end = <span class="string">&#x27;end&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addWord</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">                cur[ch] = &#123;&#125;</span><br><span class="line">            cur = cur[ch]</span><br><span class="line">        cur[self.end] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="comment"># 因为&#x27;.&#x27;相当于万能符号，所以当&#x27;.&#x27;存在的时候，要对该层的所有key进行向下的查找</span></span><br><span class="line">        <span class="comment"># 所以不是一个单路径的查找过程，故这里写成递归函数的形式，当某一条路径没有找到的时候，还能跳回上级的出发点</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">cur, w, index</span>):</span><br><span class="line">            <span class="comment"># 递归结束的条件</span></span><br><span class="line">            <span class="comment"># 因为索引是从0开始的，即待查找的的字符索引是从 0 ~ N-1,（N表示word长度）</span></span><br><span class="line">            <span class="comment"># index 为 N 的时候表示遍历完了整个待查找的的字符串</span></span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(w):</span><br><span class="line">                <span class="comment"># 如果要求匹配的是前缀, 到这里可以直接返回 True</span></span><br><span class="line">                <span class="comment"># return True</span></span><br><span class="line">                <span class="comment"># 但是由于匹配的是word，即完成的单词，就涉及到要判断当前路径是否是结尾的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> self.end <span class="keyword">not</span> <span class="keyword">in</span> cur <span class="keyword">else</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">            ch = w[index]</span><br><span class="line">            <span class="comment"># 如果不是万能字符，就按照正常处理</span></span><br><span class="line">            <span class="keyword">if</span> ch != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> cur:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">return</span> recursive(cur[ch], w, index+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果当前是万能字符，就需要对该层的每一个key向下进行搜索</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> key <span class="keyword">in</span> cur:</span><br><span class="line">                    <span class="comment"># 这个条件往往容易忽略, 如果 key ==self.end, 说明该条路线上已经没有元素了</span></span><br><span class="line">                    <span class="comment"># 就不用再顺着这条路往里面递归了</span></span><br><span class="line">                    <span class="keyword">if</span> key == self.end:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> recursive(cur[key], w, index+<span class="number">1</span>):</span><br><span class="line">                        <span class="comment"># 如果向下递归的返回值是True, 这里也就返回True</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="comment"># 遍历了当前层的所有key都没有返回True的话，最后就只好返回False了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recursive(cur, word, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><span id="7.2.6.4"></span>  </p><h3 id="7-2-6-1-前缀和后缀搜索"><a href="#7-2-6-1-前缀和后缀搜索" class="headerlink" title="7.2.6.1 前缀和后缀搜索"></a>7.2.6.1 前缀和后缀搜索</h3><p><a href="https://leetcode.cn/problems/prefix-and-suffix-search/">LeetCode 745.前缀和后缀搜索</a> | | <a href="#7.2.6">返回目录7.2.6</a></p><p>思路：前缀搜索可以用前缀树的思路，那么后缀搜索就是逆序的前缀搜索；<br>所以可以考虑使用两个前缀树，一个进行前缀存储，另一个逆序前缀（即后缀）存储、  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordFilter</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>):</span><br><span class="line">        self.trie_prefix = &#123;&#125;</span><br><span class="line">        self.trie_suff = &#123;&#125;</span><br><span class="line">        self.end = <span class="string">&#x27;end&#x27;</span></span><br><span class="line">        <span class="comment"># 调用 insert_list 函数来从words列表构建前缀树和后缀树</span></span><br><span class="line">        self.insert_list(words)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为该题的测试输入时，会出现那种反复查找重复的 前缀 prefix, 后缀 suff 的情况</span></span><br><span class="line">        <span class="comment"># 所以我这里为了提速，将查找过的结果，以 “prefix#suff” 为key, 索引值index为value，存入record字典中，</span></span><br><span class="line">        <span class="comment"># 这样之后出现重复的测试输入，就不用再去计算了</span></span><br><span class="line">        self.record = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_word</span>(<span class="params">self, root, word, index</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;具体的如何插入每个单词&#x27;&#x27;&#x27;</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="comment"># 对于路径上的每一层，要保存其出现在 words列表 中的index</span></span><br><span class="line">                cur[ch] = &#123;<span class="string">&#x27;index&#x27;</span>:[], &#125;</span><br><span class="line">            cur = cur[ch]</span><br><span class="line">            cur[<span class="string">&#x27;index&#x27;</span>].append(index)</span><br><span class="line">        cur[self.end] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_index</span>(<span class="params">self, root, substr</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;查找具有子串：substr 的单词的索引&#x27;&#x27;&#x27;</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> substr:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            cur = cur[ch]</span><br><span class="line">        <span class="keyword">return</span> cur[<span class="string">&#x27;index&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_list</span>(<span class="params">self, words</span>):        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(words)):</span><br><span class="line">            self.insert_word(self.trie_prefix, words[i], i)</span><br><span class="line">            self.insert_word(self.trie_suff, words[i][::-<span class="number">1</span>], i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self, pref: <span class="built_in">str</span>, suff: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果当前的 prefix 和 suff 的组合，在之前没有查询过，就进行以下的查询</span></span><br><span class="line">        <span class="keyword">if</span> pref + <span class="string">&#x27;#&#x27;</span> + suff <span class="keyword">not</span> <span class="keyword">in</span> self.record:</span><br><span class="line">            <span class="comment"># 在前缀树中查找该前缀的index</span></span><br><span class="line">            prefix_index = self.find_index(self.trie_prefix, pref)</span><br><span class="line">            <span class="comment"># 在后缀树中查找该后缀的index</span></span><br><span class="line">            suff_index = self.find_index(self.trie_suff, suff[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果二者其一没有找到，那就说明该样例不存在</span></span><br><span class="line">            <span class="keyword">if</span> prefix_index == -<span class="number">1</span> <span class="keyword">or</span> suff_index== -<span class="number">1</span>:</span><br><span class="line">                self.record[pref + <span class="string">&#x27;#&#x27;</span> + suff] = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果前后缀都找到各自的 index，那就求它们的交集</span></span><br><span class="line">                join_index = <span class="built_in">set</span>(prefix_index) &amp; <span class="built_in">set</span>(suff_index)</span><br><span class="line">                <span class="comment"># 如果交集大于0， 就存下最大的那个 index</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(join_index) &gt; <span class="number">0</span>:</span><br><span class="line">                    self.record[pref + <span class="string">&#x27;#&#x27;</span> + suff] = <span class="built_in">max</span>(join_index)</span><br><span class="line">                <span class="comment"># 如果不存在交集，说明该样例也不存在，存储 -1 </span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.record[pref + <span class="string">&#x27;#&#x27;</span> + suff] = -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.record[pref + <span class="string">&#x27;#&#x27;</span> + suff]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7-1 树</title>
      <link href="/Data-Structure/DS_71_tree.html"/>
      <url>/Data-Structure/DS_71_tree.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="7-1-树"><a href="#7-1-树" class="headerlink" title="7-1 树"></a>7-1 树</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>7.1.1</td><td><a href="#7.1.1">树结构</a></td></tr><tr><td>7.1.2</td><td><a href="#7.1.2">二叉树</a></td></tr><tr><td>7.1.3</td><td><a href="#7.1.3">二叉树的存储结构</a></td></tr><tr><td>7.1.4</td><td><a href="#7.1.4">二叉树的遍历方式</a></td></tr></tbody></table></div><p><span id="7.1.1"></span> </p><h2 id="7-1-1-树结构"><a href="#7-1-1-树结构" class="headerlink" title="7.1.1 树结构"></a>7.1.1 树结构</h2><h3 id="7-1-1-1-树的概念"><a href="#7-1-1-1-树的概念" class="headerlink" title="7.1.1.1 树的概念"></a>7.1.1.1 树的概念</h3><p>前面讲的都是 <strong>线性存储结构</strong>，而树是一种典型的<strong>非线性存储结构</strong>，一个元素可以有<strong>多个直接后继元素</strong>。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/7_1_1_1.webp" width="40%">   </p><p>树的一些术语如下所示：<br>|称呼|含义|<br>|—-|—-|<br>|叶子|没有后继结点的 结点称为叶子结点|<br>|子结点|某一个结点的直接后继结点|<br>|父结点|某个子结点的直接前驱结点|<br>|兄弟|具有同一父结点的 一群结点|<br>|祖先|从根结点开始走到该结点的所有上级结点，都是该结点的祖先|<br>|结点的度|直接后继结点的数目（子结点数目）|<br>|结点的层次|根结点为1，其它结点的层次等于它的父结点层次+1|<br>|树的深度|结点的最大层次值|<br>|森林|不同的树的集合；如果一棵树删除了根结点，那么剩下的子树就组成一片森林|</p><h3 id="7-1-1-2-争议问题"><a href="#7-1-1-2-争议问题" class="headerlink" title="7.1.1.2 争议问题"></a>7.1.1.2 争议问题</h3><p>关于树的根结点的数目的问题<br>这个似乎一直以来都有点矛盾，不同的书上可能说的不一样。<br>有的书说，<strong>树有且只有一个根结点</strong>，即根结点数目为1；有的书说，<strong>树的根结点可以为0</strong>，这时候称为<strong>空树</strong>。  </p><p>而且连<strong>网上的各种资料也都存在这两种说法</strong>：<br><strong>维基百科截图如下</strong>：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/7_1_1_2.webp" width="100%">  </p><p><strong>还是维基百科</strong>：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/7_1_1_3.webp" width="100%">  </p><p>按照这里的说法: 二叉树结点可以为0，普通树不行；<br>那么，二叉树是不是树？？？二叉树当然是树。所以要说【树的结点】最小可以是1还是0呢？这里感觉说法确实很难自洽。<br>那就看具体情况来回答这个问题吧，也不用过多纠结。 </p><h3 id="7-1-1-3-树的种类"><a href="#7-1-1-3-树的种类" class="headerlink" title="7.1.1.3 树的种类"></a>7.1.1.3 树的种类</h3><p>树依据不同的划分基准可以分为很多种类，这里大致罗列出常见的一些，并不完整，只是作为基本了解：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/7_1_1_4.webp" width="80%"></p><p><span id="7.1.2"></span>   </p><h2 id="7-1-2-二叉树"><a href="#7-1-2-二叉树" class="headerlink" title="7.1.2 二叉树"></a>7.1.2 二叉树</h2><p>本文简要介绍几种常见的二叉树。简单地理解，满足以下两个条件的树就是二叉树：  </p><p><b>①本身是有序树（区分左右）！！！<br>②树中包含的各个结点的度不能超过 2，即只能是 0、1 或者 2；</b></p><h3 id="7-1-2-1-满二叉树"><a href="#7-1-2-1-满二叉树" class="headerlink" title="7.1.2.1 满二叉树"></a>7.1.2.1 满二叉树</h3><table>    <tr>        <td><b>定义</b></td>        <td>如果二叉树中除了叶子结点，<b>每个结点的度都为 2</b>，则此二叉树称为满二叉树。</td>    </tr>        <tr>        <td rowspan="4"><b>性质</b></td>        <td>①满二叉树中第 k 层的结点数为 <b>2^ (k-1)</b> 个。（假设根结点层数是1）</td>    </tr>    <tr>        <td>②深度为 k 的满二叉树必有 <b>2^k - 1</b> 个结点（等比数列求和公式） ，叶子数为 <b>2^ (k-1)</b>。</td>    </tr>        <tr>        <td>③满二叉树中不存在度为 1 的结点，每一个分支点都有两棵深度相同的子树，且叶子结点都在最底层。</td>    </tr>        <tr>        <td>④具有 n 个结点的满二叉树的深度为 <b>log2(n+1)</b> </td>    </tr></table>  <h3 id="7-1-2-2-完全二叉树"><a href="#7-1-2-2-完全二叉树" class="headerlink" title="7.1.2.2 完全二叉树"></a>7.1.2.2 完全二叉树</h3><table>    <tr>        <td><b>定义</b></td>        <td>二叉树中 除去最后一层结点 为满二叉树，且最后一层的结点依次从左到右有序分布;<br>或者这么理解：一个具有n个结点的二叉树，如果其结点编号 和 一颗满二叉树的1---n个结点的编号完全一致，那这棵树就是完全二叉树。</td>    </tr>        <tr>        <td rowspan="4"><b>性质</b></td>        <td>①N 个结点的完全二叉树的深度为 <b>⌊log2  N⌋+1。</b>（向下取整再加1）</td>    </tr>    <tr>        <td>②如果将含有的结点按照层次从左到右依次标号，对于任意一个结点 i 完全二叉树，有以下几个结论成立：            <br>（首先假设<b>i=0 时，表示的是根结点</b>，无父亲结点；在python中，往往是索引从0开始计数）            <br>a. i>0 时，父亲结点为结点 <b>[(i-1)/2]</b> （向下取整）。<br><i>(在实际python的code中，用int取整即可，如果使用//向下取整，会在-0.5时取到-1,当i=0时使用//无法正确取数，所以用int向靠近0取整，能将i=0也直接统一进来)</i>            <br>b. i 结点的左孩子( 如果有的话 )是结点 2*i +1 。            <br>c. i 结点的右孩子( 如果有的话 )是结点 2*i +2。。</td></tr></table><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/7_1_2_1.webp" width="80%"></p><p>在讲排序部分和优先队列的时候，遇到的大根堆/小根堆，就是属于完全二叉树；<br>大根堆：根结点是整棵树的最大值；并且对于每一棵子树而言，其最大值也都在子树根结点<br>小根堆：根结点是整棵树的最小值；并且对于每一棵子树而言，其最小值也都在子树根结点  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/7_1_2_2.webp" width="80%"></p><h3 id="7-1-2-3-排序二叉树（二叉查找树、二叉搜索树）"><a href="#7-1-2-3-排序二叉树（二叉查找树、二叉搜索树）" class="headerlink" title="7.1.2.3 排序二叉树（二叉查找树、二叉搜索树）"></a>7.1.2.3 排序二叉树（二叉查找树、二叉搜索树）</h3><p>又称二叉查找树（Binary Search Tree - BST），亦称二叉搜索树。<br>定义为：一棵空树，或者是具有下列性质的二叉树：<br>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>（3）左、右子树也分别为二叉排序树。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/7_1_2_3.webp" width="25%"></p><p>二叉搜索树有着高效的插入、删除、查询操作。<br>平均时间的时间复杂度为 O(log n)，最差情况为 O(n)。<br>二叉搜索树与堆不同，不一定是完全二叉树，底层不容易直接用数组表示，一般是用链表来进行构造的；<br>其实二叉搜索树查找元素的过程，就是在实现“二分查找”。</p><h3 id="7-1-2-4-平衡二叉搜索树"><a href="#7-1-2-4-平衡二叉搜索树" class="headerlink" title="7.1.2.4 平衡二叉搜索树"></a>7.1.2.4 平衡二叉搜索树</h3><p>平衡二叉搜索树又被称为 AVL树，是 Adelson-Velsky and Landis Tree的缩写，分别是两个提出者的名字。<br>其实是对普通二叉搜索树的改进。考虑以下情况：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/7_1_2_4.webp" width="60%">  </p><p>右侧的情况很显然其查找时间是O(N)，但它确实是一个二叉搜索树，只是形状太极端了。<br>可以将其进行改进为AVL树，定义为一棵空树，或者是具有下列性质的二叉树：：<br>（1）本身是一棵二叉搜索树；<br>（2）<b>每个结点的左右两子树高度差都不超过一；（这就是平衡的含义）</b><br>（3）左、右子树也分别为平衡二叉搜索树。<br>称为平衡二叉搜索树。</p><p>平衡二叉搜索树就不会出现上面图(b)的这种极端情况了。<br>注意：由于维护这种高度平衡所付出的代价比从中获得的效率收益还大,故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树.（下面会提及）<br>如果应用场景中对插入删除不频繁,只是对查找要求较高,还是可以用AVL树，其查找效率是O(logN)。</p><h3 id="7-1-2-4-红黑树"><a href="#7-1-2-4-红黑树" class="headerlink" title="7.1.2.4 红黑树"></a>7.1.2.4 红黑树</h3><p>红黑树（Red Black Tree）算是对AVL树进行的一种改进，但是它的左右子树高差有可能大于 1，所以红黑树不是严格意义上的平衡二叉树（AVL），但 对之进行平衡的代价较低， 其平均统计性能要强于 AVL 。<br>红黑树的得名原因是，其结点有颜色之分，分为红色结点和黑色结点，所以每个结点要增加一个存储位表示结点的颜色，其性质如下： </p><ul><li>每个结点非红即黑.</li><li>根结点是黑的。</li><li>每个叶结点都是黑的.（叶子结点是NULL）</li><li>每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）</li><li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。  </li></ul><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/7_1_2_5_b.webp" width="80%"></p><p>红黑树的一些具体操作不在这里细讲，只需要知道： 它是查找，插入和删除效率都是(logN)。  </p><p><span id="7.1.3"></span>   </p><h2 id="7-1-3-二叉树的存储结构"><a href="#7-1-3-二叉树的存储结构" class="headerlink" title="7.1.3  二叉树的存储结构"></a>7.1.3  二叉树的存储结构</h2><h3 id="7-1-3-1-顺序存储结构"><a href="#7-1-3-1-顺序存储结构" class="headerlink" title="7.1.3.1 顺序存储结构"></a>7.1.3.1 顺序存储结构</h3><p>使用顺序表（数组）存储二叉树。需要注意的是，顺序存储只适用于完全二叉树。<br>完全二叉树的顺序存储，仅需从根结点开始，按照层次依次将树中结点存储到数组即可。<br>如果我们想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树。方法很简单，人为添加一些并不存在的空结点（其元素值为“空”），使之成为一颗完全二叉树的形式。但是这种方式明显会浪费大量内存，这时就应考虑链式存储方式。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/7_1_3_1.webp" width="40%">  </p><p>从顺序表中还原完全二叉树也很简单。我们知道，完全二叉树具有这样的性质，将树中结点按照层次并从左到右依次标号（0,1,2,3,…），若结点 i 有左右孩子，则其左孩子结点为 2 <em> i + 1，右孩子结点为 2 </em> i+ 2。此性质可用于还原数组中存储的完全二叉树。  </p><h3 id="7-1-3-2-链式存储结构"><a href="#7-1-3-2-链式存储结构" class="headerlink" title="7.1.3.2 链式存储结构"></a>7.1.3.2 链式存储结构</h3><p>只需从树的根结点开始，将各个结点及其左右孩子使用链表存储即可。不必非得是完全二叉树。下面是二叉树的二叉链表示意图：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/7_1_3_2.webp" width="70%">  </p><p>二叉树的结点：<br>其结点结构由 3 部分构成：<br>指向左孩子结点的指针（Lchild）；结点存储的数据（data）；指向右孩子结点的指针（Rchild）<br>这样的链表结构，通常称为二叉链表。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BiTNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val = <span class="literal">None</span></span>):</span><br><span class="line">        self.data = val; //数据域</span><br><span class="line">        self.lchild = <span class="literal">None</span></span><br><span class="line">        self.rchild = <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="7.1.4"></span>   </p><h2 id="7-1-4-二叉树的遍历方式"><a href="#7-1-4-二叉树的遍历方式" class="headerlink" title="7.1.4 二叉树的遍历方式"></a>7.1.4 二叉树的遍历方式</h2><h3 id="7-1-4-1-深度优先遍历"><a href="#7-1-4-1-深度优先遍历" class="headerlink" title="7.1.4.1 深度优先遍历"></a>7.1.4.1 深度优先遍历</h3><p><b>深度优先搜索(Depth First Search - DFS)</b>是沿着树的深度遍历树的结点，尽可能深的搜索树的分支。<br>那么深度遍历有重要的三种方法。这三种方式常被用于访问树的结点，它们之间的不同在于访问每个结点的次序不同。这三种遍历分别叫做<b>先序遍历（preorder），中序遍历（inorder）和后序遍历（postorder）</b>。    </p><h4 id="7-1-4-1-1-先序遍历"><a href="#7-1-4-1-1-先序遍历" class="headerlink" title="7.1.4.1.1 先序遍历"></a>7.1.4.1.1 先序遍历</h4><p>在先序遍历中，我们对每一棵子树，都是先访问其根结点，然后访问其左孩子结点，最后访问其又孩子结点。</p><p>路径为：根结点-&gt;左子树-&gt;右子树</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;递归法&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 递归法就是调用系统栈</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 对每棵子树的结构，都先访问根结点的值</span></span><br><span class="line">    res.append(root.val)</span><br><span class="line">    <span class="comment"># 然后递归地分别处理左右子结点</span></span><br><span class="line">    preorder(root.left)</span><br><span class="line">    preorder(root.right)</span><br><span class="line"></span><br><span class="line">res =[]</span><br><span class="line">preorder(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-1-4-1-2-中序遍历"><a href="#7-1-4-1-2-中序遍历" class="headerlink" title="7.1.4.1.2 中序遍历"></a>7.1.4.1.2 中序遍历</h4><p>在先序遍历中，我们对每一棵子树，都是先访问其左子结点，然后访问其根结点，最后访问其右孩子结点。</p><p>路径为：左子树-&gt;根结点-&gt;右子树<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;递归法&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 递归法就是调用系统栈</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    inorder(node.left)</span><br><span class="line">    res.append(node.val)</span><br><span class="line">    inorder(node.right)</span><br><span class="line"></span><br><span class="line">res =[]</span><br><span class="line">preorder(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h4 id="7-1-4-1-3-后序遍历"><a href="#7-1-4-1-3-后序遍历" class="headerlink" title="7.1.4.1.3 后序遍历"></a>7.1.4.1.3 后序遍历</h4><p>在先序遍历中，我们对每一棵子树，都是先访问其左子结点，然后访问其右孩子结点，最后访问其根结点。</p><p>路径为：左子树-&gt;右子树-&gt;根结点<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;递归法&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 递归法就是调用系统栈</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    postorder(node.left)</span><br><span class="line">    postorder(node.right)</span><br><span class="line">    res.append(node.val)</span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line">postorder(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="7-1-4-2-广度优先遍历-层次遍历"><a href="#7-1-4-2-广度优先遍历-层次遍历" class="headerlink" title="7.1.4.2 广度优先遍历(层次遍历)"></a>7.1.4.2 广度优先遍历(层次遍历)</h3><p><b>广度优先遍历(Breath First Search - BFS)</b>是横向遍历，即从上到下，一层一层的遍历结点。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;迭代法&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 宽度优先遍历，是利用的队列的思想，先进先出</span></span><br><span class="line"><span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">q, res = [root], []</span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">    layer =[]</span><br><span class="line">    <span class="comment"># 这个 n 其实就是在求要遍历的那一层的宽度</span></span><br><span class="line">    n = <span class="built_in">len</span>(q)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        node = q.pop(<span class="number">0</span>)</span><br><span class="line">        layer.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            q.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            q.append(node.right)</span><br><span class="line">    <span class="comment"># 根据自己想要的输出格式，选用 append 或者 extend</span></span><br><span class="line">    res.append(layer)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6-2 链表相关题目</title>
      <link href="/Data-Structure/DS_62_link_list_exercises.html"/>
      <url>/Data-Structure/DS_62_link_list_exercises.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="6-2-链表相关题目"><a href="#6-2-链表相关题目" class="headerlink" title="6-2 链表相关题目"></a>6-2 链表相关题目</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p><b>版权声明：以下题目均来自 <a href="https://leetcode.cn">LeetCode</a>， 仅仅提供跳转到力扣官网的链接，不在本页面出现题目内容，本文章内容禁止商业用途。</b></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>6.2.1</td><td><a href="#6.2.1">链表逆序部分</a></td></tr><tr><td>6.2.2</td><td><a href="#6.2.2">链表删除元素的相关题目</a></td></tr><tr><td>6.2.3</td><td><a href="#6.2.3">链表双指针</a></td></tr><tr><td>6.2.4</td><td><a href="#6.2.4">链表排序部分</a></td></tr><tr><td>6.2.5</td><td><a href="#6.2.5">链表有环与相交</a></td></tr></tbody></table></div><p><span id="6.2.1"></span>  </p><h2 id="6-2-1-链表逆序部分"><a href="#6-2-1-链表逆序部分" class="headerlink" title="6.2.1 链表逆序部分"></a>6.2.1 链表逆序部分</h2><div class="table-container"><table><thead><tr><th>序号</th><th><strong><a href="#6.2.1">链表逆序部分</a></strong></th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/reverse-linked-list/">LeetCode 206.反转链表</a></td><td><a href="#6.2.1.1">6.2.1.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">LeetCode 92.反转链表 II</a></td><td><a href="#6.2.1.2">6.2.1.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">LeetCode 25. K 个一组翻转链表</a></td><td><a href="#6.2.1.3">6.2.1.3题解</a></td></tr></tbody></table></div><p><span id="6.2.1.1"></span>  </p><h3 id="6-2-1-1-反转链表"><a href="#6-2-1-1-反转链表" class="headerlink" title="6.2.1.1 反转链表"></a>6.2.1.1 反转链表</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/">LeetCode 206.反转链表</a>| | <a href="#6.2.1">返回目录6.2.1</a></p><blockquote><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。    </p></blockquote><p>思路：链表逆序在章节6-1中已经详细讲解过了。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.递归法&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recursive_func</span>(<span class="params">node:ListNode</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">            </span><br><span class="line">            node_new = recursive_func(node.<span class="built_in">next</span>)</span><br><span class="line">            node.<span class="built_in">next</span>.<span class="built_in">next</span> = node</span><br><span class="line">            node.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> node_new</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> recursive_func(head)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归法&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 在时间和内存上的消耗比 递归法 要好</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        node_A, node_B = head, head.<span class="built_in">next</span> </span><br><span class="line">        <span class="keyword">while</span> node_B.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            node_C = node_B.<span class="built_in">next</span></span><br><span class="line">            node_B.<span class="built_in">next</span> = node_C.<span class="built_in">next</span></span><br><span class="line">            node_C.<span class="built_in">next</span> = node_A.<span class="built_in">next</span></span><br><span class="line">            node_A.<span class="built_in">next</span> = node_C</span><br><span class="line">        node_B.<span class="built_in">next</span> = node_A</span><br><span class="line">        new_head = node_A.<span class="built_in">next</span></span><br><span class="line">        node_A.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;3.非递归法-2&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 速度最快，消耗内存最少</span></span><br><span class="line">        pre, cur = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            rest = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = rest</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><p><span id="6.2.1.2"></span>  </p><h3 id="6-2-1-2-反转链表-II"><a href="#6-2-1-2-反转链表-II" class="headerlink" title="6.2.1.2 反转链表 II"></a>6.2.1.2 反转链表 II</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">LeetCode 92.反转链表 II</a>| | <a href="#6.2.1">返回目录6.2.1</a></p><p>思路：区间内反转链表，最主要的是找准区间左右边界点。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        start, node_L, pre = <span class="number">1</span>, head, <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 先找到node_L,反转起始结点</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; left:</span><br><span class="line">            pre = node_L</span><br><span class="line">            node_L = node_L.<span class="built_in">next</span></span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 采用code最简单的那个反转方式</span></span><br><span class="line">        <span class="comment"># 这里不用专门找结束位置，因为可以通过控制 i 与 right 的关系来停止</span></span><br><span class="line">        front, cur, i = <span class="literal">None</span>, node_L, left</span><br><span class="line">        <span class="keyword">while</span> i &lt;= right:</span><br><span class="line">            res = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = front</span><br><span class="line">            front = cur</span><br><span class="line">            cur = res</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 反转完成后，这一部分的起始结点就是 front结点了</span></span><br><span class="line">        <span class="comment"># 这一部分的尾结点，就是原始这一区间的开头：node_L</span></span><br><span class="line">        <span class="comment"># 还需要和 区间之后的那一部分 链接起来</span></span><br><span class="line">        node_L.<span class="built_in">next</span> = res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 还需要和 区间之前的那一部分 也链接起来  </span></span><br><span class="line">        <span class="keyword">if</span> pre: <span class="comment"># pre不为初始值none，说明不是从头结点开始反转的</span></span><br><span class="line">            pre.<span class="built_in">next</span> = front</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># pre 为none，说明是从头结点开始反转的，需要更新头结点</span></span><br><span class="line">            <span class="keyword">return</span> front </span><br></pre></td></tr></table></figure><p><span id="6.2.1.3"></span>  </p><h3 id="6-2-1-3-K个一组翻转链表"><a href="#6-2-1-3-K个一组翻转链表" class="headerlink" title="6.2.1.3 K个一组翻转链表"></a>6.2.1.3 K个一组翻转链表</h3><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">LeetCode 25. K 个一组翻转链表</a> | | <a href="#6.2.1">返回目录6.2.1</a></p><p>思路：反转链表的要点，还是要找准开始点和结束点。<br>每隔k个结点一组反转，意思是索引为 k 的倍数的结点（索引从0开始计数），是上一个区间的右边界。比如示例中的 索引2（结点3）, 索引4（结点5）；同时它也是下一次反转区间的起始结点。（如果下一次还足够反转的话）  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse_linklist</span>(<span class="params">node, k</span>):</span><br><span class="line">            <span class="comment"># 因为该题只在有限区间内进行反转，所以需要用k来控制步长</span></span><br><span class="line">            <span class="comment"># 注意反转完成后，node变成这部分的尾部结点</span></span><br><span class="line">            pre, cur = <span class="literal">None</span>, node </span><br><span class="line">            i = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cur <span class="keyword">and</span> i &lt;=k:</span><br><span class="line">                res = cur.<span class="built_in">next</span> </span><br><span class="line">                cur.<span class="built_in">next</span> = pre </span><br><span class="line">                pre = cur </span><br><span class="line">                cur = res </span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span>  pre </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果只有1个结点或者k=1，就不用做反转</span></span><br><span class="line">        <span class="keyword">if</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> head </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先在前面设立一个哑结点</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        pre, start, j = dummy, head, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> start:</span><br><span class="line">            start = start.<span class="built_in">next</span> </span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j % k == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 根据我们的分析，索引是k的倍数时，</span></span><br><span class="line">                <span class="comment"># 当前结点start是前一个区间的右边界, 也是下一个区间的起始结点</span></span><br><span class="line">                <span class="comment"># 待反转区间的起始结点用pre来控制</span></span><br><span class="line">                old_begin = pre.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 反转之后得到该区间的新的起始结点</span></span><br><span class="line">                new_begin = reverse_linklist(old_begin, k)  </span><br><span class="line">                <span class="comment"># 将新的起始结点 new_begin 与 pre 进行连接              </span></span><br><span class="line">                pre.<span class="built_in">next</span> = new_begin</span><br><span class="line">                <span class="comment"># 反转后，老的起始结点是尾结点，自然要与右边界进行链接 </span></span><br><span class="line">                old_begin.<span class="built_in">next</span> = start</span><br><span class="line">                <span class="comment"># 所以 pre 更新为start的上一个结点，现在就是 old_begin</span></span><br><span class="line">                pre = old_begin    </span><br><span class="line">        <span class="comment"># 返回哑结点之后的部分</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span> </span><br></pre></td></tr></table></figure><h2 id="6-2-2-链表删除元素的相关题目"><a href="#6-2-2-链表删除元素的相关题目" class="headerlink" title="6.2.2 链表删除元素的相关题目"></a>6.2.2 链表删除元素的相关题目</h2><p><span id="6.2.2"></span>  </p><div class="table-container"><table><thead><tr><th>序号</th><th><strong><a href="#6.2.2">链表删除元素的相关题目</a></strong></th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">LeetCode 83.删除排序链表中的重复元素</a></td><td><a href="#6.2.2.1">6.2.2.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">LeetCode 82.删除排序链表中的重复元素 II</a></td><td><a href="#6.2.2.2">6.2.2.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">LeetCode 237.删除链表中的节点</a></td><td><a href="#6.2.2.3">6.2.2.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/remove-linked-list-elements/">LeetCode 203.移除链表元素</a></td><td><a href="#6.2.2.4">6.2.2.4题解</a></td></tr></tbody></table></div><p><span id="6.2.2.1"></span>  </p><h3 id="6-2-2-1-删除排序链表中的重复元素"><a href="#6-2-2-1-删除排序链表中的重复元素" class="headerlink" title="6.2.2.1 删除排序链表中的重复元素"></a>6.2.2.1 删除排序链表中的重复元素</h3><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">LeetCode 83.删除排序链表中的重复元素</a> | | <a href="#6.2.2">返回目录6.2.2</a> </p><p>思路 1：题目中说了已排序，已经简化了问题了，也就是重复部分只要保留第一个就行。<br>如果未排序的话，可能会用到哈希表。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 使用哑结点作为虚拟头结点，就可以不用单独讨论头结点是否为空的情况</span></span><br><span class="line">        dummy = ListNode(-<span class="number">200</span>)</span><br><span class="line">        <span class="comment"># 哑结点的值取-200是因为题目中的结点值范围在-100到100间</span></span><br><span class="line">        dummy.<span class="built_in">next</span> = head </span><br><span class="line"></span><br><span class="line">        pre, cur = dummy, head </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 如果当前结点值和前一个结点值相等，就删除当前结点</span></span><br><span class="line">            <span class="keyword">if</span> pre.val == cur.val:</span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur </span><br><span class="line">            cur = cur.<span class="built_in">next</span> </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span>        </span><br></pre></td></tr></table></figure><p>思路 2 ：思路 1 的 code 的想法是，每遇到一个和 pre 重复的结点，就将它删除，这样有点费时间，比如若中间有很多个重复出现的值，就要一个一个的进行删除操作。<br>如果直接找到重复数字区域的最末尾，从末尾处断开，这样每个区域只用执行一次断开和链接操作，理论上来说会更快一点。   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line"></span><br><span class="line">        dummy = ListNode(-<span class="number">200</span>, head)</span><br><span class="line">        pre, cur = dummy, head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.<span class="built_in">next</span> :</span><br><span class="line">            <span class="comment"># 如果出现了重复，就进入下面的循环</span></span><br><span class="line">            <span class="keyword">if</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 直接将中间这段重复数值的区域全部删除</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur</span><br><span class="line">            </span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><span id="6.2.2.2"></span>  </p><h3 id="6-2-2-2-删除排序链表中的重复元素-II"><a href="#6-2-2-2-删除排序链表中的重复元素-II" class="headerlink" title="6.2.2.2 删除排序链表中的重复元素 II"></a>6.2.2.2 删除排序链表中的重复元素 II</h3><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">LeetCode 82.删除排序链表中的重复元素 II</a> | | <a href="#6.2.2">返回目录6.2.2</a></p><p>思路：这道题与上一道题的区别在于，若出现重复的元素，就将结点全部删除，而非简单的去重。<br>比较容易想到的思路是哈希表，先遍历一道元素，将value和出现的次数cnt记录入哈希表中；第二次遍历的时候就删除cnt&gt;1的val对应的node。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1. 哈希表存储&#x27;&#x27;&#x27;</span></span><br><span class="line">        hash_s = &#123;&#125;</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val <span class="keyword">in</span> hash_s:</span><br><span class="line">                hash_s[cur.val] +=<span class="number">1</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_s[cur.val] = <span class="number">0</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        dummy = ListNode(-<span class="number">200</span>, head)</span><br><span class="line">        pre, cur = dummy, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 仍然是遇到满足删除条件，就删除该结点</span></span><br><span class="line">            <span class="keyword">if</span> hash_s[cur.val] &gt; <span class="number">0</span>:</span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>思路 2：很明显哈希表的思路过于简单，可能不是它想考察的点。<br>由于该链表是已经有序的了，基于上一题的思路 2，这一次让pre位于重复区域的前方，而不是第一个结点即可。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 因为要删除重复过的结点，所以头结点可能会变化，这里就先建立一个哑结点</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        pre, cur = dummy, head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> :</span><br><span class="line">            <span class="comment"># 如果出现了重复，就进入下面的循环</span></span><br><span class="line">            <span class="keyword">if</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">                <span class="comment"># 因为我们要对比 cur 和cur.next 的值，所以while的条件要确保 cur.next 也不为None</span></span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">                    cur = cur.<span class="built_in">next</span> </span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 因为循环结束后，cur是重复区域的最后一个结点，</span></span><br><span class="line">                <span class="comment"># 如果它后面还有结点，就要将cur后移一位 </span></span><br><span class="line">                <span class="keyword">if</span> cur.<span class="built_in">next</span>: cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果没有重复就正常遍历</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur=cur.<span class="built_in">next</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span>        </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="6.2.2.3"></span>  </p><h3 id="6-2-2-3-删除链表中的节点"><a href="#6-2-2-3-删除链表中的节点" class="headerlink" title="6.2.2.3 删除链表中的节点"></a>6.2.2.3 删除链表中的节点</h3><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">LeetCode 237.删除链表中的节点</a> | | <a href="#6.2.2">返回目录6.2.2</a></p><p>思路：这个题乍一看很唬人，因为平时删除结点，都是利用 pre 指针，但此题无法访问head结点，也就无法访问pre结点，感觉好像无法做。<br>但是题目中已经在疯狂暗示解法了：<br>① 题目中明确说了【<b>注意，删除节点并不是指从内存中删除它</b>】。意思是并不用将这个结点 node 从链表中移开。<br>② 题目强调了，【<b>node 一定不是最后一个结点</b>】。那说明什么？说明 node.next 一定存在。<br>回忆一下，平常删除结点是遍历到要删除的结点 node，然后 pre.next = node.next;<br>那么我们现在知道题目给的 node 结点，也知道一定存在 node.next 结点；<br>此题在暗示不用删除 node，但是又要结点少1，那明显就是要删除 node.next 这个结点：<br>node.next = node.next.next</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type node: ListNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 先把下一个结点的值复制给node</span></span><br><span class="line">        node.val = node.<span class="built_in">next</span>.val</span><br><span class="line">        <span class="comment"># 然后删除 node的下一个结点</span></span><br><span class="line">        node.<span class="built_in">next</span> = node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><span id="6.2.2.4"></span>  </p><h3 id="6-2-2-4-移除链表元素"><a href="#6-2-2-4-移除链表元素" class="headerlink" title="6.2.2.4 移除链表元素"></a>6.2.2.4 移除链表元素</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">LeetCode 203.移除链表元素</a> | | <a href="#6.2.2">返回目录6.2.2</a></p><blockquote><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。  </p></blockquote><p>思路：比较简单,就是普通的链表删除结点操作。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 因为可能会删除首结点，所以这里搞一个哑结点</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        pre, cur = dummy, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span>  </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><span id="6.2.3"></span></p><h2 id="6-2-3-链表双指针"><a href="#6-2-3-链表双指针" class="headerlink" title="6.2.3 链表双指针"></a>6.2.3 链表双指针</h2><div class="table-container"><table><thead><tr><th>序号</th><th><strong><a href="#6.2.3">链表双指针</a></strong></th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">LeetCode 876.链表的中间结点</a></td><td><a href="#6.2.3.1">6.2.3.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/">LeetCode 2095.删除链表的中间节点</a></td><td><a href="#6.2.3.2">6.2.3.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/palindrome-linked-list/">LeetCode 234.回文链表</a></td><td><a href="#6.2.3.3">6.2.3.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">LeetCode 剑指 Offer 22.链表中倒数第k个节点</a></td><td><a href="#6.2.3.4">6.2.3.4题解</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">LeetCode 19.删除链表的倒数第 N 个结点</a></td><td><a href="#6.2.3.5">6.2.3.5题解</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/rotate-list/">LeetCode 61.旋转链表</a></td><td><a href="#6.2.3.6">6.2.3.6题解</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/add-two-numbers/description/">LeetCode 2.两数相加</a></td><td><a href="#6.2.3.7">6.2.3.7题解</a></td></tr><tr><td>⑧</td><td><a href="https://leetcode.cn/problems/add-two-numbers-ii/">LeetCode 445.两数相加II</a></td><td><a href="#6.2.3.8">6.2.3.8题解</a></td></tr></tbody></table></div><p><span id="6.2.3.1"></span>  </p><h3 id="6-2-3-1-链表的中间结点"><a href="#6-2-3-1-链表的中间结点" class="headerlink" title="6.2.3.1 链表的中间结点"></a>6.2.3.1 链表的中间结点</h3><p><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">LeetCode 876.链表的中间结点</a> | | <a href="#6.2.3">返回目录6.2.3</a></p><p>思路：这是链表快慢双指针的典型应用，即“寻找链表的中间结点”。<br>正常来讲，可以先遍历一遍链表，统计链表长度 N, 然后第二遍遍历 N/2 次基本就能找到中间结点。<br>但是使用快慢指针只需要O(N/2)即可找到中间结点。这里来稍微总结一下找链表中点的两种情况：</p><font color="green">方案一：fast指针从头结点出发，那么slow指针最后要么正好是中间点(奇数链表),要么是中间两个结点的后一个(偶数链表) 。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">slow, fast = head, head</span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">    slow = slow.<span class="built_in">next</span></span><br><span class="line">    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><font color="green">方案二：fast从第二个结点开始出发，slow最后要么正好是中间点(奇数链表),要么是中间两个结点的前一个(偶数链表)。</font>    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">slow, fast = head, head.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">    slow = slow.<span class="built_in">next</span></span><br><span class="line">    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><p><b>根据不同的需求，选用不同的fast指针起始点。</b></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">middleNode</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;由于此题要找的是 中间or偏后的结点，所以选用上述的方案 一 &#x27;&#x27;&#x27;</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="6.2.3.2"></span>  </p><h3 id="6-2-3-2-删除链表的中间节点"><a href="#6-2-3-2-删除链表的中间节点" class="headerlink" title="6.2.3.2 删除链表的中间节点"></a>6.2.3.2 删除链表的中间节点</h3><p><a href="https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/">LeetCode 2095.删除链表的中间节点</a> | | <a href="#6.2.3">返回目录6.2.3</a></p><p>思路：这里要删除的是中间链表，或者是中间两个链表中的右侧链表。所以采取之前讲过的方案一，来寻求中间结点。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteMiddle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 因为可能会删除首结点，所以这里搞一个哑结点</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        <span class="comment"># fast从头结点开始，</span></span><br><span class="line">        pre, slow, fast = dummy, head, head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            pre = slow</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># slow就是我们要删除的那个中间点    </span></span><br><span class="line">        pre.<span class="built_in">next</span> = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><span id="6.2.3.3"></span>  </p><h3 id="6-2-3-3-回文链表"><a href="#6-2-3-3-回文链表" class="headerlink" title="6.2.3.3 回文链表"></a>6.2.3.3 回文链表</h3><p><a href="https://leetcode.cn/problems/palindrome-linked-list/">LeetCode 234.回文链表</a> | | <a href="#6.2.3">返回目录6.2.3</a></p><p>思路：所谓回文链表，就是指链表的前后两半数据，是不是以中间轴为对称的关系。<br>换句话说，只要将链表的后一半数据逆序，然后看看与前一半是否相等，即可。<br>后一半的起始结点如何判断？  </p><ol><li><p>如果链表个数为奇数，那么就是中间那个结点本身为对称轴，既不算在前一半，也不算在后一半。后一半从中间结点的下一个开始算起。  </p></li><li><p>如果链表个数为偶数，那么中间的两个结点之间为对称轴，两个结点中的右侧的结点是后一半的起始结点。  </p></li></ol><p>为了统一表达形式，可以看做两个结点中的左侧结点的下一个结点，是后一半的起始结点。  </p><p>故此，我们需要找到中间结点（奇数个链表结点），或者中间左侧结点（偶数个链表结点）—&gt; 这就是上面提到的链表中点的 【方案二】；<br>然后取该结点的下一位，作为后一半的“头结点”，表达形式就完成统一了。<br>然后只需要将后一半的逆序，再与前一半一一对比即可。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        slow, fast = head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast= fast.<span class="built_in">next</span>.<span class="built_in">next</span> </span><br><span class="line">        <span class="comment"># 循环结束后，slow指向中间结点，或者中间两个中靠左侧的结点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将右侧的链表进行逆序</span></span><br><span class="line">        pre, cur = <span class="literal">None</span>, slow.<span class="built_in">next</span> </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            rest = cur.<span class="built_in">next</span> </span><br><span class="line">            cur.<span class="built_in">next</span> = pre </span><br><span class="line">            pre = cur </span><br><span class="line">            cur = rest</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 左右两部分进行对比</span></span><br><span class="line">        left, right = head, pre </span><br><span class="line">        <span class="keyword">while</span> right:</span><br><span class="line">            <span class="keyword">if</span> right.val != left.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            right = right.<span class="built_in">next</span> </span><br><span class="line">            left = left.<span class="built_in">next</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        每个循环都只遍历了 一半的链表，所以时间复杂度是O(3N/2)-&gt;O(N)</span></span><br><span class="line"><span class="string">        只使用了有限个辅助变量，空间复杂度是O(1)</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><span id="6.2.3.4"></span>  </p><h3 id="6-2-3-4-链表中倒数第k个节点"><a href="#6-2-3-4-链表中倒数第k个节点" class="headerlink" title="6.2.3.4 链表中倒数第k个节点"></a>6.2.3.4 链表中倒数第k个节点</h3><p><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">LeetCode 剑指 Offer 22.链表中倒数第k个节点</a> | | <a href="#6.2.3">返回目录6.2.3</a></p><p>思路：利用快慢指针，快指针先走K步之后（遍历完k个结点），慢指针再启动；（即快指针指向k+1结点的时候，慢指针指向head结点）<br>此时还剩下 n-k 个结点，等快指针遍历完序要遍历 n-k 次（此时快指针指向None结点）；<br>慢指针也走了 n-k 次，当前正好指向倒数第k个结点。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getKthFromEnd</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> head </span><br><span class="line"></span><br><span class="line">        fast, slow = head, head </span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            <span class="keyword">if</span> cnt &gt; k:</span><br><span class="line">                <span class="comment"># 慢指针仅在快指针超过k个点的情况下才往后遍历</span></span><br><span class="line">                slow = slow.<span class="built_in">next</span> </span><br><span class="line">            fast = fast.<span class="built_in">next</span> </span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow </span><br><span class="line">        </span><br></pre></td></tr></table></figure><p><span id="6.2.3.5"></span>  </p><h3 id="6-2-3-5-删除链表的倒数第-N-个结点"><a href="#6-2-3-5-删除链表的倒数第-N-个结点" class="headerlink" title="6.2.3.5 删除链表的倒数第 N 个结点"></a>6.2.3.5 删除链表的倒数第 N 个结点</h3><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">LeetCode 19.删除链表的倒数第 N 个结点</a> | | <a href="#6.2.3">返回目录6.2.3</a></p><p>思路：和上一题的本质是一样的，先要定位到倒数第 k 个结点，然后再做删除操作。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>,head)</span><br><span class="line">        fast, slow, pre = head, head, dummy</span><br><span class="line">        k = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            <span class="comment"># 慢指针仅在快指针超过k个点的情况下才往后遍历</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n:</span><br><span class="line">                pre = pre.<span class="built_in">next</span></span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            k+=<span class="number">1</span></span><br><span class="line">        pre.<span class="built_in">next</span> = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><span id="6.2.3.6"></span>  </p><h3 id="6-2-3-6-旋转链表"><a href="#6-2-3-6-旋转链表" class="headerlink" title="6.2.3.6 旋转链表"></a>6.2.3.6 旋转链表</h3><p><a href="https://leetcode.cn/problems/rotate-list/">LeetCode 61.旋转链表</a> | | <a href="#6.2.3">返回目录6.2.3</a></p><p>思路：观察示例可以发现，旋转后的链表，其实新的头结点，就是原来的倒数第 k 个结点。所以本质思路和上面两道题是一样的，只不过这里要注意，k 可能会大于链表长度，所以要先遍历一道链表，确定其长度，然后再对k求模。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotateRight</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> head </span><br><span class="line">        <span class="comment"># 1.计算链表长度</span></span><br><span class="line">        cnt, cur = <span class="number">1</span>, head </span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            cnt+=<span class="number">1</span></span><br><span class="line">            cur= cur.<span class="built_in">next</span> </span><br><span class="line">        <span class="comment"># cur 此时指向最后一个结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2.求模</span></span><br><span class="line">        N = k % cnt </span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> head </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3.原链表首尾相连成环</span></span><br><span class="line">        cur.<span class="built_in">next</span> = head</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 向右移动 k 个位置，其实等效于成环之后，原倒数第k个结点做新的头结点</span></span><br><span class="line">        <span class="comment"># 所以问题转化为 定位倒数第 k 个结点</span></span><br><span class="line">        fast, slow, pre = head, head, cur</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= cnt:</span><br><span class="line">            <span class="keyword">if</span> i &gt; N:</span><br><span class="line">                pre = pre.<span class="built_in">next</span></span><br><span class="line">                slow = slow.<span class="built_in">next</span> </span><br><span class="line">            fast = fast.<span class="built_in">next</span>  </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 此时slow指向倒数第k个结点，可以作为新的头结点，在此处断开环</span></span><br><span class="line">        pre.<span class="built_in">next</span> = <span class="literal">None</span> </span><br><span class="line">        <span class="keyword">return</span> slow </span><br></pre></td></tr></table></figure><p><span id="6.2.3.7"></span>  </p><h3 id="6-2-3-7-两数相加"><a href="#6-2-3-7-两数相加" class="headerlink" title="6.2.3.7 两数相加"></a>6.2.3.7 两数相加</h3><p><a href="https://leetcode.cn/problems/add-two-numbers/description/">LeetCode 2.两数相加</a>| | <a href="#6.2.3">返回目录6.2.3</a></p><p>思路：此题和 【LeetCode 415.字符串相加】这一题本质是一样的，区别在于，我们无法直接获得链表的长度。但是由于题目中提及是逆序存储的数字，且返回的也是相同形式（即逆序）相当于简化了这个题。只要每个位置对应相加即可。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line"></span><br><span class="line">        cur1, cur2, dummy = l1, l2, ListNode(<span class="number">0</span>)</span><br><span class="line">        add = <span class="number">0</span></span><br><span class="line">        pre = dummy</span><br><span class="line">        <span class="keyword">while</span> add&gt;<span class="number">0</span> <span class="keyword">or</span> cur1 <span class="keyword">or</span> cur2:</span><br><span class="line">            <span class="keyword">if</span> cur1: </span><br><span class="line">                a = cur1.val </span><br><span class="line">                cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur2: </span><br><span class="line">                b = cur2.val </span><br><span class="line">                cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            digit = (a+b+add) % <span class="number">10</span></span><br><span class="line">            add = (a+b+add-digit) // <span class="number">10</span></span><br><span class="line">            pre.<span class="built_in">next</span> = ListNode(digit) </span><br><span class="line">            pre = pre.<span class="built_in">next</span> </span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><span id="6.2.3.8"></span>  </p><h3 id="6-2-3-8-两数相加II"><a href="#6-2-3-8-两数相加II" class="headerlink" title="6.2.3.8 两数相加II"></a>6.2.3.8 两数相加II</h3><p><a href="https://leetcode.cn/problems/add-two-numbers-ii/">LeetCode 445.两数相加II</a>| | <a href="#6.2.3">返回目录6.2.3</a></p><p>思路：此题是上一题的升级版，因为顺序变成正序了。可以先反转两个链表，然后基本就和上一题差不多。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse_linklist</span>(<span class="params">head</span>):</span><br><span class="line">            pre, cur = <span class="literal">None</span>, head </span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                rest = cur.<span class="built_in">next</span> </span><br><span class="line">                cur.<span class="built_in">next</span> = pre</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = rest </span><br><span class="line">            <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">        cur1, cur2 = reverse_linklist(l1), reverse_linklist(l2)</span><br><span class="line">        <span class="comment"># pre = dummy</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;可以选择上一题一样的做法，先逆序构造链表，然后在调用逆序函数处理一次；</span></span><br><span class="line"><span class="string">        但是这样时间消耗的有点多；</span></span><br><span class="line"><span class="string">        所以对code做了一点改动，生成链表的时候，直接逆序着生成&#x27;&#x27;&#x27;</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> add&gt;<span class="number">0</span> <span class="keyword">or</span> cur1 <span class="keyword">or</span> cur2:</span><br><span class="line">            <span class="keyword">if</span> cur1: </span><br><span class="line">                a = cur1.val </span><br><span class="line">                cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> cur2: </span><br><span class="line">                b = cur2.val </span><br><span class="line">                cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            digit = (a+b+add) % <span class="number">10</span></span><br><span class="line">            add = (a+b+add-digit) // <span class="number">10</span></span><br><span class="line">            <span class="comment"># pre.next = ListNode(digit) </span></span><br><span class="line">            cur = ListNode(digit)</span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur </span><br><span class="line"></span><br><span class="line">        <span class="comment"># return reverse_linklist(dummy.next)</span></span><br><span class="line">        <span class="keyword">return</span> pre </span><br></pre></td></tr></table></figure><p><span id="6.2.4"></span>  </p><h2 id="6-2-4-链表排序部分"><a href="#6-2-4-链表排序部分" class="headerlink" title="6.2.4 链表排序部分"></a>6.2.4 链表排序部分</h2><div class="table-container"><table><thead><tr><th>序号</th><th><strong><a href="#6.2.4">链表排序部分</a></strong></th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">LeetCode 21.合并两个有序链表</a></td><td><a href="#6.2.4.1">6.2.4.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">LeetCode 23.合并 K 个升序链表</a></td><td><a href="#6.2.4.2">6.2.4.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/sort-list/">LeetCode 148.排序链表</a></td><td><a href="#6.2.4.3">6.2.4.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/insertion-sort-list/">LeetCode 147.对链表进行插入排序</a></td><td><a href="#6.2.4.4">6.2.4.4题解</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/odd-even-linked-list/">LeetCode 328.奇偶链表</a></td><td><a href="#6.2.4.5">6.2.4.5题解</a></td></tr></tbody></table></div><p><span id="6.2.4.1"></span>  </p><h3 id="6-2-4-1-合并两个有序链表"><a href="#6-2-4-1-合并两个有序链表" class="headerlink" title="6.2.4.1 合并两个有序链表"></a>6.2.4.1 合并两个有序链表</h3><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">LeetCode 21.合并两个有序链表</a>| |<a href="#6.2.4">返回目录6.2.4</a> </p><p>思路1 ：对于两个有序部分合并成一个新的有序部分，很自然会想到归并排序中的归并操作。   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1 <span class="keyword">and</span> <span class="keyword">not</span> list2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> list1:</span><br><span class="line">            <span class="keyword">return</span> list2</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> list2:</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur1, cur2 = list1, list2</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;1.利用辅助数组&#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="comment"># q = []</span></span><br><span class="line">            <span class="comment"># while cur1 and cur2:</span></span><br><span class="line">            <span class="comment">#     if cur1.val &lt;= cur2.val:</span></span><br><span class="line">            <span class="comment">#         q.append(cur1)</span></span><br><span class="line">            <span class="comment">#         cur1 = cur1.next</span></span><br><span class="line">            <span class="comment">#     else:</span></span><br><span class="line">            <span class="comment">#         q.append(cur2)</span></span><br><span class="line">            <span class="comment">#         cur2 = cur2.next</span></span><br><span class="line">            <span class="comment"># while cur1:</span></span><br><span class="line">            <span class="comment">#     q.append(cur1)</span></span><br><span class="line">            <span class="comment">#     cur1 = cur1.next</span></span><br><span class="line">            <span class="comment"># while cur2:</span></span><br><span class="line">            <span class="comment">#     q.append(cur2)</span></span><br><span class="line">            <span class="comment">#     cur2 = cur2.next</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># head = q.pop(0)</span></span><br><span class="line">            <span class="comment"># cur = head</span></span><br><span class="line">            <span class="comment"># while q:</span></span><br><span class="line">            <span class="comment">#     node = q.pop(0)</span></span><br><span class="line">            <span class="comment">#     cur.next = node</span></span><br><span class="line">            <span class="comment">#     cur = cur.next</span></span><br><span class="line">            <span class="comment"># cur.next = None</span></span><br><span class="line">            <span class="comment"># return head</span></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;2.不用辅助数组，只用几个辅助node&#x27;&#x27;&#x27;</span></span><br><span class="line">            dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">            pre = dummy</span><br><span class="line">            <span class="keyword">while</span> cur1 <span class="keyword">and</span> cur2:</span><br><span class="line">                <span class="keyword">if</span> cur1.val &lt;= cur2.val:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur1</span><br><span class="line">                    pre = cur1</span><br><span class="line">                    cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur2</span><br><span class="line">                    pre = cur2</span><br><span class="line">                    cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> cur1:</span><br><span class="line">                <span class="comment"># 如果此时cur1不为空，说明上面最后一个node一定来自于cur2</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur1</span><br><span class="line">            <span class="keyword">if</span> cur2:</span><br><span class="line">                <span class="comment"># 如果此时cur2不为空，说明上面最后一个node一定来自于cur1</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur2</span><br><span class="line">            <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>思路2: 递归操作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> list1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> list2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> list1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> list2</span><br><span class="line">        <span class="keyword">elif</span> list2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">elif</span> list1.val &lt;= list2.val:</span><br><span class="line">            <span class="comment"># 当前list1点的值更小, 那么就让list1的后面部分去和list2做过合并</span></span><br><span class="line">            list1.<span class="built_in">next</span> = self.mergeTwoLists(list1.<span class="built_in">next</span>,list2)</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 当前list2点的值更小, 那么就让list2的后面部分去和list1做过合并</span></span><br><span class="line">            list2.<span class="built_in">next</span> = self.mergeTwoLists(list1,list2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> list2</span><br></pre></td></tr></table></figure><p><span id="6.2.4.2"></span>  </p><h3 id="6-2-4-2-合并-K-个升序链表"><a href="#6-2-4-2-合并-K-个升序链表" class="headerlink" title="6.2.4.2 合并 K 个升序链表"></a>6.2.4.2 合并 K 个升序链表</h3><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">LeetCode 23.合并 K 个升序链表</a>| | <a href="#6.2.4">返回目录6.2.4</a></p><p>思路1：该题是上题的加强版，从合并2个链表变为合并k个链表。那么比较自然的想法就是，先写出合并两个链表的函数，再对链表的list进行依次两两合并即可。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 直接复用上一题的合并两个链表的函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge_two_linklist</span>(<span class="params">head1: <span class="type">Optional</span>[ListNode], head2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head1 <span class="keyword">and</span> <span class="keyword">not</span> head2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> head1:</span><br><span class="line">                <span class="keyword">return</span> head2</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> head2:</span><br><span class="line">                <span class="keyword">return</span> head1</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">                pre = dummy</span><br><span class="line">                cur1, cur2 = head1, head2</span><br><span class="line">                <span class="keyword">while</span> cur1 <span class="keyword">and</span> cur2:</span><br><span class="line">                    <span class="keyword">if</span> cur1.val &lt; cur2.val:</span><br><span class="line">                        pre.<span class="built_in">next</span> = cur1</span><br><span class="line">                        pre = pre.<span class="built_in">next</span></span><br><span class="line">                        cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        pre.<span class="built_in">next</span> = cur2</span><br><span class="line">                        pre = pre.<span class="built_in">next</span></span><br><span class="line">                        cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> cur1:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur1</span><br><span class="line">                <span class="keyword">if</span> cur2:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur2</span><br><span class="line">            <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 思路1：从头到尾依次两两合并，耗费时间明显会很多</span></span><br><span class="line">        res_node = lists[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(lists)):</span><br><span class="line">            res_node = merge_two_linklist(res_node, lists[i])</span><br><span class="line">        <span class="keyword">return</span> res_node</span><br></pre></td></tr></table></figure><p>思路 2：两两之间先合并，然后合并后的链表再两两之间合并。<br>换句话说，就是使用二分法，进行递归操作，减少时间复杂度。   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 直接复用上一题的合并两个链表的函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge_two_linklist</span>(<span class="params">head1: <span class="type">Optional</span>[ListNode], head2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head1 <span class="keyword">and</span> <span class="keyword">not</span> head2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> head1:</span><br><span class="line">                <span class="keyword">return</span> head2</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> head2:</span><br><span class="line">                <span class="keyword">return</span> head1</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">                pre = dummy</span><br><span class="line">                cur1, cur2 = head1, head2</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> cur1 <span class="keyword">and</span> cur2:</span><br><span class="line">                    <span class="keyword">if</span> cur1.val &lt; cur2.val:</span><br><span class="line">                        pre.<span class="built_in">next</span> = cur1</span><br><span class="line">                        pre = pre.<span class="built_in">next</span></span><br><span class="line">                        cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        pre.<span class="built_in">next</span> = cur2</span><br><span class="line">                        pre = pre.<span class="built_in">next</span></span><br><span class="line">                        cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> cur1:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur1</span><br><span class="line">                <span class="keyword">if</span> cur2:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur2</span><br><span class="line">            <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 思路2： 既然是两两合并，很明显可以用二分法的思想，分而治之，用递归进行，耗时明显下降</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge_k_linklist</span>(<span class="params">lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]], Left:<span class="built_in">int</span>, Right:<span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">            <span class="keyword">if</span> Left == Right:</span><br><span class="line">                <span class="keyword">return</span> lists[Left]</span><br><span class="line">            M = (Right-Left)//<span class="number">2</span> + Left</span><br><span class="line"></span><br><span class="line">            L_node = merge_k_linklist(lists, Left, M)</span><br><span class="line">            R_node = merge_k_linklist(lists, M+<span class="number">1</span>, Right)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> merge_two_linklist(L_node, R_node)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  merge_k_linklist(lists, <span class="number">0</span>, <span class="built_in">len</span>(lists)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><span id="6.2.4.3"></span>  </p><h3 id="6-2-4-3-排序链表"><a href="#6-2-4-3-排序链表" class="headerlink" title="6.2.4.3 排序链表"></a>6.2.4.3 排序链表</h3><p><a href="https://leetcode.cn/problems/sort-list/">LeetCode 148.排序链表</a>| | <a href="#6.2.4">返回目录6.2.4</a></p><p>思路：可以使用归并排序的思路。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">MergeTwoList</span>(<span class="params">list1:<span class="type">Optional</span>[ListNode], list2:<span class="type">Optional</span>[ListNode]</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> list1 <span class="keyword">and</span> <span class="keyword">not</span> list2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> list2:</span><br><span class="line">                <span class="keyword">return</span> list1</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> list1:</span><br><span class="line">                <span class="keyword">return</span> list2</span><br><span class="line">            <span class="keyword">elif</span> list1 == list2:</span><br><span class="line">                <span class="keyword">return</span> list1 </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 因为考虑到要使用递归操作，所以这里不创建哑结点</span></span><br><span class="line">                <span class="comment"># 否则可能会创建很多无用的哑结点，浪费内存</span></span><br><span class="line">                cur1, cur2 = list1, list2 </span><br><span class="line">                <span class="keyword">if</span> cur1.val &lt;= cur2.val:</span><br><span class="line">                    head, cur1 = cur1, cur1.<span class="built_in">next</span> </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    head, cur2 = cur2, cur2.<span class="built_in">next</span></span><br><span class="line">                pre = head </span><br><span class="line">                <span class="keyword">while</span> cur1 <span class="keyword">and</span> cur2:</span><br><span class="line">                    <span class="keyword">if</span> cur1.val &lt;= cur2.val:</span><br><span class="line">                        pre.<span class="built_in">next</span> = cur1 </span><br><span class="line">                        pre = pre.<span class="built_in">next</span></span><br><span class="line">                        cur1 = cur1.<span class="built_in">next</span> </span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        pre.<span class="built_in">next</span> = cur2 </span><br><span class="line">                        pre = pre.<span class="built_in">next</span></span><br><span class="line">                        cur2 = cur2.<span class="built_in">next</span> </span><br><span class="line">                <span class="keyword">if</span> cur1:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur1 </span><br><span class="line">                <span class="keyword">if</span> cur2:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur2 </span><br><span class="line">            <span class="keyword">return</span> head </span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">MergeSort</span>(<span class="params">start, end</span>):</span><br><span class="line">            <span class="keyword">if</span> start <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> start.<span class="built_in">next</span> == end:</span><br><span class="line">                <span class="comment"># 在定义的MergeSort函数的时候，规定的是end位置的结点是不取的</span></span><br><span class="line">                <span class="comment"># 比如最外层调用时传入的是 MergeSort(head, None)</span></span><br><span class="line">                <span class="comment"># 所以 start.next == end 的情况，就是在说，当前部分只有一个结点</span></span><br><span class="line">                <span class="comment"># 同时一定要注意，需要在这里将start彻底断开，使其真的成为一个孤立结点</span></span><br><span class="line">                start.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">return</span> start</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 然后使用快慢指针寻找中间结点</span></span><br><span class="line">            slow, fast = start, start</span><br><span class="line">            <span class="comment"># 需要注意的是此时 fast的终点是 end，一定不要遗漏这一点</span></span><br><span class="line">            <span class="keyword">while</span> fast != end <span class="keyword">and</span> fast.<span class="built_in">next</span> != end:</span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">                fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># slow指向中间结点，或者中间二结点的右边那个结点</span></span><br><span class="line">            mid = slow</span><br><span class="line">            </span><br><span class="line">            left_h = MergeSort(start,mid)</span><br><span class="line">            <span class="comment"># 这里也要注意，右侧的起始点是 mid，因为根据定义左侧部分是不取mid结点的</span></span><br><span class="line">            right_h = MergeSort(mid, end)</span><br><span class="line">            <span class="keyword">return</span> merge_two_linklist(left_h, right_h)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># MergeSort函数也有另一种写法，即末尾head2规定可以取到的情况</span></span><br><span class="line">        <span class="comment"># def MergeSort(head1, head2):</span></span><br><span class="line">        <span class="comment">#     if head1 is None or  head1.next is None:</span></span><br><span class="line">        <span class="comment">#         return head1</span></span><br><span class="line">        <span class="comment">#     if head1 == head2:</span></span><br><span class="line">        <span class="comment">#     # 此时，判断是否是一个结点的条件就变为了 head1==head2</span></span><br><span class="line">        <span class="comment">#     # 同样要将 head1 断开</span></span><br><span class="line">        <span class="comment">#         head1.next = None</span></span><br><span class="line">        <span class="comment">#         return head1</span></span><br><span class="line">        <span class="comment">#     # 然后快慢结点的写法也稍作修改，找寻中间二结点中左侧的那个结点</span></span><br><span class="line">        <span class="comment">#     slow, fast = head1, head1.next</span></span><br><span class="line">        <span class="comment">#     while fast != head2 and fast.next != head2:</span></span><br><span class="line">        <span class="comment">#         slow = slow.next</span></span><br><span class="line">        <span class="comment">#         fast = fast.next.next</span></span><br><span class="line">        <span class="comment">#     left_end = slow</span></span><br><span class="line">        <span class="comment">#     right_start = slow.next</span></span><br><span class="line">        <span class="comment">#     # 因为规定了head2部分可以取到，所以left_end就要填入左侧的递归函数中</span></span><br><span class="line">        <span class="comment">#     left_h = MergeSort(head1, left_end)</span></span><br><span class="line">        <span class="comment">#     right_h = MergeSort(right_start, head2)</span></span><br><span class="line">        <span class="comment">#     return merge_two_linklist(left_h, right_h)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> MergeSort(head, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><span id="6.2.4.4"></span>  </p><h3 id="6-2-4-4-对链表进行插入排序"><a href="#6-2-4-4-对链表进行插入排序" class="headerlink" title="6.2.4.4 对链表进行插入排序"></a>6.2.4.4 对链表进行插入排序</h3><p><a href="https://leetcode.cn/problems/insertion-sort-list/">LeetCode 147.对链表进行插入排序</a>| |<a href="#6.2.4">返回目录6.2.4</a></p><p>思路：因如果链表只有一个结点，默认有序；<br>所以我们从第二个结点开始遍历，每一次都需要去该结点之前，对比数字的大小，并在适当的位置进行结点插入。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertionSortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        <span class="comment"># 从第二个结点开始遍历</span></span><br><span class="line">        tail, cur = head, head.<span class="built_in">next</span> </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> tail.val &lt;= cur.val:</span><br><span class="line">                <span class="comment"># 先就近对比tail和cur</span></span><br><span class="line">                tail = cur</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 将cur从链表中先断开</span></span><br><span class="line">                tail.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 从head开始到tail之前找</span></span><br><span class="line">                pre = dummy</span><br><span class="line">                <span class="keyword">while</span> pre.<span class="built_in">next</span>.val &lt;= cur.val:</span><br><span class="line">                    pre = pre.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 因为上面先判断了和tail的大小关系</span></span><br><span class="line">                <span class="comment"># 所以此处的while循环，一定会在tail之前停下来</span></span><br><span class="line">                <span class="comment"># 此时 pre.next.val &gt; cur.val</span></span><br><span class="line">                <span class="comment"># 所以 cur 将会在pre和pre.next中间插入</span></span><br><span class="line">                cur.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur</span><br><span class="line">            <span class="comment"># 更新cur</span></span><br><span class="line">            cur = tail.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span> </span><br></pre></td></tr></table></figure><p><span id="6.2.4.5"></span>  </p><h3 id="6-2-4-5-奇偶链表"><a href="#6-2-4-5-奇偶链表" class="headerlink" title="6.2.4.5 奇偶链表"></a>6.2.4.5 奇偶链表</h3><p><a href="https://leetcode.cn/problems/odd-even-linked-list/">LeetCode 328.奇偶链表</a>| | <a href="#6.2.4">返回目录6.2.4</a></p><p>思路：创建两个头结点，一个用来连接奇数结点，另一个用来链接偶数结点。最后将两个链表合并。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">oddEvenList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span> <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            <span class="comment"># 如果结点数是0、1、2 直接返回head</span></span><br><span class="line">            <span class="keyword">return</span> head </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># odd, even = head, head.next </span></span><br><span class="line">        <span class="comment"># 创建两个哑结点，分别作为 奇偶链表的头结点</span></span><br><span class="line">        dummy_odd = ListNode(<span class="number">0</span>,head)</span><br><span class="line">        dummy_even = ListNode(<span class="number">0</span>,head.<span class="built_in">next</span>)</span><br><span class="line">        pre_odd, pre_even, cur = dummy_odd, dummy_even, head</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 遍历的时候判断当前是 奇数 还是 偶数 即可</span></span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                pre_odd.<span class="built_in">next</span> = cur </span><br><span class="line">                pre_odd = cur </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre_even.<span class="built_in">next</span> = cur </span><br><span class="line">                pre_even = cur </span><br><span class="line">            cur = cur.<span class="built_in">next</span> </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        pre_odd.<span class="built_in">next</span> = dummy_even.<span class="built_in">next</span> </span><br><span class="line">        pre_even.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 这里很容易忘记给 pre_even.next 改为 None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy_odd.<span class="built_in">next</span> </span><br></pre></td></tr></table></figure><p><span id="6.2.5"></span>  </p><h2 id="6-2-5-链表有环与相交"><a href="#6-2-5-链表有环与相交" class="headerlink" title="6.2.5 链表有环与相交"></a>6.2.5 链表有环与相交</h2><div class="table-container"><table><thead><tr><th>序号</th><th><strong><a href="#6.2.5">链表有环与相交</a></strong></th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/linked-list-cycle/">LeetCode 141.环形链表</a></td><td><a href="#6.2.5.1">6.2.5.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">LeetCode 142.环形链表II</a></td><td><a href="#6.2.5.2">6.2.5.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">LeetCode 160.相交链表</a></td><td><a href="#6.2.5.3">6.2.5.3题解</a></td></tr><tr><td>④</td><td><a href="##6.2.5.4">有环链表相交的情况</a></td><td><a href="#6.2.5.4">6.2.5.4题解</a></td></tr></tbody></table></div><p><span id="6.2.5.1"></span>  </p><h3 id="6-2-5-1-环形链表"><a href="#6-2-5-1-环形链表" class="headerlink" title="6.2.5.1 环形链表"></a>6.2.5.1 环形链表</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle/">LeetCode 141.环形链表</a>| | <a href="#6.2.5">返回目录6.2.5</a></p><p>思路：使用快慢指针，一个跑得快，一个跑得慢，如果快指针反而与慢指针相遇，则一定是有环的。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><span id="6.2.5.2"></span>  </p><h3 id="6-2-5-2-环形链表-II"><a href="#6-2-5-2-环形链表-II" class="headerlink" title="6.2.5.2 环形链表 II"></a>6.2.5.2 环形链表 II</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">LeetCode 142.环形链表II</a>| | <a href="#6.2.5">返回目录6.2.5</a></p><p>思路：这是上一题的升级版，不光要判断是否有环，还要返回入环的那个结点。<br>通过上一个题，我们已经知道如何判断有环。<br>在有环的情况下，开始寻找入环结点：<br>再设置两个游标，cur1从快慢指针相遇点开始，cur2从头结点开始，每次都只走一步，这两个游标再一次相遇的点一定是入环结点  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/6_2_5_2.webp" width="100%">   </p><p>因为fast指针是一步走两个节点，slow指针一步走一个节点，<br>所以 fast指针走过的节点数 = slow指针走过的节点数 <em> 2：  x + y + n (z + y) = (x + y) </em> 2 , n&gt;=1<br>两边消掉一个（x+y）得: x + y = n (z + y)<br>求 x 的表达式的：x = n (z + y) - y = (n-1)<em>(z + y) + z<br>x = (n-1)</em>环 + z  这个等式意味着:<br>如果另一个指针cur2从头结点开始走，走过x步；必然和从相遇点出发的cur1指针，在环的入口处相遇!<br>我们不用管cur1在环内究竟转了几圈，只要关注cur2几时能遇到cur1即可。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                <span class="comment"># 说明有环</span></span><br><span class="line">                cur1, cur2 = head, slow</span><br><span class="line">                <span class="keyword">while</span> cur2 != cur1:</span><br><span class="line">                    cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">                    cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> cur2</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><span id="6.2.5.3"></span>  </p><h3 id="6-2-5-3-相交链表"><a href="#6-2-5-3-相交链表" class="headerlink" title="6.2.5.3 相交链表"></a>6.2.5.3 相交链表</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">LeetCode 160.相交链表</a>| | <a href="#6.2.5">返回目录6.2.5</a></p><blockquote><p><strong>题目数据保证整个链式结构中不存在环</strong>。     </p></blockquote><p>思路 1.比较直接的思想是用哈希表来查询。只不过这样需要消耗较多的空间。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        curA = headA</span><br><span class="line">        curB = headB</span><br><span class="line">        hast_a = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> curA <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            hast_a[curA] = <span class="number">1</span></span><br><span class="line">            curA=curA.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> curB <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> curB <span class="keyword">in</span> hast_a:</span><br><span class="line">                <span class="keyword">return</span> curB</span><br><span class="line">            curB=curB.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>思路 2.不用哈希表，这样比较省空间。</p><ul><li>两个链表依次分别遍历，指针a负责遍历链表A，指针b负责遍历链表B，</li><li>若指针a指向了链表A的末尾，那么指针a就转头指向链表B，</li><li>同理指针b在指到末尾时也转头指向链表A，继续依次遍历。</li><li>当下一次指针a或者指针b其中一个又来到链表末尾，仍未找到相交结点，则确实没有相交。</li><li>（一定要注意，指针a和指针b这个转向另外一个链表去遍历的行为，只能做一次，）</li><li>否则，在之前的遍历中，一定能够找到那个相交结点。  </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        curA = headA</span><br><span class="line">        curB = headB</span><br><span class="line">        <span class="comment"># 设置统计两个游标转换链表次数的flag变量</span></span><br><span class="line">        end_a, end_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 遍历过程中发现相同的结点，即可返回</span></span><br><span class="line">            <span class="keyword">if</span> curA == curB:</span><br><span class="line">                <span class="keyword">return</span> curA</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 依次遍历</span></span><br><span class="line">                curA = curA.<span class="built_in">next</span></span><br><span class="line">                curB = curB.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 当游标a来到链表的末尾，就在不触发flag的条件下，转向另一个链表</span></span><br><span class="line">                <span class="keyword">if</span> curA <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="comment"># end_a +1 表示链表A已经遍历完成过一次</span></span><br><span class="line">                    end_a +=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> end_a &lt; <span class="number">2</span>:</span><br><span class="line">                        curA = headB</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">                <span class="comment"># 当游标b来到链表的末尾，就在不触发flag的条件下，转向另一个链表</span></span><br><span class="line">                <span class="keyword">if</span> curB <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="comment"># end_b +1 表示链表B已经遍历完成过一次</span></span><br><span class="line">                    end_b +=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> end_b &lt; <span class="number">2</span>:</span><br><span class="line">                        curB = headA</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><span id="6.2.5.4"></span>  </p><h3 id="6-2-5-4-有环链表相交"><a href="#6-2-5-4-有环链表相交" class="headerlink" title="6.2.5.4 有环链表相交"></a>6.2.5.4 有环链表相交</h3><p><a href="#6.2.5">返回目录6.2.5</a></p><blockquote><p>那么如果问题是有环的链表相交呢？没有在LeetCode上找到对应的题目，但是这里也拿出来讨论一下。</p><p>无环链表相交的情况上一题已经讨论。<br>对于有环链表，首先，可以排除一个有环，一个无环的情况，这种情况必不可能相交。<br>所以，【有环】链表相交，一定是【两个都有环】链表的情况。<br>分为3种情况：<br>①不相交，各自有环<br>②共用一个环，环外相交于一个点（或刚好入环点），然后才出现环。<br>&emsp;这种情况，我们可以忽略那个环，就成了【从头结点到入环结点这段区间】的无环单链表相交的问题了。<br>③环外不相交，各自从不同的结点入环。<br>&emsp;这种情况，从入环结点CircleA开始沿着环移动，回到CircleA之前，会遇到另一入环结点CircleB。<br>可以看到，要处理这个问题，就需要用到上面两个问题作为子问题：链表求环，链表相交。<br>代码可能比较长，但确实逻辑上很清楚。 </p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;1.判断是否有环 &amp; 求入环结点的函数&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                <span class="comment"># 说明有环</span></span><br><span class="line">                cur1, cur2 = head, slow</span><br><span class="line">                <span class="keyword">while</span> cur2 != cur1:</span><br><span class="line">                    cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">                    cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> cur2</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;2.求无环链表相交结点的函数&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode_No_Circle</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 这里采用的是哈希表方法，代码写起来简洁一点</span></span><br><span class="line">        <span class="comment"># 也可以使用另一种方法</span></span><br><span class="line">        curA = headA</span><br><span class="line">        curB = headB</span><br><span class="line">        hast_a = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 遍历链表a，将所有结点装入哈希表</span></span><br><span class="line">        <span class="keyword">while</span> curA <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            hast_a.update(&#123;curA:<span class="number">1</span>&#125;)</span><br><span class="line">            curA=curA.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历链表b，每次都看看b的结点是否在哈希表中已经存在</span></span><br><span class="line">        <span class="keyword">while</span> curB <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> curB <span class="keyword">in</span> hast_a:</span><br><span class="line">                <span class="keyword">return</span> curB</span><br><span class="line">            curB=curB.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;3.求有环链表相交结点的函数&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode_With_Circle</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> headA <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> headB <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 1.判断链表A和B是否有环，如果有的话返回环的结点</span></span><br><span class="line">        Circle_A = self.detectCycle(headA)</span><br><span class="line">        Circle_B = self.detectCycle(headB)</span><br><span class="line">        <span class="comment"># 2.如果两个链表都无环，就使用求无环链表相交结点的函数</span></span><br><span class="line">        <span class="keyword">if</span> Circle_A <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> Circle_B <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.getIntersectionNode_No_Circle(headA, headB)</span><br><span class="line">        <span class="comment"># 3.如果一个有环一个无环，则必不可能相交，</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> Circle_A <span class="keyword">and</span> Circle_B:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> Circle_A <span class="keyword">and</span> <span class="keyword">not</span> Circle_B:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 4.两个链表都有环</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 4.1 两个链表入环结点一样，说明公用一个环,可以当做无环链表处理</span></span><br><span class="line">            <span class="keyword">if</span> Circle_A == Circle_B:</span><br><span class="line">                <span class="keyword">return</span> self.getIntersectionNode_No_Circle(headA, headB)</span><br><span class="line">            <span class="comment"># 4.2 入环结点不一样</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 从链表A的入环结点开始在环里遍历</span></span><br><span class="line">                cur = Circle_A</span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> != Circle_A:</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                    <span class="comment"># 在链表A的环里果然找到链表B的入环结点</span></span><br><span class="line">                    <span class="keyword">if</span> cur == Circle_B:</span><br><span class="line">                        <span class="comment"># 说明两个链表的公用一个环，但入环结点不一样</span></span><br><span class="line">                        <span class="keyword">return</span> Circle_A</span><br><span class="line">                        <span class="comment"># 其实 Circle_B 也是相交点 , 也可以 return Circle_B</span></span><br><span class="line">                        </span><br><span class="line">                <span class="comment"># 循环结束，没有遇到 Circle_B, 说明两个有环链表各自成环，且不相交</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6-1 链表</title>
      <link href="/Data-Structure/DS_61_link_list.html"/>
      <url>/Data-Structure/DS_61_link_list.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="6-1-链表"><a href="#6-1-链表" class="headerlink" title="6-1 链表"></a>6-1 链表</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>6.1.1</td><td><a href="#6.1.1">单链表</a></td></tr><tr><td>6.1.2</td><td><a href="#6.1.2">双链表</a></td></tr><tr><td>6.1.3</td><td><a href="#6.1.3">循环链表</a></td></tr><tr><td>6.1.4</td><td><a href="#6.1.4">链表逆序</a></td></tr><tr><td>6.1.5</td><td><a href="#6.1.5">顺序表和链表的对比</a></td></tr></tbody></table></div><p><span id="6.1.1"></span></p><h2 id="6-1-1-单链表"><a href="#6-1-1-单链表" class="headerlink" title="6.1.1 单链表"></a>6.1.1 单链表</h2><p>链表，别名链式存储结构或单链表，是链式存储结构中最简单和最基本的结构，与顺序表不同，链表不限制数据的物理存储状态。换句话说，使用链表存储的数据元素，其物理存储位置是随机的。在存储每个元素的同时，需要存储其直接后继(或直接前驱）的位置，这一部分称为：链。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/6_1_1_1.webp" width="40%">  </p><h3 id="6-1-1-1-单链表结点"><a href="#6-1-1-1-单链表结点" class="headerlink" title="6.1.1.1 单链表结点"></a>6.1.1.1 单链表结点</h3><p>单向链表的每个元素都由两部分组成，存储元素的 <strong>数据域 data</strong>，和存储直接后继元素地址的 <strong>指针域 next</strong>，这样的一种结构成为结点。在C/C++中，可以用 struct 结构体来实现这个结构，在python中我们可以用class类来实现这种结构：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/6_1_1_2.webp" width="20%">    </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># node</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="literal">None</span></span>):</span><br><span class="line">        self.val=val</span><br><span class="line">        self.<span class="built_in">next</span>=<span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="6-1-1-2-单链表的实现"><a href="#6-1-1-2-单链表的实现" class="headerlink" title="6.1.1.2 单链表的实现"></a>6.1.1.2 单链表的实现</h3><p>单链表在实现时，又可以分为两种情况：不带头结点的单链表、带头结点的单链表，二者的区别可以从下图中看到：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/6_1_1_3.webp" width="50%">    </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/6_1_1_4.webp" width="50%">  </p><ul><li>这里所谓的“头结点”，就是指的专门设立一个结点node（上面的第2幅图），<strong>它的指针域保存的（指向的）是第一个实际存储了元素的区域的地址，如果没有元素，就是NULL。</strong> 即不管有没有元素，都有这么一个结点存在。头结点的数据域可以不存储任何信息（也可以存储像线性表的表长那样的数据信息，但一般都不存数据）。通常这个结点也被称为：<strong>哑结点</strong>。</li><li>头结点的作用是使所有链表（包括空表）的头指针非空，把空表和非空表的处理统一起来了，并使对单链表的插入、删除操作不需要区分是否为空表或是否在第一个位置进行，从而与其他位置的插入、删除操作一致。</li><li>比如说如果要删除第一个元素，没有头结点的链表，第一个元素的位置就是h，删除第一个元素之后，h 指针就得更新为原来的第二个元素的位置；但是对于有头结点的单链表，由于 h 指针指向的是头结点，所以删除第一个位置的元素和删除其他位置的元素的操作都是一样的，不需要再更新 h 指针！</li></ul><p>下面给出不带头结点的链表的python实现方式，因为这种情况处理更难一点，弄懂了这种情况的 code 写法，再写带头结点的链表的实现，就会简单很多。<strong>而且在很多场景，其实并没有这么严格的抠字眼说链表带不带头结点，题目中出现的大多数是这里谈及的 “不带头结点” 的单链表，但是也习惯称呼第一个结点为 “头结点”，这并不影响做题 。所以这里只是做一个概念上的了解，知道单链表有这么两种写法即可。在做题时根据实际情况写就行了。</strong>    </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/6_1_1_5.webp" width="60%">  </p><p><b>主要涉及到的，就是链表的<font color="red">增、删、改、查</font>操作。</b> </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># node</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="literal">None</span></span>):</span><br><span class="line">        self.val=val</span><br><span class="line">        self.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single_Link_List</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, node=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        该实现是构造“不带头结点的单链表”</span></span><br><span class="line"><span class="string">        一定要牢记,head就是第一个元素结点,而非head.next.</span></span><br><span class="line"><span class="string">        实际上head.next其实已经是第二个元素结点了</span></span><br><span class="line"><span class="string">        所以下面的某一些操作才会先判断head本身是不是空,即判断链表是否为空，</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.__head = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_random_init</span>(<span class="params">self, n=<span class="number">0</span></span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            self.append(random.randint(<span class="number">0</span>, <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.__head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt, cur = <span class="number">0</span>, self.__head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(cur.val, end=<span class="string">&#x27;-&gt;&#x27;</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">###############【增】###############</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;头插法&#x27;&#x27;&#x27;</span></span><br><span class="line">        node = Node(val)</span><br><span class="line">        node.<span class="built_in">next</span> = self.__head</span><br><span class="line">        self.__head = node</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;尾插法&#x27;&#x27;&#x27;</span></span><br><span class="line">        node, cur = Node(val), self.__head</span><br><span class="line">        <span class="comment"># 这里就需要先判断是否为空,否则None.next会报错</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.__head = node</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 循环结束后，cur指向最后一个数据结点</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;随机位置插入&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 先确保传入的pos属于[0, size]</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;insert pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> pos == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> self.add(val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = Node(val)</span><br><span class="line">                i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">                <span class="comment"># 循环结束后, cur指向pos-1的位置，因为pos的位置要留给node</span></span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos-<span class="number">1</span>:</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># print(&#x27;i:&#x27;,i,end=&#x27;-&gt;&#x27;)</span></span><br><span class="line">                    <span class="comment"># print(cur.val)</span></span><br><span class="line">                node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = node</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【删】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据值来删除第一个符合条件的结点&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;the linklist is empty!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        pre, cur = <span class="literal">None</span>, self.__head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                <span class="comment"># 先要判断是否删除的是首结点</span></span><br><span class="line">                <span class="keyword">if</span> cur == self.__head:</span><br><span class="line">                    <span class="comment"># 更新首结点</span></span><br><span class="line">                    self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">                    cur = self.__head</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                    cur = pre.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">del_pos</span>(<span class="params">self, pos</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据位置来指定删除&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;del pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 先要判断是否删除的是首结点</span></span><br><span class="line">            <span class="keyword">if</span> pos == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 更新首结点</span></span><br><span class="line">                self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line">                pre, cur = <span class="literal">None</span>, self.__head</span><br><span class="line">                <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                    pre = cur</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【改】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, pos: <span class="built_in">int</span>, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据位置改变值&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;change pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">            <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.val = val</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【查】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;依据值来定位位置(索引)&#x27;&#x27;&#x27;</span></span><br><span class="line">        i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;not find %s&#x27;</span> % <span class="built_in">str</span>(val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">locate</span>(<span class="params">self, pos: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;依据索引查找值&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">            <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> cur.val </span><br></pre></td></tr></table></figure><h3 id="6-1-1-3-带头结点单链表的实现"><a href="#6-1-1-3-带头结点单链表的实现" class="headerlink" title="6.1.1.3 带头结点单链表的实现"></a>6.1.1.3 带头结点单链表的实现</h3><p>带头结点的单链表逻辑思考上更为简单一点，其与【不带头结点】的链表的核心差别主要有以下：</p><ol><li>head 一定不为空，在首结点进行操作时，与其他位置的操作是一致的；</li><li>当游标cur 指向 head 时，其索引为 -1，表示首结点的前一位置，即首结点是从 head.next 开始算起。  </li></ol><p>掌握好这两个关键点，实现起来就十分简单了.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Single_Link_List_With_Head</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, node=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        这里实现的是所谓【带头结点】的单链表</span></span><br><span class="line"><span class="string">        所以初始化时不是为None或者从外面传入的node</span></span><br><span class="line"><span class="string">        初始化时就一定是一个结点，我们可以用这个结点的数据域来存储链表的长度</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.__head = Node(<span class="number">0</span>)</span><br><span class="line">        self.__head.<span class="built_in">next</span> = node</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>)-&gt;<span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.__head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">        cnt, cur = <span class="number">0</span>, self.__head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cnt +=<span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># self.__head.val = cnt  # 也可以用头结点的数据域来存储链表长度    </span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">print</span>(cur.val, end=<span class="string">&#x27;-&gt;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="comment">###############【增】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>)-&gt;<span class="built_in">bool</span>:</span><br><span class="line">        node = Node(val)</span><br><span class="line">        <span class="comment"># 注意这一步和不带头结点的链表的区别</span></span><br><span class="line">        node.<span class="built_in">next</span> = self.__head.<span class="built_in">next</span></span><br><span class="line">        self.__head.<span class="built_in">next</span> = node</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, val</span>)-&gt;<span class="built_in">bool</span>:</span><br><span class="line">        node= Node(val)</span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="comment"># 这里就不用单独判断链表是否为空了</span></span><br><span class="line">        <span class="comment"># 空链表也包含在下面的情况</span></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = node</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos:<span class="built_in">int</span>, val</span>)-&gt;<span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;failed! insert pos out of range!&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.__head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;empty link-list!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = Node(val)</span><br><span class="line">            i, cur = -<span class="number">1</span>, self.__head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i&lt;pos-<span class="number">1</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">###############【删】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val</span>)-&gt;<span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;empty link-list!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        pre, cur = self.__head, self.__head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;not find %s&#x27;</span> % <span class="built_in">str</span>(val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">del_pos</span>(<span class="params">self, pos:<span class="built_in">int</span></span>)-&gt;<span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        删除指定pos的结点</span></span><br><span class="line"><span class="string">        与【不带头结点】的单链表对比,不用特殊处理首结点(pos==0)的删除</span></span><br><span class="line"><span class="string">        只是索引从-1开始,其他的部分不变</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;failed! insert pos out of range!&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.__head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;empty link-list!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = -<span class="number">1</span>, self.__head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos-<span class="number">1</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【改】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, pos: <span class="built_in">int</span>, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据位置改变值&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;change pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = -<span class="number">1</span>, self.__head</span><br><span class="line">            <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.val = val</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【查】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;依据值来定位位置(索引)&#x27;&#x27;&#x27;</span></span><br><span class="line">        i, cur = -<span class="number">1</span>, self.__head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                <span class="keyword">return</span> i             </span><br><span class="line">                </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;not find %s&#x27;</span> % <span class="built_in">str</span>(val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">locate</span>(<span class="params">self, pos: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;依据索引查找值&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = -<span class="number">1</span>, self.__head</span><br><span class="line">            <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> cur.val</span><br></pre></td></tr></table></figure><p><span id="6.1.2"></span>  </p><h2 id="6-1-2-双链表"><a href="#6-1-2-双链表" class="headerlink" title="6.1.2 双链表"></a>6.1.2 双链表</h2><p>双向链表除了相当于在单链表的基础上，每个结点多了一个指针域prior，用于存储其直接前驱的地址。同时保留有next，用于存储其直接后继的地址。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/6_1_2_1.webp" width="40%"> </p><p>所以对于双链表，其实很多操作都和单链表是一样的，因为你完全可以忽视掉它有个 prior指针，这样就可以当做单链表来使用。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/6_1_2_2.webp" width="60%">   </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/6_1_2_3.webp" width="80%">  </p><p>因为有了prior指针，所以在插入和删除新元素时，应该考虑可以利用这一值。<br>鉴于有些操作其实可以和单链表保持一致，比如判空、求长度、遍历、查找等等，所以我们可以用类的继承来实现双链表，主要要修改的其实就是<b><font color="red">增、删</font>元素两种操作，因为涉及到“链”的变化。</b><br>特别注意：在更新某结点node的prior链接时，也要记得check一下该node是否为空！<br>下面的code是继承不带头结点的单链表的类来进行实现。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D_Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val      <span class="comment"># 数据源</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span>    <span class="comment"># 后继</span></span><br><span class="line">        self.prior=<span class="literal">None</span>     <span class="comment"># 前驱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Double_Link_List</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, node=<span class="literal">None</span></span>):</span><br><span class="line">        self.__head = node</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_random_init</span>(<span class="params">self, n=<span class="number">0</span></span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            self.append(random.randint(<span class="number">0</span>, <span class="number">20</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;普通的三项基本操作和简单的单链表一样&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt, cur = <span class="number">0</span>, self.__head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> cnt </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(cur.val, end=<span class="string">&#x27;-&gt;&#x27;</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">###############【增】###############</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;增加元素的操作一定要记得 prior 指针连接上&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;头插法&#x27;&#x27;&#x27;</span></span><br><span class="line">        node = D_Node(val)</span><br><span class="line">        node.<span class="built_in">next</span> = self.__head</span><br><span class="line">        <span class="keyword">if</span> self.__head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.__head.prior = node</span><br><span class="line">        self.__head = node</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;尾插法&#x27;&#x27;&#x27;</span></span><br><span class="line">        node, cur = D_Node(val), self.__head</span><br><span class="line">        <span class="comment"># 这里就需要先判断是否为空,否则None.next会报错</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.__head = node</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 循环结束后，cur指向最后一个数据结点</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line">            node.prior = cur</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;随机位置插入&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 先确保传入的pos属于[0, size]</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;insert pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> pos == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> self.add(val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = D_Node(val)</span><br><span class="line">                i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">                <span class="comment"># 循环结束后, cur指向pos-1的位置，因为pos的位置要留给node</span></span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos-<span class="number">1</span>:</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># print(&#x27;i:&#x27;,i,end=&#x27;-&gt;&#x27;)</span></span><br><span class="line">                    <span class="comment"># print(cur.val)</span></span><br><span class="line">                node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = node</span><br><span class="line">                </span><br><span class="line">                node.prior = cur</span><br><span class="line">                <span class="keyword">if</span> node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    node.<span class="built_in">next</span>.prior = node</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【删】###############</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;删除元素的操作也要记得重置prior&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据值来删除第一个符合条件的结点&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;the linklist is empty!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        pre, cur = <span class="literal">None</span>, self.__head</span><br><span class="line">        <span class="comment"># 这里的 pre 完全可以用 cur.prior 来表示，我懒得改了</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                <span class="comment"># 先要判断是否删除的是首结点</span></span><br><span class="line">                <span class="keyword">if</span> cur == self.__head:</span><br><span class="line">                    <span class="comment"># 更新首结点</span></span><br><span class="line">                    self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">                    <span class="comment"># 判断更新后的 self.__head 是否为空</span></span><br><span class="line">                    <span class="keyword">if</span> self.__head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                        self.__head.prior = cur.prior</span><br><span class="line">                    cur = self.__head</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                    <span class="comment"># 判断 cur.next 是否为空</span></span><br><span class="line">                    <span class="keyword">if</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                        cur.<span class="built_in">next</span>.prior = pre</span><br><span class="line">                    cur = pre.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">del_pos</span>(<span class="params">self, pos</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据位置来指定删除&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;del pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 先要判断是否删除的是首结点</span></span><br><span class="line">            <span class="keyword">if</span> pos == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 更新首结点</span></span><br><span class="line">                self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 判断更新后的 self.__head 是否为空</span></span><br><span class="line">                <span class="keyword">if</span> self.__head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    self.__head.prior = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 这里的 pre 完全可以用 cur.prior 来表示，我懒得改了</span></span><br><span class="line">                pre, cur = <span class="literal">None</span>, self.__head</span><br><span class="line">                <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                    pre = cur</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    cur.<span class="built_in">next</span>.prior = pre</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【改】###############</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;改元素值不涉及重连，所以与单链表一样&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, pos: <span class="built_in">int</span>, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据位置改变值&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;change pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">            <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.val = val</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【查】###############</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;改元素值不涉及重连，所以与单链表一样&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;依据值来定位位置(索引)&#x27;&#x27;&#x27;</span></span><br><span class="line">        i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;not find %s&#x27;</span> % <span class="built_in">str</span>(val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">locate</span>(<span class="params">self, pos: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;依据索引查找值&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">            <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> cur.val</span><br></pre></td></tr></table></figure><p><span id="6.1.3"></span>  </p><h2 id="6-1-3-循环链表"><a href="#6-1-3-循环链表" class="headerlink" title="6.1.3 循环链表"></a>6.1.3 循环链表</h2><p>循环链表就是链表首尾相接连成一个环，即链表的最后一个结点，的后继结点，是头（首）结点；可以用单向链表和双向链表来实现，分别形成单向循环链表和双向循环链表，又可再分为带头结点和不带头结点，这里只画出不带头结点的单向循环链表的例子示意图如下：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/6_1_2_3.webp" width="60%">  </p><p>所以<b>判断是否是最后一个元素 的条件 也<font color="red">从 p-&gt;next != null; 变成了 p-&gt;next != head;</font></b>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Single_Cycle_Link_list</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单向循环链表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_random_init</span>(<span class="params">self, n=<span class="number">0</span></span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            self.append(random.randint(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.__head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        cnt, cur = <span class="number">1</span>, self.__head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            cnt +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="built_in">print</span>(cur.val, end=<span class="string">&#x27;-&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">print</span>(cur.val, end=<span class="string">&#x27;-&gt;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">###############【增】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>):</span><br><span class="line">        node = Node(val)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.__head = node</span><br><span class="line">            <span class="comment"># 循环链表要记得尾部也指向head</span></span><br><span class="line">            node.<span class="built_in">next</span> = self.__head</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.<span class="built_in">next</span> = self.__head</span><br><span class="line">            cur = self.__head</span><br><span class="line">            <span class="comment"># 循环结束后，cur到链表尾部</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将尾部的next指向node, 并将node更新为新的head</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line">            self.__head = node</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;尾插法&#x27;&#x27;&#x27;</span></span><br><span class="line">        node, cur = Node(val), self.__head</span><br><span class="line">        <span class="comment"># 这里就需要先判断是否为空,否则None.next会报错</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.__head = node</span><br><span class="line">            <span class="comment"># 循环链表要记得尾部也指向head</span></span><br><span class="line">            node.<span class="built_in">next</span> = self.__head</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 循环结束后，cur指向最后一个数据结点</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line">            <span class="comment"># 将node后继指向 head</span></span><br><span class="line">            node.<span class="built_in">next</span> = self.__head</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;随机位置插入&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 先确保传入的pos属于[0, size]</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;insert pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> pos == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> self.add(val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = Node(val)</span><br><span class="line">                i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">                <span class="comment"># 循环结束后, cur指向pos-1的位置，因为pos的位置要留给node</span></span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head <span class="keyword">and</span> i &lt; pos-<span class="number">1</span>:</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># print(&#x27;i:&#x27;,i,end=&#x27;-&gt;&#x27;)</span></span><br><span class="line">                    <span class="comment"># print(cur.val)</span></span><br><span class="line">                node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = node</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【删】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据值来删除第一个符合条件的结点&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;the linklist is empty!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="comment"># 先要判断首结点的值是否符合删除条件</span></span><br><span class="line">        <span class="keyword">if</span> cur.val == val:</span><br><span class="line">            <span class="comment"># 如果链表只有一个结点</span></span><br><span class="line">            <span class="keyword">if</span> cur.<span class="built_in">next</span> == self.__head:</span><br><span class="line">                self.__head = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 循环结束后cur指向最后一个结点</span></span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head:</span><br><span class="line">                    cur = cur.<span class="built_in">next</span> </span><br><span class="line">                <span class="comment"># 将尾部与新的首结点连起来</span></span><br><span class="line">                cur.<span class="built_in">next</span> = self.__head.<span class="built_in">next</span></span><br><span class="line">                self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 说明首结点的值不符合</span></span><br><span class="line">            pre, cur = self.__head, self.__head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> cur != self.__head:</span><br><span class="line">                <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span> </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre = cur</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;not find %s &#x27;</span> % <span class="built_in">str</span>(val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">del_pos</span>(<span class="params">self, pos</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据位置来指定删除&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;del pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 先要判断是否删除的是首结点</span></span><br><span class="line">            <span class="keyword">if</span> pos == <span class="number">0</span>:</span><br><span class="line">                cur = self.__head</span><br><span class="line">                <span class="comment"># 如果链表只有一个结点</span></span><br><span class="line">                <span class="keyword">if</span> cur.<span class="built_in">next</span> == self.__head:</span><br><span class="line">                    self.__head = <span class="literal">None</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 循环结束后cur指向最后一个结点</span></span><br><span class="line">                    <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head:</span><br><span class="line">                        cur = cur.<span class="built_in">next</span> </span><br><span class="line">                    <span class="comment">#print(&#x27;end val:&#x27;, cur.val)</span></span><br><span class="line">                    <span class="comment"># 将尾部与新的首结点连起来</span></span><br><span class="line">                    cur.<span class="built_in">next</span> = self.__head.<span class="built_in">next</span></span><br><span class="line">                    self.__head = self.__head.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i = <span class="number">1</span></span><br><span class="line">                pre, cur = self.__head, self.__head.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">                <span class="keyword">while</span> cur != self.__head <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                    pre = cur</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【改】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, pos: <span class="built_in">int</span>, val</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据位置改变值&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;change pos out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">            <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.val = val</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############### 【查】###############</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;依据值来定位位置(索引)&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.__head.val == val:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = <span class="number">1</span>, self.__head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> cur != self.__head:</span><br><span class="line">                <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;not find %s&#x27;</span> % <span class="built_in">str</span>(val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">locate</span>(<span class="params">self, pos: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;依据索引查找值&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt; <span class="number">0</span> <span class="keyword">or</span> pos &gt; self.size()-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;out of range!&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.is_empty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;the linklist is empty!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, cur = <span class="number">0</span>, self.__head</span><br><span class="line">            <span class="comment"># 循环结束后, cur指向pos的位置</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head <span class="keyword">and</span> i &lt; pos:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> cur.val</span><br></pre></td></tr></table></figure><p><span id="6.1.4"></span>  </p><h2 id="6-1-4-链表逆序"><a href="#6-1-4-链表逆序" class="headerlink" title="6.1.4 链表逆序"></a>6.1.4 链表逆序</h2><p>链表逆序就是把一个链表的尾变头，头变尾。属于链表中的经典问题。  </p><h3 id="6-1-4-1-方案一"><a href="#6-1-4-1-方案一" class="headerlink" title="6.1.4.1 方案一"></a>6.1.4.1 方案一</h3><p>将<b>第二个结点后面的元素依次插入到第一个结点后面</b>，<br>这个方法对于带不带头结点的链表都适用。<br>举例<br>① 不带头结点的链表<br>原始链表，其中第二个元素是 <font color="red">B</font><br>A -&gt; <font color="red">B</font>-&gt; ==C== -&gt; D -&gt; E -&gt; F -&gt; null<br>先进入循环,不断的把B的后继元素往第一个元素后面插<br>A -&gt; C -&gt; <font color="red">B</font> -&gt; ==D== -&gt; E -&gt; F -&gt; null   #将上面 B后的 C 插入到A后面<br>A -&gt; D -&gt; C -&gt; <font color="red">B</font> -&gt; ==E== -&gt; F -&gt; null   #将上面 B后的 D 插入到A后面<br>A -&gt; E -&gt; D -&gt; C -&gt; <font color="red">B</font> -&gt; ==F== -&gt; null   #将上面 B后的 E 插入到A后面<br>A -&gt; F -&gt; E -&gt; D -&gt; C -&gt; <font color="red">B</font> -&gt; null   #将上面 B后的 F 插入到A后面<br>最后将F作为新的首结点,将A放到B后面：<br>F -&gt; E -&gt; D -&gt; C -&gt; B -&gt; A -&gt; null  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">if</span> self.is_empty():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;empty link-list!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> self.__head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node_A, node_B = self.__head, self.__head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> node_B.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 相当于先把B后的结点从链表中断开</span></span><br><span class="line">            node_C = node_B.<span class="built_in">next</span></span><br><span class="line">            node_B.<span class="built_in">next</span> = node_C.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 然后插入首结点后面</span></span><br><span class="line">            node_C.<span class="built_in">next</span> = node_A.<span class="built_in">next</span></span><br><span class="line">            node_A.<span class="built_in">next</span> = node_C</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 尾首相连，相当于形成了一个循环链表了</span></span><br><span class="line">        node_B.<span class="built_in">next</span> = node_A</span><br><span class="line">        <span class="comment"># 然后从A点next处断开即可</span></span><br><span class="line">        self.__head = node_A.<span class="built_in">next</span></span><br><span class="line">        node_A.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>② 带头结点的链表<br>可以将头结点视为第一个元素，那么就是直接把 A 的后继元素不断的往head后面插：<br>带头结点原始链表，将头结点视为第1个元素，那么其中第2个元素是 A<br>Head -&gt; <font color="red">A</font> -&gt; ==B==-&gt; C -&gt; D -&gt; E -&gt; F -&gt; null<br>先进入循环,不断的把A的后继元素往头结点后面插<br>Head -&gt; B -&gt; <font color="red">A</font> -&gt; ==C== -&gt; D -&gt; E -&gt; F -&gt; null<br>Head -&gt; C -&gt; B -&gt; <font color="red">A</font> -&gt; ==D== -&gt; E -&gt; F -&gt; null<br>Head -&gt; D -&gt; C -&gt; B -&gt; <font color="red">A</font> -&gt; ==E== -&gt; F -&gt; null<br>Head -&gt; E -&gt; D -&gt; C -&gt; B -&gt; <font color="red">A</font> -&gt; ==F== -&gt; null<br>Head -&gt; F -&gt; E -&gt; D -&gt; C -&gt; B -&gt; <font color="red">A</font> -&gt; null</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">if</span> self.is_empty():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;empty link-list!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> self.__head.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node_H, node_B = self.__head, self.__head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> node_B.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 相当于先把B后的结点从链表中断开</span></span><br><span class="line">            node_C = node_B.<span class="built_in">next</span></span><br><span class="line">            node_B.<span class="built_in">next</span> = node_C.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 然后插入头结点后面</span></span><br><span class="line">            node_C.<span class="built_in">next</span> = node_H.<span class="built_in">next</span></span><br><span class="line">            node_H.<span class="built_in">next</span> = node_C</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 循环结束之后，结点B后的结点都被逆序插入到A之后</span></span><br><span class="line">        <span class="comment"># 由于A是作为头结点head一直稳定不变，所以已经结束了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="6-1-4-2-方案二"><a href="#6-1-4-2-方案二" class="headerlink" title="6.1.4.2 方案二"></a>6.1.4.2 方案二</h3><p>直接利用辅助变量，将node一个一个改变指向，这个方法就是要注意中间一定不能断了。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, head</span>):</span><br><span class="line">    pre, cur = <span class="literal">None</span>, head</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="comment"># 先保存剩余部分的头</span></span><br><span class="line">        rest = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 当前结点指向前面</span></span><br><span class="line">        cur.<span class="built_in">next</span> = pre</span><br><span class="line">        <span class="comment"># pre指针移动到当前结点</span></span><br><span class="line">        pre = cur</span><br><span class="line">        <span class="comment"># cur指针指向剩下部分的头</span></span><br><span class="line">        cur = rest</span><br><span class="line">    <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h3 id="6-1-4-3-方案三"><a href="#6-1-4-3-方案三" class="headerlink" title="6.1.4.3 方案三"></a>6.1.4.3 方案三</h3><p>采用递归的思路  </p><p>① 不带头结点<br>递归其实就是一直要找到最后一个结点，然后每次改一下。<br>这个时候其实 函数递归的时，<font color="red">函数用系统栈存储了前面每个结点的信息</font>，所以一步一步从最后面改动到前面去，最后返回了一个以原始尾结点的地址为头指针的 无头结点单链表。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_linklist_by_recursion</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 调用递归函数, 更新新的首结点</span></span><br><span class="line">    self.__head = self.__recursion_func(self.__head)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__recursion_func</span>(<span class="params">self, node</span>):</span><br><span class="line">    <span class="comment"># 结束的条件:链表为空或者链表最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="comment"># 递归调用</span></span><br><span class="line">    node_new = self.__recursion_func(node.<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每次都把当前结点 重新设置成 当前结点的下一个结点的下一个结点</span></span><br><span class="line">    node.<span class="built_in">next</span>.<span class="built_in">next</span> = node</span><br><span class="line">    <span class="comment"># 然后再把当前结点的新后继设置为空，相当于当前结点作为新链表的尾结点</span></span><br><span class="line">    node.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node_new</span><br></pre></td></tr></table></figure><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/6_1_4_1.gif" width="70%">   </p><p>② 带头结点<br>其实依然可以用上面的函数，只是不能把头结点传入进去，因为头结点本身不该算在链表的存储的数据中。我们可以把带头结点的单链表的头结点后面的那部分，看成是不带头结点的单链表，即可复用上面的函数了。即，传入的指针应该是 head-&gt;next  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__reverse_linklist_by_recursion</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 这里直接把self.__head.next之后的链表，当作不带头结点的链表处理即可</span></span><br><span class="line">    self.__head.<span class="built_in">next</span> = self.recursion_func(self.__head.<span class="built_in">next</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__recursion_func</span>(<span class="params">self, node</span>):</span><br><span class="line">    <span class="comment"># 结束的条件:链表为空或者链表最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="comment"># 递归调用</span></span><br><span class="line">    node_new = self.__recursion_func(node.<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每次都把当前结点 重新设置成 当前结点的下一个结点的下一个结点</span></span><br><span class="line">    node.<span class="built_in">next</span>.<span class="built_in">next</span> = node</span><br><span class="line">    <span class="comment"># 然后再把当前结点的新后继设置为空，相当于当前结点作为新链表的尾结点</span></span><br><span class="line">    node.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node_new</span><br></pre></td></tr></table></figure><p><span id="6.1.5"></span>  </p><h2 id="6-1-5-顺序表和链表的对比"><a href="#6-1-5-顺序表和链表的对比" class="headerlink" title="6.1.5 顺序表和链表的对比"></a>6.1.5 顺序表和链表的对比</h2><ul><li>存储结构的不同<br>虽然它们同属于线性表，但数据的存储结构有本质的不同：<br>顺序表存储数据，需预先申请一整块足够大的存储空间，然后将数据按照次序逐一存储，逻辑关系就是靠元素间物理空间上的邻接关系来维持<br>链表 ，什么时候存储数据，什么时候才申请存储空间，数据之间的逻辑关系依靠每个数据元素携带的指针维持，</li><li>空间利用率<br>顺序表的空间利用率显然要比链表高。<br>首先是链表每个结点不光有数据域，还有指针域。这就比顺序表多耗费一点空间。<br>链表在存储数据时，每次只新开辟一个node的空间，且位置是随机的，会产生很多空间碎片，一定程序上造成了空间浪费。</li><li>时间复杂度<br>根据顺序表和链表在存储结构上的差异，问题类型主要分为以下 2 类：<br><strong>第 1 类问题：主要涉及访问元素的操作，元素的插入、删除和移动操作极少</strong>；<br>适合使用顺序表。这是因为，顺序表中存储的元素可以使用数组下标直接访问，无需遍历整个表，因此使用顺序表访问元素的时间复杂度为 O(1)；如果要在链表中访问元素，需要从头指针依次遍历，直到找到指定节点，花费的时间复杂度为 O(n).<br><strong>第 2 类问题:主要涉及元素的插入、删除和移动，访问元素的需求很少</strong>；<br>适合使用链表。链表中数据元素之间的逻辑关系靠的是节点之间的指针，当需要在链表中某处插入或删除节点时，只需改变相应节点的指针指向即可，不用大量移动元素，因此链表中插入、删除或移动数据所耗费的时间复杂度为 O(1)；而顺序表中，插入、删除和移动数据可能会牵涉到大量元素的整体移动，时间复杂度至少为 O(n).</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5-2 栈和队列相关题目</title>
      <link href="/Data-Structure/DS_52_stack_and_queue_exercises.html"/>
      <url>/Data-Structure/DS_52_stack_and_queue_exercises.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="5-2-栈和队列相关题目"><a href="#5-2-栈和队列相关题目" class="headerlink" title="5-2 栈和队列相关题目"></a>5-2 栈和队列相关题目</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p><b>版权声明：以下题目均来自 <a href="https://leetcode.cn">LeetCode</a>， 仅仅提供跳转到力扣官网的链接，不在本页面出现题目内容，本文章内容禁止商业用途。</b></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>5.2.1</td><td><a href="#5.2.1">栈的常见题目</a></td></tr><tr><td>5.2.2</td><td><a href="#5.2.2">单调栈</a></td></tr><tr><td>5.2.3</td><td><a href="#5.2.3">队列的常见题目</a></td></tr><tr><td>5.2.4</td><td><a href="#5.2.4">优先队列</a></td></tr></tbody></table></div><p><span id="5.2.1"></span>  </p><h2 id="5-2-1-栈的常见题目："><a href="#5-2-1-栈的常见题目：" class="headerlink" title="5.2.1 栈的常见题目："></a>5.2.1 栈的常见题目：</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">LeetCode 232.用栈实现队列 </a></td><td><a href="#5.2.1.1">5.2.1.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/min-stack">LeetCode 155.最小栈</a></td><td><a href="#5.2.1.2">5.2.1.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string">LeetCode 1047.删除字符串中的所有相邻重复项</a></td><td><a href="#5.2.1.3">5.2.1.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/valid-parentheses">LeetCode 20.有效的括号</a></td><td><a href="#5.2.1.4">5.2.1.4题解</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/longest-valid-parentheses">LeetCode 32.最长有效括号</a></td><td><a href="#5.2.1.5">5.2.1.5题解</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/basic-calculator">LeetCode 224.基本计算器</a></td><td><a href="#5.2.1.6">5.2.1.6题解</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/basic-calculator-ii">LeetCode 227.基本计算器II</a></td><td><a href="#5.2.1.7">5.2.1.7题解</a></td></tr><tr><td>⑧</td><td><a href="https://leetcode.cn/problems/decode-string">LeetCode 394.字符串解码</a></td><td><a href="#5.2.1.8">5.2.1.8题解</a></td></tr><tr><td>⑨</td><td><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">LeetCode 150.逆波兰表达式求值</a></td><td><a href="#5.2.1.9">5.2.1.9题解</a></td></tr><tr><td>⑩</td><td><a href="https://leetcode.cn/problems/validate-stack-sequences/">LeetCode 946. 验证栈序列</a></td><td><a href="#5.2.1.10">5.2.1.10题解</a></td></tr></tbody></table></div><p><span id="5.2.1.1"></span>   </p><h3 id="5-2-1-1-用栈实现队列"><a href="#5-2-1-1-用栈实现队列" class="headerlink" title="5.2.1.1 用栈实现队列"></a>5.2.1.1 用栈实现队列</h3><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">LeetCode 232.用栈实现队列 </a> | | <a href="#5.2.1">返回目录5.2.1</a></p><p>思路：队列是先入的先出，所以要用一个栈存储数据，另一个栈用来调整顺序。    </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__s_a = []</span><br><span class="line">        self.__s_b = []</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 专门用 a 栈来存储数据</span></span><br><span class="line">        self.__s_a.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先将a栈的数据全部导入b栈，此时顺序就反过来了</span></span><br><span class="line">        <span class="keyword">while</span> self.__s_a:</span><br><span class="line">            self.__s_b.append(self.__s_a.pop())</span><br><span class="line">        <span class="comment"># 这样b栈的栈顶元素就是刚刚的队头元素，将其弹出给res</span></span><br><span class="line">        res = self.__s_b.pop()</span><br><span class="line">        <span class="comment"># 然后再把b栈里的元素恢复到a栈中，保持a栈存储元素,b栈常态为空的状态</span></span><br><span class="line">        <span class="keyword">while</span> self.__s_b:</span><br><span class="line">            self.__s_a.append(self.__s_b.pop())</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 与pop的操作几乎一致，只不过不用使用pop弹出</span></span><br><span class="line">        <span class="keyword">while</span> self.__s_a:</span><br><span class="line">            self.__s_b.append(self.__s_a.pop())</span><br><span class="line">        res = self.__s_b[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> self.__s_b:</span><br><span class="line">            self.__s_a.append(self.__s_b.pop())</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.__s_a</span><br></pre></td></tr></table></figure><p><span id="5.2.1.2"></span>  </p><h3 id="5-2-1-2-最小栈"><a href="#5-2-1-2-最小栈" class="headerlink" title="5.2.1.2 最小栈"></a>5.2.1.2 最小栈</h3><p><a href="https://leetcode.cn/problems/min-stack">LeetCode 155.最小栈</a> | | <a href="#5.2.1">返回目录5.2.1</a></p><p>思路1：用一个栈维护数据，再用另一个栈维护最小值。数据栈在进行入栈、出栈操作时，也要同时对最小值栈进行操作。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>:</span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__stack_list=[]</span><br><span class="line">        self.__min_list=[]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.__stack_list.append(val)</span><br><span class="line">        <span class="keyword">if</span> self.__min_list:</span><br><span class="line">            <span class="comment">#self.__min_list.append(val)</span></span><br><span class="line">            min_v = <span class="built_in">min</span>(val, self.__min_list[-<span class="number">1</span>])</span><br><span class="line">            self.__min_list.append(min_v)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__min_list.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> self.__stack_list:</span><br><span class="line">            self.__stack_list.pop()</span><br><span class="line">            self.__min_list.pop()</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.__stack_list:</span><br><span class="line">            <span class="keyword">return</span> self.__stack_list[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> math.nan</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.__min_list:</span><br><span class="line">            <span class="keyword">return</span> self.__min_list[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> math.nan</span><br></pre></td></tr></table></figure><p>思路2：由于思路1中用到了一个辅助栈，空间的消耗会是原始数据的2倍。这里可以考虑一个不用辅助栈的方案.<br>只维护一个栈，栈里存储的是与 min_value 的差值:delta<br>min_value 其实承担了两个功能，第一个就是栈中最小值，另一个就是如果delta是小于0的话，那就是栈中对应位置的真实值。<br>换句话说，那个delta栈，想从它恢复成原始数据栈，要么就是对应的delta值加上min，要么就是直接填入min值。这完全取决于delta的正负，这个正负的信息其实很重要。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 维护一个delta栈，和一个最小值</span></span><br><span class="line">        self.__delta_stack = []</span><br><span class="line">        self.__minv = -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 这个最小值的初始值可以不用在意，</span></span><br><span class="line">        <span class="comment"># 最小值是在栈不为空的时候才会有意义的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.__delta_stack) == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 如果栈为空，当前数就是唯一存在的数，自然就是最小值</span></span><br><span class="line">            self.__minv = val</span><br><span class="line">            <span class="comment"># 它与自己的差值明显就是 0</span></span><br><span class="line">            self.__delta_stack.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            delta = val - self.__minv</span><br><span class="line">            <span class="keyword">if</span> delta &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 说明新来的val比已有的minv更小，需要更新 minv 为当前val</span></span><br><span class="line">                self.__minv = val</span><br><span class="line">            <span class="comment"># 如果delta大于0 ，说明原来的minv确实还是更小的，就不用更新</span></span><br><span class="line">            <span class="comment"># 然后不管是大于0还是小于0 ，依然要将delta入栈</span></span><br><span class="line">            self.__delta_stack.append(delta)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> self.__delta_stack:</span><br><span class="line">            delta = self.__delta_stack.pop()</span><br><span class="line">            <span class="keyword">if</span> delta &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 说明min_v储存的值就是对应的 val</span></span><br><span class="line">                <span class="comment"># 这是由我们之前的入栈操作决定的</span></span><br><span class="line">                val = self.__minv</span><br><span class="line">                <span class="comment"># 并还原之前的 minv</span></span><br><span class="line">                self.__minv = val - delta</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                val = delta + self.__minv</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.__delta_stack:</span><br><span class="line">            delta = self.__delta_stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> self.__minv <span class="keyword">if</span> delta &lt; <span class="number">0</span> <span class="keyword">else</span> delta+self.__minv</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.__minv <span class="keyword">if</span> self.__delta_stack <span class="keyword">else</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><span id="5.2.1.3"></span>   </p><h3 id="5-2-1-3-删除字符串中的所有相邻重复项"><a href="#5-2-1-3-删除字符串中的所有相邻重复项" class="headerlink" title="5.2.1.3 删除字符串中的所有相邻重复项"></a>5.2.1.3 删除字符串中的所有相邻重复项</h3><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string">LeetCode 1047.删除字符串中的所有相邻重复项</a> | | <a href="#5.2.1">返回目录5.2.1</a></p><p>方案：用一个栈来循环装入每个字符，每个字符入栈时，都要与栈顶元素（即前一个字符）对比一下，若不相同才装入；若相同就不装入，同时删除栈顶元素。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        char_s = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char_s: <span class="comment"># 如果栈不为空才进行后续操作</span></span><br><span class="line">                <span class="keyword">if</span> ch == char_s[-<span class="number">1</span>]:</span><br><span class="line">                    char_s.pop()</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            char_s.append(ch)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(char_s)</span><br></pre></td></tr></table></figure><p><span id="5.2.1.4"></span>  </p><h3 id="5-2-1-4-有效的括号"><a href="#5-2-1-4-有效的括号" class="headerlink" title="5.2.1.4 有效的括号"></a>5.2.1.4 有效的括号</h3><p><a href="https://leetcode.cn/problems/valid-parentheses">LeetCode 20.有效的括号</a> | | <a href="#5.2.1">返回目录5.2.1</a></p><p>方案：和上面的  <a href="#5.2.1.2">5.2.1.2</a> 的思想类似，只不过上面是成对的消字符，这里是成对的消除括号，原理是一样的。如果中途就碰见不能消除的情况，就返回False了。最终消除完之后看看是否还剩的有括号</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        bracket_s = []</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">&#x27;(&#x27;</span> <span class="keyword">or</span> ch == <span class="string">&#x27;[&#x27;</span> <span class="keyword">or</span> ch == <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                bracket_s.append(ch)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> ch == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> bracket_s <span class="keyword">and</span> bracket_s[-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    bracket_s.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> ch == <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> bracket_s <span class="keyword">and</span> bracket_s[-<span class="number">1</span>] == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                    bracket_s.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> ch == <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> bracket_s <span class="keyword">and</span> bracket_s[-<span class="number">1</span>] == <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                    bracket_s.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(bracket_s) == <span class="number">0</span></span><br></pre></td></tr></table></figure><p><span id="5.2.1.5"></span>  </p><h3 id="5-2-1-5-最长有效括号"><a href="#5-2-1-5-最长有效括号" class="headerlink" title="5.2.1.5 最长有效括号"></a>5.2.1.5 最长有效括号</h3><p><a href="https://leetcode.cn/problems/longest-valid-parentheses">LeetCode 32.最长有效括号</a> | |<a href="#5.2.1">返回目录5.2.1</a></p><p>方案：此题依旧和上面两个题是一样的原理，做消消乐。同样是成对的消括号，只不过这一次要算一下消除的区域的长度。一个很自然的想法就是：需要消掉的部分的最后一个字符的索引index，减去尚未被消除的部分的最后一个字符的索引index，就是此次消除区域的长度gap。最后要得到的是最长的这个gap，只需要每次用一个max函数更新一下就行。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;code version.1&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestValidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 我们将(符号，索引) 的结构进行入栈，这样就既能判断符号，又可以知道对应的索引了</span></span><br><span class="line">        <span class="comment"># 这里为何要将 stack 初始化为 (&#x27;)&#x27;, -1)？ </span></span><br><span class="line">        <span class="comment"># 因为如果字符串是 &quot;()&quot;开头，这块区域消掉之后，前面并没有未消除区域，我们不太好追溯左边界的索引值，所以要人为设置一个左边界</span></span><br><span class="line">        <span class="comment"># 所以我们假设是由&#x27;)&#x27;开头，且位于-1位置，这样不影响原数据。</span></span><br><span class="line">        <span class="comment"># 而且这个开头一定不会被消掉，相当于规定了一个边界值。所以我们的栈一定不会为空，简化了条件</span></span><br><span class="line">        stack,  gap = [[<span class="string">&#x27;)&#x27;</span>, -<span class="number">1</span>]], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            ch = s[i]</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                <span class="comment"># 如果为左括号，直接入栈符号和其索引</span></span><br><span class="line">                stack.append([ch, i])</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 如果来的是右括号</span></span><br><span class="line">                <span class="keyword">if</span> stack[-<span class="number">1</span>][<span class="number">0</span>] ==<span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                <span class="comment"># 当前来的是右括号，且栈顶元素（上一个符号）是左括号</span></span><br><span class="line">                <span class="comment"># 说明可以被消掉，则先消除前面的符号</span></span><br><span class="line">                    stack.pop()</span><br><span class="line">                    <span class="comment"># 然后用当前索引 i, 减去尚未消掉部分的最后一个字符的索引，得到gap</span></span><br><span class="line">                    gap = <span class="built_in">max</span>(gap, i-stack[-<span class="number">1</span>][<span class="number">1</span>]) </span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                <span class="comment"># 如果为右括号，且无法消掉，直接修改其索引，相当于更新边界</span></span><br><span class="line">                    stack[-<span class="number">1</span>][<span class="number">1</span>] = i</span><br><span class="line">                    <span class="comment"># stack.append([ch, i]) </span></span><br><span class="line">        <span class="keyword">return</span> gap</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27; code version.2</span></span><br><span class="line"><span class="string">上面的code中，栈每次入栈的时候，同时存下了(符号，索引)， 两个数据；</span></span><br><span class="line"><span class="string">这样的好处是便于理解，从直观上看和我们上面的题目的code能统一；</span></span><br><span class="line"><span class="string">但是辅助栈消耗的空间就较大了，这里可以在原有的基础上进一步update</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">### update 进行如下修改</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestValidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack,  gap = [-<span class="number">1</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            ch = s[i]</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                <span class="comment"># 如果为左括号，直接入栈 索引</span></span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 直接弹出栈顶元素</span></span><br><span class="line">                stack.pop()</span><br><span class="line">                <span class="comment"># 下面这段实现的功能是：</span></span><br><span class="line">                <span class="comment"># 如果栈不为空，那就可以直接计算gap值。</span></span><br><span class="line">                <span class="comment"># 如果 弹出栈顶元素之后，栈为空了，那就将现在的右括号的索引入栈存下</span></span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    gap = <span class="built_in">max</span>(gap, i-stack[-<span class="number">1</span>]) </span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    stack.append(i)</span><br><span class="line">                <span class="comment"># 和上面的code发现判断条件从 是左括号还是右括号的，变成了判断栈是否为空</span></span><br><span class="line">                <span class="comment"># ① 假设弹出的是左括号，那么必然不为空，</span></span><br><span class="line">                <span class="comment"># 因为栈中剩下的要么是左括号，要么是右括号（因为我们一开始先假设了一个右括号放在-1位置作为边界值）</span></span><br><span class="line">                <span class="comment"># ② 假设弹出的是右括号，那么栈必然空了，因为在上面的code，我们始终只维护了一个作为边界的右括号；即如果栈不为空，那么有且只有一个右括号存在，且位于最左侧</span></span><br><span class="line">                <span class="comment"># 既然我们不需要再判断出栈的元素是左括号还是右括号，只需要判断栈是否为空</span></span><br><span class="line">                <span class="comment"># 那么意味着我们不需要将符号入栈了！！！只需要入栈索引即可，所以code就改为了这个版本</span></span><br><span class="line">        <span class="keyword">return</span> gap</span><br></pre></td></tr></table></figure><p><span id="5.2.1.6"></span>  </p><h3 id="5-2-1-6-基本计算器"><a href="#5-2-1-6-基本计算器" class="headerlink" title="5.2.1.6 基本计算器"></a>5.2.1.6 基本计算器</h3><p><a href="https://leetcode.cn/problems/basic-calculator">LeetCode 224.基本计算器</a> | | <a href="#5.2.1">返回目录5.2.1</a></p><p>方案：<br>这个题只有加法和减法两种运算符出现，而这两种运算符根据交换律和结合律，是可以从左到右依次计算就行。<br>但是此题还涉及到括号’(‘和’)’，那么这个括号会造成什么影响呢？从直观上来看，括号内的区域要先计算，所以一种思路是先判断括号，然后先计算括号内区域的值，最后退化成只有普通加减法的情况，当涉及到括号的多层嵌套的时候，可能会有点复杂；</p><p>另一种思路，那就是消掉括号，把式子改写为没有括号的情况，而且由于只涉及到加、减运算，消掉括号后依然能保持从左往右的基本计算顺序，只要保证消括号时数字前面的运算符能够完成转换即可。  </p><p>这里采用第二种思路，消括号的思路。 如果把一对括号( )包含的区域视为一个整体的话，这个整体都会受到括号外的正/负号的影响。<br>比如括号外是’+’，那么括号内的每一个运算符都要在原来的基础上多一个’+’,对于加减运算而言，相当于原来的符号不变；<br>如果括号外是’-‘，那么括号内的每一个运算符都要取一次反，即括号内’+’变’-‘，括号内’-‘变’+’。我们在代码中用+1和-1来描述这两种状态。  </p><p>此外该题目还隐藏了一个陷阱： <u>题目举的例子中都是个位数</u>。如果遇到十位、百位不为空的情况，是需要注意，这个数字也会按照字符被分割开。比如12会被分割成1和2的字符依次输入，我们需要将其还原为原始的12！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 把一对括号()包含的区域视为一个整体的话，这个整体都会受到括号外的正/负号的影响</span></span><br><span class="line">        <span class="comment"># 所以对括号内数组的正负号再乘以括号外这个整体的正负号，才是实际的正负号</span></span><br><span class="line">        <span class="comment"># 这里用 +1 表示正，-1表示负，初始状态明显为正</span></span><br><span class="line">        num, preSign = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="comment"># 用一个栈来存储每一个括号区域整体的正负号</span></span><br><span class="line">        sign_list = [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 因为题目中说，字符仅仅包含  数字、&#x27;+&#x27;、&#x27;-&#x27;、&#x27;(&#x27;、&#x27;)&#x27;、和 &#x27; &#x27; </span></span><br><span class="line">        <span class="comment"># 所以我们人为设置一个右边界 + ---&gt; s + &#x27;+&#x27;</span></span><br><span class="line">        <span class="comment"># 这是为了在遇到以数字结尾的情况时，仍能进入运算阶段</span></span><br><span class="line">        <span class="comment"># 就好比在使用计算器时，如果不使用&#x27;=&#x27;号键，按&#x27;+&#x27;键也能得出之前的加减结果</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s + <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> ch.isdigit():</span><br><span class="line">                <span class="comment"># 如果是几个数字字符连续出现，这样就能获得整个数字的实际值，比如&quot;12&quot;</span></span><br><span class="line">                num = num*<span class="number">10</span> + <span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># ch == &#x27;(&#x27; or &#x27;)&#x27; or &#x27;+&#x27; or &#x27;-&#x27;</span></span><br><span class="line">                <span class="comment"># 进入到非数字环节，就要结算前面的数字部分</span></span><br><span class="line">                res += preSign * num</span><br><span class="line">                <span class="comment"># 需要将数字部分重新置零</span></span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">in</span> <span class="string">&#x27;-+&#x27;</span>:</span><br><span class="line">                    <span class="comment"># 后面区域的真实的符号，是要和最近一层的括号区域的符号乘以一次进行修正</span></span><br><span class="line">                    preSign = sign_list[-<span class="number">1</span>]*(-<span class="number">1</span> <span class="keyword">if</span> ch == <span class="string">&#x27;-&#x27;</span> <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">elif</span> ch == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    <span class="comment"># 遇到左括号， 就需要对前面的符号进行暂存</span></span><br><span class="line">                    sign_list.append(preSign)</span><br><span class="line">                <span class="keyword">elif</span> ch == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                    <span class="comment"># 当一个括号结束时，就要消掉一个括号区域的符号</span></span><br><span class="line">                    sign_list.pop()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="5.2.1.7"></span>  </p><h3 id="5-2-1-7-基本计算器Ⅱ"><a href="#5-2-1-7-基本计算器Ⅱ" class="headerlink" title="5.2.1.7 基本计算器Ⅱ"></a>5.2.1.7 基本计算器Ⅱ</h3><p><a href="https://leetcode.cn/problems/basic-calculator-ii">LeetCode 227.基本计算器II</a> | | <a href="#5.2.1">返回目录5.2.1</a>  </p><p>方案：<br>这里相对于上题来说，没有括号符，但是又多了乘法和除法运算符，而这两个运算符的优先级比加、减运算要高。所以我们可以考虑先对高优先级的部分进行运算，其余部分不动。就能退化为简单的没有括号的数组相加形式。<br>具体实现方式为：<br>如果遇到’+’号，就将数字直接存入栈中；<br>如果遇到’-‘号，就将数字取反后存入栈中；<br>如果遇到’*、/‘号，就将数字与栈顶元素运算之后，替换原有栈顶元素存入栈中；</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        num_stack = []</span><br><span class="line">        preSign = <span class="string">&#x27;+&#x27;</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s+<span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> ch.isdigit():</span><br><span class="line">                num = num*<span class="number">10</span> + <span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">if</span> preSign == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    num_stack.append(num)</span><br><span class="line">                <span class="keyword">elif</span> preSign == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    num_stack.append(-num)</span><br><span class="line">                <span class="keyword">elif</span> preSign == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    num_stack.append(num_stack.pop() * num)</span><br><span class="line">                    <span class="comment"># 也可以写成 num_stack[-1] = num_stack[-1] * num</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    num_stack.append(<span class="built_in">int</span>(num_stack.pop() / num))</span><br><span class="line">                    <span class="comment"># 也可以写成 num_stack[-1] = int(num_stack[-1] / num)</span></span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                preSign = ch</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(num_stack)</span><br></pre></td></tr></table></figure><p><span id="5.2.1.8"></span> </p><h3 id="5-2-1-8-字符串解码"><a href="#5-2-1-8-字符串解码" class="headerlink" title="5.2.1.8 字符串解码"></a>5.2.1.8 字符串解码</h3><p><a href="https://leetcode.cn/problems/decode-string">LeetCode 394.字符串解码</a> | | <a href="#5.2.1">返回目录5.2.1</a></p><p>这个题的思想和 <a href="#5.2.1.6">5.2.1.6</a> 很相似，也是有括号，只不过这里是中括号[ ];<br>同样也会有括号外的因素影响括号内的值，5.2.1.6是括号外的符号影响括号内的符号，此题是括号的数字影响括号内的字符重复次数；所以我们也需要用辅助栈来存储括号外的值：<br>建立辅助栈 num_list 和 str_list 来分别存储括号外的数字和字符串。<br>对于数字和字符本身的处理，也借鉴5.2.1.6中的处理方式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decodeString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        num, tmp_str = <span class="number">0</span>, <span class="string">&#x27;&#x27;</span></span><br><span class="line">        num_list, str_list = [], []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch.isdigit():</span><br><span class="line">                <span class="comment"># 如果出现连续的数字字符，通过此方法来还原其真实数值</span></span><br><span class="line">                num = num*<span class="number">10</span> + <span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> ch.isalpha():</span><br><span class="line">                <span class="comment"># 如果出现连续的单字符，也通过此方法来还原大的字符串</span></span><br><span class="line">                tmp_str += ch</span><br><span class="line">            <span class="keyword">elif</span> ch == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                <span class="comment"># 出现左括号，意味着要对括号外的元素进行存储了</span></span><br><span class="line">                num_list.append(num)</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                str_list.append(tmp_str)</span><br><span class="line">                tmp_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 出现右括号，意味着要对最近的一对括号进行清算了</span></span><br><span class="line">                out_num = num_list.pop()</span><br><span class="line">                out_str = str_list.pop()</span><br><span class="line">                <span class="comment"># 一定要注意，括号外的顺序是 out_str + out_num</span></span><br><span class="line">                <span class="comment"># out_num要乘以的是当前括号内的tmp_str                </span></span><br><span class="line">                tmp_str = out_str + out_num * tmp_str</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmp_str</span><br></pre></td></tr></table></figure><p><span id="5.2.1.9"></span></p><h3 id="5-2-1-9-逆波兰表达式求值"><a href="#5-2-1-9-逆波兰表达式求值" class="headerlink" title="5.2.1.9  逆波兰表达式求值"></a>5.2.1.9  逆波兰表达式求值</h3><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">LeetCode 150.逆波兰表达式求值</a> | | <a href="#5.2.1">返回目录5.2.1</a></p><p>方案：该题的思路其实在例3中已经体现出来了，就是观察规律而已。<br>规律就是每遇到一个运算符号，就要用这个符号与运算左侧最近的两个数字，得到一个数字后，继续向右遍历。所以又需要用辅助栈来存储数字。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&quot;+-*/&quot;</span>:</span><br><span class="line">            <span class="comment"># 如果遇到了数字，直接用栈进行存储</span></span><br><span class="line">                s.append(<span class="built_in">int</span>(ch))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果遇到的是运算符，就先把左侧两个数出栈</span></span><br><span class="line">            <span class="comment"># 然后就要用运算符去结合这两个数，得到的结果，存入栈中</span></span><br><span class="line">                a2 = s.pop()</span><br><span class="line">                a1 = s.pop()</span><br><span class="line">                <span class="keyword">if</span> ch == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    s.append(a1+a2)</span><br><span class="line">                <span class="keyword">elif</span> ch == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    s.append(a1-a2)</span><br><span class="line">                <span class="keyword">elif</span> ch == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    s.append(a1*a2)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    s.append(<span class="built_in">int</span>(a1/a2))</span><br><span class="line">        <span class="keyword">return</span> s[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><span id="5.2.1.10"></span></p><h3 id="5-2-1-10-验证栈序列"><a href="#5-2-1-10-验证栈序列" class="headerlink" title="5.2.1.10  验证栈序列"></a>5.2.1.10  验证栈序列</h3><p><a href="https://leetcode.cn/problems/validate-stack-sequences/">LeetCode 946. 验证栈序列</a> | | <a href="#5.2.1">返回目录5.2.1</a></p><p>方案：此题主要是模拟栈的压入压出操作。<br>对于pushed的数字，先假设都能压入，那么每来一个数字，都压入辅助栈；<br>每次压入之后，都要看看栈顶元素是否是poped中的对应位置的数字，是的话，那就又把该数字pop出去  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validateStackSequences</span>(<span class="params">self, pushed: <span class="type">List</span>[<span class="built_in">int</span>], popped: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        s, i = [], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> pushed:</span><br><span class="line">            <span class="comment"># 每遍历一个pushed中的数字，就将其压入辅助栈</span></span><br><span class="line">            s.append(num)</span><br><span class="line">            <span class="keyword">while</span> (s <span class="keyword">and</span> s[-<span class="number">1</span>] == popped[i]):</span><br><span class="line">                s.pop()</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s) == <span class="number">0</span></span><br></pre></td></tr></table></figure><p><span id="5.2.2"></span></p><h2 id="5-2-2-单调栈"><a href="#5-2-2-单调栈" class="headerlink" title="5.2.2 单调栈"></a>5.2.2 单调栈</h2><p>所谓单调栈，就是从栈顶到栈底的方向上是单调递增(减)，所以其实从栈底到栈顶的方向也是单调的。（因为python中一般用 list 来当栈用，所以从序号0开始看的话，我们一般都是看栈底到栈顶的方向。）  </p><p>单调栈如何用操作呢？假设讨论单调递增的情况，如果一个元素比栈顶的元素大，我们才入栈；否则就先pop掉栈顶元素，然后继续比；直到满足等待入栈的元素比栈顶元素大了，或者栈已经为空了，才入栈。<b>这样栈中的元素就是能保持单调递增的关系</b>。</p><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>〇</td><td><a href="#5.2.2.0">解法总结</a></td><td><a href="#5.2.2.0">5.2.2.0题解</a></td></tr><tr><td>①</td><td><a href="https://leetcode.cn/problems/daily-temperatures">LeetCode 739.每日温度</a></td><td><a href="#5.2.2.1">5.2.2.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/next-greater-element-i">LeetCode 496.下一个更大元素 I</a></td><td><a href="#5.2.2.2">5.2.2.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/next-greater-element-ii">LeetCode 503.下一个更大元素 II</a></td><td><a href="#5.2.2.3">5.2.2.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/online-stock-span">LeetCode 901.股票价格跨度</a></td><td><a href="#5.2.2.4">5.2.2.4题解</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">LeetCode 84.柱状图中最大的矩形</a></td><td><a href="#5.2.2.5">5.2.2.5题解</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/trapping-rain-water">LeetCode 42.接雨水</a></td><td><a href="#5.2.2.7">5.2.2.7题解</a></td></tr></tbody></table></div><p><span id="5.2.2.0"></span>  </p><h3 id="5-2-2-0-解法总结"><a href="#5-2-2-0-解法总结" class="headerlink" title="5.2.2.0 解法总结"></a>5.2.2.0 解法总结</h3><p>单调栈通常被用来解决：求上一个更大（小）值 和 下一个更大（小）值的问题，如果遇到这类题型，其核心code的写法几乎都是差不多的，在这里先总结一下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27; 假设 数据列表是 data_lt, 单调栈是 help_s ；</span></span><br><span class="line"><span class="string">    在下面讨论的情况中，单调栈存储的都是索引值index&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;(1) 求下一个更大值 &#x27;&#x27;&#x27;</span> </span><br><span class="line"><span class="comment"># 此时构造单调栈的目标是【单调递减】(可以相等)</span></span><br><span class="line"><span class="comment"># 理由如下：</span></span><br><span class="line"><span class="comment"># 如果元素一直递减(或相等)，意味着【下一个更大数】一直未出现；</span></span><br><span class="line"><span class="comment"># 那么栈就可以一直默认压入元素</span></span><br><span class="line"><span class="comment"># 直到遇到一个【更大数】，栈才会进行pop出栈操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 核心code</span></span><br><span class="line"><span class="keyword">while</span> help_s <span class="keyword">and</span> data_lt[help_s[-<span class="number">1</span>]] &lt; data_lt[i]:</span><br><span class="line">    <span class="comment"># 当栈不为空，且遇当前数 &gt; 栈顶元素，说明遇到了【下一个更大数】</span></span><br><span class="line">    <span class="comment"># 就需要出栈，直到当前数 &lt;= 栈顶元素，栈又能保持单调递减性，既可以跳出循环</span></span><br><span class="line">    <span class="comment"># old_i 代表栈顶元素的索引，很明显，当前i位置的数，就是old_i位置数的【下一个更大数】</span></span><br><span class="line">    old_i = help_s.pop()</span><br><span class="line">    <span class="comment"># gap存储的是old_i位置的数，距离它的【下一个更大数】i位置的 间距</span></span><br><span class="line">    gap[old_i] = i - old_i </span><br><span class="line">    <span class="comment"># next_big_id，存储的是old_i位置数，的【下一个更大数】的索引</span></span><br><span class="line">    next_big_id[old_i] = i  </span><br><span class="line"><span class="comment"># 如果i位置的数能能保持栈的单调递减，就压入i位置的索引</span></span><br><span class="line">help_s.append(i)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;(4) 求下一个更小值&#x27;&#x27;&#x27;</span> </span><br><span class="line"><span class="comment"># 此时构造单调栈的目标是【单调递增】(可以相等)</span></span><br><span class="line"><span class="comment"># 理由如下：</span></span><br><span class="line"><span class="comment"># 如果元素一直递增(或相等)，意味着【下一个更小数】一直未出现；</span></span><br><span class="line"><span class="comment"># 那么栈就可以一直默认压入元素</span></span><br><span class="line"><span class="comment"># 直到遇到一个【更小数】，栈才会进行pop出栈操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 核心code</span></span><br><span class="line"><span class="keyword">while</span> help_s <span class="keyword">and</span> data_lt[help_s[-<span class="number">1</span>]] &gt; data_lt[i]:</span><br><span class="line">    <span class="comment"># 当栈不为空，且遇当前数 &lt; 栈顶元素，说明遇到了【下一个更小数】</span></span><br><span class="line">    <span class="comment"># 就需要出栈，直到当前数 &gt;= 栈顶元素，栈又能保持单调递减性，既可以跳出循环</span></span><br><span class="line">    <span class="comment"># old_i 代表栈顶元素的索引，很明显，当前i位置的数，就是old_i位置数的【下一个更小数】</span></span><br><span class="line">    old_i = help_s.pop()</span><br><span class="line">    gap[old_i] = i - old_i </span><br><span class="line">    next_small_id[old_i] = i  </span><br><span class="line"></span><br><span class="line">help_s.append(i)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;(3) 求上一个更大值 &#x27;&#x27;&#x27;</span> </span><br><span class="line"><span class="comment"># 此时构造单调栈的目标是【单调递减】(不可以相等)</span></span><br><span class="line"><span class="comment"># 理由如下：</span></span><br><span class="line"><span class="comment"># 如果元素一直递减(不可以相等)，意味着前面的数一直比后面的数大，故后面的数的【上一个更大数】，就是紧邻它的上一个数；</span></span><br><span class="line"><span class="comment"># 那么栈就可以一直默认压入元素</span></span><br><span class="line"><span class="comment"># 直到遇到一个较大的数，此时栈顶元素小，为了寻找前面是否有当前数的【上一个更大数】，就需要出栈操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里要注意，相较于求【下一个更大数】，此时的单调栈中是不允许出现连续相等值的</span></span><br><span class="line"><span class="comment"># 因为如果出现相等值，比如连续出现两个6，那么第二个6的前一个数。并不是它的【上一个更大数】</span></span><br><span class="line"><span class="comment"># 为了去寻找上一个更大数，只能往更前方去寻找，所以还是要执行出栈操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 核心code</span></span><br><span class="line"><span class="keyword">while</span> help_s <span class="keyword">and</span> data_lt[help_s[-<span class="number">1</span>]] &lt;= data_lt[i]:</span><br><span class="line">    <span class="comment"># 当栈不为空，且遇当前数 &gt;= 栈顶元素，说明当前数需要去更前方寻找【上一个更大数】</span></span><br><span class="line">    <span class="comment"># 就需要出栈，直到当前数 &lt; 栈顶元素，栈又能保持单调性，说明找到了当前数的【上一个更大数】</span></span><br><span class="line">    help_s.pop()</span><br><span class="line"><span class="comment"># 跳出while循环后，栈顶的数是满足&lt;上一个更大数&gt;的条件的</span></span><br><span class="line">last_big_id[i] = help_s[-<span class="number">1</span>] <span class="keyword">if</span> help_s <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">gap[i] = i - help_s[-<span class="number">1</span>] <span class="keyword">if</span> help_s <span class="keyword">else</span> i <span class="comment"># or -1</span></span><br><span class="line"> </span><br><span class="line">help_s.append(i)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;(4) 上一个更小值 &#x27;&#x27;&#x27;</span> </span><br><span class="line"><span class="comment"># 此时构造单调栈的目标是【单调递增】(不可以相等)</span></span><br><span class="line"><span class="comment"># 理由如下：</span></span><br><span class="line"><span class="comment"># 如果元素一直递增(不可以相等)，意味着前面的数一直比后面的数小，故后面的数的【上一个更小数】，就是紧邻它的上一个数；</span></span><br><span class="line"><span class="comment"># 直到遇到一个较小的数，此时栈顶元素较大，为了寻找前面是否有当前数的【上一个更小数】，就需要出栈操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里要注意，相较于求【下一个更小数】，此时的单调栈中是不允许出现连续相等值的</span></span><br><span class="line"><span class="comment"># 因为如果出现相等值，比如连续出现两个6，那么第二个6的前一个数。并不是它的【上一个更小数】</span></span><br><span class="line"><span class="comment"># 为了去寻找上一个更小数，只能往更前方去寻找，所以还是要执行出栈操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 核心code</span></span><br><span class="line"><span class="keyword">while</span> help_s <span class="keyword">and</span> data_lt[help_s[-<span class="number">1</span>]] &gt;= data_lt[i]:</span><br><span class="line">    <span class="comment"># 当栈不为空，且遇当前数 &lt;= 栈顶元素，说明当前数需要去更前方寻找【上一个更小数】</span></span><br><span class="line">    <span class="comment"># 就需要出栈，直到当前数 &gt; 栈顶元素，栈又能保持单调性，说明找到了当前数的【上一个更小数】</span></span><br><span class="line">    help_s.pop()</span><br><span class="line"><span class="comment"># 跳出while循环后，栈顶的数是满足&lt;上一个更小数&gt;的条件的</span></span><br><span class="line">last_small_id = help_s[-<span class="number">1</span>] <span class="keyword">if</span> help_s <span class="keyword">else</span> -<span class="number">1</span> </span><br><span class="line">gap[i] = i - help_s[-<span class="number">1</span>] <span class="keyword">if</span> help_s <span class="keyword">else</span> i <span class="comment"># or -1</span></span><br><span class="line"></span><br><span class="line">help_s.append(i)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">找更大 、 更小时，栈里的数据</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 找【更大】数，不管是上一个还是下一个，单调栈中 数据的趋势是递减的；</span></span><br><span class="line"><span class="comment"># 找【更小】数，不管是上一个还是下一个，单调栈中 数据的趋势是递增的。</span></span><br></pre></td></tr></table></figure><p><span id="5.2.2.1"></span>  </p><h3 id="5-2-2-1-每日温度"><a href="#5-2-2-1-每日温度" class="headerlink" title="5.2.2.1 每日温度"></a>5.2.2.1 每日温度</h3><p><a href="https://leetcode.cn/problems/daily-temperatures">LeetCode 739.每日温度</a> | | <a href="#5.2.2">返回目录5.2.2</a></p><p>方案：<br>此题的核心思想就是：【求下一个更大数】<br>用的是单调栈，且保持单调递减的关系。<br>就是如果后面的温度总比前一天小（或相等），我们就可以不管它，相当于直接入单调栈；<br>如果后面的温度比前面的大，我们才来计算相差的gap天数。具体看操作看code：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        s = [] <span class="comment"># s是单调栈</span></span><br><span class="line">        N = <span class="built_in">len</span>(temperatures)</span><br><span class="line">        <span class="comment"># gap 是用来保存相差天数的数组，默认为0</span></span><br><span class="line">        gap = [<span class="number">0</span>]*N</span><br><span class="line">        <span class="comment"># 这里我们的单调栈存储的是天数（index），但是用的是温度值进行比较大小</span></span><br><span class="line">        <span class="comment"># 因为只要能获得index，就能从温度数组中定位到具体的温度</span></span><br><span class="line">        <span class="comment"># 对于该方法，我们维护的单调栈是递减的（或相等）</span></span><br><span class="line">        <span class="comment"># 即每遍历到一个元素，栈顶的元素应当 不小于 当前元素</span></span><br><span class="line">        <span class="comment"># 否则，当前元素就是【更大数】，就需要出栈计算差值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="comment"># 单调栈不为空，且当前元素 比 栈顶元素大的情况，我们就需要操作</span></span><br><span class="line">            <span class="keyword">while</span> s <span class="keyword">and</span> temperatures[i] &gt; temperatures[s[-<span class="number">1</span>]]:</span><br><span class="line">                <span class="comment"># 将单调栈的栈顶元素出栈</span></span><br><span class="line">                <span class="comment"># 对于该题，lower_i 是之前较低温度的索引</span></span><br><span class="line">                lower_i = s.pop()</span><br><span class="line">                <span class="comment"># 同时顺便计算一波差值delta</span></span><br><span class="line">                <span class="comment"># 即被出栈的那一天，与当前日期的差值，（因为当前天就是一个高温值）</span></span><br><span class="line">                gap[lower_i] = i - lower_i</span><br><span class="line">            <span class="comment"># 直到满足了单调递减的关系，（或者栈为空），我们才入栈</span></span><br><span class="line">            s.append(i)</span><br><span class="line">        <span class="keyword">return</span> gap</span><br></pre></td></tr></table></figure><p><span id="5.2.2.2"></span>  </p><h3 id="5-2-2-2-下一个更大元素I"><a href="#5-2-2-2-下一个更大元素I" class="headerlink" title="5.2.2.2 下一个更大元素I"></a>5.2.2.2 下一个更大元素I</h3><p><a href="https://leetcode.cn/problems/next-greater-element-i">LeetCode 496.下一个更大元素 I</a> | | <a href="#5.2.2">返回目录5.2.2</a></p><p>方案:问题分为两个子问题:<br>①依据nums1中的元素定位到nums2中的索引位置；<br>②求该位置下一个更大的元素;<br>对于问题①，虽然可以用list.index(obj)来返回，但是该操作每次执行的时间复杂度是O(N)；<br>所以干脆先遍历一道nums2，将元素和索引存入哈希表中，后续再查的时候，查询的时间复杂度就是O(1)。<br>对于问题②，其实就是 【求下一更大数】 这个问题，直接套用单调栈核心code。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;方案1. 暴力求解&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hash_l = &#123;&#125;</span><br><span class="line">        N2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        <span class="comment"># 先将nums2的元素与序号对应关系存入哈希表</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums2):</span><br><span class="line">            hash_l[num] = i</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每次遍历nums1获得的num，都去num2中其位置右侧进行遍历，试图找到最近的最大值</span></span><br><span class="line">        <span class="comment"># 时间复杂度 O(N1*N2)</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums1:</span><br><span class="line">            index = hash_l[num]</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">while</span> index &lt; N2 <span class="keyword">and</span> <span class="keyword">not</span> flag:</span><br><span class="line">                <span class="keyword">if</span> nums2[index] &gt; num:</span><br><span class="line">                    res.append(nums2[index])</span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> flag: res.append(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;方案2. 利用单调栈，借鉴【5.2.8 每日温度】的解法&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        h=&#123;&#125;</span><br><span class="line">        N = <span class="built_in">len</span>(nums2)</span><br><span class="line">        s, next_big_val = [], [-<span class="number">1</span>]*N</span><br><span class="line">        <span class="comment"># 注意，此题需要求的是【下一个更大数】的数值，所以 next_big_val直接存入数值</span></span><br><span class="line">        <span class="comment"># 且题目中规定了，不存在的话值为-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            h[nums2[i]]=i</span><br><span class="line">            <span class="keyword">while</span> s <span class="keyword">and</span> nums2[s[-<span class="number">1</span>]] &lt; nums2[i]:</span><br><span class="line">                lower_i = s.pop()</span><br><span class="line">                next_big_val[lower_i] = nums2[i] <span class="comment"># 这里直接存储nums2的元素</span></span><br><span class="line">            s.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [next_big_val[h[num]] <span class="keyword">for</span> num <span class="keyword">in</span> nums1]</span><br></pre></td></tr></table></figure><p><span id="5.2.2.3"></span>  </p><h3 id="5-2-2-3-下一个更大元素-II"><a href="#5-2-2-3-下一个更大元素-II" class="headerlink" title="5.2.2.3 下一个更大元素 II"></a>5.2.2.3 下一个更大元素 II</h3><p><a href="https://leetcode.cn/problems/next-greater-element-ii">LeetCode 503.下一个更大元素 II</a> | | <a href="#5.2.2">返回目录5.2.2</a></p><p>方案：问题本质依旧是【求下一个更大数】；核心点在于数组可以循环。<br>也就是一个数能够往右看的范围，到数组尾部后，又可以从头可以回到它自己身上。<br>那么说明如果看完一圈还没有找到更大的话，那再多看几圈也不会有更大的。所以数组最多遍历2次就够了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;1.最简单的思路，就是把原来数组扩充一倍，</span></span><br><span class="line"><span class="string">    只不过返回结果的时候，只返回前N个就可以了&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElements</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        s, res = [], [-<span class="number">1</span>]*<span class="number">2</span>*N</span><br><span class="line">        nums2 = nums + nums</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums2)):</span><br><span class="line">            <span class="keyword">while</span> s <span class="keyword">and</span> nums2[i] &gt; nums2[s[-<span class="number">1</span>]]:</span><br><span class="line">                tmp_i = s.pop()</span><br><span class="line">                res[tmp_i] = nums2[i] <span class="comment"># 直接存储数字值</span></span><br><span class="line">            s.append(i)</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>:N]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;方案1稍微有点耗内存，可以考虑不用扩充数组的方式来循环，即求模运算。</span></span><br><span class="line"><span class="string">但求模可能又会多花点时间&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElements</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        s = []</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        next_big_val = [-<span class="number">1</span>]*N</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*N):</span><br><span class="line">            <span class="comment"># nums取值将index限定在[0,N-1]</span></span><br><span class="line">            <span class="keyword">while</span> s <span class="keyword">and</span> nums[s[-<span class="number">1</span>]] &lt; nums[i%N]:</span><br><span class="line">                lower_i = s.pop()</span><br><span class="line">                next_big_val[lower_i] = nums[i%N]</span><br><span class="line">            <span class="comment"># s存入index时，也要求模运算，将index限定在[0,N-1]</span></span><br><span class="line">            s.append(i%N)</span><br><span class="line">        <span class="keyword">return</span> next_big_val</span><br></pre></td></tr></table></figure><p><span id="5.2.2.4"></span>  </p><h3 id="5-2-2-4-股票价格跨度"><a href="#5-2-2-4-股票价格跨度" class="headerlink" title="5.2.2.4 股票价格跨度"></a>5.2.2.4 股票价格跨度</h3><p><a href="https://leetcode.cn/problems/online-stock-span">LeetCode 901.股票价格跨度</a> | | <a href="#5.2.2">返回目录5.2.2</a></p><p>方案：问题本质：【求上一个更大数】。gap是当前 i 位置与上一个更大元素的位置的gap。那么在这个gap区间，所有的数都是小于当前值的，这就是该题要求的跨度。<br>所以我们需要维护一个 单调递减栈。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StockSpanner</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__s = []</span><br><span class="line">        self.__data = []</span><br><span class="line">        self.__<span class="built_in">len</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self, price: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 需要先存入新来的数据</span></span><br><span class="line">        self.__<span class="built_in">len</span> +=<span class="number">1</span></span><br><span class="line">        self.__data.append(price)</span><br><span class="line">        i = self.__<span class="built_in">len</span> - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> self.__s <span class="keyword">and</span> self.__data[self.__s[-<span class="number">1</span>]] &lt;= price:</span><br><span class="line">            self.__s.pop()</span><br><span class="line">        gap = i- self.__s[-<span class="number">1</span>] <span class="keyword">if</span> self.__s <span class="keyword">else</span> self.__<span class="built_in">len</span></span><br><span class="line">        self.__s.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> gap</span><br></pre></td></tr></table></figure><p><span id="5.2.2.5"></span></p><h3 id="5-2-2-5-柱状图中最大的矩形"><a href="#5-2-2-5-柱状图中最大的矩形" class="headerlink" title="5.2.2.5 柱状图中最大的矩形"></a>5.2.2.5 柱状图中最大的矩形</h3><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">LeetCode 84.柱状图中最大的矩形</a> | | <a href="#5.2.2">返回目录5.2.2</a></p><p>方案：<br>首先，对于每一个柱状体，都至少有一个面积，就是它自身。<br>其次，如果一个柱状体的左右两侧都有高于或等于它的柱状体，那么它就能以它自身的高度进行横向扩展。<br>所以，对于每一个柱状体能够构成的矩形，其高度是固定的，就是该柱状体的高度，我们只需要求能够扩展的宽度，就能求出以每一个柱状体为base，能够构成的最大矩形的面。<br>所以这个题目，就转化成了一个求每个柱状体能够扩展的最大的宽度的这么一个问题。<br>也就是说，对于每一个柱状体，需要找到左侧第一个比它小的柱状体，和右侧第一个比它小的柱状体。这二者之间间隔的宽度，就是能够扩展的最大宽度。<br><strong><font color="#FF0000">问题就转化成了：【上一个更小数】，和【下一个更小数】</font></strong>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(heights)</span><br><span class="line">        left_small_list, right_small_list = [-<span class="number">1</span>]*N, [N]*N</span><br><span class="line">        L_s, R_S = [], []</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="comment"># 求【上一个更小数】的索引</span></span><br><span class="line">            <span class="keyword">while</span> L_s <span class="keyword">and</span> heights[i] &lt;= heights[L_s[-<span class="number">1</span>]]:</span><br><span class="line">                L_s.pop()</span><br><span class="line">            left_small_list[i] = L_s[-<span class="number">1</span>] <span class="keyword">if</span> L_s <span class="keyword">else</span> -<span class="number">1</span> <span class="comment"># L_S 为空的话，最左侧边界为-1</span></span><br><span class="line">            L_s.append(i)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 求【下一个更小数】的索引</span></span><br><span class="line">            <span class="keyword">while</span> R_S <span class="keyword">and</span> heights[i] &lt; heights[R_S[-<span class="number">1</span>]]:</span><br><span class="line">                larger_i = R_S.pop()</span><br><span class="line">                right_small_list[larger_i] = i</span><br><span class="line">            R_S.append(i)</span><br><span class="line">        <span class="comment"># print(left_small_list, right_small_list)</span></span><br><span class="line">        <span class="comment"># 区间宽度就是：下一个最小的索引 - 上一个最小的索引 - 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>([heights[i]*(right_small_list[i] - left_small_list[i]-<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="5.2.2.7"></span>  </p><h3 id="5-2-2-7-接雨水"><a href="#5-2-2-7-接雨水" class="headerlink" title="5.2.2.7 接雨水"></a>5.2.2.7 接雨水</h3><p><a href="https://leetcode.cn/problems/trapping-rain-water">LeetCode 42.接雨水</a> | | <a href="#5.2.2">返回目录5.2.2</a></p><p>该题在处已经讲过，但是同样可以用单调栈来做。<br>考虑何时当前柱子能够接到水？必然是其左右侧都有高于它的边界才行。<br>如果对于遍历的数，如果求【上一个更大数】，那么这上一个更大数（可相等），和当前数之间的区域，就都能装水；<br>因为这区间的中的数，都小于当前数，同样更小于找到的【上一个更大数（相等数）】；<br>由于维护的单调栈是单调递减的，所以在寻找【上一个更大数】的过程中，每从栈中pop处一个数，<br>该数的左侧数一定是比它高的（因为递减关系），那么被pop出来的数 的左侧的数，就能作为被pop出的数的左边界。<br>此时，就能计算从pop出的位置开始，向右延伸到当前位置为右边的，一条横的水柱的体积。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27; 单调栈解法&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(height)</span><br><span class="line">        <span class="comment"># 最左和最右的柱子只能当边界，无法装水</span></span><br><span class="line">        <span class="comment"># 柱子一定要至少有3个才能装水</span></span><br><span class="line">        water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> N &lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> water</span><br><span class="line"></span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">while</span> s <span class="keyword">and</span> height[i] &gt; height[s[-<span class="number">1</span>]]:</span><br><span class="line">                <span class="comment"># 过程中每pop出一个索引，就要计算pop出的这个位置，能装多少水</span></span><br><span class="line">                tmp = s.pop()</span><br><span class="line">                <span class="keyword">if</span> s:</span><br><span class="line">                <span class="comment"># 当栈中还有元素可以作为左边界时，才进行下面的运算</span></span><br><span class="line">                    <span class="comment"># 刚刚被pop出的tmp的左侧数，也就是当前栈顶元素，作为tmp的左边界</span></span><br><span class="line">                    L = s[-<span class="number">1</span>]</span><br><span class="line">                    <span class="comment"># 以当前位置i作为tmp的右边界，计算区间宽度</span></span><br><span class="line">                    W = i - L -<span class="number">1</span></span><br><span class="line">                    <span class="comment"># 计算这个横向水柱的高度</span></span><br><span class="line">                    H = <span class="built_in">min</span>(height[L], height[i]) - height[tmp]</span><br><span class="line">                    water += W * H </span><br><span class="line">            s.append(i)</span><br><span class="line">        <span class="keyword">return</span> water</span><br></pre></td></tr></table></figure><p><span id="5.2.3"></span>  </p><h2 id="5-2-3-队列的常见题目："><a href="#5-2-3-队列的常见题目：" class="headerlink" title="5.2.3 队列的常见题目："></a>5.2.3 队列的常见题目：</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/implement-stack-using-queues/">LeetCode 225.用队列实现栈</a></td><td><a href="#5.2.3.1">5.2.3.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/design-circular-queue/">LeetCode 622.设计循环队列</a></td><td><a href="#5.2.3.2">5.2.3.2题解</a></td></tr></tbody></table></div><p><span id="5.2.3.1"></span>  </p><h3 id="5-2-3-1-用队列实现栈"><a href="#5-2-3-1-用队列实现栈" class="headerlink" title="5.2.3.1 用队列实现栈"></a>5.2.3.1 用队列实现栈</h3><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">LeetCode 225.用队列实现栈</a> | | <a href="#5.2.3">返回目录5.2.3</a></p><p>方案：核心点在于队列只能从队首元素出队，也就是说，先进的先出；而栈是后进的先出。<br>那么如果要出栈，只需要把队尾的那个元素，挪到队首即可，怎么挪呢？<br>可以把前面的所有元素先存到另一个队列里去，这样队列元素的顺序依然能够保持，剩下一个队尾元素，进行出队列操作即可。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 虽然也能用list来充当队列，但是这里可以用更为标准的队列类:deque来作为队列使用</span></span><br><span class="line">        <span class="comment"># 注意，deque其实是个双端队列，这里我们使用左侧为出队，右侧入队</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        self.__q_a = deque([])</span><br><span class="line">        self.__q_b = deque([])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.__q_a <span class="keyword">and</span> <span class="keyword">not</span> self.__q_b:</span><br><span class="line">            <span class="comment"># 如果两个队列初始都为空，就先默认用队列a来填充元素</span></span><br><span class="line">            self.__q_a.append(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 否则的话就使用二者中 不为空 的那个队列来填充</span></span><br><span class="line">        <span class="comment"># (我们在后续的操作中，会保证常规状态下至少有一个队列是空的，另一个队列用来装元素)</span></span><br><span class="line">        <span class="comment"># (所以不会出现两个队列都有元素的状态)</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> self.__q_a:</span><br><span class="line">            self.__q_b.append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__q_a.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果当前是队列a有元素</span></span><br><span class="line">        <span class="keyword">if</span> self.__q_a:</span><br><span class="line">            <span class="comment"># 那就将队列a中除了队尾元素之外的所有元素装入队列b</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self.__q_a)&gt;<span class="number">1</span>:</span><br><span class="line">                self.__q_b.append(self.__q_a.popleft())</span><br><span class="line">            <span class="comment"># 然后使用出队列操作弹出a队列中仅剩的这一个队尾元素（被当做栈顶元素）</span></span><br><span class="line">            <span class="keyword">return</span> self.__q_a.popleft()</span><br><span class="line">            <span class="comment"># 结束后，会发现队列a为空，元素全在队列b中了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果当前队列b有元素,操作同上</span></span><br><span class="line">        <span class="keyword">elif</span> self.__q_b:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self.__q_b)&gt; <span class="number">1</span>:</span><br><span class="line">                self.__q_a.append(self.__q_b.popleft())</span><br><span class="line">            <span class="keyword">return</span> self.__q_b.popleft()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 两个队列都为空</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 栈的top()操作本来就有队列中对应的 rear()操作，即取末尾元素</span></span><br><span class="line">        <span class="keyword">if</span> self.__q_a:</span><br><span class="line">            <span class="keyword">return</span> self.__q_a[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__q_b[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.__q_a <span class="keyword">and</span> <span class="keyword">not</span> self.__q_b:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><span id="5.2.3.2"></span>  </p><h3 id="5-2-3-2-设计循环队列"><a href="#5-2-3-2-设计循环队列" class="headerlink" title="5.2.3.2 设计循环队列"></a>5.2.3.2 设计循环队列</h3><p><a href="https://leetcode.cn/problems/design-circular-queue/">LeetCode 622.设计循环队列</a> | | <a href="#5.2.3">返回目录5.2.3</a></p><p>思路：<br>①首先，要设置 head 和 tail 两个游标，分别来控制队首和队尾；<br>∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷<br>②在初始化的时候，heal 和 tail 两个游标默认值通常是0的；<br>那么也就推出，在后续判断队列是否为空的时候，判断条件就是 head == tail;<br>∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷<br>③对于普通队列，如果tail超过了数组的长度length，那就说明队列满了；<br>但是由于此题是要构造循环队列，所以单纯用数组的长度来限制，是不够的；<br>将数组收尾相连成环的话，会发现，如果 tail的下一个位置是head，说明确实无空间再存储新元素了；<br>所以满队列的条件应当是 (tail +1) % length。<br>∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷<br>④关于tail游标指向的位置，是否应该指向最后一个元素？<br>在初始化时，head 和 tail 都是0，且 判断空队列的条件是，head == tail;<br>所以在队列为空的时候，tail指向的位置是head，但其实head处是没有元素的；<br>如果新增一个元素，head位置有元素了，队列不为空，那么tail就不应该再指向head；<br>而是应该指向head 的下一位；<br>由此可以知道，tail其实并不指向最后一个元素的位置，而是应该指向最后一个元素的下一个位置；<br>成为类似于“右边界”的存在。<br>所以，如果要让队列能存储的数据有 K 个，那么实际上需要有 K+1 长度的数组；<br>这样，当队列在不dequeue操作，第一次装满时：head=0，指向第一个元素；最后一个元素的位置是K；tail指向的是K+1</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k: <span class="built_in">int</span></span>):</span><br><span class="line">        self.__cycle_q = [-<span class="number">999</span>] *(k+<span class="number">1</span>)</span><br><span class="line">        self.__head = <span class="number">0</span></span><br><span class="line">        self.__tail = <span class="number">0</span></span><br><span class="line">        self.__<span class="built_in">len</span> = k+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enQueue</span>(<span class="params">self, value: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> self.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__cycle_q[self.__tail] = value</span><br><span class="line">            self.__tail = (self.__tail+<span class="number">1</span>) % self.__<span class="built_in">len</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deQueue</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 并不需要真的删除原来的head指向的元素</span></span><br><span class="line">            <span class="comment"># 只需要将它排除出有效区间即可</span></span><br><span class="line">            self.__head = (self.__head+<span class="number">1</span>) % self.__<span class="built_in">len</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Front</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:         </span><br><span class="line">            <span class="keyword">return</span> self.__cycle_q[self.__head]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Rear</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 这里要留心，tail指向的是最后元素的下一位</span></span><br><span class="line">            <span class="comment"># 所以最后的元素是 tail-1的位置！         </span></span><br><span class="line">            <span class="keyword">return</span> self.__cycle_q[self.__tail-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.__head == self.__tail</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isFull</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> (self.__tail+<span class="number">1</span>) % self.__<span class="built_in">len</span> == self.__head</span><br></pre></td></tr></table></figure><h2 id="5-2-4-优先队列："><a href="#5-2-4-优先队列：" class="headerlink" title="5.2.4 优先队列："></a>5.2.4 优先队列：</h2><p>优先队列，是一种特殊的队列。它的增加和删除元素的方式和普通队列一样，入队从队尾增加元素，出队删除队头元素。区别点在于，普通队列的内部元素顺序就是按照元素入队列的顺序排布的，而<b>优先队列自己会将内部元素按照一定的顺序进行排布。</b>  </p><p>也就是说，在新元素添加到队尾之后，队列会自己将这个新元素放到合适的位置，使得满足其顺序定义。而在出队列操作，弹出队首元素后，队列也会对剩下的元素重新梳理一遍顺序。而这个顺序，其实就是之前在排序章节，堆排序部分，讲过的堆结构的顺序。  </p><p><font color="purple"><b>所以优先队列也被称为堆队列(Heap queue)，可以理解为大（小）根堆。python中有自带的优先队列的库:<code>heapq</code>，</b></font><br><a href="https://docs.python.org/3/library/heapq.html">官方文档点击此处</a>。<a href="https://github.com/python/cpython/blob/main/Lib/heapq.py">官方源码点击此处</a>。<br>下面讲解几个常用的操作：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">list_test = [<span class="number">10</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">1.heapify </span></span><br><span class="line"><span class="string">将list转换为一个 小根堆，最小的元素会被放到队首（根节点）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">heapq.heapify(list_test)</span><br><span class="line"><span class="built_in">print</span>(list_test)</span><br><span class="line"><span class="comment"># [0, 1, 4, 2, 5, 6, 8, 10, 9, 7]</span></span><br><span class="line"><span class="comment"># (结果顺序并不一定和这个相同，只要0在根结点，满足小根堆，都是对的)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">2.heappush </span></span><br><span class="line"><span class="string">将新元素插入末尾，并按照小根堆的顺序排序</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">heapq.heappush(list_test, -<span class="number">1</span>)</span><br><span class="line">heapq.heappush(list_test, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(list_test)</span><br><span class="line"><span class="comment"># [-1, 0, 4, 2, 1, 6, 8, 10, 9, 7, 5, 20]</span></span><br><span class="line"><span class="comment"># (结果顺序并不一定和这个相同，只要-1在根结点，20在某个叶子结点，满足小根堆，都是对的)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 3.heappop </span></span><br><span class="line"><span class="string">将队首元素（根节点）弹出，并将剩下的元素恢复成小根堆</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">top = heapq.heappop(list_test)</span><br><span class="line"><span class="built_in">print</span>(list_test)</span><br><span class="line"><span class="comment"># [0, 1, 4, 2, 5, 6, 8, 10, 9, 7, 20]</span></span><br><span class="line"><span class="built_in">print</span>(top)</span><br><span class="line"><span class="comment"># -1</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 4.heapreplace </span></span><br><span class="line"><span class="string">同时执行heappop和heappush，但注意，操作顺序是：</span></span><br><span class="line"><span class="string">先pop队首元素，然后push新元素</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">top2 = heapq.heapreplace(list_test, <span class="number">11</span>)</span><br><span class="line"><span class="built_in">print</span>(list_test)</span><br><span class="line"><span class="comment"># [1, 2, 4, 9, 5, 6, 8, 10, 11, 7, 20]</span></span><br><span class="line"><span class="built_in">print</span>(top2)</span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 5.heappushpop </span></span><br><span class="line"><span class="string">同时执行heappush和heappop，</span></span><br><span class="line"><span class="string">这里先push新元素，然后再pop队首元素</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">top3 = heapq.heappushpop(list_test, -<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(list_test)</span><br><span class="line"><span class="comment"># [1, 2, 4, 9, 5, 6, 8, 10, 11, 7, 20]</span></span><br><span class="line"><span class="built_in">print</span>(top3)</span><br><span class="line"><span class="comment"># -10 </span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 6.merge </span></span><br><span class="line"><span class="string"># 将多个堆合并,合并后的结果也是小根堆</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">a = [<span class="number">10</span>, <span class="number">7</span>, <span class="number">6</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">c = heapq.merge(a,b)</span><br><span class="line"><span class="built_in">print</span>(c, <span class="built_in">list</span>(c))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 7.nlargest </span></span><br><span class="line"><span class="string"> 查询堆中的最大n个元素， 并返回</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">nlarge = heapq.nlargest(<span class="number">3</span>, list_test)</span><br><span class="line"><span class="built_in">print</span>(nlarge)</span><br><span class="line"><span class="comment"># [20, 11, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 8.nsmallest </span></span><br><span class="line"><span class="string"># 查询堆中的最小n个元素</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">nsmall = heapq.nsmallest(<span class="number">3</span>, list_test)</span><br><span class="line"><span class="built_in">print</span>(nsmall)</span><br><span class="line"><span class="comment"># [1, 2, 4]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 9._heapify_max </span></span><br><span class="line"><span class="string"># 构造大根堆 </span></span><br><span class="line"><span class="string"># 注意, 对于数值型数据，一般都不会用到建立大根堆的操作</span></span><br><span class="line"><span class="string"># 因为将数值取反，建立小根堆，就能完成大根堆的目的</span></span><br><span class="line"><span class="string"># 举例： list_new = list(map(lambda x : -x, list_test))</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">heapq._heapify_max(list_test)</span><br><span class="line"><span class="built_in">print</span>(list_test)   </span><br><span class="line"><span class="comment"># 同时，如果是用这种方式构造的大根堆，其pop是：</span></span><br><span class="line"><span class="comment"># heapq._heappop_max</span></span><br><span class="line"><span class="comment"># 更为具体的一些写法参考源码： https://github.com/python/cpython/blob/main/Lib/heapq.py</span></span><br><span class="line"><span class="comment"># 大根堆对应的函数并不多，所以在日常中一般自己将数值取反，然后使用小根堆</span></span><br></pre></td></tr></table></figure><p><span id="5.2.4"></span>  </p><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/sliding-window-maximum/">LeetCode 239.滑动窗口最大值</a></td><td><a href="#5.2.4.1">5.2.4.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream/">LeetCode 703.数据流中的第 K 大元素</a></td><td><a href="#5.2.4.2">5.2.4.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">LeetCode 215.数组中的第K个最大元素</a></td><td><a href="#5.2.4.3">5.2.4.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/top-k-frequent-elements/">LeetCode 347.前 K 个高频元素</a></td><td><a href="#5.2.4.4">5.2.4.4题解</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/sort-characters-by-frequency/">LeetCode 451.根据字符出现频率排序</a></td><td><a href="#5.2.4.5">5.2.4.5题解</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/find-median-from-data-stream/">LeetCode 295.数据流的中位数</a></td><td><a href="#5.2.4.6">5.2.4.6题解</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/k-closest-points-to-origin/">LeetCode 973.最接近原点的 K 个点</a></td><td><a href="#5.2.4.7">5.2.4.7题解</a></td></tr></tbody></table></div><p><span id="5.2.4.1"></span>  </p><h3 id="5-2-4-1-滑动窗口最大值"><a href="#5-2-4-1-滑动窗口最大值" class="headerlink" title="5.2.4.1 滑动窗口最大值"></a>5.2.4.1 滑动窗口最大值</h3><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">LeetCode 239.滑动窗口最大值</a> | | <a href="#5.2.4">返回目录5.2.4</a></p><p>思路：滑动窗口是典型的用优先队列的题目。如果直接使用暴力方法，一般都会超时。<br>这里由于要求窗口内最大的元素，所以要建立大根堆。但是python自带的<code>heapq</code>默认建立的是小根堆，我们只需要把元素取反即可适应它的默认结构，获取结果时记得取反取回来就好  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> N &lt;= k:</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">max</span>(nums)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 暴力求解会超时</span></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># for i in range(0,N-k+1):</span></span><br><span class="line">        <span class="comment">#     res.append(max(nums[i:i+k]))</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> heapq </span><br><span class="line">        <span class="comment"># 先将第一个宽度为k的窗口内的元素初始化为优先队列</span></span><br><span class="line">        <span class="comment"># 记得要将元素值取反去建立小根堆</span></span><br><span class="line">        window = [(-nums[i], i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">        heapq.heapify(window)</span><br><span class="line">        <span class="comment"># 小根堆最小的元素，取反之后的原数值就是最大的</span></span><br><span class="line">        res = [-window[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">        <span class="comment"># print(window)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 窗口每挪动一次，就用heappush添加一个数，维护成小根堆</span></span><br><span class="line">        <span class="comment"># 需要注意的是，如果堆顶元素，不在当前滑动窗口范围内，要及时pop出去</span></span><br><span class="line">        <span class="comment"># i 指向作为滑动窗口的最后一个元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, N):</span><br><span class="line">            <span class="comment"># 当前堆顶元素，不在当前窗口 i-k+1 ~ i 内</span></span><br><span class="line">            <span class="keyword">while</span> window <span class="keyword">and</span> window[<span class="number">0</span>][<span class="number">1</span>] &lt; i-k+<span class="number">1</span>:</span><br><span class="line">                heapq.heappop(window)</span><br><span class="line">            <span class="comment"># 将 i 位置的数push入</span></span><br><span class="line">            heapq.heappush(window, (-nums[i], i))</span><br><span class="line">            res.append(-window[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;值得注意的是，堆的规模其实并不一定会维持在k的大小；</span></span><br><span class="line"><span class="string">           因为pop操作只是在堆顶元素不在窗口内时执行；</span></span><br><span class="line"><span class="string">           有一些元素如果已经不在窗口内，但是其并不在堆顶的话，并不影响我们取值；</span></span><br><span class="line"><span class="string">           所以可以留在堆里不用管；</span></span><br><span class="line"><span class="string">           核心是，要保证每一次的堆顶元素，要在考察的窗口内！&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># print(window)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="5.2.4.2"></span>  </p><h3 id="5-2-4-2-数据流中的第-K-大元素"><a href="#5-2-4-2-数据流中的第-K-大元素" class="headerlink" title="5.2.4.2 数据流中的第 K 大元素"></a>5.2.4.2 数据流中的第 K 大元素</h3><p><a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream/">LeetCode 703.数据流中的第 K 大元素</a> | | <a href="#5.2.4">返回目录5.2.4</a></p><p>思路：因为要返回第K大的元素，所以每新到一个数，我们就需要将其与原来的前k大的元素相比较，然后判断这个新的数是否能够被划入前 k 大的元素中，并可以丢弃那些已经不在前k大范围内的数。<br>这是一个动态的过程，相当于维护了一个保留前k大数的数组。<br>python的默认优先队列是小根堆，意思是根节点的值一定比左右子树的值小。<br>如果设置优先队列的长度为 k ， 那么根节点下面就有 k-1 个比它大树，那么根节点恰好就是就是第 k 大 的数。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        self.__nums = nums</span><br><span class="line">        <span class="comment"># 先将初始化列表构造为一个小根堆</span></span><br><span class="line">        heapq.heapify(self.__nums)</span><br><span class="line">        self.__k = k</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先将新来的元素入队列，形成一个新的小根堆</span></span><br><span class="line">        heapq.heappush(self.__nums, val)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.__nums) &gt; self.__k:</span><br><span class="line">            <span class="comment"># 如果队列的数目超过了限定的k</span></span><br><span class="line">            <span class="comment"># 那就把根节点的元素弹出，也就是这些数当中最小的那个数弹出</span></span><br><span class="line">            <span class="comment"># 剩下的数自然就是较大的k个数</span></span><br><span class="line">            heapq.heappop(self.__nums)</span><br><span class="line">        <span class="comment"># 根节点正好是第 k 大 的数</span></span><br><span class="line">        <span class="keyword">return</span> self.__nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><span id="5.2.4.3"></span>  </p><h3 id="5-2-4-3-数组中的第K个最大元素"><a href="#5-2-4-3-数组中的第K个最大元素" class="headerlink" title="5.2.4.3 数组中的第K个最大元素"></a>5.2.4.3 数组中的第K个最大元素</h3><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">LeetCode 215.数组中的第K个最大元素</a> | | <a href="#5.2.4">返回目录5.2.4</a></p><p>思路：该题之前在<a href="https://teeyohuang.github.io/Data-Structure/DS_33_sort_exercises.html">3-3 排序相关题目</a>的 <a href="#3.3.10">3.3.10</a> 已经做过，当时是采用的排序算法，堆方案中也是手写的函数；这里尝试直接使用python自带的优先队列来写code。</p><p><b>写法一：对数组整体应用优先队列，然后再执行k-1次pop操作</b></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;写法1：使用默认的小根堆函数，所以需要先手动将数组取反&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 时间上更快, 空间消耗的反而比自己写heapify操作多一点</span></span><br><span class="line">        nums_new = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:-x,nums))</span><br><span class="line">        heapq.heapify(nums_new)</span><br><span class="line">        <span class="comment"># 因为是找第 k 个最大数, 所以pop掉k-1个即可</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):</span><br><span class="line">            heapq.heappop(nums_new)</span><br><span class="line">        <span class="keyword">return</span> -nums_new[<span class="number">0</span>] <span class="comment"># 这里要注意之前是将数组元素取反了的，现在要取回来</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.如果对函数熟悉的话，直接使用大根堆的函数&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 时间和空间的消耗都是最优的</span></span><br><span class="line">        <span class="comment"># heapq._heapify_max(nums)</span></span><br><span class="line">        <span class="comment"># for _ in range(k-1):</span></span><br><span class="line">        <span class="comment">#     heapq._heappop_max(nums)</span></span><br><span class="line">        <span class="comment"># return nums[0]</span></span><br></pre></td></tr></table></figure><p><b>写法二：像<a href="#5.2.2.2">5.2.2.2</a>那样，维护一个k大小的小根堆</b></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先初始化一个规模为k的优先队列</span></span><br><span class="line">        tmp = nums[:k].copy()</span><br><span class="line">        heapq.heapify(tmp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 每一次都先push入当前i位置i位置的数字</span></span><br><span class="line">            <span class="comment"># 然后对队列执行pop操作，这样使得队列的规模始终是 k </span></span><br><span class="line">            heapq.heappushpop(tmp, (nums[i]))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 循环结束后, 得到的就是整个数组的前K个最大数</span></span><br><span class="line">        <span class="comment"># 堆顶元素就是 第 k 大的数</span></span><br><span class="line">        <span class="keyword">return</span>  tmp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><span id="5.2.4.4"></span>  </p><h3 id="5-2-4-4-前-K-个高频元素"><a href="#5-2-4-4-前-K-个高频元素" class="headerlink" title="5.2.4.4 前 K 个高频元素"></a>5.2.4.4 前 K 个高频元素</h3><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">LeetCode 347.前 K 个高频元素</a> | | <a href="#5.2.4">返回目录5.2.4</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:  </span><br><span class="line">        <span class="keyword">import</span> heapq </span><br><span class="line">        h = &#123;&#125;</span><br><span class="line">        <span class="comment"># 遍历原始list，时间复杂度 O(N)</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> h:</span><br><span class="line">                h[num] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h[num] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        N = <span class="built_in">len</span>(h)</span><br><span class="line">        <span class="comment"># 频率放在数字前面，这样就能按照频率的大小 构造小根堆</span></span><br><span class="line">        new_nums = [(freq, num) <span class="keyword">for</span> num, freq <span class="keyword">in</span> h.items() ]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化一个 k 规模的小根堆</span></span><br><span class="line">        q = new_nums[:k]</span><br><span class="line">        heapq.heapify(q)</span><br><span class="line">        <span class="comment"># 遍历字典，时间复杂度不超过 O(N)，每一次都要恢复成小根堆，时间O(logk)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k,N):</span><br><span class="line">            <span class="comment"># 每一次都先push入当前i位置 的元素</span></span><br><span class="line">            <span class="comment"># 然后对队列执行pop操作，这样使得队列的规模始终是 k </span></span><br><span class="line">            heapq.heappushpop(q, new_nums[i])</span><br><span class="line">        <span class="keyword">return</span> [data[<span class="number">1</span>] <span class="keyword">for</span> data <span class="keyword">in</span> q]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最终时间复杂度应该是 O(N*logk)</span></span><br></pre></td></tr></table></figure><p><span id="5.2.4.5"></span>  </p><h3 id="5-2-4-5-根据字符出现频率排序"><a href="#5-2-4-5-根据字符出现频率排序" class="headerlink" title="5.2.4.5 根据字符出现频率排序"></a>5.2.4.5 根据字符出现频率排序</h3><p><a href="https://leetcode.cn/problems/sort-characters-by-frequency/">LeetCode 451.根据字符出现频率排序</a> | | <a href="#5.2.4">返回目录5.2.4</a></p><p>思路：这个题和上题很相似，也是先统计频率，然后可以依据频率排序，也可以用优先队列做，两种写法都给出在下面。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">frequencySort</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        h = &#123;&#125;</span><br><span class="line">        <span class="comment"># 先用哈希表统计字符的频率</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> h:</span><br><span class="line">                h[ch] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h[ch] += <span class="number">1</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.排序后再处理&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 生成 (字符，频率)的列表，并依据频率排序 key = lambda x:x[1]</span></span><br><span class="line">        <span class="comment"># 这里为简便，直接使用了自带的sort方法；这里如果面试需要的话，可以换成自己现场写的排序code</span></span><br><span class="line">        <span class="comment"># tmp = [(k,v) for k,v in h.items()]</span></span><br><span class="line">        <span class="comment"># tmp.sort(key = lambda x:x[1], reverse=True)</span></span><br><span class="line">        <span class="comment"># res = [ k*v for k,v in tmp]</span></span><br><span class="line">        <span class="comment"># return &#x27;&#x27;.join(res)</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.使用优先队列&#x27;&#x27;&#x27;</span></span><br><span class="line">        s2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        <span class="comment"># 依然是根据哈希表，生成(频率,字符)的列表</span></span><br><span class="line">        <span class="comment"># 这里将频率放在前面是为了优先队列依据频率数值构造小根堆</span></span><br><span class="line">        tmp = [(v,k) <span class="keyword">for</span> k,v <span class="keyword">in</span> h.items()]</span><br><span class="line">        heapq.heapify(tmp)</span><br><span class="line">        <span class="comment"># print(tmp)</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(tmp)&gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 不断的弹出频率最低的字符和其频率</span></span><br><span class="line">            freq, ch = heapq.heappop(tmp)</span><br><span class="line">            <span class="comment"># 因为题目要求频率从高到低，后被pop出来的字符，频率是比先被pop出来的更高的</span></span><br><span class="line">            <span class="comment"># 即 s2应该放在右侧</span></span><br><span class="line">            s2 = ch*freq + s2</span><br><span class="line">        <span class="keyword">return</span> s2</span><br></pre></td></tr></table></figure><p><span id="5.2.4.6"></span>  </p><h3 id="5-2-4-6-数据流的中位数"><a href="#5-2-4-6-数据流的中位数" class="headerlink" title="5.2.4.6 数据流的中位数"></a>5.2.4.6 数据流的中位数</h3><p><a href="https://leetcode.cn/problems/find-median-from-data-stream/">LeetCode 295.数据流的中位数</a> | | <a href="#5.2.4">返回目录5.2.4</a></p><p>思路：题目首先给了中位数的定义，是要在有序数组中进行查找。但是并没有保证输入的数据，一定是有序的。<br>如果按照排序再查找的话，那么每来一个数，就要排序一次，这样时间复杂度会很高。所以不如考虑每来一个数，给它找一个合适的位置放置，即用堆的想法。  </p><p>这里就可以分为两个堆，一个大根堆，存储小于等于中位数的那一半数字，这样它的堆顶(根节点)就是这一半数字中最接近中位数的那个；一个小根堆，存储大于等于中位数的那一半数字，这样它的堆顶(根节点)，也是最接近中位数的那个数。<br>∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷<br>只要能维护这两个堆，我们查找中位数就很方便了，只要保持两个堆都各存储一半的数字（偶数个时，规模相等；奇数个时规模相差一），中位数要么就是两个根节点其中之一，要么就是二者的均值。<br>∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷∷<br>我们在实际操作中，<font color="red">为了方便起见，始终保持前半部分的数目 大于等于后半部分，</font><br>即如果是偶数个，就两部分相等；如果是奇数个，就让前半部分多一个。   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._left_heap = []</span><br><span class="line">        self._right_heap = []</span><br><span class="line">        self.__length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addNum</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.__length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># left_heap用来装小于中位数的那部分，且长度为 N//2 或 N//2+1</span></span><br><span class="line">        <span class="comment"># right_heap用来装大于中位数的那一部分, 且长度为 N//2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果left部分为空，或者新来的数的数值，小于等于目前的中位数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self._left_heap) == <span class="number">0</span> <span class="keyword">or</span> num &lt;= -self._left_heap[<span class="number">0</span>]:</span><br><span class="line">            <span class="comment"># 这里对 num取反，是因为该操作默认是维护小根堆，但我们需要该部分数字的关系是大根堆</span></span><br><span class="line">            heapq.heappush(self._left_heap, -num)</span><br><span class="line">            <span class="comment"># 然后需要判断两个部分的数的规模是否相差在1之内</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self._left_heap) &gt; <span class="built_in">len</span>(self._right_heap) + <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 因为上面是在往left添加元素，所以只可能会出现left比right多的情况</span></span><br><span class="line">                <span class="comment"># 此时就把left多出来的pop出来，然后push进right</span></span><br><span class="line">                heapq.heappush(self._right_heap, -heapq.heappop(self._left_heap))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果left不为空，且新来的数大于目前的中位数，就往right添加</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heapq.heappush(self._right_heap, num)</span><br><span class="line">            <span class="comment"># 如果right部分的长度超过了left，就需要pop一个出来，push入left</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self._right_heap) &gt; <span class="built_in">len</span>(self._left_heap):</span><br><span class="line">                heapq.heappush(self._left_heap, -heapq.heappop(self._right_heap))</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMedian</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self._left_heap) &gt; <span class="built_in">len</span>(self._right_heap):</span><br><span class="line">            <span class="comment"># 说明此时left部分是 N//2+1个数， right部分是 N//2个数</span></span><br><span class="line">            <span class="keyword">return</span> -self._left_heap[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 说明left和right部分各有 N//2个数</span></span><br><span class="line">            <span class="keyword">return</span> (-self._left_heap[<span class="number">0</span>] + self._right_heap[<span class="number">0</span>]) / <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 这是自己额外写的一个测试函数，可以查看两个堆里的数的情况</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;self._left_heap: &quot;</span>, self._left_heap)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;self._right_heap: &quot;</span>, self._right_heap)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="5.2.4.7"></span>  </p><h3 id="5-2-4-7-最接近原点的-K-个点"><a href="#5-2-4-7-最接近原点的-K-个点" class="headerlink" title="5.2.4.7 最接近原点的 K 个点"></a>5.2.4.7 最接近原点的 K 个点</h3><p><a href="https://leetcode.cn/problems/k-closest-points-to-origin/">LeetCode 973.最接近原点的 K 个点</a> | | <a href="#5.2.4">返回目录5.2.4</a></p><p>思路：这个题最在排序部分也总结过，当时用的是排序的方法。<br>这里也可以使用优先队列来解决。维护一个规模为 k 的堆  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kClosest</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        q = [(-x ** <span class="number">2</span> - y ** <span class="number">2</span>, i) <span class="keyword">for</span> i, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(points[:k])]</span><br><span class="line">        heapq.heapify(q)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 默认的是小根堆，所以要对元素值取反</span></span><br><span class="line">        <span class="comment"># 且元素是 d距离放在索引i前面, 这样会根据 d 的数值来进行堆的构造</span></span><br><span class="line">        N = <span class="built_in">len</span>(points)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, N):</span><br><span class="line">            x, y = points[i]</span><br><span class="line">            d = -(x ** <span class="number">2</span> + y ** <span class="number">2</span>)</span><br><span class="line">            heapq.heappushpop(q, (d, i))</span><br><span class="line">        </span><br><span class="line">        res = [points[idx] <span class="keyword">for</span> (_, idx) <span class="keyword">in</span> q]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5-1 栈和队列</title>
      <link href="/Data-Structure/DS_51_stack_and_queue.html"/>
      <url>/Data-Structure/DS_51_stack_and_queue.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="5-1-栈和队列"><a href="#5-1-栈和队列" class="headerlink" title="5-1 栈和队列"></a>5-1 栈和队列</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>5.1.1</td><td><a href="#5.1.1">栈的概念</a></td></tr><tr><td>5.1.2</td><td><a href="#5.1.2">栈的python实现</a></td></tr><tr><td>5.1.3</td><td><a href="#5.1.3">队列的概念</a></td></tr><tr><td>5.1.4</td><td><a href="#5.1.4">队列的python实现</a></td></tr></tbody></table></div><p><span id="5.1.1"></span>  </p><h2 id="5-1-1-栈的概念"><a href="#5-1-1-栈的概念" class="headerlink" title="5.1.1 栈的概念"></a>5.1.1 栈的概念</h2><p>栈是限制仅在<strong><font color="#FF0000">表的一端进行插入和删除</font></strong>操作的线性表。<br>通常称插入、删除的这一端为<strong>【栈顶】</strong>， 另一端称为栈底。当表中没有元素时称为空栈。<br>由于栈中元素的插入和删除操作都只能在<strong>栈顶进行</strong>，所以总是<strong><font color="#FF0000">后进栈的先出栈</font></strong>。即：<br><b><font color="orangered">(LIFO) Last In First Out. 后进先出</font></b></p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/5_1_1.webp" width="40%">  </p><p>栈的基本操作有如下几种:  </p><div class="table-container"><table><thead><tr><th>操作名称</th><th>操作内容</th></tr></thead><tbody><tr><td>init()</td><td>将栈初始化为空</td></tr><tr><td>empty()</td><td>判空栈，判断栈是否为空</td></tr><tr><td>size()</td><td>求长度，返回栈中元素的个数</td></tr><tr><td>top()</td><td>取栈顶， 读取栈顶元素，但并不修改栈</td></tr><tr><td>pop()</td><td>若栈非空，则删除栈顶元素，（亦称 弹出）</td></tr><tr><td>push(x)</td><td>在栈顶插入元素，（亦称为 压入/压栈）</td></tr></tbody></table></div><p><span id="5.1.2"></span>  </p><h2 id="5-1-2-栈的python实现"><a href="#5-1-2-栈的python实现" class="headerlink" title="5.1.2 栈的python实现"></a>5.1.2 栈的python实现</h2><h3 id="5-1-2-1-顺序栈"><a href="#5-1-2-1-顺序栈" class="headerlink" title="5.1.2.1 顺序栈"></a>5.1.2.1 顺序栈</h3><p>就是用顺序表来实现栈，其 <font face="Times" new roman><em>python code</em></font> 如下所示:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sequence_Stack</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;使用空列表进行初始化&#x27;&#x27;&#x27;</span></span><br><span class="line">        self.__<span class="built_in">list</span> = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;判断栈是否为空&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.__<span class="built_in">list</span> == []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;返回栈里元素的个数&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.__<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;返回栈顶元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__<span class="built_in">list</span>[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;弹出栈顶元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.__<span class="built_in">list</span>.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;在栈顶压入元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        self.__<span class="built_in">list</span>.append(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>        </span><br></pre></td></tr></table></figure></p><h3 id="5-1-2-2-链栈"><a href="#5-1-2-2-链栈" class="headerlink" title="5.1.2.2 链栈"></a>5.1.2.2 链栈</h3><p>一般将链表<strong>头部作为栈顶</strong>，这样可以避免在 <strong>入栈 和 出栈</strong>的时候进行大量的遍历操作。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val    <span class="comment"># 数据域</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 指针域</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Link_stack</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__top = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__top <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        cur = self.__top</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__top.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        cur = self.__top</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.__top = cur.<span class="built_in">next</span> <span class="comment"># 修改头结点</span></span><br><span class="line">            <span class="keyword">return</span> cur.val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val</span>):</span><br><span class="line">        node = LNode(val)</span><br><span class="line">        node.<span class="built_in">next</span> = self.__top</span><br><span class="line">        self.__top = node <span class="comment"># 修改头结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p><p><span id="5.1.3"></span>    </p><h2 id="5-1-3-队列的概念"><a href="#5-1-3-队列的概念" class="headerlink" title="5.1.3 队列的概念"></a>5.1.3 队列的概念</h2><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的<strong><font color="#FF0000"> 前端（front）进行删除</font></strong>操作，而在表的<strong><font color="#FF0000">后端（rear）进行插入</font></strong>操作，和栈一样，队列是一种操作受限制的线性表。前端称为队头 ，后端称为队尾。<br><b><font color="orangered">FIFO (First In First Out) 先进先出</font></b>  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/5_1_2.webp" width="50%">  </p><p>队列的基本操作有如下几种:  </p><div class="table-container"><table><thead><tr><th>操作名称</th><th>操作内容</th></tr></thead><tbody><tr><td>init()</td><td>将队列初始化为空</td></tr><tr><td>empty()</td><td>判断队列是否为空</td></tr><tr><td>size()</td><td>求长度，返回队列中元素的个数</td></tr><tr><td>front()</td><td>取队头元素，若队列未空，则函数返回队头 数据元素，队列不变。</td></tr><tr><td>rear()</td><td>取队尾元素，若队列未空，则函数返回队尾 数据元素，队列不变。</td></tr><tr><td>enqueue(x)</td><td>入队列，若队列未满，在原队尾后加入数据元素x，使x成为新的队尾元素。</td></tr><tr><td>dequeue()</td><td>出队列，若队列未空，则将队列的队头元素删除。</td></tr></tbody></table></div><p><span id="5.1.4"></span>    </p><h2 id="5-1-4-队列的python实现"><a href="#5-1-4-队列的python实现" class="headerlink" title="5.1.4 队列的python实现"></a>5.1.4 队列的python实现</h2><h3 id="5-1-4-1-顺序表实现"><a href="#5-1-4-1-顺序表实现" class="headerlink" title="5.1.4.1 顺序表实现"></a>5.1.4.1 顺序表实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sq_Queue</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;使用空列表进行初始化&#x27;&#x27;&#x27;</span></span><br><span class="line">        self.__<span class="built_in">list</span> = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;判断队列是否为空&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.__<span class="built_in">list</span> == []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;返回队列里元素的个数&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.__<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">front</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;返回队头元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__<span class="built_in">list</span>[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rear</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;返回队尾元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__<span class="built_in">list</span>[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;弹出队头元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.__<span class="built_in">list</span>.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;在队尾压入元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        self.__<span class="built_in">list</span>.append(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="5-1-4-2-链表实现"><a href="#5-1-4-2-链表实现" class="headerlink" title="5.1.4.2 链表实现"></a>5.1.4.2 链表实现</h3><p>我们在插入的时候，选择在链表尾部使用尾插法插入，所以<strong>链表尾部视为队尾rear</strong>；<br>在删除时，为了方便起见，我们可以把<strong>头结点认为是front</strong>.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val    <span class="comment"># 数据域</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 指针域</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">L_Queue</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 初始化时同时设置头和尾两个指针</span></span><br><span class="line">        self.__front = <span class="literal">None</span></span><br><span class="line">        self.__rear = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__front <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cnt, cur = <span class="number">1</span>, self.__front</span><br><span class="line">            <span class="keyword">while</span> cur != self.__rear:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                cnt +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> cnt </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">front</span>(<span class="params">self</span>):</span><br><span class="line">        res = <span class="literal">None</span> <span class="keyword">if</span> self.is_empty() <span class="keyword">else</span> self.__front.val</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rear</span>(<span class="params">self</span>):</span><br><span class="line">        res = <span class="literal">None</span> <span class="keyword">if</span> self.is_empty() <span class="keyword">else</span> self.__rear.val</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):</span><br><span class="line">        cur = self.__front</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__front = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> self.__front <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 出队后队列为空(原队列仅含一个元素)</span></span><br><span class="line">                self.__rear = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> cur.val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self, val</span>):</span><br><span class="line">        node = LNode(val)</span><br><span class="line">        <span class="keyword">if</span> self.__rear <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 说明当前链表(队列)为空</span></span><br><span class="line">            self.__front = node</span><br><span class="line">            self.__rear = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__rear.<span class="built_in">next</span> = node</span><br><span class="line">            self.__rear = node</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4-2 字符串相关题目</title>
      <link href="/Data-Structure/DS_42_string_exercises.html"/>
      <url>/Data-Structure/DS_42_string_exercises.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="4-2-字符串相关题目"><a href="#4-2-字符串相关题目" class="headerlink" title="4-2 字符串相关题目"></a>4-2 字符串相关题目</h1><hr style="border:solid; height:1px; color=#000000 size=1">   <p><b>版权声明：以下题目均来自 <a href="https://leetcode.cn">LeetCode</a>， 仅仅提供跳转到力扣官网的链接，不在本页面出现题目内容，本文章内容禁止商业用途。</b></p><p><span id="4.2"></span>  </p><h2 id="4-2-目录"><a href="#4-2-目录" class="headerlink" title="4.2 目录"></a>4.2 目录</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/reverse-string/">LeetCode 344.反转字符串</a></td><td><a href="#4.2.1">4.2.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">LeetCode 151.反转字符串中的单词</a></td><td><a href="#4.2.2">4.2.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/">LeetCode 557.反转字符串中的单词 III</a></td><td><a href="#4.2.3">4.2.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">LeetCode 3.无重复字符的最长子串</a></td><td><a href="#4.2.4">4.2.4题解</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/group-anagrams/">LeetCode 49.字母异位词分组</a></td><td><a href="#4.2.5">4.2.5题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/valid-palindrome/">LeetCode 125.验证回文串</a></td><td><a href="#4.2.6">4.2.6题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/add-strings/">LeetCode 415.字符串相加</a></td><td><a href="#4.2.7">4.2.7题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/multiply-strings/">LeetCode 43.字符串相乘</a></td><td><a href="#4.2.8">4.2.8题解</a></td></tr></tbody></table></div><p><span id="4.2.1"></span>  </p><h3 id="4-2-1-反转字符串"><a href="#4-2-1-反转字符串" class="headerlink" title="4.2.1 反转字符串"></a>4.2.1 反转字符串</h3><p><a href="https://leetcode.cn/problems/reverse-string/">LeetCode 344.反转字符串</a> | | <a href="#4.2">返回目录4.2</a></p><p>思路：这道题其实就是很简单的列表逆序的问题。可以用列表切片或者双指针。需要注意的是题目要求【使用 O(1) 的额外空间】  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 1.直接用列表切片法</span></span><br><span class="line"><span class="string">        # 但是不符合题目要求的O(1)额外空间</span></span><br><span class="line"><span class="string">        # 因为python的list切片操作会创建一个临时的list</span></span><br><span class="line"><span class="string">        s[:] = s[::-1]  </span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 2.用双指针</span></span><br><span class="line"></span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            s[L], s[R] = s[R], s[L]</span><br><span class="line">            L += <span class="number">1</span></span><br><span class="line">            R -=<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="4.2.2"></span>  </p><h3 id="4-2-2-反转字符串中的单词"><a href="#4-2-2-反转字符串中的单词" class="headerlink" title="4.2.2 反转字符串中的单词"></a>4.2.2 反转字符串中的单词</h3><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">LeetCode 151.反转字符串中的单词</a> | | <a href="#4.2">返回目录4.2</a></p><p>思路：这个题可能用python来说比较容易，因为python的split能够默认处理空格……<br>s.split()之后直接就是一个单词列表，然后用4.2.1中的逆序就解决了。而且此题还没有要求空间复杂度，可以直接用list切片操作。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(s.split()[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 或者也可以用 reversed方法使得 列表逆序</span></span><br><span class="line">        <span class="comment"># return &#x27; &#x27;.join( reversed(s.split()))</span></span><br></pre></td></tr></table></figure><p><span id="4.2.3"></span>  </p><h3 id="4-2-3-反转字符串中的单词III"><a href="#4-2-3-反转字符串中的单词III" class="headerlink" title="4.2.3 反转字符串中的单词III"></a>4.2.3 反转字符串中的单词III</h3><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/">LeetCode 557.反转字符串中的单词 III</a> | | <a href="#4.2">返回目录4.2</a></p><blockquote><p>示例 1<br>思路：和4.2.2换汤不换药，只是对单词内部的字母的逆序而已，不对整体逆序。  </p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s_list = s.split()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join([ ele[::-<span class="number">1</span>] <span class="keyword">for</span> ele <span class="keyword">in</span> s_list])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这种解法确实能跑通所有样例，是因为：</span></span><br><span class="line">        <span class="comment"># 题目最下方的提示中写了：所有单词都用一个空格隔开。</span></span><br><span class="line">        <span class="comment"># 所以在使用 &#x27; &#x27;.join时只用到1个空格， 是可以保证正确的</span></span><br><span class="line">        <span class="comment"># 如果题目不给出这个条件，那就不能直接这么写</span></span><br></pre></td></tr></table></figure><p>拓展：如果题目中没有规定单词之间只有一个空格</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s_list = <span class="built_in">list</span>(s)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义一个逆序的函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse_list</span>(<span class="params">a, L, R</span>):</span><br><span class="line">            <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                a[L], a[R] = a[R], a[L]</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                R -=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用快慢指针</span></span><br><span class="line">        p1, p2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        N = <span class="built_in">len</span>(s_list)</span><br><span class="line">        <span class="keyword">while</span> p2&lt;N:</span><br><span class="line">            <span class="keyword">if</span> p2== N-<span class="number">1</span> <span class="keyword">or</span> (s_list[p2] != <span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> s_list[p2+<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>):</span><br><span class="line">                reverse_list(s_list, p1, p2)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> s_list[p2] == <span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> s_list[p2+<span class="number">1</span>] != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                p1 = p2+<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            p2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s_list)</span><br></pre></td></tr></table></figure><p><span id="4.2.4"></span>  </p><h3 id="4-2-4-无重复字符的最长子串"><a href="#4-2-4-无重复字符的最长子串" class="headerlink" title="4.2.4 无重复字符的最长子串"></a>4.2.4 无重复字符的最长子串</h3><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">LeetCode 3.无重复字符的最长子串</a> | | <a href="#4.2">返回目录4.2</a></p><p>思路：这个题的思路和 <a href="https://teeyohuang.github.io/Data-Structure/DS_23_array_double_pointer_exercises.html">2-3 数组数组双指针</a> 的 <a href="https://teeyohuang.github.io/Data-Structure/DS_22_array_exercises.html#2.3.2.8">2.3.2.8</a> 只能说一模一样。只不过一个是求连续重复1区间的长度，一个是求不出现重复的区间长度。<br>：：：<br>那么核心就是，判断重复与否的条件是什么？<br>不重复的条件有两个：<br>1.字符未出现过； 或者<br>2.字符出现过，但是不在当前判断的区域内，即字符的索引在L边界左侧<br>：：：<br>所以对应的重复条件是：<br>字符出现过，且位于当前判断的区间内，即字符的索引在L右侧  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span> <span class="keyword">or</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> N </span><br><span class="line">        L, R = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        h = &#123;&#125;</span><br><span class="line">        <span class="comment"># 慢指针L表示无重复区域的 左侧外边界</span></span><br><span class="line">        <span class="comment"># 快指针R用来判断当前位置的值是否已经在哈希表中出现</span></span><br><span class="line">        gap = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 有两种写法</span></span><br><span class="line">        <span class="comment"># 写法1：在未遇到重复字符之前，一直更新区间长度</span></span><br><span class="line">        <span class="comment"># 遇到重复值时，不更新区间长度，而是更新L边界</span></span><br><span class="line">        <span class="keyword">for</span> R <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="comment"># 如果s[R]未出现过, 或者索引位于L左侧, 即当前考察区域更左</span></span><br><span class="line">            <span class="comment"># 说明当前连续未重复区域仍未中断, 可以更新一下gap</span></span><br><span class="line">            <span class="keyword">if</span> s[R] <span class="keyword">not</span> <span class="keyword">in</span> h <span class="keyword">or</span> h[s[R]] &lt;= L:</span><br><span class="line">                gap = <span class="built_in">max</span>(gap, R-L)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># L 指向重复元素已经记录的索引位置</span></span><br><span class="line">            <span class="comment"># 相当于将该元素排除出去，新区间从该元素右侧开始考察</span></span><br><span class="line">                L = h[s[R]]</span><br><span class="line">            h[s[R]] = R</span><br><span class="line">        <span class="keyword">return</span> gap</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 写法2: 在遇到重复元素的时候，才计算一次区间长度</span></span><br><span class="line"><span class="string">        for R in range(N):</span></span><br><span class="line"><span class="string">            if s[R] in h and h[s[R]] &gt; L:</span></span><br><span class="line"><span class="string">            # 出现重复字符时，才计算区间长度，要注意当前位置不算在区间内</span></span><br><span class="line"><span class="string">                gap = max(gap, R-L -1)</span></span><br><span class="line"><span class="string">                L = h[s[R]]</span></span><br><span class="line"><span class="string">            h[s[R]] = R</span></span><br><span class="line"><span class="string">        # 这里要注意需要补充计算一下最后一段区间的长度</span></span><br><span class="line"><span class="string">        # 因为R取不到N，否则会漏算最后一段符合条件的区间</span></span><br><span class="line"><span class="string">        # 比如：若最后一段区间直到N-1都没有出现重复字符，是该计算长度的</span></span><br><span class="line"><span class="string">        # 但是由于计算的条件是出现重复字符才计算，所以上面并没有机会去计算</span></span><br><span class="line"><span class="string">        return max(gap, N-L-1)</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="4.2.5"></span>  </p><h3 id="4-2-5-字母异位词分组"><a href="#4-2-5-字母异位词分组" class="headerlink" title="4.2.5 字母异位词分组"></a>4.2.5 字母异位词分组</h3><p><a href="https://leetcode.cn/problems/group-anagrams/">LeetCode 49.字母异位词分组</a> | | <a href="#4.2">返回目录4.2</a></p><p>思路：该题的核心点在于如何判断字母异位词，其实很简单。只需要把单词排序之后，看看它们是否相等。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">groupAnagrams</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        h = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> strs:</span><br><span class="line">            <span class="comment"># 将单词排序，然后来判断其是否出现过</span></span><br><span class="line">            key = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">sorted</span>(word))</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> h:</span><br><span class="line">                h[key] = [word]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h[key] += [word]</span><br><span class="line">        <span class="comment"># 直接返回字典的值列表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(h.values())</span><br></pre></td></tr></table></figure><p><span id="4.2.6"></span>  </p><h3 id="4-2-6-验证回文串"><a href="#4-2-6-验证回文串" class="headerlink" title="4.2.6 验证回文串"></a>4.2.6 验证回文串</h3><p><a href="https://leetcode.cn/problems/valid-palindrome/">LeetCode 125.验证回文串</a> | | <a href="#4.2">返回目录4.2</a></p><p>思路：这个题也是采用双指针的思路。只不过需要注意，字符串中可能出现不是数字或者字母的字符，所以需要多一个判断条件。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 先将所有字母转换为小写</span></span><br><span class="line">        s = s.lower()</span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            <span class="comment"># while L &lt; R and not (s[L].isalpha() or s[L].isdigit()):</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> <span class="keyword">not</span> s[L].isalnum():</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="comment"># while L &lt; R and not (s[R].isalpha() or s[R].isdigit()):</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> <span class="keyword">not</span> s[R].isalnum():</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> L &lt; R:</span><br><span class="line">                <span class="keyword">if</span> s[L] == s[R]:</span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><span id="4.2.7"></span>  </p><h3 id="4-2-7-字符串相加"><a href="#4-2-7-字符串相加" class="headerlink" title="4.2.7 字符串相加"></a>4.2.7 字符串相加</h3><p><a href="https://leetcode.cn/problems/add-strings/">LeetCode 415.字符串相加</a> | | <a href="#4.2">返回目录4.2</a></p><p>思路：由于题目中明确表示不能够直接将两个输入字符串转换成数字进行计算，所以就需要将其一位一位的拆分之后计算。<br>此题考察的点就是希望手动模拟按位相加。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addStrings</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> num1 == <span class="string">&quot;0&quot;</span> :</span><br><span class="line">            <span class="keyword">return</span> num2</span><br><span class="line">        <span class="keyword">elif</span> num2 == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            </span><br><span class="line">            m, n = <span class="built_in">len</span>(num1), <span class="built_in">len</span>(num2)</span><br><span class="line">            s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            plus = <span class="number">0</span> <span class="comment"># plus是代表的进位的数字</span></span><br><span class="line">            k = <span class="number">1</span> </span><br><span class="line">            <span class="comment"># 因为加法是从个位开始，所以往左遍历字符串</span></span><br><span class="line">            <span class="keyword">while</span> plus &gt; <span class="number">0</span> <span class="keyword">or</span> k &lt;= <span class="built_in">max</span>(m, n):</span><br><span class="line">                a = <span class="built_in">int</span>(num1[m-k]) <span class="keyword">if</span> k&lt;=m <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                b = <span class="built_in">int</span>(num2[n-k]) <span class="keyword">if</span> k&lt;=n <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                <span class="comment"># digit 表示在当前位置应该出现的数字</span></span><br><span class="line">                digit = (plus + a + b ) % <span class="number">10</span> </span><br><span class="line">                <span class="comment"># 新来的字符要加在左侧</span></span><br><span class="line">                s = <span class="built_in">str</span>(digit)+s</span><br><span class="line">                <span class="comment"># 计算进位数字</span></span><br><span class="line">                plus = (plus + a+b - digit) // <span class="number">10</span></span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">                <span class="string">&#x27;&#x27;&#x27;需要注意的是，在计算的时候不要漏加了plus&#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p><span id="4.2.8"></span>  </p><h3 id="4-2-8-字符串相乘"><a href="#4-2-8-字符串相乘" class="headerlink" title="4.2.8 字符串相乘"></a>4.2.8 字符串相乘</h3><p><a href="https://leetcode.cn/problems/multiply-strings/">LeetCode 43.字符串相乘</a> | | <a href="#4.2">返回目录4.2</a></p><p>思路：由于上一题做过字符串相加，我们可以套用其思想，让num2的每一位同num1相乘，然后再加起来即可。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">add_num_list</span>(<span class="params">num_list</span>):</span><br><span class="line">            <span class="comment"># </span></span><br><span class="line">            <span class="comment"># 对2个数字字符串相加的code稍加修改</span></span><br><span class="line">            <span class="comment"># 即可得到对 N 个数字字符串相加的code</span></span><br><span class="line">            <span class="comment"># 当然也可以不做修改，使用2数相加，只需要对每一次做乘法得到的结果，及时应用两数相加即可</span></span><br><span class="line">            <span class="comment"># </span></span><br><span class="line">            num_cnt = <span class="built_in">len</span>(num_list)</span><br><span class="line">            len_num = [<span class="built_in">len</span>(num) <span class="keyword">for</span> num <span class="keyword">in</span> num_list]</span><br><span class="line">            k = <span class="number">1</span></span><br><span class="line">            plus = <span class="number">0</span></span><br><span class="line">            s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">while</span> plus &gt; <span class="number">0</span> <span class="keyword">or</span> k &lt;= <span class="built_in">max</span>(len_num):</span><br><span class="line">                a = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_cnt):</span><br><span class="line">                    N_i = len_num[i]</span><br><span class="line">                    <span class="string">&#x27;&#x27;&#x27;要点1.是对第i个数字的倒数第k位取值&#x27;&#x27;&#x27;</span></span><br><span class="line">                    a += <span class="built_in">int</span>(num_list[i][N_i-k]) <span class="keyword">if</span> k&lt;= N_i <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                    <span class="comment"># print(k,a)</span></span><br><span class="line">                <span class="string">&#x27;&#x27;&#x27;要点2.这下面的几行要写在for循环之外</span></span><br><span class="line"><span class="string">                因为for循环结束后，对应位置的数字才相加完毕&#x27;&#x27;&#x27;</span></span><br><span class="line">                digit = (a+plus) % <span class="number">10</span></span><br><span class="line">                <span class="comment"># print(digit)</span></span><br><span class="line">                s = <span class="built_in">str</span>(digit) + s </span><br><span class="line">                plus = (a+plus-digit) // <span class="number">10</span></span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> num1 == <span class="string">&quot;0&quot;</span> <span class="keyword">or</span> num2 == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num_list = []</span><br><span class="line">            m, n = <span class="built_in">len</span>(num1), <span class="built_in">len</span>(num2)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 对num2从个位开始取数</span></span><br><span class="line">                <span class="string">&#x27;&#x27;&#x27;要点3.当j是来自十位、百位、千位...时，屁股后要接上相应个数的0&#x27;&#x27;&#x27;</span></span><br><span class="line">                res = <span class="string">&quot;0&quot;</span>*(j-<span class="number">1</span>)</span><br><span class="line">                b = <span class="built_in">int</span>(num2[n-j])</span><br><span class="line">                plus = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">                    a = <span class="built_in">int</span>(num1[m-i])</span><br><span class="line">                    digit = (plus + a*b) % <span class="number">10</span></span><br><span class="line">                    res = <span class="built_in">str</span>(digit) + res</span><br><span class="line">                    plus = (plus + a*b -digit) // <span class="number">10</span></span><br><span class="line">                <span class="string">&#x27;&#x27;&#x27;要点4.for循环玩之后，plus不用留到下一轮，因为该阶段的相加已经结束了</span></span><br><span class="line"><span class="string">                直接加到数前面去即可&#x27;&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> plus &gt; <span class="number">0</span>:</span><br><span class="line">                    res = <span class="built_in">str</span>(plus) + res</span><br><span class="line">                num_list.append(res)</span><br><span class="line">            <span class="built_in">print</span>(num_list)</span><br><span class="line">            <span class="keyword">return</span> add_N_num(num_list)</span><br><span class="line">        <span class="comment">##############################################################################</span></span><br><span class="line">        <span class="comment"># 每一次只对两个数字字符串相加，时间上稍微慢一点</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4-1 字符串</title>
      <link href="/Data-Structure/DS_41_string.html"/>
      <url>/Data-Structure/DS_41_string.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="4-1-字符串"><a href="#4-1-字符串" class="headerlink" title="4-1 字符串"></a>4-1 字符串</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>4.1.1</td><td><a href="#4.1.1">字符串简介</a></td></tr><tr><td>4.1.2</td><td><a href="#4.1.2">字符串的常用运算符</a></td></tr><tr><td>4.1.3</td><td><a href="#4.1.3">字符串格式化</a></td></tr></tbody></table></div><p><span id="4.1.1"></span> </p><h2 id="4-1-1-字符串简介"><a href="#4-1-1-字符串简介" class="headerlink" title="4.1.1 字符串简介"></a>4.1.1 字符串简介</h2><p>字符串是 Python 中最常用的数据类型，使用引号  ‘ 或 “  来创建字符串以及表示字符串。<br>和C/C++不同，python中的没有单字符这一个类型，即没有 char 类型，一个字符也是作为字符串类型来使用的, 这也就是它的单引号和双引号都能用来表示字符串的原因。  </p><p><span id="4.1.2"></span>  </p><h2 id="4-1-2-字符串的常用运算符"><a href="#4-1-2-字符串的常用运算符" class="headerlink" title="4.1.2 字符串的常用运算符"></a>4.1.2 字符串的常用运算符</h2><div class="table-container"><table><thead><tr><th>操作符</th><th>含义</th><th>例子</th></tr></thead><tbody><tr><td>+</td><td>字符串连接（拼接）</td><td>“hello” + “World”</td></tr><tr><td>*</td><td>重复输出字符串</td><td>“abc” * 3</td></tr><tr><td>[ ]</td><td>通过索引获取字符串中字符</td><td>a[1]</td></tr><tr><td>[ : ]</td><td>截取字符串中的一部分，和列表一样遵循左闭右开原则</td><td>a[3:5]</td></tr><tr><td>in</td><td>成员运算符 - 如果字符串中包含给定的字符返回 True</td><td>d in “word”</td></tr><tr><td>not in</td><td>成员运算符 - 如果字符串中不包含给定的字符返回 True</td><td>n not in “word”</td></tr><tr><td>r/R</td><td>将字符串转化为原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</td><td>print( r’\n’ )或print( R’\n’ )</td></tr></tbody></table></div><p>有一定需要特别注意，字符串和元组(tuple)一样，<font color="red"> <b>属于不变的类型</b> </font> ，即不能对一个字符串进行修改。比如下面的code就无法执行：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;P&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;TypeError: &#x27;str&#x27; object does not support item assignment.&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上面使用 <strong>‘+’</strong> 进行拼接操作,实际上是将结<strong>果存入一个新的地址，形成一个 新的字符串</strong>,而不是对原地址上的内容进行修改。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(s))</span><br><span class="line"></span><br><span class="line">s = s +<span class="string">&#x27; hello&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(s))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2081678577264</span></span><br><span class="line"><span class="string">2081678063472</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><span id="4.1.3"></span></p><h2 id="4-1-3-字符串格式化"><a href="#4-1-3-字符串格式化" class="headerlink" title="4.1.3 字符串格式化"></a>4.1.3 字符串格式化</h2><p>后续有空再写……</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3-3 排序相关题目</title>
      <link href="/Data-Structure/DS_33_sort_exercises.html"/>
      <url>/Data-Structure/DS_33_sort_exercises.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="3-3-排序相关题目"><a href="#3-3-排序相关题目" class="headerlink" title="3-3 排序相关题目"></a>3-3 排序相关题目</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p><b>版权声明：以下题目均来自 <a href="https://leetcode.cn">LeetCode</a>， 仅仅提供跳转到力扣官网的链接，不在本页面出现题目内容，本文章内容禁止商业用途。</b></p><p><span id="3.3"></span>  </p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/sort-an-array/">LeetCode 912.排序数组</a></td><td><a href="#3.3.1">3.3.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">LCR 164. 破解闯关密码</a></td><td><a href="#3.3.2">3.3.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/largest-number/">LeetCode 179.最大数</a></td><td><a href="#3.3.3">3.3.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/move-zeroes/">LeetCode 283.移动零</a></td><td><a href="#3.3.4">3.3.4题解</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/sort-colors/">LeetCode 75.颜色分类</a></td><td><a href="#3.3.5">3.3.5题解</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/contains-duplicate/">LeetCode 217.存在重复元素</a></td><td><a href="#3.3.6">3.3.6题解</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/contains-duplicate-ii/">LeetCode 219. 存在重复元素II</a></td><td><a href="#3.3.7">3.3.7题解</a></td></tr><tr><td>⑧</td><td><a href="https://leetcode.cn/problems/contains-duplicate-iii/">LeetCode 220.存在重复元素 III</a></td><td><a href="#3.3.8">3.3.8题解</a></td></tr><tr><td>⑨</td><td><a href="https://leetcode.cn/problems/maximum-gap/">LeetCode 164.最大间距</a></td><td><a href="#3.3.9">3.3.9题解</a></td></tr><tr><td>⑩</td><td><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">LeetCode 215.数组中的第K个最大元素</a></td><td><a href="#3.3.10">3.3.10题解</a></td></tr><tr><td>⑪</td><td><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">LeetCode 剑指 Offer 40.最小的k个数</a></td><td><a href="#3.3.11">3.3.11题解</a></td></tr><tr><td>⑫</td><td><a href="https://leetcode.cn/problems/majority-element/">LeetCode 169.多数元素</a></td><td><a href="#3.3.12">3.3.12题解</a></td></tr><tr><td>⑬</td><td><a href="https://leetcode.cn/problems/merge-sorted-array/">LeetCode 88.合并两个有序数组</a></td><td><a href="#3.3.13">3.3.13题解</a></td></tr><tr><td>⑭</td><td><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">LCR 170. 交易逆序对的总数</a></td><td><a href="#3.3.14">3.3.14题解</a></td></tr><tr><td>⑮</td><td><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">LeetCode 315.计算右侧小于当前元素的个数</a></td><td><a href="#3.3.15">3.3.15题解</a></td></tr><tr><td>⑯</td><td><a href="https://leetcode.cn/problems/k-closest-points-to-origin/">LeetCode 973.最接近原点的 K 个点</a></td><td><a href="#3.3.16">3.3.16题解</a></td></tr></tbody></table></div><p><span id="3.3.1"></span>  </p><h3 id="3-3-1-排序数组"><a href="#3-3-1-排序数组" class="headerlink" title="3.3.1 排序数组"></a>3.3.1 排序数组</h3><p><a href="https://leetcode.cn/problems/sort-an-array/">LeetCode 912.排序数组</a> | |  <a href="#3.3">返回目录3.3</a></p><p>思路：这个题就是简单的考察排序算法，可以用这个题来当作测试模板，看看自己写的各个版本的排序代码是不是正确的。<br>但是一般在做题是很少会用到时间复杂度 O(n^2)的算法，一般都是用的 O(N*logN) 的算法，或者视具体情况使用计数排序、基数排序、桶排序。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 具体的排序算法 code 可以看 文章3-1 中的详细简介，这里就不写了</span></span><br></pre></td></tr></table></figure><p><span id="3.3.2"></span>  </p><h3 id="3-3-2-把数组排成最小的数"><a href="#3-3-2-把数组排成最小的数" class="headerlink" title="3.3.2 把数组排成最小的数"></a>3.3.2 把数组排成最小的数</h3><p><a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">LCR 164. 破解闯关密码</a> | | <a href="#3.3">返回目录3.3</a></p><p>思路：这个题就其实比较新奇，是考察排序，但是排序的规则不是按照我们平时的数值大小。<br>针对此题，我们对<b>字符串 x, y </b>的大小 作如下 <b>自定义</b>：<br>如果：x + y &gt; y + x , 则 x &gt; y;<br>如果：x + y == y + x , 则 x = y;<br>如果：x + y &lt; y + x , 则 x &lt; y;<br><b>按照我们自定义的规则进行排序即可</b>，题目要求是最小的数，那么就按照降序排列。  </p><p>同时，题目中叙述 “最后结果不需要去掉前导 0”，意思是如果出现 [1,2,0] 这样的数组，结果可以输出 “012” 这样的字符串。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">comp_str</span>(<span class="params">x:<span class="built_in">str</span>,y:<span class="built_in">str</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            definition:</span></span><br><span class="line"><span class="string">            if x+y &gt; y+x: x&gt;y</span></span><br><span class="line"><span class="string">            elif x+y == y+x: x==y</span></span><br><span class="line"><span class="string">            else: x&lt;y</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> x+y &gt; y+x:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">            <span class="keyword">elif</span> x+y == y+x:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">QuickSort</span>(<span class="params">a, L, R</span>):</span><br><span class="line">            <span class="keyword">if</span> L &gt;= R:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            pl, pr, key = L-<span class="number">1</span>, R, R </span><br><span class="line">            i = pl+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; pr:</span><br><span class="line">                <span class="comment"># 利用自定义的大小规则，进行快速排序的大小比对</span></span><br><span class="line">                comp = comp_str(a[i], a[key])</span><br><span class="line">                <span class="keyword">if</span> comp == <span class="number">1</span>:</span><br><span class="line">                    a[i], a[pl+<span class="number">1</span>] = a[pl+<span class="number">1</span>], a[i]</span><br><span class="line">                    pl += <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> comp == <span class="number">2</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    a[i], a[pr-<span class="number">1</span>] = a[pr-<span class="number">1</span>], a[i]</span><br><span class="line">                    pr -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># i==pr </span></span><br><span class="line">            a[pr], a[key] = a[key], a[pr]</span><br><span class="line">            QuickSort(a,L, pl)</span><br><span class="line">            QuickSort(a, pr+<span class="number">1</span>, R)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="comment"># 将数字转化为字符串</span></span><br><span class="line">        str_list = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>,nums))</span><br><span class="line">        QuickSort(str_list, <span class="number">0</span>, <span class="built_in">len</span>(str_list)-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(str_list)</span><br></pre></td></tr></table></figure><p><span id="3.3.3"></span>  </p><h3 id="3-3-3-最大数"><a href="#3-3-3-最大数" class="headerlink" title="3.3.3 最大数"></a>3.3.3 最大数</h3><p><a href="https://leetcode.cn/problems/largest-number/">LeetCode 179.最大数</a> | | <a href="#3.3">返回目录3.3</a></p><p>思路：这个题和上一个题其实是一回事，只不过一个要最小数，一个要最大数。所以这个题需要按自定义规则从大到小排序即可。。</p><p>但要注意的是，由于此题是要求排列最大的情况，所以如果有单个0和其他整数出现，0必不会出现在开头，而是会出现在末尾。<br>只有一种特殊情况，那就是数组中只有0的时候，比如[0,0,0]，字符串的结果是 “000”，我们需要处理成对应的整数形式 “0”   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">comp_str</span>(<span class="params">x:<span class="built_in">str</span>,y:<span class="built_in">str</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            definition:</span></span><br><span class="line"><span class="string">            if x+y &gt; y+x: x&gt;y</span></span><br><span class="line"><span class="string">            elif x+y == y+x: x==y</span></span><br><span class="line"><span class="string">            else: x&lt;y</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> x+y &gt; y+x:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> x+y == y+x:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">QuickSort</span>(<span class="params">a, L, R</span>):</span><br><span class="line">            <span class="keyword">if</span> L &gt;= R:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            pl, pr, key = L-<span class="number">1</span>, R, R </span><br><span class="line">            i = pl+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; pr:</span><br><span class="line">                comp = comp_str(a[i], a[key])</span><br><span class="line">                <span class="keyword">if</span> comp == <span class="number">1</span>:</span><br><span class="line">                    a[i], a[pl+<span class="number">1</span>] = a[pl+<span class="number">1</span>], a[i]</span><br><span class="line">                    pl += <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> comp == <span class="number">2</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    a[i], a[pr-<span class="number">1</span>] = a[pr-<span class="number">1</span>], a[i]</span><br><span class="line">                    pr -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># i==pr </span></span><br><span class="line">            a[pr], a[key] = a[key], a[pr]</span><br><span class="line">            QuickSort(a,L, pl)</span><br><span class="line">            QuickSort(a, pr+<span class="number">1</span>, R)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        str_list = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>,nums))</span><br><span class="line">        QuickSort(str_list, <span class="number">0</span>, <span class="built_in">len</span>(str_list)-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        s = <span class="string">&#x27;&#x27;</span>.join(str_list)</span><br><span class="line">        <span class="comment"># 这个题的要求没有说可以不处理先导 0</span></span><br><span class="line">        <span class="comment"># 所以如果出现了&quot;000&quot;这种情况，要手动处理成 &#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p><span id="3.3.4"></span>  </p><h3 id="3-3-4-移动零"><a href="#3-3-4-移动零" class="headerlink" title="3.3.4 移动零"></a>3.3.4 移动零</h3><p><a href="https://leetcode.cn/problems/move-zeroes/">LeetCode 283.移动零</a> | | <a href="#3.3">返回目录3.3</a> </p><p>思路：这个提已经在 <a href="https://teeyohuang.github.io/Data-Structure/DS_23_array_double_pointer_exercises.html">2-3 数组双指针</a> 中的 <a href="https://teeyohuang.github.io/Data-Structure/DS_23_array_double_pointer_exercises.html#2.3.2.5">2.3.2.5</a> 讲解过，在<a href>3-2快速排序讨论</a>中时，介绍的partition问题也对其进行深入讨论过。<br>按照partition问题的理解，就是与0比较，非0数排左侧，0排右侧。<br>需要注意的是，Partition 操作本身是不稳定移动，（这也是快速排序是不稳定排序的原因）但是应用到该题中，只有0的部分会不稳定，（即几个0之间可能发生相对位置的变化）而非0部分的相对顺序是不会变的。是符合题目要求的。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        ps, pf = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pf &lt;N:</span><br><span class="line">            <span class="keyword">if</span> nums[pf] != <span class="number">0</span>:</span><br><span class="line">                nums[pf], nums[ps+<span class="number">1</span>] = nums[ps+<span class="number">1</span>], nums[pf]</span><br><span class="line">                ps += <span class="number">1</span></span><br><span class="line">            pf += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="3.3.5"></span></p><h3 id="3-3-5-颜色分类"><a href="#3-3-5-颜色分类" class="headerlink" title="3.3.5 颜色分类"></a>3.3.5 颜色分类</h3><p><a href="https://leetcode.cn/problems/sort-colors/">LeetCode 75.颜色分类</a> | | <a href="#3.3">返回目录3.3</a></p><p>思路：在<a href="https://teeyohuang.github.io/Data-Structure/DS_32_quick_sort_discussion.html">3-2快速排序讨论</a>中讨论过的荷兰国旗问题。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;荷兰国旗问题&#x27;&#x27;&#x27;</span></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        L, R = -<span class="number">1</span>, N</span><br><span class="line">        i = L+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; R:</span><br><span class="line">            <span class="keyword">if</span> L &lt; R <span class="keyword">and</span> nums[i] &lt; <span class="number">1</span>:</span><br><span class="line">                nums[i], nums[L+<span class="number">1</span>] = nums[L+<span class="number">1</span>], nums[i]</span><br><span class="line">                L+=<span class="number">1</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> L &lt; R <span class="keyword">and</span> nums[i] == <span class="number">1</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[i], nums[R-<span class="number">1</span>] = nums[R-<span class="number">1</span>], nums[i]</span><br><span class="line">                R -=<span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="3.3.6"></span>  </p><h3 id="3-3-6-存在重复元素"><a href="#3-3-6-存在重复元素" class="headerlink" title="3.3.6 存在重复元素"></a>3.3.6 存在重复元素</h3><p><a href="https://leetcode.cn/problems/contains-duplicate/">LeetCode 217.存在重复元素</a> | | <a href="#3.3">返回目录3.3</a></p><blockquote><p>给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。  </p></blockquote><p>思路：较为简单，使用哈希表计数即可。<br>这个题主要是为了下面两个题做铺垫。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        h = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">not</span> <span class="keyword">in</span> h:</span><br><span class="line">                h[nums[i]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><span id="3.3.7"></span>  </p><h3 id="3-3-7-存在重复元素II"><a href="#3-3-7-存在重复元素II" class="headerlink" title="3.3.7 存在重复元素II"></a>3.3.7 存在重复元素II</h3><p><a href="https://leetcode.cn/problems/contains-duplicate-ii/">LeetCode 219. 存在重复元素II</a> | | <a href="#3.3">返回目录3.3</a></p><p>思路1：这个题也可以理解为找寻找至少出现两次的元素，只不过多了一个条件，即两数索引之间的距离不能超过 k。<br>简单的思路是：用哈希表存储数字的索引，计算重复出现的数字的索引之差，满足条件则可以返回True；<br>否则就用最新的索引 i 进行覆盖，以方便下一次判断条件。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        h = <span class="built_in">dict</span>()</span><br><span class="line">        N =<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> h <span class="keyword">and</span> i-h[nums[i]] &lt;=k :</span><br><span class="line">                <span class="comment"># 如果哈希表中已经存在该数, 且索引之差 &lt;=k</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 用最新的索引 i 覆盖</span></span><br><span class="line">                h[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>思路 2：还有一种方案，那就是 每次遍历到 i 时，将哈希表中，<b>前 k 个位置 之前的元素 删除掉</b>。如果是在最近的 k 个数范围内，就不删除。<br>即哈希表中只保留距离i最近的k个数，这样就不需要去计算是否符合索引值差小于等于k，因为只要没被删除的，就一定在 最近的 k 个范围。<br>该思路的时间消耗比思路1长，但是空间消耗比思路1小。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        h = <span class="built_in">dict</span>()</span><br><span class="line">        N =<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">if</span> i &gt; k: <span class="comment"># 说明目前遍历的已经超过了 k 个数</span></span><br><span class="line">                <span class="comment"># 且仍未返回True</span></span><br><span class="line">                <span class="comment"># 那么直接删除 距离当前 i 超过 k 的元素对应的键值对</span></span><br><span class="line">                <span class="comment"># 即哈希表中只保留距离i最近的k个数</span></span><br><span class="line">                h.pop(nums[i-(k+<span class="number">1</span>)])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> h:</span><br><span class="line">                <span class="comment"># 哈希表中已存在该数, 说明是第二次出现了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h[nums[i]] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><span id="3.3.8"></span>  </p><h3 id="3-3-8-存在重复元素-III"><a href="#3-3-8-存在重复元素-III" class="headerlink" title="3.3.8 存在重复元素 III"></a>3.3.8 存在重复元素 III</h3><p><a href="https://leetcode.cn/problems/contains-duplicate-iii/">LeetCode 220.存在重复元素 III</a> | | <a href="#3.3">返回目录3.3</a></p><p>思路1：遍历数组，每次遍历时，在大小为 indexDiff 区间上进行遍历，看看是否有符合条件的数字。<br>这种思路比较直观，容易想到，能跑通大部分用例；但是对于某一些用例，会出现超时现象。<br>因为时间复杂度是O(N*indexDiff)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], indexDiff: <span class="built_in">int</span>, valueDiff: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        N =<span class="built_in">len</span>(nums)</span><br><span class="line">        k = indexDiff</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N):</span><br><span class="line">            <span class="comment"># 对于数组的每一个数字，都在它前方的 indexDiff 区间对比数值</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(<span class="number">0</span>,i-k),i):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(nums[i] - nums[j]) &lt;= valueDiff:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>思路2：所以如何能高效判断 abs(nums[i] - nums[j]) &lt;= valueDiff ？  是该题的要点。</p><ul><li><p>上面两个题，是要判断【两个数字在重复出现】的情况下，索引的差值是否满足条件。<br>那么这里如果将元素按照值域进行分组呢？满足条件的数落到同一个分桶里。那么问题就转化为：<br>两个数字在重复出现在一个分桶，即【两个数字的分桶序号重复出现】的情况下，索引的差值是否满足条件。<br>然后思路就是一样的了。</p></li><li><p>所以先对数字进行分桶操作：设 t = valueDiff<br>取最差的情况，即两个数相差 t，比如 0 和 t, 那么可见每个分桶内应该有(t+1)个元素，那么我们就每隔(t+1)的值进行分桶，即看数字是 (t+1) 的多少倍，就分入哪个桶。 </p></li><li><p>另外，如果两个数落在不同分桶，也不是说就一定不满足情况，比如 若a=t 和 b=t+1按照我们上面的分桶规则，就会分别分入0号桶和1号桶，但是他们也是有可能满足索引差值的条件的。所以还需考察相邻的桶的元素。</p></li><li><p>还有，这里说的对数字进行分桶，并不是先对全部数字分好桶，而是一边遍历，一边对数字进行分桶；参考上两个题在遍历时对数字存入hash表，这里也是在遍历时分桶，然后将分桶的序号存入哈希表。也就是说其实这里分桶只是在虚拟分桶，只会用到桶的序号。  </p></li></ul><p><b>写法一：参考上一题目<a href="#3.3.7">3.3.7</a>的思路1的代码写法</b></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], indexDiff: <span class="built_in">int</span>, valueDiff: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        h = <span class="built_in">dict</span>()</span><br><span class="line">        N =<span class="built_in">len</span>(nums)</span><br><span class="line">        t, k = valueDiff, indexDiff</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="comment"># 先计算当前数字的分桶序号 group_idx</span></span><br><span class="line">            group_idx = nums[i] // (t + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> group_idx <span class="keyword">in</span> h <span class="keyword">and</span> i-h[group_idx] &lt;=k :</span><br><span class="line">                <span class="comment"># 如果哈希表中已存在该序号，说明两数之差 &lt;=t</span></span><br><span class="line">                <span class="comment"># 且索引之差也&lt;=k</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 要考虑左右相邻两个桶内是否也有符合条件的数            </span></span><br><span class="line">            <span class="keyword">elif</span> group_idx-<span class="number">1</span> <span class="keyword">in</span> h <span class="keyword">and</span> <span class="built_in">abs</span>(i-h[group_idx-<span class="number">1</span>]) &lt;= k <span class="keyword">and</span> <span class="built_in">abs</span>(nums[i]-nums[h[group_idx-<span class="number">1</span>]]) &lt;=t :</span><br><span class="line">            <span class="comment"># # 如果1.左桶存在； and 2.数字序号之差 &lt;=k; and 3.数值之差&lt;=t</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> group_idx+<span class="number">1</span> <span class="keyword">in</span> h <span class="keyword">and</span> <span class="built_in">abs</span>(i-h[group_idx+<span class="number">1</span>]) &lt;= k <span class="keyword">and</span> <span class="built_in">abs</span>(nums[i]-nums[h[group_idx+<span class="number">1</span>]]) &lt;=t :</span><br><span class="line">            <span class="comment"># # 如果1.右桶存在； and 2.数字序号之差 &lt;=k; and 3.数值之差&lt;=t</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 用最新的索引 i 覆盖 </span></span><br><span class="line">                h[group_idx] = i</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>   </span><br></pre></td></tr></table></figure><p><b>写法二：参考上一题目<a href="#3.3.7">3.3.7</a>的思路2的代码写法</b></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], indexDiff: <span class="built_in">int</span>, valueDiff: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;因为哈希表只存储最近的k个数，所以比上面的代码要节省空间&#x27;&#x27;&#x27;</span></span><br><span class="line">        group = <span class="built_in">dict</span>()</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        t, k = valueDiff, indexDiff</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="comment"># 即哈希表中只保留距离i最近的k个数</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; k:</span><br><span class="line">                <span class="comment"># 计算更前面的数字的分桶序号, 并将其从哈希表中移除</span></span><br><span class="line">                old_key = nums[i - (k+<span class="number">1</span>)] // (t + <span class="number">1</span>)</span><br><span class="line">                group.pop(old_key)</span><br><span class="line">            <span class="comment"># 经过这个if条件，各个桶中如果仍存在元素，则必然满足 abs(i-j)&lt;=k这个条件</span></span><br><span class="line">            <span class="comment"># 下面只需要考察 abs(nums[i] - nums[j]) &lt;= t 这个条件即可</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算当前i位置数字的分桶序号</span></span><br><span class="line">            key = nums[i] // (t + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> group:</span><br><span class="line">                <span class="comment"># 哈希表中已存在该分桶序号，说明这两个数被分入同一个桶</span></span><br><span class="line">                <span class="comment"># 即 abs(nums[i] - nums[j]) &lt;= t 满足</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断左右侧桶是否满足条件</span></span><br><span class="line">            <span class="comment"># 这里注意到，因为哈希表中只保留了距离i最近的k个数，所以这里相较于上面的代码</span></span><br><span class="line">            <span class="comment"># 可以不用比较索引是否满足条件，因为一定满足条件</span></span><br><span class="line">            <span class="comment"># 只需要比较数值之差是否满足条件</span></span><br><span class="line">            <span class="keyword">elif</span> (key - <span class="number">1</span>) <span class="keyword">in</span> group <span class="keyword">and</span> <span class="built_in">abs</span>(nums[group[key - <span class="number">1</span>]] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 判断右侧桶是否满足条件</span></span><br><span class="line">            <span class="keyword">elif</span> (key + <span class="number">1</span>) <span class="keyword">in</span> group <span class="keyword">and</span> <span class="built_in">abs</span>(nums[group[key + <span class="number">1</span>]] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 用最新的索引 i 覆盖 </span></span><br><span class="line">                group[key] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><span id="3.3.9"></span>  </p><h3 id="3-3-9-最大间距"><a href="#3-3-9-最大间距" class="headerlink" title="3.3.9 最大间距"></a>3.3.9 最大间距</h3><p><a href="https://leetcode.cn/problems/maximum-gap/">LeetCode 164.最大间距</a> | | <a href="#3.3">返回目录3.3</a></p><p>思路：此题要求 时间复杂度是 O(N), 空间复杂度也是O(N)<br>已经在暗示要从计数排序、基数排序、桶排序中找方法做了。<br>该题数字的范围看起来要比数字规模大(0 &lt;= nums[i] &lt;= 10^9; 1 &lt;= nums.length &lt;= 10^5)，计数排序可能没有桶排序表现好，我这里使用桶排序。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumGap</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> N &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;最基础的情况，元素都为非负整数&#x27;&#x27;&#x27;</span></span><br><span class="line">        max_v = <span class="built_in">max</span>(nums)</span><br><span class="line">        <span class="comment"># d 这里在统计最高的位数</span></span><br><span class="line">        d = <span class="built_in">len</span>(<span class="built_in">str</span>(max_v))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">            radix = <span class="number">10</span> ** i <span class="comment"># radix 代表本次循环基于哪一个位</span></span><br><span class="line">            Groups = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="comment"># 初始化从0到9，共10个分组</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                digit = num // radix % <span class="number">10</span></span><br><span class="line">                <span class="comment"># 按照当前位的数字，将原始数据分别装入不同的group中</span></span><br><span class="line">                Groups[digit].append(num)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 该 print 函数能打印各个阶段 数字装入分组后的状况，</span></span><br><span class="line">            <span class="comment"># 可以取消注释后打印中间结果，帮助理解</span></span><br><span class="line">            <span class="comment"># print(i, Groups)        </span></span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> group <span class="keyword">in</span> Groups:</span><br><span class="line">                <span class="keyword">for</span> num <span class="keyword">in</span> group:</span><br><span class="line">                    nums[j] = num </span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(nums)</span><br><span class="line">        max_res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N):</span><br><span class="line">            max_res = <span class="built_in">max</span>(max_res, <span class="built_in">abs</span>(nums[m-<span class="number">1</span>]-nums[m]))</span><br><span class="line">            <span class="comment"># print(max_res)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_res</span><br></pre></td></tr></table></figure><p><span id="3.3.10"></span>  </p><h3 id="3-3-10-数组中的第K个最大元素"><a href="#3-3-10-数组中的第K个最大元素" class="headerlink" title="3.3.10 数组中的第K个最大元素"></a>3.3.10 数组中的第K个最大元素</h3><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">LeetCode 215.数组中的第K个最大元素</a> | | <a href="#3.3">返回目录3.3</a></p><p>思路 1：题目中又出现了 【时间复杂度为 O(n)】，又可以考虑计数排序、基数排序、桶排序。<br>计数排序 O(n+width),该题 n 最大为 10^5; width最大为 2*10^4:<br>即最大的 n &gt; 最大的 width，所以可以先用计数排序尝试一次</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;题目条件中可能出现负数，所以要用delta做偏移&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">CountSort_update</span>(<span class="params">a, K</span>):</span><br><span class="line">            max_v, min_v = <span class="built_in">max</span>(a), <span class="built_in">min</span>(a)</span><br><span class="line">            <span class="comment"># max、min 函数的时间复杂度是 O(n)，符合题意</span></span><br><span class="line"></span><br><span class="line">            delta = -<span class="built_in">min</span>(<span class="number">0</span>, min_v)</span><br><span class="line">            <span class="comment"># 空间复杂度 O(width)</span></span><br><span class="line">            count_list = [<span class="number">0</span>]*(<span class="number">1</span>+max_v+delta)</span><br><span class="line">            <span class="comment"># 遍历数组a，时间负责度 O(n)</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> a:</span><br><span class="line">                count_list[num+delta] +=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 注意，由于题目中要求的是 第 k 大的数</span></span><br><span class="line">            <span class="comment"># 我们此时从后往前取，就是从大的那边开始取，取够k个就停止</span></span><br><span class="line">            <span class="comment"># 所以该循环时间复杂度是O(k), k最大也就只能是n, 不会超过数组本身规模</span></span><br><span class="line">            <span class="comment"># (极端情况，第 n 大的数, 也就是数组中最小的数)</span></span><br><span class="line">            <span class="keyword">for</span> elem <span class="keyword">in</span> <span class="built_in">range</span>(max_v+delta, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">while</span> count_list[elem] &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># a[i] = elem - delta</span></span><br><span class="line">                    <span class="comment"># i 是从0开始的，所以 i == k-1时，就是第 k 个数</span></span><br><span class="line">                    <span class="keyword">if</span> i == K-<span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> elem - delta</span><br><span class="line">                    count_list[elem] -= <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 综上所述, 时间复杂度依然是O(n)，符合题意</span></span><br><span class="line">        <span class="keyword">return</span> CountSort_update(nums,k)</span><br></pre></td></tr></table></figure><p>思路 2： 由于数字最多只有5位： -10000 or 10000；<br>更多的情况只有 4 位，所以基数排序的时间复杂度 O(n<em>d) = O(5</em>n) = O(n),也值得一试。<br>只不过要注意这里会有负数，所以处理上要稍微仔细一点。   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;简单基数排序也能跑通所有样例&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">RadixSort</span>(<span class="params">nums</span>):</span><br><span class="line">            max_v, min_v = <span class="built_in">max</span>(nums), <span class="built_in">min</span>(nums)</span><br><span class="line">            <span class="comment"># 因为可能存在负数，所以要排除负号</span></span><br><span class="line">            d1 = <span class="built_in">len</span>(<span class="built_in">str</span>(max_v)) <span class="keyword">if</span> max_v &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">len</span>(<span class="built_in">str</span>(max_v)) -<span class="number">1</span></span><br><span class="line">            d2 = <span class="built_in">len</span>(<span class="built_in">str</span>(min_v)) <span class="keyword">if</span> min_v &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">len</span>(<span class="built_in">str</span>(min_v)) -<span class="number">1</span></span><br><span class="line">            d = <span class="built_in">max</span>(d1, d2)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">                radix = <span class="number">10</span>**i</span><br><span class="line">                Groups = [ [] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">                Groups_neg = [ [] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">                <span class="comment"># Groups_neg: [0:-9], [1:-8], [8:-1], [9:-0]</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                    digit = <span class="built_in">int</span>(num/radix) % <span class="number">10</span> </span><br><span class="line">                    <span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">                        Groups[digit].append(num)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        Groups_neg[digit-<span class="number">1</span>].append(num) </span><br><span class="line"></span><br><span class="line">                j = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> group <span class="keyword">in</span> Groups_neg:</span><br><span class="line">                    <span class="keyword">for</span> num <span class="keyword">in</span> group:</span><br><span class="line">                        nums[j] = num </span><br><span class="line">                        j+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> group <span class="keyword">in</span> Groups:</span><br><span class="line">                    <span class="keyword">for</span> num <span class="keyword">in</span> group:</span><br><span class="line">                        nums[j] = num </span><br><span class="line">                        j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        RadixSort(nums)</span><br><span class="line">        <span class="comment"># 因为我们是从小到大排序的，所以这里取数时要注意换算</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums) - k]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>思路 3： 使用堆排序。虽然完整的堆排序，时间复杂度是 O(NlogN);<br>但是我们并不需要使用完整的堆排序，先构造大根堆,时间复杂度O(N)；<br>再进行 k-1次 heapify恢复大根堆操作，时间复杂度 k<em>O(logN);<br>总时间复杂度 O(N) +  k</em>O(logN) 约为 O(N), 也可以尝试一下   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">Heapify</span>(<span class="params">a, index, heapsize</span>):</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;时间复杂度 o(logN) &#x27;&#x27;&#x27;</span></span><br><span class="line">            L = <span class="number">2</span>*index+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt;= heapsize:</span><br><span class="line">                R = L+<span class="number">1</span></span><br><span class="line">                large = R <span class="keyword">if</span>(R&lt;=heapsize <span class="keyword">and</span> a[R] &gt; a[L]) <span class="keyword">else</span> L</span><br><span class="line">                large = large <span class="keyword">if</span> a[large] &gt; a[index] <span class="keyword">else</span> index</span><br><span class="line">                <span class="keyword">if</span> large == index :</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                a[index], a[large] = a[large], a[index]</span><br><span class="line">                index = large </span><br><span class="line">                L = <span class="number">2</span>*index+<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;构造大根堆 时间复杂度 o(N) &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(N/<span class="number">2</span>), -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            Heapify(nums, i, N-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># small = min(nums)-1</span></span><br><span class="line">        small = -<span class="number">10001</span> </span><br><span class="line">        <span class="comment"># 用更小的数替换掉大根堆堆顶, 相当与将这个最大数给删除了，因为我们本来就不需要它</span></span><br><span class="line">        <span class="comment"># k*O(logN) = O(logN)</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):</span><br><span class="line">            nums[<span class="number">0</span>] = small </span><br><span class="line">            Heapify(nums, <span class="number">0</span>, N-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><span id="3.3.11"></span>  </p><h3 id="3-3-11-最小的k个数"><a href="#3-3-11-最小的k个数" class="headerlink" title="3.3.11 最小的k个数"></a>3.3.11 最小的k个数</h3><p><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">LeetCode 剑指 Offer 40.最小的k个数</a> | | <a href="#3.3">返回目录3.3</a>  </p><p>思路： 由于此题没有要求时间复杂度，可以直接调用原生sort函数，或者用任意一种排序方法，先排序。<br>如果要追求时间复杂度较低的话，和上一道题有异曲同工之妙，此题找到是最小的k个数，所以仍然可以复用方法。 </p><ul><li>写法一：直接调用sort</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLeastNumbers</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        arr.sort()</span><br><span class="line">        <span class="keyword">return</span> arr[:k]</span><br></pre></td></tr></table></figure><ul><li>写法二：复用上一题目的思路<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLeastNumbers</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;由于和上一题几乎一样，这里仅给出用自带的heapq的code，其他的不赘述&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heapq.heapify(arr)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            res.append(arr[<span class="number">0</span>])</span><br><span class="line">            heapq.heappop(arr)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment"># 甚至可以直接调用求最小的n个函数</span></span><br><span class="line">        <span class="comment"># return heapq.nsmallest(k, arr)</span></span><br></pre></td></tr></table></figure></li></ul><p><span id="3.3.12"></span>  </p><h3 id="3-3-12-多数元素"><a href="#3-3-12-多数元素" class="headerlink" title="3.3.12 多数元素"></a>3.3.12 多数元素</h3><p><a href="https://leetcode.cn/problems/majority-element/">LeetCode 169.多数元素</a>| | | <a href="#3.3">返回目录3.3</a></p><p>思路：该题就是先排序，至于排序方法可以任选，反正没有要求时间复杂度。拍完序后，该数一定会出现在 [n/2]位置，因为它的个数超过了[n/2]  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><span id="3.3.13"></span>  </p><h3 id="3-3-13-合并两个有序数组"><a href="#3-3-13-合并两个有序数组" class="headerlink" title="3.3.13 合并两个有序数组"></a>3.3.13 合并两个有序数组</h3><p><a href="https://leetcode.cn/problems/merge-sorted-array/">LeetCode 88.合并两个有序数组</a> | | <a href="#3.3">返回目录3.3</a></p><p>思路 1：这个题一看就知道可以用归并排序中的 【归并】步骤做。<br>只不过这里是直接在nums1上进行填充（题目中nums1的空间是有冗余的），所以对nums1从右往左进行填充。<br>这样的话就是从右往左遍历，较大数往nums1右侧填充即可。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">        p1, p2 = m-<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">        i = m+n-<span class="number">1</span></span><br><span class="line">        <span class="comment"># p1, p2, i 都是从右往左遍历</span></span><br><span class="line">        <span class="comment"># 较大数往 i 位置填充</span></span><br><span class="line">        <span class="keyword">while</span> p1 &gt;=<span class="number">0</span> <span class="keyword">and</span> p2 &gt;=<span class="number">0</span> :</span><br><span class="line">            <span class="keyword">if</span> nums1[p1] &gt; nums2[p2]:</span><br><span class="line">                nums1[i] =  nums1[p1] </span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">                i-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[i] =  nums2[p2] </span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">                i-=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果 p1 &gt;= 0，说明 nums2的数已经全部填入合适位置了</span></span><br><span class="line">        <span class="comment"># 那 nums1剩下的部分可以不用动，所以这部分可以注释掉</span></span><br><span class="line">        <span class="comment"># while p1 &gt;= 0:</span></span><br><span class="line">        <span class="comment">#     nums1[i] =  nums1[p1]</span></span><br><span class="line">        <span class="comment">#     p1 -= 1</span></span><br><span class="line">        <span class="comment">#     i-=1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p2 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 如果nums2还有剩余，就继续填充即可</span></span><br><span class="line">            nums1[i] =  nums2[p2]</span><br><span class="line">            p2 -= <span class="number">1</span></span><br><span class="line">            i-=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>思路 2：因为 nums1 也已经是有序部分，所以可以用插入排序的思路做，即将 nums2 中的元素逐个插入到 nums1 中合适的位置即可。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># .插入排序</span></span><br><span class="line">        <span class="comment"># 换句话说nums1 在 (0,m) 区间 已经有序了</span></span><br><span class="line">        <span class="comment"># 那可以用插入排序，将 nums2的数一个一个插入到合适的位置</span></span><br><span class="line">        <span class="comment"># 只需要考察 m 到 m+n-1 的位置了</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m, m+n):</span><br><span class="line">            nums1[i] = nums2[i-m]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums1[j] &gt; nums1[j+<span class="number">1</span>]:</span><br><span class="line">                    nums1[j+<span class="number">1</span>], nums1[j] = nums1[j], nums1[j+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><span id="3.3.14"></span>  </p><h3 id="3-3-14-逆序对"><a href="#3-3-14-逆序对" class="headerlink" title="3.3.14 逆序对"></a>3.3.14 逆序对</h3><p><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">LCR 170. 交易逆序对的总数</a> | | <a href="#3.3">返回目录3.3</a></p><p>思路：如果用暴力手段去遍历的话，可能会超时。逆序对问题，可以用归并排序的过程来求解，具体的讲解放在注释中了。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePairs</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 就是手写归并排序，只不过这里需要多传入一个统计量 cnt 参与计数</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;核心思想就是在归并操作，对比左右两部分的数字的时候，</span></span><br><span class="line"><span class="string">           考察右侧的每一个数，在左边有多少个数比它大，则左边的这些数就都能与右侧的该数，</span></span><br><span class="line"><span class="string">           组成逆序对</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, L, R, cnt</span>):</span><br><span class="line">            <span class="keyword">if</span> L &gt;= R :</span><br><span class="line">                <span class="keyword">return</span> cnt </span><br><span class="line">            </span><br><span class="line">            M = L + (R-L) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            cnt = func(a,L,M,cnt)</span><br><span class="line">            cnt = func(a,M+<span class="number">1</span>,R,cnt)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># merge </span></span><br><span class="line">            p1, p2 = L, M+<span class="number">1</span></span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">while</span> p1&lt;=M <span class="keyword">and</span> p2 &lt;=R:</span><br><span class="line">                <span class="keyword">if</span> a[p1] &lt;= a[p2]:</span><br><span class="line">                    <span class="comment"># 左边的比右边的小，不构成逆序对，不用考虑</span></span><br><span class="line">                    res.append(a[p1])</span><br><span class="line">                    p1+=<span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># a[p1] &gt; a[p2]</span></span><br><span class="line">                    <span class="comment"># 因为归并排序的特点，左右两部分都各自已经是有序的了</span></span><br><span class="line">                    <span class="comment"># 所以left部分的 [p1,M] 区间的数都比 a[p1] 大</span></span><br><span class="line">                    <span class="comment"># 那么自然也比a[p2]大，都可与a[p2]组成逆序对</span></span><br><span class="line">                    cnt += M - p1 + <span class="number">1</span></span><br><span class="line">                    res.append(a[p2])</span><br><span class="line">                    p2+=<span class="number">1</span>     </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果是左侧数组还剩余有元素</span></span><br><span class="line">            <span class="comment"># 说明右侧数组已经考察完了</span></span><br><span class="line">            <span class="comment"># 而我们上面的计算方案是，对于右侧数组中的数字，计算其在左侧有多少个比它大</span></span><br><span class="line">            <span class="comment"># 此时右侧数组已经考察完，就说明cnt不用再计算了</span></span><br><span class="line">            <span class="keyword">while</span> p1 &lt;= M:</span><br><span class="line">                res.append(a[p1])</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果是右侧数组还剩余有元素</span></span><br><span class="line">            <span class="comment"># 说明左侧数组已经全部考察完了</span></span><br><span class="line">            <span class="comment"># 那么右侧数组剩余的数字一定是比左侧数组中的数字都大</span></span><br><span class="line">            <span class="comment"># 所以cnt也不用再计算了</span></span><br><span class="line">            <span class="keyword">while</span> p2 &lt;= R:</span><br><span class="line">                res.append(a[p2])</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,R-L+<span class="number">1</span>):</span><br><span class="line">                a[L+i] = res[i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> cnt</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> func(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><span id="3.3.15"></span>  </p><h3 id="3-3-15-计算右侧小于当前元素的个数"><a href="#3-3-15-计算右侧小于当前元素的个数" class="headerlink" title="3.3.15 计算右侧小于当前元素的个数"></a>3.3.15 计算右侧小于当前元素的个数</h3><p><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">LeetCode 315.计算右侧小于当前元素的个数</a> | | <a href="#3.3">返回目录3.3</a></p><p>思路：该题是上一题的升级版，难度稍微上升了一点。因为这一次等于是要计算对应位置上的逆序对，而位置在排序的时候是会移动的，就是要在这里考虑这一点。<br>所以排序的时候，可以带着索引一起排；这样对每个位置计算其各个merge阶段的逆序对的时候，还是按照索引来进行改动。<br>    将索引和数字绑定在一起形成一个元素：nums2 = [[idx, num] for idx, num in enumerate(nums)]<br>另外，由于我们是对每个位置计算其右侧的逆序对，所以这个题中，在考虑计算逆序对的时机时，应该是以left数为准，计算右侧有多少个数比它小。（<i>上一题在merge时，是对右侧的每个数计算其左侧有多少个数可以和其组成逆序对，因为只考虑逆序对的个数，而不考虑具体哪个位置上逆序对的个数，所以这么写code方便一些</i>）  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSmaller</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 先产生一个(索引，数字)为元素的新数组</span></span><br><span class="line">        nums2 = [[idx, num] <span class="keyword">for</span> idx,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums)]</span><br><span class="line">        <span class="comment"># 初始化一个全0的结果list</span></span><br><span class="line">        cnt_list = [<span class="number">0</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, L, R</span>):</span><br><span class="line">            <span class="keyword">if</span> L &gt;= R:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            M = L + (R-L)//<span class="number">2</span></span><br><span class="line">            func(a, L, M)</span><br><span class="line">            func(a, M+<span class="number">1</span>, R)</span><br><span class="line"></span><br><span class="line">            p1, p2 = L, M+<span class="number">1</span></span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">while</span> p1 &lt;= M <span class="keyword">and</span> p2 &lt;= R:</span><br><span class="line">                <span class="comment"># 元素是(idx, num)</span></span><br><span class="line">                <span class="comment"># 所以这里要对比的是 p1 和 p2 位置上的第二个值：num</span></span><br><span class="line">                <span class="keyword">if</span> a[p1][<span class="number">1</span>]&lt;=a[p2][<span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># 此时轮到左侧 p1 位置上的元素进入tmp</span></span><br><span class="line">                    <span class="comment"># 说明右侧的 [M+1, p2-1] 区间先于 p1的数字进入 tmp</span></span><br><span class="line">                    <span class="comment"># 即右侧的 [M+1, p2-1]区间 比 p1位置的数小</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 获取 a[p1][0]，对该位置记录的逆序对进行修改</span></span><br><span class="line">                    cnt_list[a[p1][<span class="number">0</span>]] += p2 - (M+<span class="number">1</span>)</span><br><span class="line">                    tmp.append(a[p1])</span><br><span class="line">                    p1 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp.append(a[p2])</span><br><span class="line">                    p2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果左侧数组还剩下数字没有进入tmp</span></span><br><span class="line">            <span class="comment"># 那说明剩下的这些数字都比右侧数组的数大            </span></span><br><span class="line">            <span class="keyword">while</span> p1 &lt;= M:</span><br><span class="line">                cnt_list[a[p1][<span class="number">0</span>]] += p2 -(M+<span class="number">1</span>)</span><br><span class="line">                tmp.append(a[p1])</span><br><span class="line">                p1 += <span class="number">1</span>    </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果是右侧数组还剩下数字，说明左侧的已经考察完了</span></span><br><span class="line">            <span class="comment"># 由于我们的计算方案是对每个左侧数字计算右侧中比它大的数，</span></span><br><span class="line">            <span class="comment"># 所以此时不用变动cnt了</span></span><br><span class="line">            <span class="keyword">while</span> p2 &lt;= R:</span><br><span class="line">                tmp.append(a[p2])</span><br><span class="line">                p2 += <span class="number">1</span>       </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp)):</span><br><span class="line">                a[L+i] = tmp[i]</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        func(nums2, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)                     </span><br><span class="line">        <span class="keyword">return</span>  cnt_list  </span><br></pre></td></tr></table></figure><p><span id="3.3.16"></span>  </p><h3 id="3-3-16-最接近原点的-K-个点"><a href="#3-3-16-最接近原点的-K-个点" class="headerlink" title="3.3.16 最接近原点的 K 个点"></a>3.3.16 最接近原点的 K 个点</h3><p><a href="https://leetcode.cn/problems/k-closest-points-to-origin/">LeetCode 973.最接近原点的 K 个点</a> | | <a href="#3.3">返回目录3.3</a></p><p>思路：这个题最简单的思路就是排序时的条件设置为距离。不管是用自带的sort还是自己写的排序code，只要两个元素之间的大小关系的对比，设置为自定义即可。和3.3.2以及 3.3.3的核心思想一样。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kClosest</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 这里简便起见，直接使用自带的sort方法</span></span><br><span class="line">        points.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]*x[<span class="number">0</span>] + x[<span class="number">1</span>]*x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> points[:k]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果要使用自己写的排序code，就需要定义一个比较大小的函数</span></span><br><span class="line">        <span class="comment"># 根据其返回值确定两个元素谁大，然后套用各种排序code即可</span></span><br><span class="line">        <span class="comment"># def Compare_two_ele(x,y):</span></span><br><span class="line">        <span class="comment">#     if x[0]*x[0] + x[1]*x[1]  &gt; y[0]*x[0] + y[1]*y[1]:</span></span><br><span class="line">        <span class="comment">#         return 1</span></span><br><span class="line">        <span class="comment">#     elif x[0]*x[0] + x[1]*x[1] == y[0]*x[0] + y[1]*y[1]:</span></span><br><span class="line">        <span class="comment">#         return 2</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         return 3</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3-2 快速排序讨论</title>
      <link href="/Data-Structure/DS_32_quick_sort_discussion.html"/>
      <url>/Data-Structure/DS_32_quick_sort_discussion.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="3-2-快速排序讨论"><a href="#3-2-快速排序讨论" class="headerlink" title="3-2 快速排序讨论"></a>3-2 快速排序讨论</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>3.2.1</td><td><a href="#3.2.1">基础问题-分块操作</a></td></tr><tr><td>3.2.2</td><td><a href="#3.2.2">经典快速排序问题</a></td></tr><tr><td>3.2.3</td><td><a href="#3.2.3">荷兰国旗问题</a></td></tr><tr><td>3.2.4</td><td><a href="#3.2.4">利用荷兰国旗问题改进快</a></td></tr><tr><td>3.2.5</td><td><a href="#3.2.5">快速排序再改进</a></td></tr></tbody></table></div><p><span id="3.2.1"></span>  </p><h2 id="3-2-1-基础问题-分块操作"><a href="#3-2-1-基础问题-分块操作" class="headerlink" title="3.2.1 基础问题-分块操作"></a>3.2.1 基础问题-分块操作</h2><p>分块问题（Partition 问题）：<br>给定一个数组arr，和一个数num，请把小于 num的数放在数组的左边，大于等于num的数放在数组的右边。<br>要求额外空间复杂度O(1)，时间复杂度O(N)。  </p><ul><li>解决思路_1：<br>  设立一个游标，该游标可以从左向右逐渐移动，移动的条件为，将数组中小于num的数，不断的插入到游标的位置，然后游标右移。<br>  这样，游标的左侧区域就逐渐扩张，相当于顶着游标在往右移动。<br>  最终，当所有元素都考察过之后，游标左侧区域的数，一定是小于num，游标右侧的数大于等于num。  </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Swap</span>(<span class="params">a, i, j</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a[i], a[j] = a[j], a[i]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(i, j)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Partition_1</span>(<span class="params">a</span>):</span><br><span class="line"></span><br><span class="line">    N = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="comment"># 我们现在假设待比较的num是数组最后的元素，即N-1位置的元素</span></span><br><span class="line">    <span class="comment"># L 就是我们的游标，在这里，我们设置游标L指向 小于等于num区域 的最后一个数的位置</span></span><br><span class="line">    <span class="comment"># 由于最开始的时候，左侧区域是没有数的，所以游标初始值是-1</span></span><br><span class="line">    key, L = N-<span class="number">1</span>, -<span class="number">1</span></span><br><span class="line">    base = a[key]</span><br><span class="line">    <span class="comment"># 因为 N-1位置的值，被我们当作比较的基准，所以只用遍历前N-1个数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, N-<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 这里的意思是，如果i位置的数，小于基准数</span></span><br><span class="line">        <span class="comment"># 就将i位置的数，与游标L右侧紧挨着的数交换位置，同时游标L右移一位，左侧区域扩张一位</span></span><br><span class="line">        <span class="keyword">if</span> a[i] &lt; base:</span><br><span class="line">            Swap(a, i, L+<span class="number">1</span>)</span><br><span class="line">            L+=<span class="number">1</span></span><br><span class="line">    <span class="comment"># for循环遍历完之后, 数组 0-L位置上的数都是小于base的数</span></span><br><span class="line">    <span class="comment"># 最后将key位置的基准数num与游标右侧L+1位置的数字交换，</span></span><br><span class="line">    <span class="comment"># 因为while循环结束之后，游标右侧的数一定是大于等于base的</span></span><br><span class="line">    <span class="comment"># 所以base与L+1位置的数交换，不影响区域的大小，但便于观察数据</span></span><br><span class="line">    <span class="comment"># 这样的话， 0-L 上的数小于base; L+1 的数等于base; L+2 至 N-1 位置上的数 大于等于 base</span></span><br><span class="line"></span><br><span class="line">    Swap(a, L+<span class="number">1</span>, key)</span><br><span class="line">    <span class="keyword">return</span> (a, L+<span class="number">1</span>, base)</span><br></pre></td></tr></table></figure><ul><li>解题思路_2: 双指针法<br>  上面的方案，设立了一个游标 L 从左往右移动，使得 L 左侧的值小于base。但是i要从左往右遍历一次，速度不够快。<br>  这里可以改进一下，再增加一个游标 R，让其从右往左移动，使得 R 右侧的数，大于等于base。<br>  当L和R撞在一起的时候，就可以结束了。  </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Partition_2</span>(<span class="params">a</span>):</span><br><span class="line"></span><br><span class="line">    N = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="comment"># 这里仍然取最后一个元素为base</span></span><br><span class="line">    <span class="comment"># 但是 L 不是从-1开始，而是从0开始；这是因为下面不是与L+1位置的数做交换了</span></span><br><span class="line">    <span class="comment"># 而是 L 和 R 两个游标指向的数做交换！即 L 和 R 指向各自区域内的边界位置</span></span><br><span class="line">    L, R, key = <span class="number">0</span>, N-<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">    base = a[key]</span><br><span class="line">    <span class="keyword">while</span> L &lt; R:</span><br><span class="line">    <span class="comment"># L 一旦等于R了，就说明两个游标都已经将区域确立好了，就该停止了</span></span><br><span class="line">    <span class="comment"># 所以下面的步骤也需要注意这个停止条件</span></span><br><span class="line">        <span class="keyword">while</span> a[L] &lt; base <span class="keyword">and</span> L&lt;R:</span><br><span class="line">            <span class="comment"># L 从0开始，如果L指向的数满足条件，则L就往右移动            </span></span><br><span class="line">            L+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果L指向了大于等于base的数，就先跳出左侧区域循环，等着下面和R位置交换</span></span><br><span class="line">        <span class="keyword">while</span> a[R] &gt;= base <span class="keyword">and</span> L&lt;R:</span><br><span class="line">            <span class="comment"># R 从 N-1 开始，如果R指向的数满足条件，则R就往左移动</span></span><br><span class="line">            R-=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果R指向了小于base的数，就先跳出右侧区域循环，等着下面和L位置交换</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行到这里，如果不是 L&gt;=R这个条件触发，那么一定是这样的情况：</span></span><br><span class="line">        <span class="comment"># L 指向的数大于等于base，R指向的数小于base</span></span><br><span class="line">        <span class="comment"># 则正好将它俩交换一下位置，然后进行下一次循环    </span></span><br><span class="line">        <span class="keyword">if</span> L&lt; R: Swap(a, R, L)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 循环结束时 L==R，此时该位置的数必然 &gt;= a[key]，直接将其交换</span></span><br><span class="line">    <span class="comment"># 这里之所以有这个结论，其实跟上面的一些设置有关系</span></span><br><span class="line">    <span class="comment"># 首先是选取的key是数组最右侧的数，其次是因为循环里先移动L的位置</span></span><br><span class="line">    <span class="comment"># 如果我们选择0作为key，那么就应该先移动右边的数，然后循环结束时，该位置的数一定&lt;=a[0]</span></span><br><span class="line">    <span class="comment"># 这段解析可以细品一下，或者自己多找几个数组试一下  </span></span><br><span class="line">    Swap(a, R, key)</span><br><span class="line">    <span class="keyword">return</span>(a, R, base)</span><br></pre></td></tr></table></figure><p><span id="3.2.2"></span>   </p><h2 id="3-2-2-经典快速排序问题"><a href="#3-2-2-经典快速排序问题" class="headerlink" title="3.2.2 经典快速排序问题"></a>3.2.2 经典快速排序问题</h2><p>在了解了上面的分区域（partition）操作之后，就已经可以将其应用到快速排序中了。<br>快速排序其实也是一种分而治之思想在排序算法上的典型应用，而且使用了递归的方法。<br>不断的将数组分为更小的两块区域，使其在最小的区域上能有序，进而在全局都有序。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">QuickSort_1</span>(<span class="params">a, L, R</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;经典快速排序&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span>(L&gt;=R):</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="comment"># partition stage            </span></span><br><span class="line">    pl, pr, key = L, R, L</span><br><span class="line">    <span class="comment"># 这里选择 partition_2的思路来做分块partition</span></span><br><span class="line">    <span class="comment"># 这里选择每一次的0作为key，以及先移动右边的数，</span></span><br><span class="line">    <span class="comment"># 然后循环结束时，该位置的数一定 &lt;=a[0]</span></span><br><span class="line">    <span class="comment"># 然后与 pl位置的进行交换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> pl &lt; pr:</span><br><span class="line">        <span class="keyword">while</span> a[pr] &gt; a[key] <span class="keyword">and</span> pl &lt; pr:</span><br><span class="line">            pr-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> a[pl] &lt;= a[key] <span class="keyword">and</span> pl &lt; pr:</span><br><span class="line">            pl+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> pl&lt; pr: Swap(a,pl,pr)</span><br><span class="line">    Swap(a,pl,key)</span><br><span class="line">    <span class="comment"># recursion stage</span></span><br><span class="line">    QuickSort_1(a, L, pl-<span class="number">1</span>)</span><br><span class="line">    QuickSort_1(a, pl+<span class="number">1</span>, R)</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p><span id="3.2.3"></span>   </p><h2 id="3-2-3-荷兰国旗问题"><a href="#3-2-3-荷兰国旗问题" class="headerlink" title="3.2.3 荷兰国旗问题"></a>3.2.3 荷兰国旗问题</h2><p>之前的Partition操作只要求分为两块区域，一部分小于等于，另一部分大于（或者一部分小于，另一部分大于等于）。<br>会发现，等于基准base的数，并不一定处于中间位置，尤其当有很多个数等于base的时候。<br>那么如果现在分为三块区域，即【小于，等于，大于】，就能加速排序过程。<br>举个例子，比如三个区域各有 N/3个数，那么下一轮迭代，就不用考虑等于区域的数了，就减少了计算量。<br>所以三块区域的 partition 问题，被称为【荷兰国旗问题】。<br>（可是荷兰国旗明明是横着的三块区域，我也不知道为什么当初人们起这个名字，我觉得更像法国国旗……）  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Partition_3</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;荷兰国旗问题，分三块&#x27;&#x27;&#x27;</span></span><br><span class="line">    N = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="comment"># 这里还是选择两个游标，但注意，这里L又是从-1开始了，因为下面i是在和L+1的位置交换</span></span><br><span class="line">    <span class="comment"># R 从 N-1开始，但因为我们的key是选的N-1，所以R也相当于是从待分块的区域外开始</span></span><br><span class="line">    <span class="comment"># 也就是说， L 和 R 一开始都是没有指向待比较元素的</span></span><br><span class="line">    L, R, key = -<span class="number">1</span>, N-<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">    base = a[key]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里其实就是i从初始游标L右侧开始，即 待比较区域 的第1个元素开始遍历</span></span><br><span class="line">    <span class="comment"># 如果只是对整个数组应用一次该函数，其实写 i=0 更好理解</span></span><br><span class="line">    <span class="comment"># 但是在遇到递归操作时，i不可能永远是从0开始，而写L+1能够适应这种变化</span></span><br><span class="line">    i = L+<span class="number">1</span> </span><br><span class="line">    <span class="keyword">while</span> i &lt;R:</span><br><span class="line">        <span class="comment"># 我们的目标是R及其右侧的区域是【大于区域】，所以若i==R，说明该停止了</span></span><br><span class="line">        <span class="keyword">if</span> a[i]&lt;base:</span><br><span class="line">        <span class="comment"># 这里是最开始已经讲过的，左侧区域向右扩展，L和i都增加</span></span><br><span class="line">            Swap(a, i, L+<span class="number">1</span>)</span><br><span class="line">            L+=<span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span>                       </span><br><span class="line">        <span class="keyword">elif</span> a[i] == base:</span><br><span class="line">        <span class="comment"># 这里的条件，L不扩展，但i继续向右侧遍历，相当于单独留了一个等于区域出来</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">                      </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># i 和 R-1位置上的数交换，就是和大于区域左侧的那个数交换，然后大于区域向左扩张（R-=1）</span></span><br><span class="line">        <span class="comment"># 其实和小于区域L的处理，是镜像的，很容易理解，一个往右扩张，一个往左扩张</span></span><br><span class="line">            Swap(a, i , R-<span class="number">1</span>)</span><br><span class="line">            R -=<span class="number">1</span></span><br><span class="line">            <span class="comment"># i+=1 一定要注意！ 大于区域扩展之后，i不应该增加！！！</span></span><br><span class="line">            <span class="comment"># 因为这个数字是从原来R-1位置换过去的，我们其实还没有进行与base比较这个操作</span></span><br><span class="line">            <span class="comment"># 就是说这个数没有得到遍历，我们得又再看一下现在i位置的值和base的关系</span></span><br><span class="line">    <span class="comment"># 循环结束时， i==R</span></span><br><span class="line">    <span class="comment"># 然后 [L+1, R-1] 区间应当是等于 base的区域 </span></span><br><span class="line">    <span class="comment"># 这时候需要把一开始选择的key位置上的 base数放入该区域中</span></span><br><span class="line">    <span class="comment"># 也就是需要进行一次交换</span></span><br><span class="line">    <span class="comment"># 下方为何与 R 交换呢？因为这个base的位置key是在右侧，</span></span><br><span class="line">    <span class="comment"># 所以R位置上，的数本来就大于 base，把它交换到 key位置上，仍然处于右侧【大于区域】</span></span><br><span class="line">    <span class="comment"># 如果我们一开始的 key 选择的是左侧的数，比如0位置上的数</span></span><br><span class="line">    <span class="comment"># 这里就应该 Swap(a,L,key), L上的数本来就小于base，放到0位置上去也不会影响partition</span></span><br><span class="line">    Swap(a, R , key) </span><br><span class="line">    <span class="comment"># 此时：R 位置为base值，[R+1, N-1] 上的数大于 base; [L+1,R]上的数等于base; [0, L]上的值小于base</span></span><br><span class="line">    <span class="comment"># 如此一来，就分为了三个部分，且端点位置我们也能知道</span></span><br><span class="line">    <span class="keyword">return</span> (a, L, R, base)</span><br></pre></td></tr></table></figure><p><span id="3.2.4"></span>   </p><h2 id="3-2-4-利用荷兰国旗问题改进快速排序"><a href="#3-2-4-利用荷兰国旗问题改进快速排序" class="headerlink" title="3.2.4 利用荷兰国旗问题改进快速排序"></a>3.2.4 利用荷兰国旗问题改进快速排序</h2><p>快速排序的架构其实很简单，就是先Partition，然后递归左右两侧区域，<br>这里我们只需要把 Partition 的方法换成 3区域 的方法即可：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">QuickSort_2</span>(<span class="params">a, L, R</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;利用荷兰国旗问题进行小加速&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span>(L&gt;=R):</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="comment"># partition stage    </span></span><br><span class="line">    pl, pr, key = L-<span class="number">1</span>, R, R</span><br><span class="line">    <span class="comment"># print(pl, pr, key)</span></span><br><span class="line">    i = pl+<span class="number">1</span> <span class="comment"># 注意，这里如果写i=0的话会导致右半部分出错！</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; pr:</span><br><span class="line">        <span class="keyword">if</span> a[i] &lt; a[key]:</span><br><span class="line">            Swap(a, i, pl+<span class="number">1</span>)</span><br><span class="line">            pl+=<span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> a[i] == a[key]:</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Swap(a, i, pr-<span class="number">1</span>)</span><br><span class="line">            pr-=<span class="number">1</span></span><br><span class="line">    <span class="comment"># 循环结束时， i==pr</span></span><br><span class="line">    </span><br><span class="line">    Swap(a, pr, key)</span><br><span class="line">    <span class="comment"># recursion stage</span></span><br><span class="line">    <span class="comment"># 观察下面的输入游标发现：</span></span><br><span class="line">    <span class="comment"># 比起改进之前，中间的 [pl+1,pr] 这一部分若干个元素就可以不用计算了，达成加速</span></span><br><span class="line">    QuickSort_2(a, L, pl)</span><br><span class="line">    QuickSort_2(a, pr+<span class="number">1</span>, R)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p><span id="3.2.5"></span>   </p><h2 id="3-2-5-快速排序再改进"><a href="#3-2-5-快速排序再改进" class="headerlink" title="3.2.5 快速排序再改进"></a>3.2.5 快速排序再改进</h2><p>&emsp;&emsp;前面的所有 Partition 方法，都是固定了一个位置的数，作为base来进行比较，大多数时候我们习惯直接用最右侧的数。  </p><p>&emsp;&emsp;但是这样就有一个问题，那就是当数据处于某一种情况的时候，每一次的取右侧那个数作为基准，可能都会导致有较多的swap操作。  </p><p>&emsp;&emsp;输入数据是我们不可控的，为了使得算法稳定，我们可以使得每一次的key，都是随机产生的，这样从统计学角度讲，会是比较稳定快速排序。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">QuickSort_3</span>(<span class="params">a, L ,R</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;对每次取的key做随机处理，可以再次改进&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span>(L&gt;=R):</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="comment"># partition stage    </span></span><br><span class="line">    pl, pr = L-<span class="number">1</span>, R</span><br><span class="line">    key = random.randint(L,R) <span class="comment"># 在 L~R范围上随机取一个位置</span></span><br><span class="line">    Swap(a, key, R) <span class="comment"># 但是还是将该数放到R位置上，这样就能复用之前的code了</span></span><br><span class="line">    key = R <span class="comment"># 再更新一下key</span></span><br><span class="line">    <span class="comment"># 这样虽然用的还是R，但是这里的R位置上的数，其实是随机从待排区域中抽取的</span></span><br><span class="line">    i = pl+<span class="number">1</span> <span class="comment"># 注意，这里如果写i=0的话会导致右半部分出错！</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; pr:</span><br><span class="line">        <span class="keyword">if</span> a[i] &lt; a[key]:</span><br><span class="line">            Swap(a, i, pl+<span class="number">1</span>)</span><br><span class="line">            pl+=<span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> a[i] == a[key]:</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Swap(a, i, pr-<span class="number">1</span>)</span><br><span class="line">            pr-=<span class="number">1</span></span><br><span class="line">    <span class="comment"># 循环结束时， i==pr</span></span><br><span class="line">    </span><br><span class="line">    Swap(a, pr, key)</span><br><span class="line">    <span class="comment"># recursion stage</span></span><br><span class="line">    QuickSort_2(a, L, pl)</span><br><span class="line">    QuickSort_2(a, pr+<span class="number">1</span>, R)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3-1 排序</title>
      <link href="/Data-Structure/DS_31_sort_algorithm.html"/>
      <url>/Data-Structure/DS_31_sort_algorithm.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="3-1-排序与查找"><a href="#3-1-排序与查找" class="headerlink" title="3-1 排序与查找"></a>3-1 排序与查找</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>3.1.1.1</td><td><a href="#3.1.1.1">冒泡排序</a></td></tr><tr><td>3.1.1.2</td><td><a href="#3.1.1.2">选择排序</a></td></tr><tr><td>3.1.1.3</td><td><a href="#3.1.1.3">插入排序</a></td></tr><tr><td>3.1.1.4</td><td><a href="#3.1.1.4">希尔排序</a></td></tr><tr><td>3.1.1.5</td><td><a href="#3.1.1.5">归并排序</a></td></tr><tr><td>3.1.1.6</td><td><a href="#3.1.1.6">堆排序</a></td></tr><tr><td>3.1.1.7</td><td><a href="#3.1.1.7">快速排序</a></td></tr><tr><td>3.1.1.8</td><td><a href="#3.1.1.8">计数排序</a></td></tr><tr><td>3.1.1.9</td><td><a href="#3.1.1.9">基数排序</a></td></tr><tr><td>3.1.1.10</td><td><a href="#3.1.1.10">桶排序</a></td></tr><tr><td>3.1.2</td><td><a href="#3.1.2">二分查找</a></td></tr></tbody></table></div><h2 id="3-1-1-排序部分"><a href="#3-1-1-排序部分" class="headerlink" title="3.1.1 排序部分"></a>3.1.1 排序部分</h2><p>排序算法可以分为内部排序和外部排序，<br>内部排序是数据记录在内存中进行排序，<br>外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要额外辅助空间。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/3_1_1.webp" width="80%">   </p><p><span id="3.1.1.1"></span> </p><h3 id="3-1-1-1-冒泡排序"><a href="#3-1-1-1-冒泡排序" class="headerlink" title="3.1.1.1 冒泡排序"></a>3.1.1.1 冒泡排序</h3><p>它重复地遍历过要排序的数列，<b>每次比较相邻两个元素，如果其大小顺序错误就交换位置</b>。<br>遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br>这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。<br>(或者也可以让大的元素慢慢“沉”到后面去，这种写法就是右部为有序区域）<br>冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># code 写法并不唯一，思路是固定的：通过对比相邻元素，然后交换</span></span><br><span class="line"><span class="comment"># 我这里的写法是每一轮把剩余的一个最大值, 送到右侧去</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Bubble_Sort</span>(<span class="params">x</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(x)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">            <span class="keyword">if</span> x[j] &gt; x[j+<span class="number">1</span>]:</span><br><span class="line">                x[j], x[j+<span class="number">1</span>] = x[j+<span class="number">1</span>], x[j]</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><blockquote><p>上述 code 思路：<br>不断地从左侧对比出最大的值，按次序放在右侧<br>第一轮:要比较的相邻索引是 (0, 1), (1,2), … ,(N-2, N-1), 遍历完后，最大数落在 N-1 位置<br>第二轮:要比较的相邻索引是 (0, 1), (1,2), … ,(N-3, N-2), 遍历完后，最大数落在 N-2 位置<br>…<br>倒数第二轮，要比较的相邻索引是 (0, 1), (1,2), 遍历完后，最大数落在 2 位置<br>最后一轮，数据对索引是 (0, 1), 遍历完后，最大数落在 1 位置<br>故而，如果用 i 代表每一轮的对比的末尾，i 从 N-1 到 1，即 i in range(N-1,0,-1)<br>   用 j 来代表数据待比较区域的索引，j 从 0 到 i-1，即 j in range (0, i)</p></blockquote><p><span id="3.1.1.2"></span> </p><h3 id="3-1-1-2-选择排序"><a href="#3-1-1-2-选择排序" class="headerlink" title="3.1.1.2 选择排序"></a>3.1.1.2 选择排序</h3><p>每次遍历时，都将未排序区域的第一个值，假设为本次遍历的最小值，<br>然后开始遍历未排序区域，直到找到未排序区域中最小的值的序号min_Index，<br>遍历完一次后，比较 min_Index 位置的值 与 假设的最小值的大小，不及预期，则可以交换位置，同时，未排序区域减少一个位置。<br>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。<br>==排序过程中，左侧区域是已排序区域，右侧区域是未排序区域。==  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">SelectSort</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-<span class="number">1</span>):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,N):</span><br><span class="line">            min_index = j <span class="keyword">if</span> (a[j]&lt;a[min_index]) <span class="keyword">else</span> min_index</span><br><span class="line">        <span class="keyword">if</span> i != min_index:</span><br><span class="line">            a[i], a[min_index] = a[min_index], a[i]</span><br><span class="line">    <span class="keyword">return</span> a </span><br></pre></td></tr></table></figure><blockquote><p>code 思路  </p><p>第一轮:假设 0位置最小，从 1~N-1位置上找到最小的，与0位置比较，看谁更小，更小的放在0位置<br>第二轮:假设 1位置最小，从 2~N-1位置上找到最小的，与1位置比较，看谁更小，更小的放在1位置<br>. . .<br>倒数第二轮，假设 N-3位置最小, 从 N-2~N-1位置上找到最小的，与N-3位置比较，看谁更小，更小的放在N-3位置<br>最后一轮，假设 N-2位置最小, 从 N-1位置上找到最小的，与N-2位置比较，看谁更小，更小的放在N-2位置<br>故而，如果用 i 代表每一轮的假设最小位置，则 i 从 0 到 N-2，即 i in range(0,N-1)<br>          用 j 来代表数据每一轮寻找区域的起始值，则 j 从 i+1 到 N-1，即 j in range(i+1,N)  </p></blockquote><p><span id="3.1.1.3"></span>  </p><h3 id="3-1-1-3-插入排序"><a href="#3-1-1-3-插入排序" class="headerlink" title="3.1.1.3 插入排序"></a>3.1.1.3 插入排序</h3><p>工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。和打扑克时整理排序类似。<br>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">InsertSort</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> a[j]&gt;a[j+<span class="number">1</span>]:</span><br><span class="line">                a[j], a[j+<span class="number">1</span>] = a[j+<span class="number">1</span>], a[j]</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><blockquote><p>code 思路  </p><p>不断地将右侧未排序区域的第一个位置，插入到左侧已排序区域的合适位置上<br>只有1个元素时不用排序，所以右侧未排序区域的起始位置是1<br>第一轮:取得 1 位置上的值，与0位置比较，看谁更小，在合适的位置放下<br>第二轮:取得 2 位置上的值，与0~1位置比较，看谁更小，在合适的位置放下<br>。。。<br>倒数第二轮，取得 N-2 位置上的值，与0~N-3位置比较，看谁更小，在合适的位置放下<br>最后一轮，取得 N-1 位置上的值，与0~N-2位置比较，看谁更小，在合适的位置放下<br>故而，如果用 i 代表每一轮获得的起始位置，则 i 从 1 到 N-1，即 i in range(1,N)<br>          用 j 来代表数据已排序的位置，则 j 从0 到 i-1，即 j in range(0,i)<br>          <b>但要注意，我们进行对比时，是在已排序区域从右往左对比更方便，因为离i更近。<br>          所以 j 在取的时候，是先看离 i 位置近的 j， 即反过来， j in range(i-1, -1, -1) </b>  </p></blockquote><p><span id="3.1.1.4"></span>  </p><h3 id="3-1-1-4-希尔排序"><a href="#3-1-1-4-希尔排序" class="headerlink" title="3.1.1.4 希尔排序"></a>3.1.1.4 希尔排序</h3><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ShellSort</span>(<span class="params">a, d=<span class="number">4</span></span>):</span><br><span class="line">    N = <span class="built_in">len</span>(a)</span><br><span class="line">    gap = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> gap &lt; N//d:</span><br><span class="line">        gap = d*gap+<span class="number">1</span></span><br><span class="line">    <span class="comment"># gap 可以理解为分组的数量</span></span><br><span class="line">    <span class="comment"># 这里的 d 其实就是第一次分组后，组内元素的上限</span></span><br><span class="line">    <span class="comment"># 所以这里可以理解为，初始分成gap组，每组内的元素最多d个</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-gap, -<span class="number">1</span>, -gap):</span><br><span class="line">                <span class="keyword">if</span> a[j] &gt; a[j+gap]:</span><br><span class="line">                    a[j+gap], a[j] = a[j], a[j+gap]</span><br><span class="line">        <span class="comment"># 随着循环进行，要将分组数调小</span></span><br><span class="line">        gap = gap//d</span><br><span class="line">    <span class="keyword">return</span> a  </span><br></pre></td></tr></table></figure><p><span id="3.1.1.5"></span>  </p><h3 id="3-1-1-5-归并排序"><a href="#3-1-1-5-归并排序" class="headerlink" title="3.1.1.5 归并排序"></a>3.1.1.5 归并排序</h3><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>可以使用递归的方法来实现，<b>每一次都将数据分为左右两块，每一次都分别让左右两块各自排好序，然后再将两块 Merge 起来，</b>从而 整体有序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">MergeSort</span>(<span class="params">a,L,R</span>):</span><br><span class="line">    <span class="keyword">if</span> L&gt;=R:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    M = L+(R-L)//<span class="number">2</span></span><br><span class="line">    Mergesort(a, L, M)</span><br><span class="line">    MergeSort(a, M+<span class="number">1</span>, R)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Merge stage</span></span><br><span class="line">    p1,p2 = L,M+<span class="number">1</span></span><br><span class="line">    res =[] <span class="comment"># 归并排序申请了辅助空间，所以是 外部排序</span></span><br><span class="line">    <span class="keyword">while</span> p1 &lt;=M <span class="keyword">and</span> p2 &lt;=R:</span><br><span class="line">        <span class="comment"># 分离双指针</span></span><br><span class="line">        <span class="keyword">if</span> a[p1]&lt;=a[p2]:</span><br><span class="line">            res.append(a[p1])</span><br><span class="line">            p1+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(a[p2])</span><br><span class="line">            p2+=<span class="number">1</span></span><br><span class="line">    <span class="comment"># 循环结束后，p1、p2中至少有一个已经越界，下面对没有越界的部分连接</span></span><br><span class="line">    <span class="keyword">while</span> p1&lt;=M:</span><br><span class="line">        res.append(a[p1])</span><br><span class="line">        p1+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> p2&lt;=R:</span><br><span class="line">        res.append(a[p2])</span><br><span class="line">        p2+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res)): <span class="comment"># len(res) = R-L+1</span></span><br><span class="line">        a[L+k] = res[k]</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p><span id="3.1.1.6"></span>   </p><h3 id="3-1-1-6-堆排序"><a href="#3-1-1-6-堆排序" class="headerlink" title="3.1.1.6 堆排序"></a>3.1.1.6 堆排序</h3><p>堆排序需要涉及到一些二叉树的基础知识，但不需要完全了解二叉树，只需要在草稿纸上模拟一下就行。  </p><p>这里提前介绍一下 大/小根堆：<br><strong>大根堆/小根堆，就是属于完全二叉树；</strong><br>大根堆：根节点是整棵树的最大值；并且对于每一棵子树而言，其最大值也都在子树根节点<br>小根堆：根节点是整棵树的最小值；并且对于每一棵子树而言，其最小值也都在子树根节点<br>下图左侧是大根堆的示意图，右侧是小根堆的示意图：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/3_1_1_6.webp" width="70%">  </p><h4 id="3-1-1-6-1-数组转成大根堆形式"><a href="#3-1-1-6-1-数组转成大根堆形式" class="headerlink" title="3.1.1.6.1 数组转成大根堆形式"></a>3.1.1.6.1 数组转成大根堆形式</h4><p>① HeapInsert 操作  </p><p>HeapInsert 操作，就是对于新加入数组的元素，我们将其移动到大（小）根堆的合适的位置。<br>对于新加入的元素，假设其数组索引是 i, 那么在堆中，它的父亲结点的索引就是 int((i-1)/2)。可以自己在画一下完全二叉树验证这个关系。HeapInsert 操作就是将新元素，不断地与其父亲结点的值比较大小，假设是构造大根堆，那新元素若比父亲结点大，它就往上移动（与父亲结点交换），然后再与新的父亲结点比较大小……直到无法再向上移动，即找到它合适的位置了。示意图如下：  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/3_1_1_7.webp" width="100%">   </p><p>这种方式与之前讲的 插入排序 的思路很像，就是对于下一个数， 将它插入到前面结构的合适的位置上，所以这种构造大（小）根堆的方式也被称为 HeapInsert.  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">HeapInsert</span>(<span class="params">x, index</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    # 该函数只是对index位置的值，进行heap insert 操作;时间复杂度：O(logN)</span></span><br><span class="line"><span class="string">    # 因为最多往上移动的次数 就是 该二叉树的高度：log_2(N)</span></span><br><span class="line"><span class="string">    # 如果要将一个随机数组构造成 大（小）根堆，则需遍历每一个元素，应用此函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 这里直接用int取整即可，(//向下取整，会在-0.5时取到-1,当index=0时使用//无法正确取数，所以用int)，</span></span><br><span class="line">    father = <span class="built_in">int</span>((index-<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> x[index] &gt; x[father]:  <span class="comment">#  此处改为小于即可用于生成小根堆</span></span><br><span class="line">        x[index], x[father] = x[father], x[index]</span><br><span class="line">        <span class="comment"># 与父亲结点交换后，index 和 father 都要更新</span></span><br><span class="line">        index = father</span><br><span class="line">        father = <span class="built_in">int</span>((index-<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>那么，如果我们对数组中的元素，从左往右依次进行 HeapInsert 操作，最后就讲这整个数组的数据转变成了大根堆的形式：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">TurnToMaxHeap</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    问题一：将一个完全二叉树（实际结构是数组）转换成大根堆</span></span><br><span class="line"><span class="string">    时间复杂度：O(N*logN)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="comment"># 从 0 开始，将每一个 a[k] 视为新加入的数，构造大根堆</span></span><br><span class="line">        arr = HeapInsert(arr, i)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><p>这里要注意，到这里为止，只是将数组处理为大(小)根堆，并未完成排序。</p><p>② Heapify 操作  </p><p>上面的 HeapInsert 操作是对新来的数字“往上浮”，这里讲的是对原有的数字“往下沉”。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Heapify</span>(<span class="params">a, index, heapsize</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    heapify过程：将一个原本是大根堆的完全二叉树，根结点的值发生变化，要重新变成大根堆的过程.</span></span><br><span class="line"><span class="string">    方法：index位置的元素和它的左右孩子比较，如果小于它的左右孩子那么就往下沉；否则不动</span></span><br><span class="line"><span class="string">    时间复杂度Olog(N)</span></span><br><span class="line"><span class="string">    heapsize小于等于数组最后一个索引(也就是表示0~heapsize区间是个大根堆)；</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    left = <span class="number">2</span> * index +<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= heapsize:</span><br><span class="line">        right = left + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 先比较左右孩子中更大的结点</span></span><br><span class="line">        large = right <span class="keyword">if</span> (right &lt;= heapsize <span class="keyword">and</span> a[right]&gt;a[left]) <span class="keyword">else</span> left</span><br><span class="line">        <span class="comment"># 再比较当前结点与最大孩子的值</span></span><br><span class="line">        large = large <span class="keyword">if</span> (a[large] &gt; a[index]) <span class="keyword">else</span> index</span><br><span class="line">        <span class="comment"># 如果最大的是当前结点，说明不需要下沉了，停止循环</span></span><br><span class="line">        <span class="keyword">if</span> large == index:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 否则就交换位置，并更新索引，准备下一轮循环</span></span><br><span class="line">        a[index], a[large] = a[large], a[index]</span><br><span class="line">        index = large</span><br><span class="line">        left = <span class="number">2</span>*index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a </span><br></pre></td></tr></table></figure><p>因为我们上面code的前提条件是，假设“<b>一个原本是大根堆的完全二叉树，根结点的值发生变化，重新调整根结点的位置，使其恢复为一个大根堆</b>”；所以对于一个本来不是大根堆的完全二叉树，想要利用Heapify的思路转换成大根堆，就<b>从下往上进行变换。</b><br>即从倒数第二层开始，让每一个子树都称为大根堆，不断往上扩展。子树变成大根堆后，它的父节点就可以视为外层大根堆被改变了值的那个根结点，又将该父结点下沉到合适位置，又再往上扩张一层。具体实现code 如下：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BuildMaxHeap</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;时间复杂度O(N)&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    N = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(math.floor(N/<span class="number">2</span>), -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        a = Heapify(a, i, N-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> a </span><br></pre></td></tr></table></figure><p><strong>为何用这种方法构造大根堆的时间复杂度是O(N)? 解释如下</strong>：</p><blockquote><p>对于一棵满的完全二叉树，二叉树一共有 N 个结点。则：<br>倒数第1层有 $\frac{N}{2}$ 个结点，每个结点遍历1次，最多往下沉 0 次，总共就是 $\frac{N}{2}$ 次操作； </p><p>倒数第2层有 $\frac{N}{4}$ 个结点，每个结点遍历1次，每个结点最多往下沉 1 次，总共就是 $\frac{2N}{4}$ 次操作； </p><p>倒数第3层有 $\frac{N}{8}$ 个结点，每个结点遍历1次，每个结点最多往下沉 2 次，总共就是 $\frac{3N}{8}$ 次操作；<br>……<br>所以时间复杂度为 $T(N) = \frac{N}{2} + \frac{2N}{4} + \frac{3N}{8} + \cdots $<br>故而  $T(N) = 2T(N) -T(N) = N + \frac{N}{2} + \frac{N}{4} + \frac{N}{8} + \cdots - \sigma $ 这是一个等比数列，结果是 $2N$，所以时间复杂度就是 $O(N)$。  </p></blockquote><h4 id="3-1-1-6-2-堆排序部分"><a href="#3-1-1-6-2-堆排序部分" class="headerlink" title="3.1.1.6.2 堆排序部分"></a>3.1.1.6.2 堆排序部分</h4><p>假设是按照从小到大排序，那么每一次构造一个大根堆后，未排序区域的最大值就到了根结点，那么只要将该数与未排序区域末尾数交换，则该区域的最大数就到了该区域的末尾。同时未排序区域缩小一格，然后恢复未排序区域的大根堆结构，重复操作。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">HeapSort</span>(<span class="params">a</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="comment"># 先构建大根堆</span></span><br><span class="line">    a = buildMaxHeap(a)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(N-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 每一次都将顶点和最后最后一个数进行交换，则最大数就被移动到数组末尾</span></span><br><span class="line">        a[<span class="number">0</span>], a[k] = a[k], a[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 相当于 a[0] 的位置发生了变化，正好用heapify重新调整为大根堆</span></span><br><span class="line">        <span class="comment"># 注意刚刚的最大值已经是有序区域中了，所以heapsize也要每次缩小一次</span></span><br><span class="line">        a = Heapify(a,<span class="number">0</span>,k-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    可以看到，不管最开始采用哪种方法构造大根堆，O(N)或者O(N*logN)都无所谓</span></span><br><span class="line"><span class="string">    后面不断交换位置的操作才是影响时间复杂度的大头，这部分是 O(N*logN)</span></span><br><span class="line"><span class="string">    所以堆排序的总体时间复杂度是 O(N*logN)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><span id="3.1.1.7"></span>   </p><h3 id="3-1-1-7-快速排序"><a href="#3-1-1-7-快速排序" class="headerlink" title="3.1.1.7 快速排序"></a>3.1.1.7 快速排序</h3><p>快速排序采用的思想也是分治法，先将数组大致分为有序的几块区域，再对各个区域内分为几个有序的区域，直到区域已经不可再细分，这样整个数组也就有序了。下面只给出快速排序的code，至于其推导过程，见下一章【快速排序深入讨论】。  </p><p>快速排序虽然表面上只用了几个额外的变量，<b><font color="red">但是其空间复杂度是O(logN)</font></b>!<br>这是因为快速排序使用递归操作，递归操作会调用系统栈，这个系统栈的深度是O(logN)。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">QuickSort</span>(<span class="params">a, L, R</span>):</span><br><span class="line">    <span class="keyword">if</span> L &gt;= R:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="comment"># partition stage:</span></span><br><span class="line">    <span class="comment"># 随机抽取一个基础值</span></span><br><span class="line">    key = random.randint(L, R)</span><br><span class="line">    a[key], a[R] = a[R], a[key]</span><br><span class="line">    <span class="comment"># 将基础值放在最右方便下面写code</span></span><br><span class="line">    key = R</span><br><span class="line">    p1, p2 = L-<span class="number">1</span>, R</span><br><span class="line">    <span class="comment"># 这一段partition已经是经过荷兰国旗问题优化后的partition了，原始的快速排序不是这么写</span></span><br><span class="line">    i = p1+<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; p2:</span><br><span class="line">        <span class="keyword">if</span> a[i] &lt; a[key]:</span><br><span class="line">            <span class="comment"># 如果 i 位置的值更小，i与小于区域的下一位的数交换，小于区域扩张1位</span></span><br><span class="line">            a[i], a[p1+<span class="number">1</span>] = a[p1+<span class="number">1</span>], a[i]</span><br><span class="line">            p1 += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> a[i] == a[key]:</span><br><span class="line">            <span class="comment"># 如果相等，i直接往后过，两个区域都不变化</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果i位置的值更大，i与大于区域的左侧数交换，大于区域扩张(p2减少1)</span></span><br><span class="line">            a[i], a[p2-<span class="number">1</span>] = a[p2-<span class="number">1</span>], a[i]</span><br><span class="line">            p2 -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 同时i不变，因为i位置的数刚从大于区域的左侧被交换过去，还没判断呢</span></span><br><span class="line">    <span class="comment"># 循环结束后 i==p2，i位置的值一定大于等于key位置</span></span><br><span class="line">    <span class="comment"># 将基础值与i位置进行交换</span></span><br><span class="line">    a[i], a[key] = a[key], a[i]</span><br><span class="line">    <span class="comment"># recursion stage</span></span><br><span class="line">    QuickSort(a, L, p1)</span><br><span class="line">    QuickSort(a, p2+<span class="number">1</span>, R)</span><br><span class="line">    <span class="keyword">return</span> a </span><br></pre></td></tr></table></figure><p><span id="3.1.1.8"></span>   </p><h3 id="3-1-1-8-计数排序"><a href="#3-1-1-8-计数排序" class="headerlink" title="3.1.1.8 计数排序"></a>3.1.1.8 计数排序</h3><p>要求元素一定是<strong>整数！整数！</strong>且元素值的<strong>范围最好不要太大</strong>，一般来说几万以内应该都还算比较快。<br><b>计数排序不是比较排序，排序的速度快于任何比较排序算法，只不过有上一行提到的先决条件</b>。<br>基本思路如下：<br>① <strong>找出待排序的数组中最大和最小的元素</strong>，因为计数的数组Count的长度取决于待排序数组中数据的范围，<br>② <strong>创建计数数组Count</strong>，长度等于待排序数组的最大值与最小值的差加上1,元素默认值为0.<br>③ <strong>遍历原数组中的元素，以原数组中的元素值作为Count数组的索引</strong>，以原数组中的元素出现次数作为Count数组的元素值。<br>    比如原始数组中有10个66，则Count[66]=10<br>④ <strong>按照count索引从小到大（也就是原始数组元素值从小到大）进行遍历</strong>，排布好新的数组</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">CountSort_1</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;最基础的情况，元素都为非负整数&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 1.获得最大值</span></span><br><span class="line">    <span class="comment"># 如果不想用自带的max函数，那其实也可以遍历一遍数组，时间复杂度也是O(N)</span></span><br><span class="line">    <span class="comment"># 因为计数排序本来就是O(N+K)，时间复杂度是忽略系数的，O(N) + O(N) 还是 O(N)</span></span><br><span class="line">    max_v = <span class="built_in">max</span>(a)</span><br><span class="line">    <span class="comment"># 2.创建辅助数组</span></span><br><span class="line">    count_list = [<span class="number">0</span>]*(max_v+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 3.统计原数组的元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">        count_list[a[k]] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 4.对原始数组的元素按顺序排布</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(count_list)):</span><br><span class="line">        <span class="keyword">while</span> count_list[k] &gt; <span class="number">0</span>:</span><br><span class="line">            a[i] = k</span><br><span class="line">            count_list[k] -= <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 这一段 while 循环体虽然可以改写成如下形式：</span></span><br><span class="line">        <span class="comment"># if count_list[k] &gt; 0:</span></span><br><span class="line">        <span class="comment">#     a[i:i+count_list[k]] = [k]*count_list[k]</span></span><br><span class="line">        <span class="comment">#     i += count_list[k]</span></span><br><span class="line">        <span class="comment"># 但是 python在实际操作中会 在等号右边创建一个临时的数组，然后赋值给左边</span></span><br><span class="line">        <span class="comment"># 这就相当于使用了 额外空间了，所以不建议这么写</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CountSort_2</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;若可能有负数出现，只需要引入一个bias即可&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 1.获得最大值，最小值</span></span><br><span class="line">    min_v, max_v = <span class="built_in">min</span>(a), <span class="built_in">max</span>(a)</span><br><span class="line">    <span class="comment"># bias = 0-min_v if min_v &lt; 0 else 0</span></span><br><span class="line">    bias = - <span class="built_in">min</span>(<span class="number">0</span>, min_v)</span><br><span class="line">    <span class="comment"># 2.创建辅助数组</span></span><br><span class="line">    count_list = [<span class="number">0</span>]*(max_v+<span class="number">1</span>+bias)</span><br><span class="line">    <span class="comment"># 3.统计原数组的元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">        count_list[a[k]+bias] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 4.对原始数组的元素按顺序排布</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(count_list)):</span><br><span class="line">        <span class="keyword">while</span> count_list[k] &gt; <span class="number">0</span>:</span><br><span class="line">            a[i] = k - bias</span><br><span class="line">            count_list[k] -= <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a </span><br><span class="line">    <span class="comment"># 可见这个写法不管有没有负数, 其实都能跑通</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>从代码中可以看出，计数排序的时间复杂度是 O(n+k),  空间复杂度是O(k)<br>其中n是数组规模， k是数组值域范围 max_v - min_v + 1</p><p><span id="3.1.1.9"></span>   </p><h3 id="3-1-1-9-基数排序"><a href="#3-1-1-9-基数排序" class="headerlink" title="3.1.1.9 基数排序"></a>3.1.1.9 基数排序</h3><p>所谓的基数，就是指的按照数字的哪一位来排序。<br>比如按照个位来排序，基数就是 10^0;<br>按照十位数进行排序，基数就是 10^1;<br>按照百位数进行排序：基数就是 10^2;<br>基数排序也不用进行比较，因为每一位数字都是 0-9组成的，天然有序，所以只要按照每一位的数字，将数字分到对应的分组去，那么对于当前位数来说，各个组之间就按照0-9排序了。<br>对于每一位都来一次，就能够实现整体有序。  </p><p>基数排序能够实现有序的关键点在于，当按照分组分号之后，从分组中取出来排布时，<b>各个分组的元素要做到先入先出</b>。 因为同一个分组内的元素，当前考察的基数那一位，肯定是相同的，但是其进入分组的顺序，是由上一轮的考察基数位的大小顺序决定的。  </p><p>举个例子：比如 58和51 被分到了一个分组，可以肯定，当前考察的是十位，因为它们的十位都是数字5，这才有可能被分到一个分组。那么上一轮考察的就是个位，个位分别是 1 和 8，那么可以肯定，1这个分组的数字是排在8这个分组的数字之前的。  </p><p>所以在考察十位上的数字进行分组时，一定是 51先遍历到，被分到5号组，然后才是58被遍历到，也分到5号组。所以组内的顺序是: [ 51, 58 ]。那么从分组内取出进行还原时，就要保证先取出 51， 再取出 58。所以各个分组，其实可以从逻辑上视为一个队列。当然不必真的使用队列，只要使用 list 时注意先入先出的顺序就好。  </p><p><b>基数排序通常也是只能处理<font color="red">非负 整数</font>，且要求数目不要过大。</b>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">RadixSort</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;最基础的情况，元素都为非负整数&#x27;&#x27;&#x27;</span></span><br><span class="line">    max_v = <span class="built_in">max</span>(a)</span><br><span class="line">    <span class="comment"># d 这里在统计最高的位数</span></span><br><span class="line">    <span class="comment"># d=0</span></span><br><span class="line">    <span class="comment"># while max_value &gt;0:</span></span><br><span class="line">    <span class="comment">#     d+=1</span></span><br><span class="line">    <span class="comment">#     max_value//=10</span></span><br><span class="line">    d = <span class="built_in">len</span>(<span class="built_in">str</span>(max_v))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">        radix = <span class="number">10</span> ** i <span class="comment"># radix 代表本次循环基于哪一个位</span></span><br><span class="line">        <span class="comment"># 每一轮都是重新初始化 Groups</span></span><br><span class="line">        Groups = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="comment"># 初始化从0到9，共10个分组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> a:</span><br><span class="line">            digit = num // radix % <span class="number">10</span></span><br><span class="line">            <span class="comment"># 按照当前位的数字，将原始数据分别装入不同的group中</span></span><br><span class="line">            Groups[digit].append(num)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 该 print 函数能打印各个阶段 数字装入分组后的状况，</span></span><br><span class="line">        <span class="comment"># 可以取消注释后打印中间结果，帮助理解</span></span><br><span class="line">        <span class="comment"># print(i, Groups)        </span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> Groups:</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> group:</span><br><span class="line">                a[j] = num </span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p><b>稍加改动也能处理出现<font color="red">负整数</font>的情况</b><br>对于负数部分，我们需要在设置一个长度为 10 的分组，用来装 -9 — 0 。<br>这里需要注意的点， </p><ul><li><p>① 10 和 -10 与 10% 进行求模运算后，结果都是 0；但是这两个数明显不能都放入 0 号组，<br>   10 是可以放入 0 号分组的，但是 -10 却是一个负数，它的实际位置应该比0还小。</p><pre><code>为了方便讨论，我们这里称呼 -10 % 10 为 -0；在负数部分的分组中，排在最大的位置。 即负数的10个分组对应的数字为：[-9], [-8], ..., [-1], [-0]</code></pre></li><li><p>② 在求每一位上的数字时，我们之前使用的是 整除号：// 。但是整除号是向下进位，对负数使用整除号时，会往远离 0 的方向进位。 比如 -18 // 10 = -2; 但是我们希望是得到 - 1，这样能照搬非负整数部分的处理，所以就是希望向 0 靠拢。可以使用 int函数。int(-18 / 10 ) = -1.    </p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">RadixSort_2</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;要处理的数据中可能出现 负整数&#x27;&#x27;&#x27;</span></span><br><span class="line">    max_v, min_v = <span class="built_in">max</span>(a), <span class="built_in">min</span>(a)</span><br><span class="line">    <span class="comment"># d 这里在统计最高的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果存在负数，str之后会有&#x27;-&#x27;，即比数字本身多了1位，所以需要判断</span></span><br><span class="line">    L_1 = <span class="built_in">len</span>(<span class="built_in">str</span>(max_v)) <span class="keyword">if</span> max_v &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">len</span>(<span class="built_in">str</span>(max_v))-<span class="number">1</span></span><br><span class="line">    L_2 = <span class="built_in">len</span>(<span class="built_in">str</span>(min_v)) <span class="keyword">if</span> min_v &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">len</span>(<span class="built_in">str</span>(min_v))-<span class="number">1</span></span><br><span class="line">    d = <span class="built_in">max</span>(L_1, L_2)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">        radix = <span class="number">10</span> ** i <span class="comment"># radix 代表本次循环基于哪一个位</span></span><br><span class="line">        Groups = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="comment"># 初始化从 0 到9，共10个分组</span></span><br><span class="line">        Groups_neg = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="comment"># 初始化从-9 到-0，共10个分组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> a:</span><br><span class="line">            <span class="comment"># digit = num // radix % 10</span></span><br><span class="line">            digit = <span class="built_in">int</span>(num / radix) % <span class="number">10</span></span><br><span class="line">            <span class="comment"># 注意: -10 和 10 与 10 求模运算后都得 0</span></span><br><span class="line">            <span class="comment"># 但是二者的大小明显不一样</span></span><br><span class="line">            <span class="comment"># 为了便于理解，我们可以假设 10 % 10 = +0； -10 % 10 = -0</span></span><br><span class="line">            <span class="comment"># 按照当前位的数字的正负属性，将原始数据分别装入不同的group中</span></span><br><span class="line">            <span class="keyword">if</span> num &gt;= <span class="number">0</span>:</span><br><span class="line">                Groups[digit].append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 这里需要注意 -9 % 10 = 1;...; -1 % 10 = 9; -10 % 10 = -0;</span></span><br><span class="line">                Groups_neg[digit-<span class="number">1</span>].append(num)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 该 print 函数能打印各个阶段 数字装入分组后的状况，</span></span><br><span class="line">        <span class="comment"># 可以取消注释后打印中间结果，帮助理解</span></span><br><span class="line">        <span class="comment"># print(i, Groups_neg, &#x27;---&#x27;, Groups)</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 先取出负数部分</span></span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> Groups_neg:</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> group:</span><br><span class="line">                a[j] = num </span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 再取出正数部分</span></span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> Groups:</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> group:</span><br><span class="line">                a[j] = num </span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p>从代码中可以看出，基数排序的时间复杂度是 O(n*k),  空间复杂度是O(n)<br>其中n是数组规模， k是数组中位数最长的一个数的宽度   </p><p><span id="3.1.1.10"></span>   </p><h3 id="3-1-1-10-桶排序"><a href="#3-1-1-10-桶排序" class="headerlink" title="3.1.1.10 桶排序"></a>3.1.1.10 桶排序</h3><p>将数据分到若干个桶（分组）中，每个桶的元素再进行单独排序。<br>通常是按照数值大小进行分组，比如若一个数组最大数为 200，最小数为1，就可以以 20的区间进行分组，分10个桶。但是有一些题目可能也会根据另外一些属性进行分组，总之要看具体情况。<br>对每个桶内的数据进行排序操作，也是看数据的具体情况，可以使用不同的排序方法。<br>最后将各个桶内的元素组合到一起，完成最终排序。 </p><p><span id="3.1.2"></span>   </p><h2 id="3-1-2-二分查找"><a href="#3-1-2-二分查找" class="headerlink" title="3.1.2 二分查找"></a>3.1.2 二分查找</h2><p>二分查找的时间复杂度是O(logN),<a href="https://www.suibibk.com/topic/678695904085016576/">参考链接 </a> </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BinarySearch</span> (arr, L, R, x): </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 基本判断</span></span><br><span class="line">    <span class="keyword">if</span> R &gt;= L: </span><br><span class="line">  </span><br><span class="line">        mid = L + <span class="built_in">int</span>((R - L)/<span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 元素整好的中间位置</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] == x: </span><br><span class="line">            <span class="keyword">return</span> mid </span><br><span class="line">          </span><br><span class="line">        <span class="comment"># 元素小于中间位置的元素，只需要再比较左边的元素</span></span><br><span class="line">        <span class="keyword">elif</span> x &lt; arr[mid]: </span><br><span class="line">            <span class="keyword">return</span> BinarySearch (arr, L, mid-<span class="number">1</span>, x) </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 元素大于中间位置的元素，只需要再比较右边的元素</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> BinarySearch (arr, mid+<span class="number">1</span>, R, x) </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="comment"># 不存在</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2-3 数组双指针</title>
      <link href="/Data-Structure/DS_23_array_double_pointer_exercises.html"/>
      <url>/Data-Structure/DS_23_array_double_pointer_exercises.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1"> <h1 id="2-3-数组双指针"><a href="#2-3-数组双指针" class="headerlink" title="2-3 数组双指针"></a>2-3 数组双指针</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p><b>版权声明：以下题目均来自 <a href="https://leetcode.cn">LeetCode</a>， 仅仅提供跳转到力扣官网的链接，不在本页面出现题目内容，本文章内容禁止商业用途。</b>  </p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>2.3.1</td><td><a href="#2.3.1">对撞指针</a></td></tr><tr><td>2.3.2</td><td><a href="#2.3.2">快慢指针</a></td></tr></tbody></table></div><p>指针的名字来源于链表，代表的是指向结点地址的位置变量。可以迁移到数组这边来，代表存储数组索引的变量。<br>而双指针的意思就是用两个变量来维护不同的索引，从而实现特定的功能。  </p><p><span id="2.3.1"></span>  </p><h2 id="2-3-1-对撞指针"><a href="#2-3-1-对撞指针" class="headerlink" title="2.3.1 对撞指针"></a>2.3.1 对撞指针</h2><p>所谓对撞指针，就是指的初始状态的两个指针一个在左，一个在右；终止条件为左指针等于右指针。  </p><p><span id="2.3.1"></span>  </p><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">LeetCode 167.两数之和II-输入有序数组</a></td><td><a href="#2.3.1.1">题解2.3.1.1</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/reverse-string/">LeetCode 344.反转字符串</a></td><td><a href="#2.3.1.2">题解2.3.1.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/reverse-vowels-of-a-string/">LeetCode 345.反转字符串中的元音字母</a></td><td><a href="#2.3.1.3">题解2.3.1.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/valid-palindrome/">LeetCode 125.验证回文串</a></td><td><a href="#2.3.1.4">题解2.3.1.4</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">LCR 139.训练计划 I</a></td><td><a href="#2.3.1.5">题解2.3.1.5</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/boats-to-save-people/">LeetCode 881.救生艇</a></td><td><a href="#2.3.1.6">题解2.3.1.6</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/container-with-most-water/">LeetCode 11.盛最多水的容器</a></td><td><a href="#2.3.1.7">题解2.3.1.7</a></td></tr><tr><td>⑧</td><td><a href="https://leetcode.cn/problems/valid-triangle-number/">LeetCode 611.有效三角形的个数</a></td><td><a href="#2.3.1.8">题解2.3.1.8</a></td></tr><tr><td>⑨</td><td><a href="https://leetcode.cn/problems/3sum/">LeetCode 15.三数之和</a></td><td><a href="#2.3.1.9">题解2.3.1.9</a></td></tr><tr><td>⑩</td><td><a href="https://leetcode.cn/problems/3sum-closest/description/">LeetCode 16.最接近的三数之和</a></td><td><a href="#2.3.1.10">题解2.3.1.10</a></td></tr><tr><td>⑪</td><td><a href="https://leetcode.cn/problems/4sum/">LeetCode 18.四数之和</a></td><td><a href="#2.3.1.11">题解2.3.1.11</a></td></tr><tr><td>⑫</td><td><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">LeetCode 977.有序数组的平方</a></td><td><a href="#2.3.1.12">题解2.3.1.12</a></td></tr><tr><td>⑬</td><td><a href="https://leetcode.cn/problems/sort-colors/">LeetCode 75.颜色分类</a></td><td><a href="#2.3.1.13">题解2.3.1.13</a></td></tr><tr><td>⑭</td><td><a href="https://leetcode.cn/problems/trapping-rain-water/">LeetCode 42.接雨水</a></td><td><a href="#2.3.1.14">题解2.3.1.14</a></td></tr><tr><td>⑮</td><td><a href="https://leetcode.cn/problems/longest-mountain-in-array/">LeetCode 845.数组中的最长山脉</a></td><td><a href="#2.3.1.15">题解2.3.1.15</a></td></tr><tr><td>⑯</td><td><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">LeetCode 978.最长湍流子数组</a></td><td><a href="#2.3.1.16">题解2.3.1.16</a></td></tr></tbody></table></div><p><span id="2.3.1.1"></span>  </p><h3 id="2-3-1-1-两数之和II-输入有序数组"><a href="#2-3-1-1-两数之和II-输入有序数组" class="headerlink" title="2.3.1.1 两数之和II -输入有序数组"></a>2.3.1.1 两数之和II -输入有序数组</h3><p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">LeetCode 167.两数之和II-输入有序数组</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p>思路：数组已经有序，那可以从左右两侧向中间靠拢，逼近目标值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        N = <span class="built_in">len</span>(numbers)</span><br><span class="line">        L, R  =<span class="number">0</span>, N-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            <span class="keyword">while</span> L  &lt;R <span class="keyword">and</span>  numbers[L] +  numbers[R] &lt;target:</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> numbers[L] +  numbers[R] &gt; target:</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> L&lt; R <span class="keyword">and</span> numbers[L] +  numbers[R] == target:</span><br><span class="line">                <span class="keyword">return</span> [L+<span class="number">1</span>, R+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p><span id="2.3.1.2"></span></p><h3 id="2-3-1-2-反转字符串"><a href="#2-3-1-2-反转字符串" class="headerlink" title="2.3.1.2 反转字符串"></a>2.3.1.2 反转字符串</h3><p><a href="https://leetcode.cn/problems/reverse-string/">LeetCode 344.反转字符串</a> |  | <a href="#2.3.1">返回目录2.3.1</a></p><p>思路：这个题是对撞双指针的代表题目，也可以用它来进行数组逆序。   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            s[L], s[R] = s[R], s[L]</span><br><span class="line">            L += <span class="number">1</span></span><br><span class="line">            R -=<span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="2.3.1.3"></span>  </p><h3 id="2-3-1-3-反转字符串中的元音字母"><a href="#2-3-1-3-反转字符串中的元音字母" class="headerlink" title="2.3.1.3 反转字符串中的元音字母"></a>2.3.1.3 反转字符串中的元音字母</h3><p><a href="https://leetcode.cn/problems/reverse-vowels-of-a-string/">LeetCode 345.反转字符串中的元音字母</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p>思路 1：先用哈希表记住元音字母原始的索引，然后按照索引逆序改变其对应位置的值。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;思路1.使用哈希表&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        ll = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="comment"># from collections import defaultdict</span></span><br><span class="line">        <span class="comment"># dict_1 = defaultdict(str)</span></span><br><span class="line">        <span class="comment"># N = len(s)</span></span><br><span class="line">        <span class="comment"># for i in range(N):</span></span><br><span class="line">        <span class="comment">#     if ll[i] in &#x27;aeiouAEIOU&#x27;:</span></span><br><span class="line">        <span class="comment">#         dict_1[i] = ll[i]</span></span><br><span class="line">        <span class="comment"># 注释中的内容一行代码就可以写完</span></span><br><span class="line">        dict_1 = <span class="built_in">dict</span>((i,ch) <span class="keyword">for</span> (i,ch) <span class="keyword">in</span> <span class="built_in">enumerate</span>(ll) <span class="keyword">if</span> ch <span class="keyword">in</span> <span class="string">&#x27;aeiouAEIOU&#x27;</span>)</span><br><span class="line">        list_key = <span class="built_in">sorted</span>(<span class="built_in">list</span>(dict_1.keys()))</span><br><span class="line"></span><br><span class="line">        length = <span class="built_in">len</span>(list_key)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            ll[list_key[i]] =  dict_1[list_key[length-<span class="number">1</span>-i]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ll)</span><br></pre></td></tr></table></figure><p>思路2：使用双指针，可以借鉴 <a href="#2.3.1.2">2.3.1.2-反转字符串</a>  那道题的思路；<br>只不过并不是直接反转，而是先要判断条件。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;思路2. 使用双指针&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(s)</span><br><span class="line">        ll = <span class="built_in">list</span>(s)</span><br><span class="line">        L, R = <span class="number">0</span>, N-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> ll[L] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;aeiouAEIOU&#x27;</span>:</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> ll[R] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;aeiouAEIOU&#x27;</span>:</span><br><span class="line">                R -=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> L&lt;R:</span><br><span class="line">                ll[L], ll[R] = ll[R], ll[L]</span><br><span class="line">                L +=<span class="number">1</span></span><br><span class="line">                R -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ll)</span><br></pre></td></tr></table></figure><p><span id="2.3.1.4"></span>  </p><h3 id="2-3-1-4-验证回文串"><a href="#2-3-1-4-验证回文串" class="headerlink" title="2.3.1.4 验证回文串"></a>2.3.1.4 验证回文串</h3><p><a href="https://leetcode.cn/problems/valid-palindrome/">LeetCode 125.验证回文串</a> | | <a href="#2.3.1">返回目录2.3.1</a>  </p><p>思路：回文字符串就是以中心为对称的关系，而且题目中说明了只考虑小写字母和数字两种字符的情况，其他的就该跳过。<br>也是考虑使用对撞指针.  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 先将所有大写转成小写</span></span><br><span class="line">        s = s.lower()</span><br><span class="line">        <span class="comment"># 初始化双指针</span></span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> <span class="keyword">not</span> s[L].isalnum():</span><br><span class="line">                <span class="comment"># 对于非字母数字字符, 直接不考虑, 直接移动指针</span></span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> <span class="keyword">not</span> s[R].isalnum():</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> L &lt; R:</span><br><span class="line">                <span class="keyword">if</span> s[L] == s[R]:</span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果发现不相等的情况，说明左右不对称</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>   </span><br></pre></td></tr></table></figure><p><span id="2.3.1.5"></span>  </p><h3 id="2-3-1-5-调整数组顺序使奇数位于偶数前面"><a href="#2-3-1-5-调整数组顺序使奇数位于偶数前面" class="headerlink" title="2.3.1.5 调整数组顺序使奇数位于偶数前面"></a>2.3.1.5 调整数组顺序使奇数位于偶数前面</h3><p><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">LCR 139.训练计划 I</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p>思路：该题和上面【 <a href="#2.3.1.3">反转字符串中的元音字母</a> 】思路是一脉相承的；<br>这里反转的不是元音字符，而是奇数or偶数，只需将判断条件做修改就行；  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exchange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        </span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[L] % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 题目要求奇数在前，所以如果是奇数，左指针就不用反转，直接指针把L指针右移</span></span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[R] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 题目要求偶数在后，所以如果是偶数，右指针就不用反转，直接指针把R指针左移</span></span><br><span class="line">                R -=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 前面两个循环执行完毕后，说明L遇到的是偶数，R遇到的是奇数，</span></span><br><span class="line">            <span class="comment"># 此时交换一下位置即可</span></span><br><span class="line">            <span class="keyword">if</span> L &lt; R:</span><br><span class="line">                nums[L], nums[R] = nums[R], nums[L]</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><span id="2.3.1.6"></span>  </p><h3 id="2-3-1-6-救生艇"><a href="#2-3-1-6-救生艇" class="headerlink" title="2.3.1.6 救生艇"></a>2.3.1.6 救生艇</h3><p><a href="https://leetcode.cn/problems/boats-to-save-people/">LeetCode 881.救生艇</a> || <a href="#2.3.1">返回目录2.3.1</a></p><p>思路：该题说一艘船最多载两人，就容易联想到双指针。一个指针代表一个人，两个指针指向元素的和就是两个人的重量之和。<br>只不过，这里有一个和之前的题目不同的点，那就是我们需要对数组先进行排序。<br>为什么呢？因为如果两个人挤一条船，那么按照生活常识，我们肯定是希望尝试一个最轻的和一个最重的进行搭配，尽可能的利用船的承载能力。<br>所以如果用双指针代表两个人，就需要一个是来自于轻的一组，一个是来自于重的一组，所以按照重量先排序，左侧的就是轻的，右侧的就是重的，就可以利用对撞双指针了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numRescueBoats</span>(<span class="params">self, people: <span class="type">List</span>[<span class="built_in">int</span>], limit: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先按照重量升序排序</span></span><br><span class="line">        people.sort()</span><br><span class="line"></span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(people)-<span class="number">1</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            <span class="comment"># 如果重量超过限制，就先让重的人单独坐一条船走</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> people[L] + people[R] &gt; limit:</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果重量不超限制, 就两个人一起走</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> people[L] + people[R] &lt;= limit:</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果最后还剩下一个人，就让他坐一条船走</span></span><br><span class="line">            <span class="keyword">if</span> L == R:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.3.1.7"></span>  </p><h3 id="2-3-1-7-盛水最多的容器"><a href="#2-3-1-7-盛水最多的容器" class="headerlink" title="2.3.1.7 盛水最多的容器"></a>2.3.1.7 盛水最多的容器</h3><p><a href="https://leetcode.cn/problems/container-with-most-water/">LeetCode 11.盛最多水的容器</a> | | <a href="#2.3.1">返回目录2.3.1</a>  </p><p>思路：双指针代表的是 可以作为容器边界的所有位置的范围。在一开始，双指针指向数组的左右边界，表示 数组中所有的位置都可以作为容器的边界，每次将 <b>对应的数字较小的那个指针</b> 往 另一个指针 的方向移动一个位置，就表示我们认为 这个指针不可能再作为容器的边界了, 然后再比较当前装水容量和之前的装水容量, 看哪个更大即可。  </p><blockquote><p><b>因为水桶能装多少水，是最矮的那个边界决定的。<br>意思是，如果不移动最矮的边界，而移动另一侧较高的边界，它只能往中间移动，装水的容量是不可能变多的。<br>所以我们只好移动最矮的那个边界，看看移动它之后，是否能使得装水量变多。</b>  </p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">        water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">        <span class="comment"># 两个边界碰到一起之前, 能够装水</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> height[L] &lt;= height[R]:</span><br><span class="line">                water = <span class="built_in">max</span>(water, height[L]*(R-L))</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> height[L] &gt; height[R]:</span><br><span class="line">                water = <span class="built_in">max</span>(water, height[R]*(R-L))</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> water </span><br></pre></td></tr></table></figure><p><span id="2.3.1.8"></span>  </p><h3 id="2-3-1-8-有效三角形的个数"><a href="#2-3-1-8-有效三角形的个数" class="headerlink" title="2.3.1.8 有效三角形的个数"></a>2.3.1.8 有效三角形的个数</h3><p><a href="https://leetcode.cn/problems/valid-triangle-number/">LeetCode 611.有效三角形的个数</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p>思路：假设三条边分别为a,b,c;则满足三角形的条件为任意两边之和都大于第三边；<br>如果知道a,b,c的大小关系，比如 a&lt;=b&lt;=c, <b>那么两小边之和大于长边就一定能形成三角形</b>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triangleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N =<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> N &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先从大到小排序</span></span><br><span class="line">        nums.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-<span class="number">2</span>):</span><br><span class="line">            <span class="comment"># 当前 i 位置的数左为最长边 lng； 另外两个小边就在[i+1, N-1]区间找</span></span><br><span class="line">            L, R = i+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;R:</span><br><span class="line">                <span class="comment"># 目标是期望 小边之和 &gt; 长边，即 a+b &gt; c</span></span><br><span class="line">                <span class="comment"># lng, mid, sht = nums[i], nums[L], nums[R]</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果 mid + sht 不够大，说明sht应该增大，即R侧应该往左移一次，找一个更大的sht</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt;= nums[L] + nums[R]:</span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># lng &lt; mid + sht</span></span><br><span class="line">                    <span class="comment"># 如果此时能满足条件, R位置充当最短边sht，则R左侧的更大的数更能成为sht</span></span><br><span class="line">                    <span class="comment"># 即从 L+1 ~ R位置的所有数都可以成为最短边 sht(使得mid + sht更大)</span></span><br><span class="line">                    <span class="comment"># 与mid (L位置的值)一起构造一对小边; sht可取的个数为  =&gt; R - L</span></span><br><span class="line">                    res += R - L</span><br><span class="line">                    <span class="comment"># 计数完之后，再将 L 右移一位，即 mid 减小一点，</span></span><br><span class="line">                    <span class="comment"># 这样会使得 mid + sht变小</span></span><br><span class="line">                    <span class="comment"># 看变小后的和是否还能大于lng</span></span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 使用双指针的核心就在这里, L和R靠拢时, mid+sht 的值是在缩小的</span></span><br><span class="line">                    <span class="comment"># 但只要大于lng, L和R遍历的范围就能够满足条件</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>更简洁的 code 写法：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triangleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> N &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, N-<span class="number">2</span>):</span><br><span class="line">            large = nums[i]</span><br><span class="line">            L, R = i+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[L] + nums[R] &lt;= large:</span><br><span class="line">                    R -= <span class="number">1</span> <span class="comment"># 如果两边之和小于等于长边, 就说明最小边应该增大</span></span><br><span class="line">                <span class="keyword">if</span> L &lt; R:</span><br><span class="line">                    res += R- L </span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 由于L 增大后, 中边其实缩小了, 所以之前R右侧数字因比R位置还小, 所以更不满足条件</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.3.1.9"></span>  </p><h3 id="2-3-1-9-三数之和"><a href="#2-3-1-9-三数之和" class="headerlink" title="2.3.1.9 三数之和"></a>2.3.1.9 三数之和</h3><p><a href="https://leetcode.cn/problems/3sum/">LeetCode 15.三数之和</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p>思路：此题和三角形那道题一样，只不过条件变为  nums[i] + nums[j] + nums[k] == 0<br>难点在于不能出现重复的三元组。如果我们先排序的话，然后遍历数组时，每次都将遍历的值，作为三元组开头的值，<b>如果一旦发现这个开头值和上一次的开头值一样，那就说明重复，应该跳过。</b>  </p><ul><li><p>第一种代码写法 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-<span class="number">2</span>):</span><br><span class="line">            <span class="comment"># 如果三元组的开头值和上一次的开头值重复, 可能会出现重复三元组, 直接不考虑</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 每一次都在剩余可选范围内，维护左右两个指针</span></span><br><span class="line">            L, R = i+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;R:</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[L] + nums[R] &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 如果三数之和大于0, 就减小最大的数</span></span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[L] + nums[R] &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 如果三数之和小于0, 就增大中间数</span></span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 此时遇到满足条件的三个数</span></span><br><span class="line">                    <span class="keyword">if</span> res <span class="keyword">and</span> nums[i] == res[-<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">and</span> nums[L] == res[-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                        <span class="comment"># 若三个数中的前两个与之前的相同, 说明重复, 不添加进结果</span></span><br><span class="line">                        <span class="comment"># (因nums已经被排序过, 故重复的 L 一定会紧邻, 故可与rse[-1]进行比较)</span></span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res.append([nums[i], nums[L], nums[R]])</span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><p>第二种代码写法  </p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line"></span><br><span class="line">        nums.sort() <span class="comment"># 升序排列</span></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, N-<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]: </span><br><span class="line">                <span class="keyword">continue</span> <span class="comment"># 如果 三元组的第一个数字重复, 可以不用考虑</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>: <span class="keyword">break</span> <span class="comment"># 如果三元组的第一个数组都大于0, 由于已经升序排列, 所以数字之和必不为0</span></span><br><span class="line">            </span><br><span class="line">            L, R = i+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                <span class="keyword">if</span> L &gt; i+<span class="number">1</span> <span class="keyword">and</span> nums[L] == nums[L-<span class="number">1</span>]:</span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span> <span class="comment"># 如果在i不变的情况下，三元组的第二个数组重复，也可以不用考虑</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[L] + nums[R] &gt; -nums[i]: </span><br><span class="line">                    R -= <span class="number">1</span> <span class="comment"># 如果两数之和大于了目标值, 说明应该减小较大数</span></span><br><span class="line">                <span class="keyword">if</span> L &lt; R <span class="keyword">and</span>  nums[L] +  nums[R] == -nums[i]:</span><br><span class="line">                    res.append([nums[i], nums[L], nums[R]])</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 因为 L 右移之后, 数字变大, 所以原来 R右侧更大的数字更不会满足条件了, R可以先不变</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.3.1.10"></span>  </p><h3 id="2-3-1-10-最接近的三数之和"><a href="#2-3-1-10-最接近的三数之和" class="headerlink" title="2.3.1.10 最接近的三数之和"></a>2.3.1.10 最接近的三数之和</h3><p><a href="https://leetcode.cn/problems/3sum-closest/description/">LeetCode 16.最接近的三数之和</a> | | <a href="#2.3.1">返回目录2.3.1</a>  </p><p>思路：和上面的三数之和思路一样，<b>这里可以不考虑重复问题。因为题目假定每组输入只存在恰好一个解。</b>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 先将res初始化为一个极值</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-<span class="number">2</span>):</span><br><span class="line">            L, R = i+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;R :</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(nums[i]+nums[L]+nums[R] - target) &lt; <span class="built_in">abs</span>(res-target):</span><br><span class="line">                    res = nums[i]+nums[L]+nums[R]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[L]+nums[R] &lt; target:</span><br><span class="line">                    <span class="comment"># 三数和偏小, 试着增大, 以此靠近 target</span></span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i]+nums[L]+nums[R] &gt; target:</span><br><span class="line">                    <span class="comment"># 三数和偏大, 试着减小, 以此靠近 target</span></span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 如果出现相等的情况</span></span><br><span class="line">                    <span class="comment"># 那就是最接近target, 而且题目说唯一解, 可以直接返回了</span></span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.3.1.11"></span>  </p><h3 id="2-3-1-11-四数之和"><a href="#2-3-1-11-四数之和" class="headerlink" title="2.3.1.11 四数之和"></a>2.3.1.11 四数之和</h3><p><a href="https://leetcode.cn/problems/4sum/">LeetCode 18.四数之和</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p>思路：这就是升级版的三数之和问题，可以考虑多搞一层循环来直接套用三数之和的解答方式。   </p><ul><li>第一种代码写法<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line"></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 相比于三数之和问题，只是多加了一层循环嵌套而已</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N-<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, N-<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> j&gt;i+<span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j-<span class="number">1</span>]: <span class="keyword">continue</span></span><br><span class="line">                L, R = j+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                    <span class="keyword">if</span> L &gt;j+<span class="number">1</span> <span class="keyword">and</span> nums[L] == nums[L-<span class="number">1</span>]:</span><br><span class="line">                        L +=<span class="number">1</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[L] + nums[R] &gt; target - nums[i] -nums[j]:</span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> L &lt;R <span class="keyword">and</span> nums[i] + nums[j] + nums[L] + nums[R] == target:</span><br><span class="line">                        res.append([nums[i], nums[j], nums[L], nums[R]]) </span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ul><p><span id="2.3.1.12"></span>  </p><h3 id="2-3-1-12-有序数组的平方"><a href="#2-3-1-12-有序数组的平方" class="headerlink" title="2.3.1.12 有序数组的平方"></a>2.3.1.12 有序数组的平方</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">LeetCode 977.有序数组的平方</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p>思路：要是直接对数组nums内的数进行平方，再排序，这个可能不太符合题目想考察的点。这个题目对于数字的操作其实就是模拟了 $y=x^2$ 这个函数，函数开口向上，对称轴为 $x=0$ , 所以对于数组中的数据，谁离0更远，谁平方后就更大。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        暴力解法：</span></span><br><span class="line"><span class="string">        res = [num**2 for num in nums]</span></span><br><span class="line"><span class="string">        return sorted(res)</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        N  = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [<span class="number">0</span>] * N</span><br><span class="line">        L, R, idx  = <span class="number">0</span>, N - <span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt;= R:</span><br><span class="line">            <span class="keyword">while</span> L&lt;=R <span class="keyword">and</span> <span class="built_in">abs</span>(nums[L]) &gt; <span class="built_in">abs</span>(nums[R]):</span><br><span class="line">                <span class="comment"># 如果 L 位置的数更远，就将其平方结果装入 res数组的末尾</span></span><br><span class="line">                res[idx] = nums[L]**<span class="number">2</span></span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                idx -=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;=R <span class="keyword">and</span> <span class="built_in">abs</span>(nums[L]) &lt;= <span class="built_in">abs</span>(nums[R]):</span><br><span class="line">                <span class="comment"># 如果 R 位置的数更远，就将其平方结果装入 res数组的末尾</span></span><br><span class="line">                res[idx] = nums[R]**<span class="number">2</span></span><br><span class="line">                R -=<span class="number">1</span></span><br><span class="line">                idx -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.3.1.13"></span>  </p><h3 id="2-3-1-13-颜色分类"><a href="#2-3-1-13-颜色分类" class="headerlink" title="2.3.1.13 颜色分类"></a>2.3.1.13 颜色分类</h3><p><a href="https://leetcode.cn/problems/sort-colors/">LeetCode 75.颜色分类</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p>思路：该题的本质其实是荷兰国旗问题，或者说简化版本的。后面讲排序问题的时候，会专门讨论荷兰国旗问题。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;荷兰国旗问题&#x27;&#x27;&#x27;</span></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        L, R = -<span class="number">1</span>, N</span><br><span class="line">        i = L+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; R:</span><br><span class="line">            <span class="keyword">if</span> L &lt; R <span class="keyword">and</span> nums[i] &lt; <span class="number">1</span>:</span><br><span class="line">                nums[i], nums[L+<span class="number">1</span>] = nums[L+<span class="number">1</span>], nums[i]</span><br><span class="line">                L+=<span class="number">1</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> L &lt; R <span class="keyword">and</span> nums[i] == <span class="number">1</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[i], nums[R-<span class="number">1</span>] = nums[R-<span class="number">1</span>], nums[i]</span><br><span class="line">                R -=<span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="2.3.1.14"></span>  </p><h3 id="2-3-1-14-接雨水"><a href="#2-3-1-14-接雨水" class="headerlink" title="2.3.1.14 接雨水"></a>2.3.1.14 接雨水</h3><p><a href="https://leetcode.cn/problems/trapping-rain-water/">LeetCode 42.接雨水</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p>思路 1：暴力解法，计算每个位置上的最高左右边界，得到每个位置装”水柱”的大小，但是会超出时间限制。   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1.暴力解法</span></span><br><span class="line">        <span class="comment"># 计算每个位置上的&quot;水柱&quot;的大小</span></span><br><span class="line">        <span class="comment"># 注意，该方案超出时间限制，只是作为一个引子</span></span><br><span class="line">        </span><br><span class="line">        L_max, R_max = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        N = <span class="built_in">len</span>(height)</span><br><span class="line">        water = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 对每一个位置，找其左、右两侧最高的边界</span></span><br><span class="line">            <span class="comment"># max 方法的时间复杂度是O(N)</span></span><br><span class="line">            L_max = <span class="built_in">max</span>(height[<span class="number">0</span>:i])</span><br><span class="line">            R_max = <span class="built_in">max</span>(height[i+<span class="number">1</span>:N])</span><br><span class="line">            <span class="comment"># 只有左右两侧存在比当前还要高的边界，才能装水，不然水就流走了</span></span><br><span class="line">            <span class="keyword">if</span> L_max &gt; height[i] <span class="keyword">and</span> R_max &gt; height[i]:</span><br><span class="line">                <span class="comment"># 木桶能装水量是由短板决定的</span></span><br><span class="line">                H = <span class="built_in">min</span>(L_max, R_max)</span><br><span class="line">                water.append(H-height[i])</span><br><span class="line">        <span class="comment"># 整个函数的时间复杂度是O(N^2), 会有测试用例时间超限</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(water)</span><br></pre></td></tr></table></figure><p>思路 2：在思路1的基础上进行改进。<br>思路1的想法是没问题的，能够跑通大部分用例，但是对于很长的height数组会超出时间限制。<br>如果能够将：【对每一个位置寻找其左右最高边界】这个操作的时间复杂度降下来，<br>那么就能够让整个函数的时间复杂度降低，所以很容易想到 “以空间换时间”。  </p><p>如果从左往右遍历，要找左侧最高边界，就是在被遍历过的数中找，若能够将左侧遍历过的数中最高的边界，记录下来，那么每一次都只需将原来的左侧最高边界，与新遍历到的数进行对比，即：  </p><blockquote><p>对于 i 位置： L_max = max(L_max, height[i-1]) </p></blockquote><p>对于右侧的最高边界，就也同理，从右往左遍历，即可得到：  </p><blockquote><p>对于 j 位置， R_max = max(R_max, height[j+1])  </p></blockquote><p>这样，就能先遍历一道数组，将这些值记录在辅助数组中，时间复杂度O(N);<br>再遍历一道，计算装水量，还是O(N)的时间复杂度；所以总体的时间复杂度就是O(N)+O(N), 还是 O(N)<br>对于空间复杂度，额外使用了两个数组 L_max，R_max 来存放各个位置的左右边界，勉强也算是 O(2N) -&gt; O(N)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;思路2 “以空间换时间” &#x27;&#x27;&#x27;</span></span><br><span class="line">        N = <span class="built_in">len</span>(height)</span><br><span class="line">        <span class="comment"># 最左和最右的柱子只能当边界，无法装水</span></span><br><span class="line">        <span class="comment"># 柱子一定要至少有3个才能装水</span></span><br><span class="line">        water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> N &lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> water</span><br><span class="line">        L_max, R_max = height[<span class="number">0</span>], height[N-<span class="number">1</span>]        </span><br><span class="line">        L_boder, R_boder = [L_max]*N, [R_max]*N</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> L <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 将各个位置对应的左右最高边界分别存储到辅助数组中</span></span><br><span class="line">            L_boder[L] = <span class="built_in">max</span>(L_boder[L-<span class="number">1</span>], height[L])</span><br><span class="line">            R = N-<span class="number">1</span>-L</span><br><span class="line">            R_boder[R] = <span class="built_in">max</span>(height[R], R_boder[R+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 水柱高度由较矮边界决定：H = min(L_boder[i], R_boder[i])</span></span><br><span class="line">            <span class="comment"># 同时边界值还要比当前柱子本身要高才行：max(H-height[i], 0)</span></span><br><span class="line">            water += <span class="built_in">max</span>( <span class="built_in">min</span>(L_boder[i], R_boder[i]) - height[i], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> water</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>思路 3：思路 2 的改进，能够跑通全部测试用例，但是用到了两个辅助数组，增加了空间复杂度。那么是否还有优化空间呢？  </p><p>若在寻找左/右最高边界之时，直接计算装水量，岂不是可以不用辅助数组来存储数据了？<br>但是对于遍历到的数字，我们只能完全肯定其一边的最高边界。  </p><blockquote><p>比如【 <b>从左往右遍历</b>时,考察的是 L 位置】, 可以肯定 L_max 一定是 L 左侧最高边界：<br>此时 R_max 是 R 右侧的最高边界，并不一定是 L 右侧的最高边界<br>但是 <b> R_max 它是不是 L位置 的右侧最高边界重要吗？</b>来讨论一下    </p><ul><li><p><b>情况1</b>. if <font color="Red">R_max &gt; L_max</font>, then H = L_max, 即 H 取值和 R_max 无关，原因如下：<br>如果 L~R 之间，还有更高的边界可以作为L的右边界，那 L_max 依旧是更矮的，不影响 H 取值是 L_max<br>如果 L~R 之间，不存在更高的边界，那 R_max 就是 L 的最高右边界,哪怕 L~R区间都是更矮的也不影响，反正有 R_max 作为右边界兜底，故 H 取值还是更矮的 L_max</p></li><li><p><b>情况2</b>.if <font color="green">L_max &gt; R_max</font>, 那么确实就不好说了：<br>如果 L~R 之间 存在更高的边界，那么就应该判断其与 L_max 的大小关系，<br>但是我们暂时无法找到这个值，无法确定更适合 L 位置的右边界<br>如果 L~R 之间，不存在更高的边界,那 R_max 就是 L 的最高右边界, H=min(L_max, R_max)=R_max<br>主要问题在于，我们暂时无法获取 L~R之间的数字的信息，因为尚未遍历到    </p></li></ul><p>但是反其道而行之！！！对于当前条件：<font color="green">L_max &gt; R_max</font>，无法判断 L 位置的 H 取值。但是却可以判断 R 位置的 H 取值！这正是我们讨论【从左往右遍历时,考察的是 L 位置】 时的情况1<br>如果我们现在 【从 <b>右往左遍历</b> 时,考察的是 R 位置】，那么</p><ul><li><font color="green">L_max &gt; R_max</font> 这个情况<br>就是 R 位置的<b>情况1</b>：此时 R 位置的 H = R_max</li><li>对于 R 位置的<b>情况2</b>：条件是 <font color="Red">R_max &gt; L_max</font>， 同理，无法确定 L~R 之间是否有更适合作为 R 位置左边界的值<br>但是，它又转换成了 对于 L 位置的情况1.   </li></ul></blockquote><p>对于 R_max == L_max 的情况:<br>如果考察的是 L 位置，H 仍然能取 L_max<br>如果考察的是 R 位置，H 仍然能取 R_max。<br>仍然按照两个位置情况1的思路去理解<br>在写代码时，只需要将这种情况固定划分到考察 L 或者 R 的一种之中去就行<br>这样整个思路就能串通起来了,<br>由于只需要遍历一次数组，时间复杂度 O(N),<br>只有有限个辅助变量，空间复杂度O(1)。    </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(height)</span><br><span class="line">        <span class="comment"># 最左和最右的柱子只能当边界，无法装水</span></span><br><span class="line">        <span class="comment"># 柱子一定要至少有3个才能装水</span></span><br><span class="line">        water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> N &lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> water</span><br><span class="line"></span><br><span class="line">        L_max, R_max = height[<span class="number">0</span>], height[N-<span class="number">1</span>]</span><br><span class="line">        L, R = <span class="number">1</span>, N-<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> L &lt;= R :</span><br><span class="line">            <span class="keyword">if</span> L_max &lt;= R_max:</span><br><span class="line">                <span class="comment"># 这是 从左往右遍历的 L 位置的情况1:H = L_max</span></span><br><span class="line">                L_max = <span class="built_in">max</span>(L_max, height[L])</span><br><span class="line">                water += L_max - height[L]</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 这是 从右往左遍历的 r 位置的情况1: H = R_max</span></span><br><span class="line">                R_max = <span class="built_in">max</span>(R_max, height[R])</span><br><span class="line">                water += R_max - height[R]</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> water </span><br></pre></td></tr></table></figure><p><span id="2.3.1.15"></span>  </p><h3 id="2-3-1-15-数组中的最长山脉"><a href="#2-3-1-15-数组中的最长山脉" class="headerlink" title="2.3.1.15 数组中的最长山脉"></a>2.3.1.15 数组中的最长山脉</h3><p><a href="https://leetcode.cn/problems/longest-mountain-in-array/">LeetCode 845.数组中的最长山脉</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p>思路：这个其实不是对撞指针了，是对每个位置展开一个左右指针，来对每个位置求山脉宽度。<br>其实可以理解为对撞指针的<b>逆过程</b>，从中间开始往两边扩散两个指针。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestMountain</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(arr)</span><br><span class="line">        width = <span class="number">0</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; N-<span class="number">1</span>:</span><br><span class="line">            L, R = i-<span class="number">1</span>, i+<span class="number">1</span></span><br><span class="line">            <span class="comment"># 先判断是否满足左右都下降的趋势</span></span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt;arr[L] <span class="keyword">and</span> arr[i] &gt;arr[R]:</span><br><span class="line">                <span class="keyword">while</span> L&gt; <span class="number">0</span> <span class="keyword">and</span> arr[L-<span class="number">1</span>] &lt; arr[L]:</span><br><span class="line">                    <span class="comment"># L 一直尽可能地往左延伸</span></span><br><span class="line">                    L -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> R&lt; N-<span class="number">1</span> <span class="keyword">and</span> arr[R+<span class="number">1</span>] &lt; arr[R]:</span><br><span class="line">                    <span class="comment"># R 一直尽可能的往右延伸</span></span><br><span class="line">                    R += <span class="number">1</span></span><br><span class="line">                width = <span class="built_in">max</span>(width, R-L+<span class="number">1</span>)</span><br><span class="line">            i = R <span class="comment"># 如果之前存在山，那么就是(L,i,R)这一段, 所以 i 到 R 之间是下降趋势</span></span><br><span class="line">        <span class="keyword">return</span> width </span><br></pre></td></tr></table></figure><p><span id="2.3.1.16"></span>  </p><h3 id="2-3-1-16-最长湍流子数组"><a href="#2-3-1-16-最长湍流子数组" class="headerlink" title="2.3.1.16 最长湍流子数组"></a>2.3.1.16 最长湍流子数组</h3><p><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">LeetCode 978.最长湍流子数组</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p>思路：其实这个题最好的解法不是使用这种扩散指针，但是确实可以参考上面 <b><a href="#2.3.1.15">数组中的最长山脉</a></b> 的思路来做。<br>这里只是提供一种解法，拓展思路，但确实code比较复杂，看起来也不太容易懂，可以看着玩玩。<br><b>更好的解法还是建议看下面快慢指针部分 <a href="#2.3.2.7">2.3.2.7</a>题解</b>，该题的code。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxTurbulenceSize</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        首先要搞清楚湍流是什么情况：</span></span><br><span class="line"><span class="string">        ···&lt; arr[M-2] &gt; arr[M-1] &lt; arr[M] &gt; arr[M+1] &lt; arr[M+2] &gt; ···</span></span><br><span class="line"><span class="string">                                    或者</span></span><br><span class="line"><span class="string">        ···&gt; arr[M-2] &lt; arr[M-1] &gt; arr[M] &lt; arr[M+1] &gt; arr[M+2] &lt; ···</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 按照 数组中的最长山脉 的题解思路来做， 特殊情况和边界情况的判断稍显复杂</span></span><br><span class="line">        N = <span class="built_in">len</span>(arr)</span><br><span class="line">        width = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:   </span><br><span class="line">            <span class="keyword">return</span> width</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; N:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> i == N-<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 端点值先特殊讨论</span></span><br><span class="line">                <span class="keyword">if</span> (arr[<span class="number">0</span>] != arr[<span class="number">1</span>]) <span class="keyword">or</span> (arr[N-<span class="number">2</span>] != arr[N-<span class="number">1</span>]): </span><br><span class="line">                    <span class="comment"># 只要端点值的相邻值和它不相等, 就一定是一个宽度为2的湍流</span></span><br><span class="line">                    width = <span class="built_in">max</span>(<span class="number">2</span>, width)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第 1 种 湍流模式, M 点是邻域极大值</span></span><br><span class="line">            <span class="keyword">elif</span> arr[i-<span class="number">1</span>] &lt; arr[i] <span class="keyword">and</span> arr[i] &gt; arr[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 这里的两个 flag是用来控制 &lt; 或 &gt; 符号的, 利用 -1 的不断自乘来实现转向</span></span><br><span class="line">                flag_L, flag_R, left, right = -<span class="number">1</span>, -<span class="number">1</span>, i-<span class="number">1</span>, i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> (arr[left] - arr[left-<span class="number">1</span>])* flag_L &gt; <span class="number">0</span>:</span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                    flag_L *= -<span class="number">1</span>  </span><br><span class="line">                <span class="keyword">while</span> right &lt; N-<span class="number">1</span> <span class="keyword">and</span> (arr[right] - arr[right+<span class="number">1</span>])* flag_R &gt; <span class="number">0</span>:</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">                    flag_R *= -<span class="number">1</span></span><br><span class="line">                width = <span class="built_in">max</span>(width, right-left+<span class="number">1</span>)</span><br><span class="line">                i = right</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 第 2 种 湍流模式, M 点是邻域极小值</span></span><br><span class="line">            <span class="keyword">elif</span> arr[i-<span class="number">1</span>] &gt; arr[i] <span class="keyword">and</span> arr[i] &lt; arr[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 这里的两个 flag是用来控制 &lt; 或 &gt; 符号的, 利用 -1 的不断自乘来实现转向</span></span><br><span class="line">                flag_L, flag_R, left, right = -<span class="number">1</span>, -<span class="number">1</span>, i-<span class="number">1</span>, i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> (arr[left] - arr[left-<span class="number">1</span>])* flag_L &lt; <span class="number">0</span>:</span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                    flag_L *= -<span class="number">1</span>  </span><br><span class="line">                <span class="keyword">while</span> right &lt; N-<span class="number">1</span> <span class="keyword">and</span> (arr[right] - arr[right+<span class="number">1</span>])* flag_R &lt; <span class="number">0</span>:</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">                    flag_R *= -<span class="number">1</span></span><br><span class="line">                width = <span class="built_in">max</span>(width, right-left+<span class="number">1</span>)</span><br><span class="line">                i = right </span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> width</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        这种代码写法的核心思路就是借鉴的 最长山脉那道题，难点在于:</span></span><br><span class="line"><span class="string">        1. 小于/大于符号在不断的交替, 这里是利用 -1 的自乘实现</span></span><br><span class="line"><span class="string">        2. 数组左右端点值的特殊情况容易忽略</span></span><br><span class="line"><span class="string">        总之这种代码写法稍微有点困难，也是因为刚刚才做完 最长山脉的题目，</span></span><br><span class="line"><span class="string">        陷入了 定式思维 的陷阱, 才写出了这种方法。</span></span><br><span class="line"><span class="string">        等下面用快慢指针的思路, 代码就更容易理解</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><span id="2.3.2"></span></p><h2 id="2-3-2-快慢指针"><a href="#2-3-2-快慢指针" class="headerlink" title="2.3.2 快慢指针"></a>2.3.2 快慢指针</h2><p>所谓快慢指针，就是指的两个指针的移动频率不同，其中快指针因为某个条件，总是跑在慢指针更右侧。<br>通常终止条件就是快指针遍历完了数组。  </p><p><span id="2.3.2"></span>  </p><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">LeetCode 26.删除有序数组中的重复项</a></td><td><a href="#2.3.2.1">题解2.3.2.1</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/string-compression/">LeetCode 443.压缩字符串</a></td><td><a href="#2.3.2.2">题解2.3.2.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">LeetCode 80.删除有序数组中的重复项II</a></td><td><a href="#2.3.2.3">题解2.3.2.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/remove-element/">LeetCode 27.移除元素</a></td><td><a href="#2.3.2.4">题解2.3.2.4</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/move-zeroes//">LeetCode 283.移动零</a></td><td><a href="#2.3.2.5">题解2.3.2.5</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/increasing-triplet-subsequence/">LeetCode 334.递增的三元子序列</a></td><td><a href="#2.3.2.6">题解2.3.2.6</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">LeetCode 978.最长湍流子数组</a></td><td><a href="#2.3.2.7">题解2.3.2.7</a></td></tr><tr><td>⑧</td><td><a href="https://leetcode.cn/problems/max-consecutive-ones/">LeetCode 485.最大连续 1 的个数</a></td><td><a href="#2.3.2.8">题解2.3.2.8</a></td></tr></tbody></table></div><p><span id="2.3.2.1"></span>  </p><h3 id="2-3-2-1-删除有序数组中的重复项"><a href="#2-3-2-1-删除有序数组中的重复项" class="headerlink" title="2.3.2.1 删除有序数组中的重复项"></a>2.3.2.1 删除有序数组中的重复项</h3><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">LeetCode 26.删除有序数组中的重复项</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><p>思路：用快慢指针，快指针先去右侧看是否重复，慢指针用来修改原数组（维护去重部分的边界）  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> N &lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> N</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;方案一. 遍历到的重复的数, 先跳过，将重复区域的最后一个数, 加入唯一元素区域&#x27;&#x27;&#x27;</span></span><br><span class="line">        s, f = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="comment"># 慢指针代表筛选出的【唯一元素区域】的右边界, 一开始这个区域是空的, 所以s=0 </span></span><br><span class="line">        <span class="comment"># 快指针代表后续待比较区域的元素, 因为至少要有2个元素才能比较是否重复, 所以f从第2个元素开始,f=1</span></span><br><span class="line">        <span class="keyword">while</span> f &lt;= N:</span><br><span class="line">            <span class="keyword">if</span> f== N <span class="keyword">or</span> nums[f] != nums[f-<span class="number">1</span>] :</span><br><span class="line">                <span class="comment"># f位置的数与 f-1不相同, 说明：</span></span><br><span class="line">                <span class="comment"># f-1位置是某段重复区域的最后一个数了, f是新区域的第一个数.</span></span><br><span class="line">                <span class="comment"># 把f-1加进唯一元素区域</span></span><br><span class="line">                nums[s] = nums[f-<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 这个if条件里面之所以有 f==N 这个情况, 是因为f=N时, nums取不到值, </span></span><br><span class="line">                <span class="comment"># 且nums的最后一个数N-1位置一定可以加入唯一区域, 因为这个数一定是某段区域的最后一个数(不管这段区域是否重复)</span></span><br><span class="line">                <span class="comment"># 同时不要忘记 右边界s向右扩张1位</span></span><br><span class="line">                s += <span class="number">1</span></span><br><span class="line">            f += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s <span class="comment"># s是右边界, 即唯一元素区域实际是 0 ~ s-1, 共 s 个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 方案二： </span></span><br><span class="line"><span class="string">        # 上面的方案都是将重复区域的最后一个元素更新到s位置</span></span><br><span class="line"><span class="string">        # 这里是将重复区域的第一个元素更新到s位置</span></span><br><span class="line"><span class="string">        s, f = -1, 0</span></span><br><span class="line"><span class="string">        while f &lt; N:</span></span><br><span class="line"><span class="string">            # 这里的更新过程非常像在维护一个虚拟的栈</span></span><br><span class="line"><span class="string">            # 当栈为空 s==-1，或者f遇到的数不等于栈顶元素 nums[f] != nums[s]</span></span><br><span class="line"><span class="string">            # 就将栈的区域扩大一个：s+=1， 然后将f对应的元素入栈:nums[s] = nums[f]</span></span><br><span class="line"><span class="string">            if s==-1 or nums[f] != nums[s]:</span></span><br><span class="line"><span class="string">                s += 1</span></span><br><span class="line"><span class="string">                nums[s] = nums[f]</span></span><br><span class="line"><span class="string">            f += 1</span></span><br><span class="line"><span class="string">        # 虚拟栈的范围是 0 ~ s, 共 s+1 个元素       </span></span><br><span class="line"><span class="string">        return s+1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 用虚拟栈的思路会十分容易理解, 代码也很好写, 所以更推荐方案二</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>     </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.3.2.2"></span>  </p><h3 id="2-3-2-2-压缩字符串"><a href="#2-3-2-2-压缩字符串" class="headerlink" title="2.3.2.2 压缩字符串"></a>2.3.2.2 压缩字符串</h3><p><a href="https://leetcode.cn/problems/string-compression/">LeetCode 443.压缩字符串</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><p>思路：题目中说到只能使用常量额外空间，即空间复杂度要求O(1)，说明没办法用辅助数组。<br>然后这个题其实是上一题 <b><a href="#2.3.2.1">删除有序数组中的重复项</a></b> 的升级版，稍微麻烦了一点而已，思路完全是一样的。<br>同样是要判断连续的重复字符，只不过现在还要追加其数目而已。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compress</span>(<span class="params">self, chars: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(chars)</span><br><span class="line">        <span class="keyword">if</span> N &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> N</span><br><span class="line"></span><br><span class="line">        s, f = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        old = <span class="number">0</span> <span class="comment"># 需要设置一个变量来记录重复区域的起始index</span></span><br><span class="line">        <span class="keyword">while</span> f &lt;= N:</span><br><span class="line">            <span class="keyword">if</span> f==N <span class="keyword">or</span> chars[f] != chars[s]:</span><br><span class="line">                <span class="comment"># 此时f已经走出了重复区域来到了新的区域(f==N时代表list已经遍历完)</span></span><br><span class="line">                w = f-old <span class="comment"># 则上一段重复区域的长度就是 f 减去上一段重复区域的起始index: old</span></span><br><span class="line">                <span class="keyword">if</span> w&gt;=<span class="number">2</span>:  <span class="comment"># 如果该区域长度至少为2, 则说明要添加数字</span></span><br><span class="line">                    <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">str</span>(w)):</span><br><span class="line">                        s+=<span class="number">1</span></span><br><span class="line">                        chars[s] = <span class="built_in">str</span>(ch)</span><br><span class="line">                <span class="keyword">if</span> f &lt; N:</span><br><span class="line">                    <span class="comment"># 把新区域的字符添加上</span></span><br><span class="line">                    s+=<span class="number">1</span>      </span><br><span class="line">                    chars[s] = chars[f]</span><br><span class="line">                    old = f <span class="comment"># 现在已经处理完上一段重复区域, 则old更新为新重复区域的起始index</span></span><br><span class="line">            f += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="2.3.2.3"></span>  </p><h3 id="2-3-2-3-删除有序数组中的重复项II"><a href="#2-3-2-3-删除有序数组中的重复项II" class="headerlink" title="2.3.2.3 删除有序数组中的重复项II"></a>2.3.2.3 删除有序数组中的重复项II</h3><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">LeetCode 80.删除有序数组中的重复项II</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><p>思路：思路和前面两道题一脉相承，代码稍加改动即可  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        s, f = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        begin = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> f &lt;= N:</span><br><span class="line">            <span class="comment"># 这里的code写法和前面两道题不同，算是拓展一下思路</span></span><br><span class="line">            <span class="comment"># 这里是f和它前一位比较, 来判断重复区域是否结束</span></span><br><span class="line">            <span class="keyword">if</span> f == N <span class="keyword">or</span> nums[f] != nums[f-<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># f-1 就是重复区域的末尾index</span></span><br><span class="line">                nums[s] = nums[f-<span class="number">1</span>]</span><br><span class="line">                s += <span class="number">1</span></span><br><span class="line">                cnt = f - begin</span><br><span class="line">                begin = f</span><br><span class="line">                <span class="keyword">if</span> cnt &gt;= <span class="number">2</span>:</span><br><span class="line">                    nums[s] = nums[f-<span class="number">1</span>]</span><br><span class="line">                    s += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            f += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p><span id="2.3.2.4"></span>  </p><h3 id="2-3-2-4-移除元素"><a href="#2-3-2-4-移除元素" class="headerlink" title="2.3.2.4 移除元素"></a>2.3.2.4 移除元素</h3><p><a href="https://leetcode.cn/problems/remove-element/">LeetCode 27.移除元素</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><p>思路：和上面的题目一脉相承。用虚拟栈的思路会很容易理解。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 慢指针充当虚拟栈栈顶索引, 快指针用来遍历数组</span></span><br><span class="line">        s, f = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> f &lt; N:</span><br><span class="line">            <span class="keyword">if</span> nums[f] != val:</span><br><span class="line">                <span class="comment"># 将虚拟栈扩充一位, 并且将数放入栈顶</span></span><br><span class="line">                s += <span class="number">1</span></span><br><span class="line">                nums[s] = nums[f]</span><br><span class="line">            f += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 虚拟栈数据范围 0~s 共s+1个数字</span></span><br><span class="line">        <span class="keyword">return</span> s+<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.3.2.5"></span>  </p><h3 id="2-3-2-5-移动零"><a href="#2-3-2-5-移动零" class="headerlink" title="2.3.2.5 移动零"></a>2.3.2.5 移动零</h3><p><a href="https://leetcode.cn/problems/move-zeroes//">LeetCode 283.移动零</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><p>思路: partition 问题，注意，下面的代码是 非稳定的<br>因为不同的0的相对次序其实会变化，只不过题目只要求非0数据相对次序不变，所以还是能保证的。<br>后面的章节讲排序问题的快速排序讨论, 会详细讲 partition 问题;<br>这里还是先用虚拟栈的思考方式来理解更方便一点。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 慢指针充当虚拟栈栈顶索引，快指针用来遍历数组</span></span><br><span class="line">        ps, pf = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pf &lt;N:</span><br><span class="line">            <span class="keyword">if</span> nums[pf] != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 虚拟栈扩充一格</span></span><br><span class="line">                ps += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 栈顶位置的原始数字, 和 pf 位置的数字进行交换, </span></span><br><span class="line">                <span class="comment"># 就把pf位置的数放到栈里来了, 同时将原始数字放到栈外面去了</span></span><br><span class="line">                nums[pf], nums[ps] = nums[ps], nums[pf]</span><br><span class="line">            pf += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="2.3.2.6"></span>  </p><h3 id="2-3-2-6-递增的三元子序列"><a href="#2-3-2-6-递增的三元子序列" class="headerlink" title="2.3.2.6 递增的三元子序列"></a>2.3.2.6 递增的三元子序列</h3><p><a href="https://leetcode.cn/problems/increasing-triplet-subsequence/">LeetCode 334.递增的三元子序列</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><p>思路：这个题虽然没有显式的使用快慢指针，但是思想是借鉴了快慢指针的。<br>假设我们要找3个数a,b,c满足 a &lt; b &lt; c 的条件，<b>那么a应该尽可能的小，b也应该在大于a的情况下尽可能的小，这样才容易去找到满足条件的c</b>。<br>那么，比方说我们<b>如何找到一个数组中，最小的数呢（不调用min）？？</b>那就是设定一个极大的初始值，遍历一道数组，在遍历过程中发现更小的数，就更新，最终就能找到这个最小的数。<br>借鉴这个思想，我们的代码如下  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increasingTriplet</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        a = b = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &lt;= a:</span><br><span class="line">                <span class="comment"># 这样能够保证在遍历过的数字中，a一定是最小的那个数</span></span><br><span class="line">                a = num </span><br><span class="line">            <span class="keyword">elif</span> num &lt;=b:</span><br><span class="line">                <span class="comment"># elif隐含的条件是不满足上面的条件，即不满足小于等于a</span></span><br><span class="line">                <span class="comment"># 所以b一定能取到在遍历过的数目当中，位于a后面的，比a大的数当中，最小的一个数</span></span><br><span class="line">                b = num </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 在继续变量的过程中，只要遇到一个数不满足上面的条件，即比a和b都大</span></span><br><span class="line">                <span class="comment"># 这个数就能够充当 c 的角色</span></span><br><span class="line">                <span class="comment"># c = num </span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><span id="2.3.2.7"></span>  </p><h3 id="2-3-2-7-最长湍流子数组"><a href="#2-3-2-7-最长湍流子数组" class="headerlink" title="2.3.2.7 最长湍流子数组"></a>2.3.2.7 最长湍流子数组</h3><p><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">LeetCode 978.最长湍流子数组</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><p>思路：该题在对撞指针中讲过一次，但是更好的解法是使用快慢指针。<br>具体的思路可以看code中的注释，采用快慢指针要快许多  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxTurbulenceSize</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        注意到题目中给的例子，1个元素也算湍流，2个不相等的数也能组成宽度为2的湍流</span></span><br><span class="line"><span class="string">        其实不用像 山脉宽度 那样每次从一个中心点，向着左右扩散</span></span><br><span class="line"><span class="string">        湍流可以选择一个起始点，从左往右的方向一直扩散，比如：</span></span><br><span class="line"><span class="string">        情况1：arr[0] &gt; arr[1] &lt; arr[2] &gt; ··· </span></span><br><span class="line"><span class="string">        或 情况2：arr[0] &lt; arr[1] &gt; arr[2] &lt; ···</span></span><br><span class="line"><span class="string">        考虑用快慢指针，一个维护湍流的起点，另一个维护湍流的终点</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        N, width = <span class="built_in">len</span>(arr), <span class="number">1</span></span><br><span class="line">        L, R = <span class="number">0</span> ,<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> R &lt; N: <span class="comment"># 当湍流的右边界没有超过数组</span></span><br><span class="line">            <span class="comment"># 情况 1</span></span><br><span class="line">            <span class="keyword">if</span> arr[L] &gt; arr[R]:</span><br><span class="line">                flag = -<span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果右边一直能满足湍流的条件，就一直往右扩散</span></span><br><span class="line">                <span class="comment"># 这里是通过乘以 (-1)^k 来变相控制 大于/小于符号, 注意这里用的是 &gt;</span></span><br><span class="line">                <span class="keyword">while</span> R &lt; N-<span class="number">1</span> <span class="keyword">and</span> (arr[R]- arr[R+<span class="number">1</span>]) * flag &gt; <span class="number">0</span>:</span><br><span class="line">                    R += <span class="number">1</span></span><br><span class="line">                    flag *= -<span class="number">1</span></span><br><span class="line">                <span class="comment"># 循环结束后, R 指向该组湍流的最后一个满足条件的元素</span></span><br><span class="line">                width = <span class="built_in">max</span>(width, R-L+<span class="number">1</span>)                </span><br><span class="line">            <span class="comment"># 情况 2</span></span><br><span class="line">            <span class="keyword">elif</span> arr[L] &lt; arr[R]:</span><br><span class="line">                flag = -<span class="number">1</span> </span><br><span class="line">                <span class="comment"># 这里是通过乘以 (-1)^k 来变相控制 大于/小于符号, 注意这里用的是 &lt; </span></span><br><span class="line">                <span class="keyword">while</span> R &lt; N-<span class="number">1</span> <span class="keyword">and</span> (arr[R]- arr[R+<span class="number">1</span>]) * flag &lt; <span class="number">0</span>:</span><br><span class="line">                    R += <span class="number">1</span></span><br><span class="line">                    flag *= -<span class="number">1</span></span><br><span class="line">                width = <span class="built_in">max</span>(width, R-L+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 连续两个数字相等，直接pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="comment"># 更新起点和终点</span></span><br><span class="line">            L = R </span><br><span class="line">            R +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> width</span><br></pre></td></tr></table></figure><p><span id="2.3.2.8"></span>  </p><h3 id="2-3-2-8-最大连续-1-的个数"><a href="#2-3-2-8-最大连续-1-的个数" class="headerlink" title="2.3.2.8 最大连续 1 的个数"></a>2.3.2.8 最大连续 1 的个数</h3><p><a href="https://leetcode.cn/problems/max-consecutive-ones/">LeetCode 485.最大连续 1 的个数</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><p>思路：该题在 <a href="https://teeyohuang.github.io/Data-Structure/DS_22_array_exercises.html">2-2 数组相关题目</a> 的 <a href="https://teeyohuang.github.io/Data-Structure/DS_22_array_exercises.html#2.2.1.3">2.2.1.3</a> 已经见过，现在再用快慢指针的思路，更容易理解。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxConsecutiveOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        L, R =-<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 慢指针用来标记连续1区域的左边界, 快指针用来判断当前位置是否是1</span></span><br><span class="line">        gap = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> R <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[R] == <span class="number">1</span>:</span><br><span class="line">                gap = <span class="built_in">max</span>(gap, R-L)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                L = R </span><br><span class="line">        <span class="keyword">return</span> gap </span><br></pre></td></tr></table></figure><p>_</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2-2 数组相关题目</title>
      <link href="/Data-Structure/DS_22_array_exercises.html"/>
      <url>/Data-Structure/DS_22_array_exercises.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1"> <h1 id="2-2-数组相关题目"><a href="#2-2-数组相关题目" class="headerlink" title="2-2 数组相关题目"></a>2-2 数组相关题目</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p><b>版权声明：以下题目均来自 <a href="https://leetcode.cn">LeetCode</a>， 仅仅提供跳转到力扣官网的链接，不在本页面出现题目内容，本文章内容禁止商业用途。</b></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>2.2.1</td><td><a href="#2.2.1">一维数组的相关题目</a></td></tr><tr><td>2.2.2</td><td><a href="#2.2.2">二维数组相关题目</a></td></tr></tbody></table></div><p><span id="2.2.1"></span>  </p><h2 id="2-2-1-一维数组的相关题目"><a href="#2-2-1-一维数组的相关题目" class="headerlink" title="2.2.1 一维数组的相关题目"></a>2.2.1 一维数组的相关题目</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/rotate-array/">LeetCode 189.轮转数组</a></td><td><a href="#2.2.1.1">2.2.1.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/find-pivot-index/">LeetCode 724.寻找数组的中心下标</a></td><td><a href="#2.2.1.2">2.2.1.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/max-consecutive-ones/">LeetCode 485.最大连续 1 的个数</a></td><td><a href="#2.2.1.3">2.2.1.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/product-of-array-except-self/">LeetCode 238.除自身以外数组的乘积</a></td><td><a href="#2.2.1.4">2.2.1.4题解</a></td></tr></tbody></table></div><p><span id="2.2.1.1"></span>  </p><h3 id="2-2-1-1-轮转数组"><a href="#2-2-1-1-轮转数组" class="headerlink" title="2.2.1.1 轮转数组"></a>2.2.1.1 轮转数组</h3><p><a href="https://leetcode.cn/problems/rotate-array/">LeetCode 189.轮转数组</a> | |  <a href="#2.2.1">返回2.2.1目录</a>  </p><font color="#3399FF">方案一： 复制一个数组为参照，在原数组上进行修改。 </font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;时间复杂度O(n), 空间复杂度O(n)&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        tmp, n = nums.copy(), <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            nums[(i+k)%n] = tmp[i]</span><br></pre></td></tr></table></figure><font color="#3399FF">方案二： 不另外创建数组。 </font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 题目给的例子中，有k&gt;N的情况，所以先求模运算</span></span><br><span class="line">        k = k % N</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果假设数组首尾相接，是一个循环数组</span></span><br><span class="line">        <span class="comment"># 那么向右轮转k个位置，就相当于后面k个数被挤压到前面去了</span></span><br><span class="line">        <span class="comment"># 前面的 N-k 个数， 被挤压到后面全了</span></span><br><span class="line">        <span class="comment"># 所以就相当于 前 N-k 个数，和后 k个数，整体区域做一下交换</span></span><br><span class="line">        <span class="comment"># 那么如果我们直接从 第 N-k个数字后面的逗号，将数组旋转180度，他们的区域就交换了</span></span><br><span class="line">        nums[:] = nums[::-<span class="number">1</span>] <span class="comment"># 反转数组</span></span><br><span class="line">        <span class="comment"># 注意！如果写成 nums = nums[::-1],原数组num的值是不会被改变的，这种写法相当于创建了一个新的临时数组。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 但是反转数组后，各区域内的顺序也被反转了一遍，我们再将各区域的顺序调回来</span></span><br><span class="line">        <span class="comment"># 将转过来的前k个数字恢复原来的顺序（注意前k个数字序号是 0~k-1）</span></span><br><span class="line">        nums[:k] = nums[k-<span class="number">1</span>::-<span class="number">1</span>] </span><br><span class="line">        <span class="comment"># 将转过来的后的N-K个数字恢复原顺序（注意后N-K个数字序号是 k~N-1）</span></span><br><span class="line">        nums[k:] = nums[N-<span class="number">1</span>:k-<span class="number">1</span>:-<span class="number">1</span>] </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        但是问题是，python在进行切片操作的时候，</span></span><br><span class="line"><span class="string">        实际上是会在等式右边产生一个新的临时list，</span></span><br><span class="line"><span class="string">        然后将值赋给等式左边。也并不见得能省多少空间.</span></span><br><span class="line"><span class="string">        还有的解法是在反转数组的时候，自己写反转函数：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        def reverse_list(nums, start, end):</span></span><br><span class="line"><span class="string">            while start &lt; end:</span></span><br><span class="line"><span class="string">                nums[start], nums[end] = nums[end], nums[start]</span></span><br><span class="line"><span class="string">                start +=1</span></span><br><span class="line"><span class="string">                end -=1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        reverse_list(nums, 0, N-1)</span></span><br><span class="line"><span class="string">        reverse_list(nums, 0, k-1)</span></span><br><span class="line"><span class="string">        reverse_list(nums, k, N-1)     </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        这种的空间复杂度比起直接使用链表切片来说，理论上会少一些吧，反正leetcode的提交结果来看，</span></span><br><span class="line"><span class="string">        使用python2的话，空间消耗确实有减少，但是时间消耗一下就增加了</span></span><br><span class="line"><span class="string">        使用python3的话，空间消耗是真没有多少区别，时间消耗也是增加了。</span></span><br><span class="line"><span class="string">        总得来说，用切片就是快</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><span id="2.2.1.2"></span>  </p><h3 id="2-2-1-2-寻找数组的中心下标"><a href="#2-2-1-2-寻找数组的中心下标" class="headerlink" title="2.2.1.2  寻找数组的中心下标"></a>2.2.1.2  寻找数组的中心下标</h3><p><a href="https://leetcode.cn/problems/find-pivot-index/">LeetCode 724.寻找数组的中心下标</a> | | <a href="#2.2.1">返回2.2.1目录</a>  </p><font color="#3399FF">方案：最直接的思路就是遍历元素的时候，每一次都计算左侧的和 sum(nums[:i]) 和 右侧的和 sum(nums[i+1:])；但是这中间包含了大量重复计算，时间复杂度会很高。所以可以维护两个状态变量，分别记录左和右的累加和，每一次遍历的时候，直接修改状态变量即可。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 把左右结果放入中间变量缓存，就不用每次都调用sum了</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            cur_val = nums[i]</span><br><span class="line">            <span class="keyword">if</span> left == right - cur_val:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += cur_val</span><br><span class="line">                right -= cur_val</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="2.2.1.3"></span>  </p><h3 id="2-2-1-3-最大连续-1-的个数"><a href="#2-2-1-3-最大连续-1-的个数" class="headerlink" title="2.2.1.3 最大连续 1 的个数"></a>2.2.1.3 最大连续 1 的个数</h3><p><a href="https://leetcode.cn/problems/max-consecutive-ones/">LeetCode 485.最大连续 1 的个数</a> | | <a href="#2.2.1">返回2.2.1目录</a></p><font color="#3399FF">方案：这种求连续间隔的题，一般都是用索引相减来做。即右边界的索引，减去左边界的索引，就是这段区间的宽度。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxConsecutiveOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># index_0 用来记录上一次0出现的位置，作为连续1区间的左边界</span></span><br><span class="line">        index_0 = -<span class="number">1</span></span><br><span class="line">        N, gap = <span class="built_in">len</span>(nums), <span class="number">0</span></span><br><span class="line">        <span class="comment"># 在原始数组后面多加一个0，表示区域的最大右边界</span></span><br><span class="line">        nums.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 当遇到为0的时候，取该次i作为右边界，计算两个0之间的间隔</span></span><br><span class="line">                gap = <span class="built_in">max</span>(gap, i-index_0-<span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 更新完gap之后也要把index0更新为当前的0的索引。</span></span><br><span class="line">                index_0 = i</span><br><span class="line">        <span class="keyword">return</span> gap</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        当然也可以使用1来作为计算gap的判断条件，原理是一样的</span></span><br><span class="line"><span class="string">        index_0 = -1</span></span><br><span class="line"><span class="string">        N, gap = len(nums), 0</span></span><br><span class="line"><span class="string">        for i in range(N):</span></span><br><span class="line"><span class="string">            if nums[i] == 1:</span></span><br><span class="line"><span class="string">                gap = max(gap, i-index_0)</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">                index_0 = i</span></span><br><span class="line"><span class="string">        return gap</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><span id="2.2.1.4"></span>  </p><h3 id="2-2-1-4-除自身以外数组的乘积"><a href="#2-2-1-4-除自身以外数组的乘积" class="headerlink" title="2.2.1.4 除自身以外数组的乘积"></a>2.2.1.4 除自身以外数组的乘积</h3><p><a href="https://leetcode.cn/problems/product-of-array-except-self/">LeetCode 238.除自身以外数组的乘积</a> | | <a href="#2.2.1">返回2.2.1目录</a>    </p><font color="#3399FF">方案：最简单的做法就是先求所有元素的积，然后每遍历一个位置就除以该位置的值。但是题目规定不能使用除法！这也是为了避免出现0元素作为除数的情况。那么参考【2.2.2  寻找数组的中心下标】，我们可以维护两个状态，对于每一个位置，存储该数左侧全部元素的积，和右侧全部元素的积。由于不能使用除法，只好将这两个状态分别存入两个数组中，反正题目也没有要求空间复杂度。最终用了2次for循环，2个额外数组。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        l, r = [<span class="number">1</span>]*N, [<span class="number">1</span>]*N</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 原始数据从下表1开始遍历，因为0位置上的左侧积默认是1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N):</span><br><span class="line">            <span class="comment"># 对于i位置的左侧积，就是 i-1位置的左侧积，乘以 i-1 位置的值</span></span><br><span class="line">            l[i] = l[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>]</span><br><span class="line">            i2 = N-i</span><br><span class="line">            <span class="comment"># 同时倒着取索引，计算右侧积</span></span><br><span class="line">            r[i2-<span class="number">1</span>] = r[i2]*nums[i2]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [l[i]*r[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br></pre></td></tr></table></figure><p>方案二：<font color="#3399FF">此题确实有空间复杂度更低的方法。</font>因为输出结果本来就是一个数组，是不占额外空间复杂度的，可以利用该结果数组作为中间辅助数组。  </p><ul><li><font color="#3399FF">即第一轮从左往右遍历的时候，先把每个位置的左侧积暂存到结果数组res中；</font></li><li><font color="#3399FF">第二次从右往左遍历，这个时候只需要用一个变量来缓存右侧积即可，将每个位置的右侧积，乘以已经缓存在res数组中的左侧积，就可得到最终结果了。</font>  </li></ul><font color="#3399FF">最终还是只使用了2次for循环，但是没有额外用两个辅助数组，只用了一个额外变量，空间复杂度成了O(1)</font> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#l,r = [1]*N, [1]*N</span></span><br><span class="line">        <span class="comment"># 不使用左右缓存数组，而是直接用结果数组来缓存</span></span><br><span class="line">        res = [<span class="number">1</span>] * N</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N):</span><br><span class="line">            <span class="comment"># 照常计算左侧积</span></span><br><span class="line">            res[i] = res[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第二次从右往左遍历，初始化右侧积 R_mul 为1</span></span><br><span class="line">        R_mul = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N-<span class="number">1</span>,-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># j 位置结果 = 缓存的 j 位置左侧积 * 右侧积</span></span><br><span class="line">            res[j] = res[j]*R_mul</span><br><span class="line">            <span class="comment"># 更新下一位置的右侧积</span></span><br><span class="line">            R_mul *= nums[j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.2.2"></span>  </p><h2 id="2-2-2-二维数组相关题目"><a href="#2-2-2-二维数组相关题目" class="headerlink" title="2.2.2 二维数组相关题目"></a>2.2.2 二维数组相关题目</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/rotate-image">LeetCode 48.旋转图像</a></td><td><a href="#2.2.2.1">题解2.2.2.1</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/diagonal-traverse/description/">LeetCode 498.对角线遍历</a></td><td><a href="#2.2.2.2">题解2.2.2.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/spiral-matrix">LeetCode 54. 螺旋矩阵</a></td><td><a href="#2.2.2.3">题解2.2.2.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/spiral-matrix-ii">LeetCode 59. 螺旋矩阵II</a></td><td><a href="#2.2.2.4">题解2.2.2.4</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/set-matrix-zeroes/">LeetCode 73. 矩阵置零</a></td><td><a href="#2.2.2.5">题解2.2.2.5</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/game-of-life">LeetCode 289. 生命游戏</a></td><td><a href="#2.2.2.6">题解2.2.2.6</a></td></tr></tbody></table></div><p><span id="2.2.2.1"></span>  </p><h3 id="2-2-2-1-旋转图像"><a href="#2-2-2-1-旋转图像" class="headerlink" title="2.2.2.1 旋转图像"></a>2.2.2.1 旋转图像</h3><p><a href="https://leetcode.cn/problems/rotate-image">LeetCode 48.旋转图像</a> | | <a href="#2.2.2">返回2.2.2目录</a></p><font face="Times" new roman> <font color="#3399FF">方案：顺时针旋转 90°，行变成了列，列变成了行。原来是第 _i_ 行, 现在就是 倒数 第 _i_ 列 (_N_-1-_i_)；原来是第 _j_ 列, 现在到了第 _j_ 行。对于原有的一个元素 _M[i][j]_, 旋转后出现在 <b>倒数</b> 第 _i_ 列的第 _j_ 行位置：_M[j][N-1-i]_对应四个位置上的元素的变化：  _M[N-1-j][i] --> M[i][j] --> M[j][N-1-i] --> M[N-1-i][N-1-j]_</font> </font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 转换关系 M[N-1-j][i] --&gt; M[i][j] --&gt; M[j][N-1-i] --&gt; M[N-1-i][N-1-j]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 可以发现元素互换都是在自己所在的那个圈层进行交换</span></span><br><span class="line">        <span class="comment"># 每处理完最外一圈，可以视为(待处理)矩阵缩小了一圈</span></span><br><span class="line">        <span class="comment"># 所以我们可以从外到内去处理，一共有 K圈， K = N//2</span></span><br><span class="line">        <span class="comment"># K=0时，圈层左上角是(0,0), K=1时，圈层左上角是(1,1), ...以此类推</span></span><br><span class="line">        N = <span class="built_in">len</span>(matrix)</span><br><span class="line">        K =  N // <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(K):</span><br><span class="line">            <span class="comment"># 对于每一个圈层，如果一次换4个对应位置的元素</span></span><br><span class="line">            <span class="comment"># 那么只要把该圈层的首行的每个元素都进行一次【4位置】交换</span></span><br><span class="line">            <span class="comment"># 该圈层就完成了交换了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 这里一定要注意，对于k圈层的首行，左起列是 k，右侧截止是 N-1-k</span></span><br><span class="line">            <span class="comment"># 但是最右侧那一列可以不用管，因为最后那一列的元素就是首行填充过去的</span></span><br><span class="line">            <span class="comment"># 所以右侧只用取到 N-1-k -1即可</span></span><br><span class="line">            <span class="comment"># 比如k=0时，首行如果是 1,2,3；则只需要移动元素 1及其对应4个位置的，和2及其4个对应位置的；</span></span><br><span class="line">            <span class="comment"># 不用考虑 3及其4个对应位置的数，因为3已经在元素1的4个对应位置当中处理了</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, N-<span class="number">1</span>-i):</span><br><span class="line">                matrix[i][j],     matrix[j][N-<span class="number">1</span>-i], matrix[N-<span class="number">1</span>-i][N-<span class="number">1</span>-j], matrix[N-<span class="number">1</span>-j][i] = \</span><br><span class="line">                matrix[N-<span class="number">1</span>-j][i], matrix[i][j],     matrix[j][N-<span class="number">1</span>-i],     matrix[N-<span class="number">1</span>-i][N-<span class="number">1</span>-j] </span><br><span class="line">            </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.2.2.2"></span>  </p><h3 id="2-2-2-2-对角线遍历"><a href="#2-2-2-2-对角线遍历" class="headerlink" title="2.2.2.2 对角线遍历"></a>2.2.2.2 对角线遍历</h3><p><a href="https://leetcode.cn/problems/diagonal-traverse/description/">LeetCode 498.对角线遍历</a> | | <a href="#2.2.2">返回2.2.2目录</a></p><font color="#3399FF">方案：这种矩阵遍历的问题，最关键的点就在于，如果考虑好边界条件，达到某一个边界条件之后，换方向.</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDiagonalOrder</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        m,n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        left, top, right, bottom = <span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>, m-<span class="number">1</span></span><br><span class="line">        <span class="comment"># i,j表示矩阵的i 行 j 列, k表示矩阵已经遍历了多少个元素</span></span><br><span class="line">        i, j, k = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> k &lt; m*n:</span><br><span class="line">            <span class="comment"># 朝着右上遍历</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= top <span class="keyword">and</span> j &lt;= right <span class="keyword">and</span> k &lt; m*n:</span><br><span class="line">            <span class="comment"># 当 i 未超过上边界, j 未超过右边界, k 未超过元素总数</span></span><br><span class="line">                res.append(mat[i][j])</span><br><span class="line">                i -= <span class="number">1</span> <span class="comment"># 往上移动, 故 i 减小</span></span><br><span class="line">                j += <span class="number">1</span> <span class="comment"># 往右移动, 故 j 增大</span></span><br><span class="line">                k += <span class="number">1</span> <span class="comment"># 已经遍历过一个元素</span></span><br><span class="line">            <span class="comment"># 当跳出了这个while循环时:</span></span><br><span class="line">            <span class="comment"># 1.如果是 k &lt; m*n 不满足, 可以不用管</span></span><br><span class="line">            <span class="comment"># 2.如果是 i &gt;= top 不满足, 说明上方出界, i要往下回来一行才能继续遍历</span></span><br><span class="line">            <span class="comment"># 3.如果是 j &lt;= right 不满足, 说明右侧出界, j要往左侧回来一列才能继续遍历;</span></span><br><span class="line">            <span class="comment">#   同时, 出右界, 说明刚刚那一行已经被遍历完了！！所以i即使没有越上界，依然要向下, 而且是向下两行！</span></span><br><span class="line">            <span class="comment">#   比如如果是 3行2列 的矩阵,（行多列少，j一定先出界） 就会出现这种情况</span></span><br><span class="line">            <span class="comment"># 如果是2.3都出现不满足, 说明刚刚遍历过的位置是右上角, 和情况3一样</span></span><br><span class="line">            <span class="comment"># 总结起来, 伪代码 就为 :</span></span><br><span class="line">            <span class="comment"># i = i + 1 (j没有越右界) or i + 2(j越了右界)</span></span><br><span class="line">            <span class="comment"># j = j (j没有越右界) or j - 1 (j越了右界)</span></span><br><span class="line">            i, j = (i+<span class="number">1</span>, j) <span class="keyword">if</span> (j &lt;=right) <span class="keyword">else</span> (i+<span class="number">2</span>, j-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 朝着左下遍历</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= bottom <span class="keyword">and</span> j &gt;= left <span class="keyword">and</span> k&lt;m*n:</span><br><span class="line">                res.append(mat[i][j])</span><br><span class="line">                i += <span class="number">1</span> <span class="comment"># 往下移动, 故 i 增大</span></span><br><span class="line">                j -= <span class="number">1</span> <span class="comment"># 往左移动, 故 j 减小</span></span><br><span class="line">                k += <span class="number">1</span> <span class="comment"># 已经遍历过一个元素</span></span><br><span class="line">            <span class="comment"># 分析同上（可以用3行4列的矩阵帮助思考，列多行少，i一定先出界）, 此处不赘述, 伪代码 就为 :</span></span><br><span class="line">            <span class="comment"># j = j + 1 (i没有越下界) or j + 2(i越了下界)</span></span><br><span class="line">            <span class="comment"># i = i (i没有越下界) or i - 1 (i越了下界)</span></span><br><span class="line">            j, i = (j+<span class="number">1</span>, i) <span class="keyword">if</span> (i&lt;=bottom) <span class="keyword">else</span> (j+<span class="number">2</span>, i-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.2.2.3"></span>  </p><h3 id="2-2-2-3-螺旋矩阵"><a href="#2-2-2-3-螺旋矩阵" class="headerlink" title="2.2.2.3 螺旋矩阵"></a>2.2.2.3 螺旋矩阵</h3><p><a href="https://leetcode.cn/problems/spiral-matrix">LeetCode 54. 螺旋矩阵</a> | | <a href="#2.2.2">返回2.2.2目录</a>   </p><font color="#3399FF">方案：设立四个边界值，遍历的指针碰到边界值之后，就停下来，换方向，同时更新边界值。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        i, j, k = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        left, up, right, down = <span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>, m-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(left, right+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][j])</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt;= m*n : <span class="keyword">break</span></span><br><span class="line">            up += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(up, down+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][j])</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt;= m*n : <span class="keyword">break</span></span><br><span class="line">            right -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(right, left-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][j])</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt;= m*n : <span class="keyword">break</span></span><br><span class="line">            down -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(down, up-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][j])</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt;= m*n : <span class="keyword">break</span></span><br><span class="line">            left +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.2.2.4"></span>  </p><h3 id="2-2-2-4-螺旋矩阵II"><a href="#2-2-2-4-螺旋矩阵II" class="headerlink" title="2.2.2.4 螺旋矩阵II"></a>2.2.2.4 螺旋矩阵II</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-ii">LeetCode 59. 螺旋矩阵II</a> | | <a href="#2.2.2">返回2.2.2.2目录</a>  </p><font color="#3399FF">方案：上一题中的遍历顺序搞懂了之后，这个题思路很简单，代码也差不多。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 创建一个 N*N的矩阵</span></span><br><span class="line"><span class="string">        # res = n*[n*[0]]</span></span><br><span class="line"><span class="string">        # 注意，这么写是错的，这样写的后果就是里面的每行都是来源于同一行 的copy，</span></span><br><span class="line"><span class="string">        # 会共享存储空间，属于python的浅拷贝！</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 应该这么写：</span></span><br><span class="line"><span class="string">        # res = []</span></span><br><span class="line"><span class="string">        # for i in range(n):</span></span><br><span class="line"><span class="string">        #   res.append([0]*n)</span></span><br><span class="line"><span class="string">        # 即每一行都是新创建一个 [0]*n的行，然后添加进去</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 简化为如下写法：</span></span><br><span class="line">        res = [ [<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        i, j, k = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        left, up, right, down = <span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(left, right+<span class="number">1</span>):</span><br><span class="line">                res[i][j]=k</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n*n: <span class="keyword">break</span></span><br><span class="line">            up +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(up, down+<span class="number">1</span>):</span><br><span class="line">                res[i][j]=k</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n*n: <span class="keyword">break</span></span><br><span class="line">            right -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(right, left-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res[i][j]=k</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n*n: <span class="keyword">break</span></span><br><span class="line">            down -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(down, up-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res[i][j]=k</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n*n: <span class="keyword">break</span></span><br><span class="line">            left +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.2.2.5"></span>  </p><h3 id="2-2-2-5-矩阵置零"><a href="#2-2-2-5-矩阵置零" class="headerlink" title="2.2.2.5 矩阵置零"></a>2.2.2.5 矩阵置零</h3><p><a href="https://leetcode.cn/problems/set-matrix-zeroes/">LeetCode 73. 矩阵置零</a> | | <a href="#2.2.2">返回2.2.2目录</a>   </p><font color="#3399FF">方案：我们需要知道原矩阵中哪些位置为0，如果在遍历的同时修改，那么原来不为0的元素可能会被置为0，会影响后面的元素的判断。比如如果左上角是0，在遍历的时候同时修改原数组，那么第一行和第一列的元素会全部变为0；会导致后面所有元素全部为0. 所以我们只能先遍历矩阵，然后找个地方把为0的位置先记住，然后再第二次遍历的时候进行修改。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setZeroes</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 如果在遍历的时候就修改，那么前面如果出现了0，修改完之后，后面很可能都被改为0</span></span><br><span class="line">        <span class="comment"># 所以先记住这些为0的行/列索引</span></span><br><span class="line">        <span class="comment"># 再改</span></span><br><span class="line">        </span><br><span class="line">        rows, cols = [], []</span><br><span class="line">        M, N = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">in</span> rows:</span><br><span class="line">                        rows.append(i)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> j <span class="keyword">in</span> cols:</span><br><span class="line">                        cols.append(j)</span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;注意，python的二维list不支持以下写法：</span></span><br><span class="line"><span class="string">        for i in rows:</span></span><br><span class="line"><span class="string">            matrix[i][:] =0</span></span><br><span class="line"><span class="string">        for j in cols:</span></span><br><span class="line"><span class="string">            matrix[:][j] = 0</span></span><br><span class="line"><span class="string">        这是 numpy array 才支持的写法</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> rows <span class="keyword">or</span> j <span class="keyword">in</span> cols:</span><br><span class="line">                    matrix[i][j] =<span class="number">0</span> </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;思路2.直接用第一列来记录哪一行出现过0，用第一行来记录哪一列出现过0；</span></span><br><span class="line"><span class="string">后续的元素出现0时，虽然第一行和第一列被修改了，但是第一行第一列对应的位置，按照规则本来也会被改成0. </span></span><br><span class="line"><span class="string">不过要提前记录第一行和第一列是否有0元素，有的话，最后再把他们全部变为0；没有的话就不用管&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setZeroes</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        flag_col0 = <span class="built_in">any</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m))</span><br><span class="line">        flag_row0 = <span class="built_in">any</span>(matrix[<span class="number">0</span>][j] == <span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 先用第一行和第一列来记录出现0的列和行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 根据第一行和第一列的记录，来修改原始矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">or</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 再来处理第一列</span></span><br><span class="line">        <span class="keyword">if</span> flag_col0:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 再来处理第一行</span></span><br><span class="line">        <span class="keyword">if</span> flag_row0:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p><span id="2.2.2.6"></span>  </p><h3 id="2-2-2-6-生命游戏"><a href="#2-2-2-6-生命游戏" class="headerlink" title="2.2.2.6 生命游戏"></a>2.2.2.6 生命游戏</h3><p><a href="https://leetcode.cn/problems/game-of-life">LeetCode 289. 生命游戏</a> | | <a href="#2.2.2">返回2.2.2目录</a>    </p><p><font color="#3399FF">方案：规则看起来很唬人，很多，但是就是对于每一个元素判断，判断其3*3窗口内的值，然后根据该值去改变当前元素的值，的这么一个条件判断语句。<br>另外，由于是同时发生改变，所以不能让变化后的值，影响到后面的元素的判断，所以也要先找一个地方，记录状态，和上题一样，只不过这里直接拷贝一个矩阵，拿他来记录原始状态</font>。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gameOfLife</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 因为是同时发生的，所以我们不能在原有矩阵上直接修改</span></span><br><span class="line">        <span class="comment"># 而是参照原有矩阵的值，对一个新的矩阵的值进行判定</span></span><br><span class="line">        <span class="comment"># 二维数组的 深度拷贝的方式有以下几种，不能直接用 = 号去拷贝，那样是python的浅拷贝，会共享存储区域</span></span><br><span class="line">        <span class="keyword">import</span> copy</span><br><span class="line">        copy_board = copy.deepcopy(board)</span><br><span class="line">        <span class="comment"># copy_board = [copy.deepcopy(row) for row in board]</span></span><br><span class="line">        <span class="comment"># copy_board = [[board[i][j] for j in range(n)] for i in range(m)]</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># left: max(0, j-1), right: min(n, j+1+1), top: max(0, i-1), bottom: min(m, i+1+1)</span></span><br><span class="line">                <span class="keyword">if</span> copy_board[i][j] == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 如果原始状态是1，进入下面的规则</span></span><br><span class="line">                    <span class="comment"># 由于我们要算周围8个格子的和</span></span><br><span class="line">                    <span class="comment"># 先将初始值置为-1，这样就直接考虑9宫格的和（相当于减去当前元素1）</span></span><br><span class="line">                    area_sum = -<span class="number">1</span></span><br><span class="line">                    <span class="comment"># 然后就是如何遍历以当前元素为中心的9宫格的问题了</span></span><br><span class="line">                    <span class="comment"># 理想情况下，i的遍历范围[i-1, i+1 +1), j的遍历范围 [j-1, j+1 +1)</span></span><br><span class="line">                    <span class="comment"># 但是要考虑格子本身就在矩阵边界的情况，所以:</span></span><br><span class="line">                    <span class="comment"># 上边界最小只能到 0: 取max(0, i-1); 左边界最小只能到 0: 取max(0, j-1)</span></span><br><span class="line">                    <span class="comment"># 下边界最大只能到 m: 取min(m, i+1 +1); 右边界最大只能到 n：取min(n, j+1 +1);</span></span><br><span class="line">                    <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(<span class="number">0</span>,i-<span class="number">1</span>), <span class="built_in">min</span>(m,i+<span class="number">1</span> +<span class="number">1</span>)):</span><br><span class="line">                        <span class="keyword">for</span> q <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(<span class="number">0</span>,j-<span class="number">1</span>), <span class="built_in">min</span>(n, j+<span class="number">1</span> +<span class="number">1</span>)):</span><br><span class="line">                            area_sum += copy_board[p][q]</span><br><span class="line">                    <span class="keyword">if</span> area_sum &lt; <span class="number">2</span>:</span><br><span class="line">                        board[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">elif</span> area_sum &gt; <span class="number">3</span>:</span><br><span class="line">                        board[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果原始状态是0，进入下面的规则</span></span><br><span class="line">                    area_sum = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(i-<span class="number">1</span>,<span class="number">0</span>), <span class="built_in">min</span>(m,i+<span class="number">1</span>+<span class="number">1</span>)):</span><br><span class="line">                        <span class="keyword">for</span> q <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(<span class="number">0</span>,j-<span class="number">1</span>), <span class="built_in">min</span>(n, j+<span class="number">1</span>+<span class="number">1</span>)):</span><br><span class="line">                            area_sum += copy_board[p][q]</span><br><span class="line">                    <span class="keyword">if</span> area_sum == <span class="number">3</span>:</span><br><span class="line">                        board[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2-1 顺序表</title>
      <link href="/Data-Structure/DS_21_SeqList.html"/>
      <url>/Data-Structure/DS_21_SeqList.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1"> <h1 id="2-1-顺序表"><a href="#2-1-顺序表" class="headerlink" title="2-1 顺序表"></a>2-1 顺序表</h1><hr style="border:solid; height:1px; color=#000000 size=1">   <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>2.1.1</td><td><a href="#2.1.1">线性表的概念</a></td></tr><tr><td>2.1.2</td><td><a href="#2.1.2">顺序表</a></td></tr><tr><td>2.1.3</td><td><a href="#2.1.3">Python中的顺序表</a></td></tr><tr><td>2.1.4</td><td><a href="#2.1.4">Python中list内置操作的时间复杂度</a></td></tr></tbody></table></div><p><span id="2.1.1"></span>  </p><h2 id="2-1-1-线性表的概念"><a href="#2-1-1-线性表的概念" class="headerlink" title="2.1.1 线性表的概念"></a>2.1.1 线性表的概念</h2><p>线性表<font face="Times" new roman>（linear list）</font>是数据结构的一种，一个线性表是n个具有相同特性的数据元素构成的有限序列，<b>其中的元素的前驱和后置都最多只有一个</b>。<br>线性表是最基本、最简单、也是最常用的一种数据结构。我们说“线性”和“非线性”，只在逻辑层次上讨论，而不考虑存储层次，所以常见的线性表包括：顺序表、栈和队列、链表。<br>线性表通常都具有：初始化、遍历、求长度和增删改查这些操作。  </p><p><span id="2.1.2"></span>   </p><h2 id="2-1-2-顺序表"><a href="#2-1-2-顺序表" class="headerlink" title="2.1.2 顺序表"></a>2.1.2 顺序表</h2><p>顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储区域，将数据元素顺序地存储在其中，就形成一个顺序表。<br>元素间的顺序关系由它们的存储顺序自然的表示。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/2_1.webp" width="80%">  </p><p>顺序表的两种形式如图所示；<br>a) 是直接存储元素，这就要求元素的类型相同了，因为不同类型的元素占据的字节数是不一样的；<br>b) 是存储的地址，地址指向的是一些元素，由于地址本身这个类型（比如C++中的指针类型）占据的字节是固定的，所以可以存在顺序表中，这些地址指向的具体的位置，存放的元素又可以是不同的类型。  </p><p><span id="2.1.3"></span>  </p><h2 id="2-1-3-Python中的顺序表"><a href="#2-1-3-Python中的顺序表" class="headerlink" title="2.1.3 Python中的顺序表"></a>2.1.3 Python中的顺序表</h2><p>Python标准类型list（列表，就是一种线性表。但是比较特殊，它是一种元素个数可变的线性表。这种顺序表被称为【<strong>动态顺序表</strong>】，因其容量可以在使用过程中动态变化。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;执行以下code，你会发现list中相同的数:1, 竟然指向的是同一个地址</span></span><br><span class="line"><span class="string">这就跟C/C++的传统印象有区别&#x27;&#x27;&#x27;</span></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(nums[i]))</span><br><span class="line"></span><br><span class="line">nums[<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;#&#x27;</span>*<span class="number">14</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(nums[i]))</span><br><span class="line"><span class="comment">##### output ######</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073360</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073424</span></span><br><span class="line"><span class="string">##############</span></span><br><span class="line"><span class="string">1638490265040</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073360</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073424</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>Python 中的 list 的是一种 <u>采用分离式技术实现的动态顺序表</u> ，在建立空列表的时候，系统分配一块能容纳8个元素的存储区；在执行插入操作时(insert/append)，如果元素存储区满了，就换一块4倍大的存储区。但是如果当list的规模已经较大时，（目前阈值为50000），就换一块2倍大的存储区，避免出现过多的空闲存储位置。<br>Python 中的另一个顺序表，就是 tuple（元组），元组就不可以改变值了。</p><p><span id="2.1.4"></span>   </p><h2 id="2-1-4-Python中list内置操作的时间复杂度"><a href="#2-1-4-Python中list内置操作的时间复杂度" class="headerlink" title="2.1.4 Python中list内置操作的时间复杂度"></a>2.1.4 Python中list内置操作的时间复杂度</h2><div class="table-container"><table><thead><tr><th>操作</th><th>时间复杂度</th><th>举例</th></tr></thead><tbody><tr><td>a[ ]</td><td>O(1)</td><td>a[1]</td></tr><tr><td>pop()</td><td>O(1)</td><td>a.pop()</td></tr><tr><td>pop(i)</td><td>O(N)</td><td>a.pop(0)</td></tr><tr><td>insert(i,item)</td><td>O(N)</td><td>a.insert(3,100)</td></tr><tr><td>del</td><td>O(N)</td><td>del a[3]</td></tr><tr><td>len</td><td>O(N)</td><td>len(a)</td></tr><tr><td>iteration</td><td>O(N)</td><td>for x in a: print x</td></tr><tr><td>contains(in)</td><td>O(N)</td><td>3 in a</td></tr><tr><td>get slice[x:y]</td><td>O(k)</td><td>a[3:7]</td></tr><tr><td>del slice</td><td>O(N)</td><td>del a[3:7]</td></tr><tr><td>set slice</td><td>O(k+N)</td><td>a[3:7]=[3,4,5,6]</td></tr><tr><td>reverse</td><td>O(N)</td><td>a.reverse()</td></tr><tr><td>concatenate</td><td>O(k)</td><td>[1, 2, 3] + [4, 5, 6]</td></tr><tr><td>sort</td><td>O(nlogN)</td><td>a.sort()</td></tr><tr><td>multiply</td><td>O(kN)</td><td>[‘Hi!’] * 4</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1-1 数据结构与算法</title>
      <link href="/Data-Structure/DS_11_data_structure.html"/>
      <url>/Data-Structure/DS_11_data_structure.html</url>
      
        <content type="html"><![CDATA[<!-- <img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width=70%>   --><p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%"></p><hr style="border:solid; height:1px; color=#000000 size=1"> <h1 id="1-1-数据结构与算法"><a href="#1-1-数据结构与算法" class="headerlink" title="1-1 数据结构与算法"></a>1-1 数据结构与算法</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>小节</th><th>位置</th></tr></thead><tbody><tr><td>1.1.1</td><td><a href="#1.1.1">数据结构与算法</a></td></tr><tr><td>1.1.2</td><td><a href="#1.1.2">算法</a></td></tr><tr><td>1.1.3</td><td><a href="#1.1.3">程序</a></td></tr></tbody></table></div><p><span id="1.1.1"></span>  </p><h2 id="1-1-1-数据结构"><a href="#1-1-1-数据结构" class="headerlink" title="1.1.1 数据结构"></a>1.1.1 数据结构</h2><p>数据结构是讨论计算机系统中 <font color="red"> 数据的存储、组织形式 及其 相互关系</font>。  </p><ul><li>数据：客观事物 采用计算机进行识别、存储和加工所进行的描述  </li><li>结构：事物间的相互关系和约束  </li><li>数据结构的基本单元是数据元素  </li></ul><p>数据结构的3个层次：<b>① 数据的逻辑结构；② 数据的存储结构；③ 数据的运算结构(操作集合)。</b>  </p><table border="1" align="center">    <tr>        <td rowspan="3"> ①逻辑结构</td>        <td colspan="2">            反映数据 元素之间 的 逻辑关系 的结构。<br>            逻辑关系是指数据元素之间的<b>前后间关系</b>，而与他们在计算机中的存储位置无关。        </td>    </tr>    <tr>        <td> 线性结构 </td>        <td>             有且仅有一个开始元素和终点元素;<br>            且所有数据元素最多只有一个直接前趋和一个直接后继。<br>             比如 线性表。         </td>    </tr>    <tr>        <td> 非线性结构 </td>        <td>             一个元素可能有多个直接前趋和多个直接后继。<br>            比如 树结构、图结构。        </td>    </tr>    <tr>        <td rowspan="2"> ②存储结构 </td>        <td colspan="2">             数据的逻辑结构在计算机存储空间中的存放形式称为数据的存储结构。<br>            (也称为物理结构)        </td>    </tr>    <tr>        <td colspan="2">            反应数据元素在计算机中的存储方案。<br>            比如：顺序存储、链接存储、索引存储、散列存储。        </td>    </tr>    <tr>        <td rowspan="7"> ③运算结构</td>        <td colspan="2">             数据结构的操作集合        </td>    </tr>    <tr>        <td>  遍历 </td>        <td>  在数据结构的各个元素中移动，或查看所有元素。</td>    </tr>      <tr>        <td>  插入<font color="red">(增)<font> </font></font></td>        <td>  往数据结构中 添加新的元素。</td>    </tr>     <tr>        <td>  删除<font color="red">(删)<font> </font></font></td>        <td>  把指定的数据结构元素移除。</td>    </tr>     <tr>        <td>  更新<font color="red">(改)<font> </font></font></td>        <td>  修改 或 替换数据结构中的 一个或多个元素。</td>    </tr>     <tr>        <td>  查找<font color="red">(查)<font> </font></font></td>        <td>  在数据结构中找寻满足一定条件的数据元素。</td>    </tr>     <tr>        <td>  排序 </td>        <td>  在保持数据结构中元素个数不变的前提条件下，把元素按照指定的顺序重新排列，排序一般是针对线性逻辑结构。</td>    </tr> </table>  <p><span id="1.1.2"></span>  </p><h2 id="1-1-2-算法"><a href="#1-1-2-算法" class="headerlink" title="1.1.2 算法"></a>1.1.2 算法</h2><p>指为解决特定问题 的 有穷的 操作规则 的集合。  </p><table>    <th colspan="2"> 算法的 5 个基本特性 </th>    <tr>        <td> ①有穷性 </td>        <td> 有始有终，不会无限循环，且执行时间可接受。 </td>    </tr>    <tr>        <td> ②确定性 </td>        <td> 算法操作的每一步，其顺序和内容都唯一确定，不会出现二义性。 </td>    </tr>    <tr>        <td> ③数据输入 </td>        <td> 算法具有0个或多个输入。 </td>    </tr>    <tr>        <td> ④数据输出 </td>        <td> 算法至少有一个输出。</td>    </tr>    <tr>        <td> ⑤可行性 </td>        <td> 算法任一步操作都是可以付诸实践的。 </td>    </tr></table>  <p>算法点的效率可分为 时间效率 和 空间效率。  </p><table>    <tr>        <td>             空间复杂度<br>            <font face="Times" new roman> <i>S(n)=O(f(n))</i> </font>        </td>        <td colspan="4">            除开存储数据结构本身外（比如指令、常数、变量 和输入数据），实现算法所需要的额外辅助空间有多少。        </td>    </tr>        <td rowspan="5">             时间复杂度<br>            <font face="Times" new roman> <i>T(n)=O(f(n))</i> </font>        </td>        <td colspan="4">            执行算法所需要的时间以 常数时间操作 的数量级来表示。<br>            相同规模的不同输入，仍可能导致算法的运行时间不同。<br>            <b>一般使用算法最坏情况下的的复杂度来做代表。</b>        </td>    <tr>        <td colspan="4">            常数时间操作是指我们在写代码的时候会涉及到一些指令,这些执令都是固定时间的操作。<br>这些指令是和数据量没有关系的,比如加、减、乘、除、模、位移运算,又或者数组的寻址。        </td>    </tr>    <tr>        <td colspan="4">            不同的机器常数时间操作不一样，比如新一代的机器可能性能更好，常数时间操作更短。<br>但是我们用常数时间操作的数量级（而非具体的数值）来衡量时间复杂度的话，就可以忽略机器的因素，而聚焦到算法本身上来。        </td>    </tr>    <tr>        <td colspan="4">            时间复杂度可以用T(n)的自然特性加以区分，如下：        </td>    </tr>    <tr>        <td> 常量时间 O(1) </td>        <td> 线性时间 O(n) </td>        <td> 对数时间 O(logn) </td>        <td> 指数时间 O(n**2) </td>    </tr></table>  <p>Python 中的 <code>timeit</code> 模块可以来测试代码的执行时间，网上有很多资料,这里不赘述。<br>时间复杂度大致上有以下的大小关系：  </p><p>O(1) &lt; O(logN) &lt; O(logN^2) &lt; O(N) &lt; O(N*logN) &lt; O(N^2) &lt; O(N^3)&lt; …&lt;O(N^k)<br>…  &lt; O( 2^N) &lt; O(3^N)  &lt; … &lt; O(k^N) &lt; O(N!)  </p><p>可以通过数学函数图像来加深理解。  </p><p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/1_1_math_func_img.webp" width="60%">   </p><p><span id="1.1.3"></span>  </p><h2 id="1-1-3-程序"><a href="#1-1-3-程序" class="headerlink" title="1.1.3 程序"></a>1.1.3 程序</h2><p>程序 = 算法 + 数据结构                —— 尼古拉斯·沃斯<br><b> <font color="red">Algorithm + Data Structures = Programs </font>   ——  Niklaus Wirth，1984 图灵奖 <B></B></b></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法_Python</title>
      <link href="/Data-Structure/DS_00_introduction.html"/>
      <url>/Data-Structure/DS_00_introduction.html</url>
      
        <content type="html"><![CDATA[<!-- <img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width=70%>   --><p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%"></p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p>本系列文章以Python语言为基础，简要介绍基本的数据结构与算法的相关知识。<br>并配合 <a href="https://leetcode.cn/">LeetCode</a> 网站的一些题目来加深相关概念的了解。<br><b><font color="red">注意！由于版权原因，本系列文章在引用LeetCode的题目时，只提供官方页面的跳转链接，而不会直接展示题目信息。</font></b> </p><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><h2 id="1-1-数据结构与算法"><a href="#1-1-数据结构与算法" class="headerlink" title="1-1 数据结构与算法"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_11_data_structure.html">1-1 数据结构与算法</a></h2><h2 id="2-1-顺序表"><a href="#2-1-顺序表" class="headerlink" title="2-1 顺序表"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_21_SeqList.html">2-1 顺序表</a></h2><h2 id="2-2-数组相关题目"><a href="#2-2-数组相关题目" class="headerlink" title="2-2 数组相关题目"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_22_array_exercises.html">2-2 数组相关题目</a></h2><h2 id="2-3-数组双指针"><a href="#2-3-数组双指针" class="headerlink" title="2-3 数组双指针"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_23_array_double_pointer_exercises.html">2-3 数组双指针</a></h2><h2 id="3-1-排序"><a href="#3-1-排序" class="headerlink" title="3-1 排序"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_31_sort_algorithm.html">3-1 排序</a></h2><h2 id="3-2-快速排序讨论"><a href="#3-2-快速排序讨论" class="headerlink" title="3-2 快速排序讨论"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_32_quick_sort_discussion.html">3-2 快速排序讨论</a></h2><h2 id="3-3-排序相关题目"><a href="#3-3-排序相关题目" class="headerlink" title="3-3 排序相关题目"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_33_sort_exercises.html">3-3 排序相关题目</a></h2><h2 id="4-1-字符串"><a href="#4-1-字符串" class="headerlink" title="4-1 字符串"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_41_string.html">4-1 字符串</a></h2><h2 id="4-2-字符串相关题目"><a href="#4-2-字符串相关题目" class="headerlink" title="4-2 字符串相关题目"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_42_string_exercises.html">4-2 字符串相关题目</a></h2><h2 id="5-1-栈和队列"><a href="#5-1-栈和队列" class="headerlink" title="5-1 栈和队列"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_51_stack_and_queue.html">5-1 栈和队列</a></h2><h2 id="5-2-栈和队列相关题目"><a href="#5-2-栈和队列相关题目" class="headerlink" title="5-2 栈和队列相关题目"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_52_stack_and_queue_exercises.html">5-2 栈和队列相关题目</a></h2><h2 id="6-1-链表"><a href="#6-1-链表" class="headerlink" title="6-1 链表"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_61_link_list.html">6-1 链表</a></h2><h2 id="6-2-链表相关题目"><a href="#6-2-链表相关题目" class="headerlink" title="6-2 链表相关题目"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_62_link_list_exercises.html">6-2 链表相关题目</a></h2><h2 id="7-1-树"><a href="#7-1-树" class="headerlink" title="7-1 树"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_71_tree.html">7-1 树</a></h2><h2 id="7-2-树相关的题目"><a href="#7-2-树相关的题目" class="headerlink" title="7-2 树相关的题目"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_72_tree_exercises.html">7-2 树相关的题目</a></h2><h2 id="8-1-图"><a href="#8-1-图" class="headerlink" title="8-1 图"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_81_graph.html">8-1 图</a></h2><h2 id="8-2-图相关题目"><a href="#8-2-图相关题目" class="headerlink" title="8-2 图相关题目"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_81_graph.html">8-2 图相关题目</a></h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图像分割测试用例</title>
      <link href="/Computer-Vision/Image-Segmentation-By-Deeplearning/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.html"/>
      <url>/Computer-Vision/Image-Segmentation-By-Deeplearning/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.html</url>
      
        <content type="html"><![CDATA[<p>图像分割测试用例</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 深度学习下的图像分割 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习导论</title>
      <link href="/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA.html"/>
      <url>/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA.html</url>
      
        <content type="html"><![CDATA[<p>机器学习导论</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
