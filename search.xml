<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>4 激活函数</title>
      <link href="/Deep-Learning/DL_04_activation_func.html"/>
      <url>/Deep-Learning/DL_04_activation_func.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1">  <p><a href="https://teeyohuang.github.io/Deep-Learning/DL_00_introduction.html">深度学习系列博文目录一览</a><br>————————————————</p><h1 id="4-激活函数"><a href="#4-激活函数" class="headerlink" title="4 激活函数"></a>4 激活函数</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p>激活函数也就是一些<b>非线性单元</b>，如果不用激活函数，每一层输出都是上层输入的线性函数，无论神经网络有多少层，输出都是输入的线性组合。如果使用激活函数的话，<b>激活函数给神经元引入了非线性因素，使得神经网络可以任意逼近任何非线性函数，这样神经网络就可以应用到众多的非线性模型中</b>。 </p><p>对于激活函数的使用，可以追溯到多层感知机解决异或(XOR)问题。</p><p>参考资料：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/25110450">知乎</a></li></ol><h2 id="1-sigmoid"><a href="#1-sigmoid" class="headerlink" title="1.sigmoid"></a>1.sigmoid</h2><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/4_1.webp" width="90%">  </p><p><b>sigmoid作激活函数的优点</b>:</p><ul><li><p>梯度计算较为方便  </p><p>  <img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/4_1_1.webp" width="90%">  </p></li><li><p>能够控制数值的幅度</p><p>  （即能压缩数据，在深层网络中可以保持数据幅度不会出现大的变化，保证数据幅度不会有问题）  </p></li></ul><p><b>sigmoid缺点</b>：</p><ul><li><p><b>容易出现梯度消失（gradient  vanishing）的现象</b>：<br>  当激活函数的输入值接近饱和区（两边)时，变化太缓慢，导数接近0；</p><p>  根据反向传播的数学依据是微积分求导的链式法则，当前导数需要之前各层导数的乘积，几个比较小的数相乘，导数结果很接近0，从而无法完成深层网络的训练。</p></li><li><p><b>Sigmoid的输出不是0均值（zero-centered）的</b>：<br>  <b><font color="red">输出值恒大于0，这会导致模型训练的收敛速度变慢</font></b>。比如上一级 经过 sigmoid之后，输出的一定是个正数x，那么希望更新这一级的参数的时候，wx+b，w的梯度是x，但是x恒为正，那么我这一级的w（w是个向量，里面会有很多分量）的所有分量都只能往正向移动，不能各个分量朝不同的方向移动，所以收敛速度变慢。 </p></li><li><p><b>幂运算相对来讲比较耗时。</b>  </p></li></ul><h2 id="2-tanh"><a href="#2-tanh" class="headerlink" title="2.tanh"></a>2.tanh</h2><p>tanh读作 Hyperbolic Tangent  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/4_2.webp" width="90%">  </p><p>它的输出是0均值的了，解决了上面sigmoid的（2问题），但是梯度消失 和 幂运算费时的问题依然存在。</p><h2 id="3-ReLU"><a href="#3-ReLU" class="headerlink" title="3.ReLU"></a>3.ReLU</h2><p>ReLU（Rectified Linear Unit）：整流线性单元</p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/4_3.webp" width="90%">  </p><p>ReLU函数其实就是一个取最大值函数，注意这并不是全区间可导的(0点不连续)，但是我们可以取sub-gradient，如上图所示。ReLU虽然简单，但却是近几年的重要成果，有以下几大优点：  </p><ul><li>解决了gradient vanishing问题 (在正区间)</li><li>计算速度非常快，只需要判断输入是否大于0</li><li>收敛速度远快于sigmoid和tanh</li></ul><p>ReLU也有几个需要特别注意的问题：</p><ul><li><p>ReLU的输出不是zero-centered  </p></li><li><p>Dead ReLU Problem<br>  <b><font color="red">指的是某些神经元可能永远不会被激活，导致相应的参数永远不能被更新</font></b>。有两个主要原因可能导致这种情况产生:<br>   (1) 非常不幸的参数初始化，这种情况比较少见 ；  </p><p>  (2) <b>learning rate太高导致在训练过程中<font color="red"> 参数更新太大</font></b>，使得<b>输入发生巨大变化</b>后越过0界，则前向传播为0，相当于这个单元被关闭了，反向传播的时候也为0 ，这个关掉的单元就跳不出来了。解决方法是<b>可以采用Xavier初始化方法，以及避免将learning rate设置太大或使用adagrad等自动调节learning rate的算法</b>。</p></li></ul><p>尽管存在这两个问题，ReLU目前仍是最常用的activation function，在搭建人工神经网络的时候推荐优先尝试！</p><h2 id="4-Leaky-ReLU"><a href="#4-Leaky-ReLU" class="headerlink" title="4.Leaky ReLU"></a>4.Leaky ReLU</h2><p>中文称作：渗漏整流线性单元  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/4_4.webp" width="90%"> </p><p>为了解决Dead ReLU Problem，提出了将ReLU的前半段设为0.01x而非0. </p><h2 id="5-ELU"><a href="#5-ELU" class="headerlink" title="5.ELU"></a>5.ELU</h2><p>ELU (Exponential Linear Units)：指数化线性单元</p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/4_5.webp" width="90%">  </p><p>ELU也是为解决ReLU存在的问题而提出，显然，ELU有ReLU的基本所有优点，以及：</p><p>（1）不会有Dead ReLU问题</p><p>（2）输出的均值接近0，zero-centered</p><p>它的一个小问题在于计算量稍大。类似于Leaky ReLU，理论上虽然好于ReLU，但在实际使用中目前并没有好的证据ELU总是优于ReLU。</p><h2 id="6-PReLU"><a href="#6-PReLU" class="headerlink" title="6.PReLU"></a>6.PReLU</h2><p>PReLU ( Parameterized ReLU） 参数整流线性单元</p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/4_6.webp" width="40%"></p><p>从形式上看，很像Leaky ReLU，但是区别在于将 PReLU 输入为负半轴部分映射为 <b>一个可学习参数 α </b>和输入的乘积; Leaky ReLU 而负半轴的参数是一个固定值。</p><p>.</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2 卷积与池化</title>
      <link href="/Deep-Learning/DL_02_convolution_and_pool_layer%20copy.html"/>
      <url>/Deep-Learning/DL_02_convolution_and_pool_layer%20copy.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1">  <p><a href="https://teeyohuang.github.io/Deep-Learning/DL_00_introduction.html">深度学习系列博文目录一览</a><br>————————————————</p><h1 id="1-卷积与池化"><a href="#1-卷积与池化" class="headerlink" title="1 卷积与池化"></a>1 卷积与池化</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p>这里暂时不介绍卷积操作具体是如何进行的，关于这点，很多文章都有介绍。</p><p>本文主要介绍一下 <b>为何会广泛使用卷积操作</b>？</p><p>参考资料：</p><ol><li><p>《Deep Learning》</p></li><li><p><a href="https://mooc.study.163.com/learn/2001281004?tid=2001392030#/learn/content?type=detail&amp;id=2001728690">deeplearning.ai</a></p></li></ol><p>卷积运算 主要通过三个重要的思想来帮助改进机器学习系统：</p><ul><li><p>稀疏交互 sparse interactions</p></li><li><p>参数共享 parameter sharing</p></li><li><p>等变表示 equivariant representations</p></li></ul><h2 id="1-稀疏交互"><a href="#1-稀疏交互" class="headerlink" title="1.稀疏交互"></a>1.稀疏交互</h2><p>卷积网络的<b>稀疏交互 - sparse interactions</b>（也叫稀疏连接 或者 稀疏权重），是通过使<b>卷积核的大小远小于输入的大小</b>来达到的。这就区别于全连接层的 矩阵相乘运算，</p><p><b><font color="red">卷积核的话就只接受有限个输入，使得参数量减小。</font></b>&lt;/font&gt;比如3x3大小的卷积核，就只接受9个像素点上的输入。这块儿大小有个更专业的术语，叫做 <b>感受野（receptive field）</b>，或者<b>FOV（field of view）.</b>但是这样说明<b>卷积核主要是在学习局部相关性。</b></p><p>CNN中的卷积操作在对图像进行处理时，主要是为了获得图片局部特征，在计算机视觉里，我们将这样的操作叫做滤波，都是为了获得局部领域的输出。常用的卷积操作本质上就是加权平均，这样的线性运算是获取局部特征最简单的操作，利用BP算法也显得特别直接。  </p><p>CNN同样可以处理时间序列和文本数据，因为CNN利用的就是数据的局部相关性，语音和文本具备局部相关性。</p><h2 id="2-参数共享"><a href="#2-参数共享" class="headerlink" title="2.参数共享"></a>2.参数共享</h2><p>参数共享 - parameter sharing ，是指 在一个模型的多个函数中使用相同的参数。卷积网络中，一般情况下一个卷积核会作用在输入的每一个位置，这种参数共享保证了我们只需要学习一个参数集合，而不是对每一个输入位置都需要学习一个单独的参数。</p><p>通俗来讲，就是我们在运用卷积操作时，通常情况（因为也有一些特殊情况）下，是用一个卷积核 从左往右、从上到下  按照步长stride，去遍历完特征图的所有位置。</p><h2 id="3-等变表示"><a href="#3-等变表示" class="headerlink" title="3.等变表示"></a>3.等变表示</h2><p>参数共享使得神经网络层对<b>平移</b>具有等变性质。</p><p><b>所谓等变，即对其输入施加的变换也会同样反应在输出上。<br>即如果对输入进行轻微的平移，卷积运算得到的结果在忽略位置的时候，是一样的。</b><br>比如若图像上的一个特征本来位于图像左侧，现在将该区域平移到右侧，卷积网络依然能够检测到该特征，只不过探测到的位置会发生变化而已。更具体一点，如果一个图像上有一只小狗位于左侧，现在将小狗的区域平移到图像右侧去，卷积网络依然能够检测到这个区域的特征，并且判定该特征是一只小狗。</p><p>但是卷积对其他的一些变换并不是天然等变的，例如对于图像的放缩或者旋转变换，需要其他的一些机制来处理这些变换。</p><h2 id="4-常规卷积与其他卷积的对比"><a href="#4-常规卷积与其他卷积的对比" class="headerlink" title="4.常规卷积与其他卷积的对比"></a>4.常规卷积与其他卷积的对比</h2><h3 id="①常规卷积"><a href="#①常规卷积" class="headerlink" title="①常规卷积"></a>①常规卷积</h3><p>可以看作只有一个核，且被应用到各个位置。<br>相当于每个位置对应的卷积核的参数都是一样的，这就是前面说到的参数共享。  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/2_1.webp" width="70%">  </p><p><i>图中S为卷积核；x为特征值；每个卷积核接受2个位置的输入，</i></p><p>但是参数a，b一直在重复使用，相当于是同一个卷积核在从左往右遍历&lt;/i&gt;  </p><h3 id="②局部连接"><a href="#②局部连接" class="headerlink" title="②局部连接"></a>②局部连接</h3><p><i><font color="red">注意：有些地方提及的局部连接，是指的本篇博文中的第1点，稀疏交互，<br>本篇博文的名称规则是依据DeepLearning这本花书来的，这里讲的局部连接是指的非共享卷积。</font></i></p><p>局部连接有时候也称为非共享卷积，因为它和具有一个小核的离散卷积运算很像，<b>但并不横跨位置来共享参数，</b>也就是说，并不是一个卷积核 作用于所有的输入位置，而是<b>不同的输入位置所对应的卷积核 拥有不同的参数。</b>  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/2_2.webp" width="70%">  </p><p><i>图中S为卷积核；x为特征值；每个卷积核都有各自的参数。</i>  </p><h3 id="③平铺卷积"><a href="#③平铺卷积" class="headerlink" title="③平铺卷积"></a>③平铺卷积</h3><p>是介于局部卷积 和 标准卷积之间，与局部卷积相同的地方在于，<b>相邻的单元具有不同的参数</b>，与其区别在于， 会有 <b>t</b> 个不同的卷积核循环使用，也就是说<b>相隔为 t 的卷积核，就会共享参数。</b>    </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/2_3.webp" width="70%">   </p><p><i>图中S为卷积核；x为特征值；相邻的卷积核都有各自的参数；</i></p><p>但每隔 t 个（图中 t=2）卷积核，参数就会重复使用。&lt;/i&gt;  </p><h3 id="④全连接层"><a href="#④全连接层" class="headerlink" title="④全连接层"></a>④全连接层</h3><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/2_4.webp" width="70%">  </p><p><i>图中S为卷积核；x为特征值；每条边都有各自的参数，但是它的感受野是全部的x特征，并不是局部的连接。</i></p><h2 id="5-池化操作"><a href="#5-池化操作" class="headerlink" title="5.池化操作"></a>5.池化操作</h2><p>池化函数使用<b>某一位置的相邻输出的总体统计特征</b>来代替网络在该位置的输出。比如最大池化、平均池化等等。</p><p>不管采用什么样的池化函数，当输入作出少量平移时，池化能够帮助输入的表示近似不变（invariant）。</p><p><b>对于平移的不变性</b>是指当我们对输入进行<b>少量平移</b>时，经过池化函数后的大多数输出并不会发生改变。</p><p>池化对于不同大小的输入具有重要作用。例如我们想对不同大小的图像进行分类时，分类层的输入必须是固定的大小，而这通常通过调整池化区域的偏置大小来实现，这样分类层总是能接收到相同数量的统计特征。以便于后面的全连接层进行处理</p><h2 id="6-卷积与池化作为一种无限强的先验"><a href="#6-卷积与池化作为一种无限强的先验" class="headerlink" title="6.卷积与池化作为一种无限强的先验"></a>6.卷积与池化作为一种无限强的先验</h2><p>可以把卷积的使用当作是对网络中一层的参数引入了一个<b>无限强的先验概率分布</b>。</p><p><b>这个先验说明了该层应该学得的函数只包含局部连接关系并且对平移具有等变性。<br>类似的，使用池化 也是一个无限强的先验：每一个单元都具有对少量平移的不变性</b>。</p><p>.</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1 权重初始化</title>
      <link href="/Deep-Learning/DL_01_weight_init%20copy.html"/>
      <url>/Deep-Learning/DL_01_weight_init%20copy.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1"> <p><a href="https://teeyohuang.github.io/Deep-Learning/DL_00_introduction.html">深度学习系列博文目录一览</a><br>———————————————— </p><h1 id="1-权重初始化"><a href="#1-权重初始化" class="headerlink" title="1 权重初始化"></a>1 权重初始化</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="1-为什么需要权重初始化"><a href="#1-为什么需要权重初始化" class="headerlink" title="1.为什么需要权重初始化"></a>1.为什么需要权重初始化</h2><ul><li><p>① 为了使神经网络在<b>合理的时间内收敛</b>.</p></li><li><p>② 为了尽量避免在深度神经网络的正向（前向）传播过程中层激活函数的<b>输出梯度出现爆炸或消失</b>。  </p></li></ul><h2 id="2-如何进行初始化"><a href="#2-如何进行初始化" class="headerlink" title="2.如何进行初始化"></a>2.如何进行初始化</h2><p>① <b>如果将每个隐藏单元的参数都初始化为0.</b></p><p>那么在正向传播时每个隐藏单元将<b>对于相同的输入会计算出相同的值</b>，并传递至输出层。在<b>反向传播中，每个隐藏单元的参数梯度值相等</b>。因此，这些参数在使用基于梯度的优化算法迭代后值依然相等。这样所有隐层的单元都是对称的了，很难学到什么有效的信息，之后的迭代也是如此。</p><p><b><font color="red">所以权重初始化不能将权重参数全部初始化为0，应打破这种对称性。</font></b></p><p>② <b>如果将参数都初始化为0周围极小的值</b></p><p><b>也不好</b>，比如 如果用 sigmoid 做激活函数，它在0周围是近似线性的，如果我们的参数都初始化为0附近，那么可能数据经过神经元之后，输出值也在0附近，这样<b>大部分都落在激活函数线性区，那么激活函数引入非线性的作用将被削减。</b></p><p>③ <b>如果参数都初始化为较大的值，很显然容易使得输出落入饱和区。</b></p><p><b><font color="red">所以合理的初始化时比较重要的，一般采用随机的初始化。</font></b></p><h2 id="3-常见的几种初始化方式"><a href="#3-常见的几种初始化方式" class="headerlink" title="3.常见的几种初始化方式"></a>3.常见的几种初始化方式</h2><p>① <b>均匀分布初始化：</b><br>将参数初始化为 <b><font color="red">均匀分布U(a,b) </font></b>上的随机值，pytorch的实现方案：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.uniform_(tensor, a=<span class="number">0</span>, b=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>② <b>高斯初始化：</b><br>将参数初始化为 <b><font color="red">高斯分布N(0,1)</font></b> 上的随机值，pytorch的实现方案：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.normal_(tensor, mean=<span class="number">0</span>, std=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>③ <b>常数初始化：</b><br>将参数初始化为一个 <b><font color="red">固定的常数val</font></b>, pytorch实现方案为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.constant_(tensor, val)</span><br></pre></td></tr></table></figure><p>上面三种初始化方法其实并不是十分理想的初始化方案，因为如果网络层数过深的话，依然会导致 <b>梯度爆炸</b> 或者 <b>梯度弥散</b>的 情况出现，<br>一般在使用中，可能就是神经网络中的某一两层可能会用到上述初始化方案，比如自己写的某几层,并不建议对所有的参数都使用上述初始化方案。<b>对于一些较为普及的模型，比如VGG、ResNet等，往往会加载官方提供的预训练模型的参数值，对大网络进行参数初始化</b>。 </p><h2 id="4-Xavier-初始化方案"><a href="#4-Xavier-初始化方案" class="headerlink" title="4.Xavier 初始化方案"></a>4.Xavier 初始化方案</h2><p>Xavier 初始化的基本思想是，若<b><font color="red">对于一层网络的输入和输出的方差尽量不变</font>，这样就可以避免输出趋向于0，从而避免梯度弥散情况。</b>   </p><p>参考资料：<br><a href="https://prateekvjoshi.com/2016/03/29/understanding-xavier-initialization-in-deep-neural-networks/">链接1</a><br><a href="http://proceedings.mlr.press/v9/glorot10a/glorot10a.pdf">链接2</a><br><a href="https://zhuanlan.zhihu.com/p/40175178">链接3</a>  </p><p>对于 $y=wx$ , 根据假设有：</p><script type="math/tex; mode=display">Var(Y) = Var(w_iX) = Var(w_i)*Var(X) + E^2(X)Var(w_i) + E^2(w_i)Var(X);</script><p>当 $X, w_i$ 都符合均值为 0 的正态分布时，其期望 $E(X), E(w_i)$ 均为0, 则上式可以简化为: </p><script type="math/tex; mode=display">Var(Y) = Var(w_i)*Var(X)</script><p>若该层共有$n_i$个神经元，则有：</p><script type="math/tex; mode=display">Var(Y) = n_i * Vaar(w_i) * Var(X)</script><p>要使得$Var(Y) = Var(X)$， 则需要 $n_i * Var(W_i) = 1$, 则 $ Var(w_i) = 1/n_i$;</p><p>同理，当反向传播时, $Var(w_i) = 1/n_{i+1}$  </p><p>因此，综合正向和反向传播考虑，最终取 $Var(w_i) = 1 / \frac{(n_i+n_{i+1})}{2} = 2/(n_i+n_{i+1})$ </p><p>如果使用<b><font color="red">均匀分布U(a,b) </font></b>为基础进行初始化，则：</p><script type="math/tex; mode=display">\begin{aligned} E &= (a+b)/2 = 0  \\\\Var &= (b-a)^2/12 = 2/(n_i+n_{i+1}) \end{aligned}</script><p>解得： $ a= -b = -\sqrt{6/(n_i+n_{i+1})} $  </p><p>即$w_i$ 初始化为 $ U(-\sqrt{\frac{6}{(n_i+n_{i+1})}}, \sqrt{\frac{6}{(n_i+n_{i+1})}}) $  </p><p><b>pytorch的实现方案①, 以均匀分布为基础</b>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.xavier_uniform_(tensor, gain=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>将参数初始化为均匀分布 $U(-\alpha, \alpha) $上的随机值，其中 $\alpha$ 取值为：$ \alpha = gain * \sqrt{\frac{6}{(fan_{in} + fan_{out})}}$  </p><ul><li>fan_in 指输入端神经元的个数， fan_out 指输出端神经元的个数，pytorch它会自己根据网络计算。</li><li>gain 是一个增益， 默认为1；</li></ul><p><b>pytorch的实现方案②, 以高斯分布为基础</b>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.xavier_normal_(tensor, gain=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>将参数初始化为高斯分布 $N(0, std^2)$上的随机值，而 std 的取值是：$std = gain * \sqrt{\frac{2}{(fan_{in} + fan_{out})}}$ </p><h2 id="5-Kaiming初始化"><a href="#5-Kaiming初始化" class="headerlink" title="5.Kaiming初始化"></a>5.Kaiming初始化</h2><p>Kaiming初始化基本思想是，当使用<code>ReLU</code>做为激活函数时，<code>Xavier</code>的效果不好。<br>原因在于：<b>当ReLU的输入小于0时，其输出为0，影响了输出的分布模式。也就是激活函数输出均值不为0，我们上面的推导中是有假设E(X)=0的。</b>  </p><p>因此Kaiming He初始化，在Xavier的基础上，<b>假设每层网络有一半的神经元被关闭，于是其分布的方差也会变小。所以提出一个新的假设，那就是前向传播中，如果采用Xiaver，方差会缩小为原来一半</b>。那么为了修正这个缩减，就使得参数初始化的范围比原来扩大一倍。  </p><p><b>pytorch的实现方案①, 以均匀分布为基础</b>：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.kaiming_uniform_(tensor, a=<span class="number">0</span>, mode=<span class="string">&#x27;fan_in&#x27;</span>, nonlinearity=<span class="string">&#x27;leaky_relu&#x27;</span>)</span><br></pre></td></tr></table></figure><p>将参数初始化为均匀分布 $U(-bound, bound)$上的随机值，其中 bound 取值为</p><p> $bound = \sqrt{\frac{6}{(1+\alpha^2)*fan_{in} }}$</p><ul><li>$\alpha$ : 该层后面一层的激活函数中负的斜率 (0 for ReLU by default)</li><li>使用 mode = fan_in 保持 weights 的方差在<b>前向传播</b>中不变；</li><li>使用 mode = fan_out 保持weights 的方差在<b>反向传播</b>中不变。  </li></ul><p><b>pytorch的实现方案②, 以高斯分布为基础</b>：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.kaiming_normal_(tensor, a=<span class="number">0</span>, mode=<span class="string">&#x27;fan_in&#x27;</span>, nonlinearity=<span class="string">&#x27;leaky_relu&#x27;</span>)</span><br></pre></td></tr></table></figure><p>将参数初始化为高斯分布 $N(0, std^2)$上的随机值，而std的取值是：$std = \sqrt{\frac{2}{(1+\alpha^2)*fan_{in} }}$  </p><h2 id="6-pytorch常见的-权重初始化-操作方法"><a href="#6-pytorch常见的-权重初始化-操作方法" class="headerlink" title="6.pytorch常见的 权重初始化 操作方法"></a>6.pytorch常见的 权重初始化 操作方法</h2><ul><li>方案一：直接对某层的data进行赋值</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.conv1.weight.data.normal_(<span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">self.conv1.bias.data.zero_()</span><br></pre></td></tr></table></figure><ul><li>方案二：调用nn初始化模块：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.normal_(self.conv1.weight, std=<span class="number">0.01</span>)</span><br><span class="line">torch.nn.init.constant_(self.conv1.bias, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>可搭配for循环使用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> self.children():</span><br><span class="line">    torch.nn.init.normal_(layer.weight, std=<span class="number">0.01</span>)</span><br><span class="line">    torch.nn.init.constant_(layer.bias, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>方案三： 定义一个自己的小函数</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_weight_init</span>(<span class="params">m</span>):</span><br><span class="line">    classname = m.__class__.__name__</span><br><span class="line">    <span class="keyword">if</span> classname.find(<span class="string">&#x27;Conv&#x27;</span>) != -<span class="number">1</span>:</span><br><span class="line">        torch.nn.init.xavier_(m.weight)</span><br><span class="line">        torch.nn.init.xavier_(m.bias)</span><br><span class="line">    <span class="keyword">if</span> classname.find(<span class="string">&#x27;Linear&#x27;</span>) != -<span class="number">1</span>:</span><br><span class="line">        torch.nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line">        torch.nn.init.constant_(m.bias, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#或者不读取下划线，直接看是不是某个类,这种方法相对来说更安全一些</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_weights_init</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, torch.nn.Conv2d):</span><br><span class="line">        torch.nn.xavier_(m.weight)</span><br><span class="line">        torch.nn.xavier_(m.bias)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, torch.nn.Linear):</span><br><span class="line">        torch.nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line">        torch.nn.init.constant_(m.bias, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 然后对某个Net应用：</span></span><br><span class="line">Net.apply(_weight_init)</span><br></pre></td></tr></table></figure><p><b><font color="red">以上三个均为示例，具体使用情况请依据自己的网络和具体的代码，请勿生搬硬套。</font></b>&lt;/font&gt;<br>.</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度学习导论</title>
      <link href="/Deep-Learning/DL_00_introduction.html"/>
      <url>/Deep-Learning/DL_00_introduction.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">    </p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="深度学习导论"><a href="#深度学习导论" class="headerlink" title="深度学习导论"></a>深度学习导论</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p>深度学习算是机器学习的一个子领域，其和机器学习的关系如下图所示:  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Deep_Learning/AI_ML_DL.webp" width="40%">   </p><p>本系列文章简要介绍深度学习的一些基础性、常见性知识，内容源于我早期所写<a href="https://blog.csdn.net/Teeyohuang/article/details/104120242">旧博客</a>，或许其中有所纰漏或者过时之处，权当参考而已。</p><h2 id="1-权重初始化"><a href="#1-权重初始化" class="headerlink" title="1 权重初始化"></a><a href="https://teeyohuang.github.io/Deep-Learning/DL_01_weight_init.html">1 权重初始化</a></h2><h2 id="2-卷积网络与池化操作"><a href="#2-卷积网络与池化操作" class="headerlink" title="2 卷积网络与池化操作"></a><a href="https://teeyohuang.github.io/Deep-Learning/DS_02_convolution_and_pool_layer.html">2 卷积网络与池化操作</a></h2><h2 id="3-规范化操作"><a href="#3-规范化操作" class="headerlink" title="3 规范化操作"></a><a href="https://teeyohuang.github.io/Deep-Learning/DS_22_array_exercises.html">3 规范化操作</a></h2><h2 id="4-激活操作"><a href="#4-激活操作" class="headerlink" title="4 激活操作"></a><a href="https://teeyohuang.github.io/Deep-Learning/DL_04_activation_func.html">4 激活操作</a></h2><h2 id="5-随机失活"><a href="#5-随机失活" class="headerlink" title="5 随机失活"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_23_array_double_pointer_exercises.html">5 随机失活</a></h2><h2 id="6-损失函数"><a href="#6-损失函数" class="headerlink" title="6 损失函数"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_23_array_double_pointer_exercises.html">6 损失函数</a></h2><h2 id="7-优化方法"><a href="#7-优化方法" class="headerlink" title="7 优化方法"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_23_array_double_pointer_exercises.html">7 优化方法</a></h2>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3-1 排序</title>
      <link href="/Data-Structure/DS_31_sort_algorithm.html"/>
      <url>/Data-Structure/DS_31_sort_algorithm.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">   </p><hr style="border:solid; height:1px; color=#000000 size=1">   <h1 id="3-1-排序与查找"><a href="#3-1-排序与查找" class="headerlink" title="3-1 排序与查找"></a>3-1 排序与查找</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <h2 id="3-1-1-排序部分"><a href="#3-1-1-排序部分" class="headerlink" title="3-1-1 排序部分"></a>3-1-1 排序部分</h2><p>排序算法可以分为内部排序和外部排序，<br>内部排序是数据记录在内存中进行排序，<br>外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要额外辅助空间。  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/3_1_1.webp" width="80%">   </p><h3 id="3-1-1-冒泡排序"><a href="#3-1-1-冒泡排序" class="headerlink" title="3-1-1 冒泡排序"></a>3-1-1 冒泡排序</h3><p>它重复地遍历过要排序的数列，<b>每次比较相邻两个元素，如果其大小顺序错误就交换位置</b>。<br>遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br>这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。<br>(或者也可以让大的元素慢慢“沉”到后面去，这种写法就是右部为有序区域）<br>冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># code 写法并不唯一，思路是固定的：通过对比相邻元素，然后交换</span></span><br><span class="line"><span class="comment"># 我这里的写法是每一轮把剩余的一个最大值, 送到右侧去</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Bubble_Sort</span>(<span class="params">x</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(x)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">            <span class="keyword">if</span> x[j] &gt; x[j+<span class="number">1</span>]:</span><br><span class="line">                x[j], x[j+<span class="number">1</span>] = x[j+<span class="number">1</span>], x[j]</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><blockquote><p>上述 code 思路：<br>不断地从左侧对比出最大的值，按次序放在右侧<br>第一轮:要比较的相邻索引是 (0, 1), (1,2), … ,(N-2, N-1), 遍历完后，最大数落在 N-1 位置<br>第二轮:要比较的相邻索引是 (0, 1), (1,2), … ,(N-3, N-2), 遍历完后，最大数落在 N-2 位置<br>…<br>倒数第二轮，要比较的相邻索引是 (0, 1), (1,2), 遍历完后，最大数落在 2 位置<br>最后一轮，数据对索引是 (0, 1), 遍历完后，最大数落在 1 位置<br>故而，如果用 i 代表每一轮的对比的末尾，i 从 N-1 到 1，即 i in range(N-1,0,-1)<br>   用 j 来代表数据待比较区域的索引，j 从 0 到 i-1，即 j in range (0, i)</p></blockquote><h3 id="3-1-2-选择排序"><a href="#3-1-2-选择排序" class="headerlink" title="3-1-2 选择排序"></a>3-1-2 选择排序</h3><p>每次遍历时，都将未排序区域的第一个值，假设为本次遍历的最小值，<br>然后开始遍历未排序区域，直到找到未排序区域中最小的值的序号min_Index，<br>遍历完一次后，比较 min_Index 位置的值 与 假设的最小值的大小，不及预期，则可以交换位置，同时，未排序区域减少一个位置。<br>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。<br>==排序过程中，左侧区域是已排序区域，右侧区域是未排序区域。==</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">SelectSort</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-<span class="number">1</span>):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,N):</span><br><span class="line">            min_index = j <span class="keyword">if</span> (a[j]&lt;a[min_index]) <span class="keyword">else</span> min_index</span><br><span class="line">        <span class="keyword">if</span> i != min_index:</span><br><span class="line">            a[i], a[min_index] = a[min_index], a[i]</span><br><span class="line">    <span class="keyword">return</span> a </span><br></pre></td></tr></table></figure><blockquote><p>code 思路  </p><p>第一轮:假设 0位置最小，从 1~N-1位置上找到最小的，与0位置比较，看谁更小，更小的放在0位置<br>第二轮:假设 1位置最小，从 2~N-1位置上找到最小的，与1位置比较，看谁更小，更小的放在1位置<br>. . .<br>倒数第二轮，假设 N-3位置最小, 从 N-2~N-1位置上找到最小的，与N-3位置比较，看谁更小，更小的放在N-3位置<br>最后一轮，假设 N-2位置最小, 从 N-1位置上找到最小的，与N-2位置比较，看谁更小，更小的放在N-2位置<br>故而，如果用 i 代表每一轮的假设最小位置，则 i 从 0 到 N-2，即 i in range(0,N-1)<br>          用 j 来代表数据每一轮寻找区域的起始值，则 j 从 i+1 到 N-1，即 j in range(i+1,N)  </p></blockquote><h3 id="3-1-3-插入排序"><a href="#3-1-3-插入排序" class="headerlink" title="3-1-3 插入排序"></a>3-1-3 插入排序</h3><p>工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。和打扑克时整理排序类似。<br>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">InsertSort</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> a[j]&gt;a[j+<span class="number">1</span>]:</span><br><span class="line">                a[j], a[j+<span class="number">1</span>] = a[j+<span class="number">1</span>], a[j]</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><blockquote><p>code 思路  </p><p>不断地将右侧未排序区域的第一个位置，插入到左侧已排序区域的合适位置上<br>只有1个元素时不用排序，所以右侧未排序区域的起始位置是1<br>第一轮:取得 1 位置上的值，与0位置比较，看谁更小，在合适的位置放下<br>第二轮:取得 2 位置上的值，与0~1位置比较，看谁更小，在合适的位置放下<br>。。。<br>倒数第二轮，取得 N-2 位置上的值，与0~N-3位置比较，看谁更小，在合适的位置放下<br>最后一轮，取得 N-1 位置上的值，与0~N-2位置比较，看谁更小，在合适的位置放下<br>故而，如果用 i 代表每一轮获得的起始位置，则 i 从 1 到 N-1，即 i in range(1,N)<br>          用 j 来代表数据已排序的位置，则 j 从0 到 i-1，即 j in range(0,i)<br>          <b>但要注意，我们进行对比时，是在已排序区域从右往左对比更方便，因为离i更近。<br>          所以 j 在取的时候，是先看离 i 位置近的 j， 即反过来， j in range(i-1, -1, -1) </b>  </p></blockquote><h3 id="3-1-4-希尔排序"><a href="#3-1-4-希尔排序" class="headerlink" title="3-1-4 希尔排序"></a>3-1-4 希尔排序</h3><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ShellSort</span>(<span class="params">a, d=<span class="number">4</span></span>):</span><br><span class="line">    N = <span class="built_in">len</span>(a)</span><br><span class="line">    gap = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> gap &lt; N//d:</span><br><span class="line">        gap = d*gap+<span class="number">1</span></span><br><span class="line">    <span class="comment"># gap 可以理解为分组的数量</span></span><br><span class="line">    <span class="comment"># 这里的 d 其实就是第一次分组后，组内元素的上限</span></span><br><span class="line">    <span class="comment"># 所以这里可以理解为，初始分成gap组，每组内的元素最多d个</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-gap, -<span class="number">1</span>, -gap):</span><br><span class="line">                <span class="keyword">if</span> a[j] &gt; a[j+gap]:</span><br><span class="line">                    a[j+gap], a[j] = a[j], a[j+gap]</span><br><span class="line">        <span class="comment"># 随着循环进行，要将分组数调小</span></span><br><span class="line">        gap = gap//d</span><br><span class="line">    <span class="keyword">return</span> a  </span><br></pre></td></tr></table></figure><h3 id="3-1-5-归并排序"><a href="#3-1-5-归并排序" class="headerlink" title="3-1-5 归并排序"></a>3-1-5 归并排序</h3><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>可以使用递归的方法来实现，<b>每一次都将数据分为左右两块，每一次都分别让左右两块各自排好序，然后再将两块 Merge 起来，</b>从而 整体有序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">MergeSort</span>(<span class="params">a,L,R</span>):</span><br><span class="line">    <span class="keyword">if</span> L&gt;=R:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    M = L+(R-L)//<span class="number">2</span></span><br><span class="line">    Mergesort(a, L, M)</span><br><span class="line">    MergeSort(a, M+<span class="number">1</span>, R)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Merge stage</span></span><br><span class="line">    p1,p2 = L,M+<span class="number">1</span></span><br><span class="line">    res =[] <span class="comment"># 归并排序申请了辅助空间，所以是 外部排序</span></span><br><span class="line">    <span class="keyword">while</span> p1 &lt;=M <span class="keyword">and</span> p2 &lt;=R:</span><br><span class="line">        <span class="comment"># 分离双指针</span></span><br><span class="line">        <span class="keyword">if</span> a[p1]&lt;=a[p2]:</span><br><span class="line">            res.append(a[p1])</span><br><span class="line">            p1+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(a[p2])</span><br><span class="line">            p2+=<span class="number">1</span></span><br><span class="line">    <span class="comment"># 循环结束后，p1、p2中至少有一个已经越界，下面对没有越界的部分连接</span></span><br><span class="line">    <span class="keyword">while</span> p1&lt;=M:</span><br><span class="line">        res.append(a[p1])</span><br><span class="line">        p1+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> p2&lt;=R:</span><br><span class="line">        res.append(a[p2])</span><br><span class="line">        p2+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res)): <span class="comment"># len(res) = R-L+1</span></span><br><span class="line">        a[L+k] = res[k]</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><h3 id="3-1-6-堆排序"><a href="#3-1-6-堆排序" class="headerlink" title="3-1-6 堆排序"></a>3-1-6 堆排序</h3><p>堆排序需要涉及到一些二叉树的基础知识，但不需要完全了解二叉树，只需要在草稿纸上模拟一下就行。  </p><p>这里提前介绍一下 大/小根堆：<br><strong>大根堆/小根堆，就是属于完全二叉树；</strong><br>大根堆：根节点是整棵树的最大值；并且对于每一棵子树而言，其最大值也都在子树根节点<br>小根堆：根节点是整棵树的最小值；并且对于每一棵子树而言，其最小值也都在子树根节点<br>下图左侧是大根堆的示意图，右侧是小根堆的示意图：  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/3_1_1_6.webp" width="70%">  </p><h4 id="3-1-6-1-数组转成大根堆形式"><a href="#3-1-6-1-数组转成大根堆形式" class="headerlink" title="3-1-6-1 数组转成大根堆形式"></a>3-1-6-1 数组转成大根堆形式</h4><p>① HeapInsert 操作  </p><p>HeapInsert 操作，就是对于新加入数组的元素，我们将其移动到大（小）根堆的合适的位置。<br>对于新加入的元素，假设其数组索引是 i, 那么在堆中，它的父亲结点的索引就是 int((i-1)/2)。可以自己在画一下完全二叉树验证这个关系。HeapInsert 操作就是将新元素，不断地与其父亲结点的值比较大小，假设是构造大根堆，那新元素若比父亲结点大，它就往上移动（与父亲结点交换），然后再与新的父亲结点比较大小……直到无法再向上移动，即找到它合适的位置了。示意图如下：  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/3_1_1_7.webp" width="100%">   </p><p>这种方式与之前讲的 插入排序 的思路很像，就是对于下一个数， 将它插入到前面结构的合适的位置上，所以这种构造大（小）根堆的方式也被称为 HeapInsert.  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">HeapInsert</span>(<span class="params">x, index</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    # 该函数只是对index位置的值，进行heap insert 操作;时间复杂度：O(logN)</span></span><br><span class="line"><span class="string">    # 因为最多往上移动的次数 就是 该二叉树的高度：log_2(N)</span></span><br><span class="line"><span class="string">    # 如果要将一个随机数组构造成 大（小）根堆，则需遍历每一个元素，应用此函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 这里直接用int取整即可，(//向下取整，会在-0.5时取到-1,当index=0时使用//无法正确取数，所以用int)，</span></span><br><span class="line">    father = <span class="built_in">int</span>((index-<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> x[index] &gt; x[father]:  <span class="comment">#  此处改为小于即可用于生成小根堆</span></span><br><span class="line">        x[index], x[father] = x[father], x[index]</span><br><span class="line">        <span class="comment"># 与父亲结点交换后，index 和 father 都要更新</span></span><br><span class="line">        index = father</span><br><span class="line">        father = <span class="built_in">int</span>((index-<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>那么，如果我们对数组中的元素，从左往右依次进行 HeapInsert 操作，最后就讲这整个数组的数据转变成了大根堆的形式：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">TurnToMaxHeap</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    问题一：将一个完全二叉树（实际结构是数组）转换成大根堆</span></span><br><span class="line"><span class="string">    时间复杂度：O(N*logN)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="comment"># 从 0 开始，将每一个 a[k] 视为新加入的数，构造大根堆</span></span><br><span class="line">        arr = HeapInsert(arr, i)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><p>② Heapify 操作  </p><p>上面的 HeapInsert 操作是对新来的数字“往上浮”，这里讲的是对原有的数字“往下沉”。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Heapify</span>(<span class="params">a, index, heapsize</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    heapify过程：将一个原本是大根堆的完全二叉树，根结点的值发生变化，要重新变成大根堆的过程.</span></span><br><span class="line"><span class="string">    方法：index位置的元素和它的左右孩子比较，如果小于它的左右孩子那么就往下沉；否则不动</span></span><br><span class="line"><span class="string">    时间复杂度Olog(N)</span></span><br><span class="line"><span class="string">    heapsize小于等于数组最后一个索引(也就是表示0~heapsize区间是个大根堆)；</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    left = <span class="number">2</span> * index +<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= heapsize:</span><br><span class="line">        right = left + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 先比较左右孩子中更大的结点</span></span><br><span class="line">        large = right <span class="keyword">if</span> (right &lt;= heapsize <span class="keyword">and</span> a[right]&gt;a[left]) <span class="keyword">else</span> left</span><br><span class="line">        <span class="comment"># 再比较当前结点与最大孩子的值</span></span><br><span class="line">        large = large <span class="keyword">if</span> (a[large] &gt; a[index]) <span class="keyword">else</span> index</span><br><span class="line">        <span class="comment"># 如果最大的是当前结点，说明不需要下沉了，停止循环</span></span><br><span class="line">        <span class="keyword">if</span> large == index:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 否则就交换位置，并更新索引，准备下一轮循环</span></span><br><span class="line">        a[index], a[large] = a[large], a[index]</span><br><span class="line">        index = large</span><br><span class="line">        left = <span class="number">2</span>*index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a </span><br></pre></td></tr></table></figure><p>因为我们上面code的前提条件是，假设“<b>一个原本是大根堆的完全二叉树，根结点的值发生变化，重新调整根结点的位置，使其恢复为一个大根堆</b>”；所以对于一个本来不是大根堆的完全二叉树，想要利用Heapify的思路转换成大根堆，就<b>从下往上进行变换。</b><br>即从倒数第二层开始，让每一个子树都称为大根堆，不断往上扩展。子树变成大根堆后，它的父节点就可以视为外层大根堆被改变了值的那个根结点，又将该父结点下沉到合适位置，又再网上扩张一层。具体实现code 如下：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BuildMaxHeap</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;时间复杂度O(N)&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    N = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(math.floor(N/<span class="number">2</span>), -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        a = Heapify(a, i, N-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> a </span><br></pre></td></tr></table></figure><p><strong>为何用这种方法构造大根堆的时间复杂度是O(N)? 解释如下</strong>：</p><blockquote><p>对于一棵满的完全二叉树，二叉树一共有 N 个结点。则：<br>倒数第1层有 $\frac{N}{2}$ 个结点，每个结点遍历1次，最多往下沉 0 次，总共就是 $\frac{N}{2}$ 次操作； </p><p>倒数第2层有 $\frac{N}{4}$ 个结点，每个结点遍历1次，每个结点最多往下沉 1 次，总共就是 $\frac{2N}{4}$ 次操作； </p><p>倒数第3层有 $\frac{N}{8}$ 个结点，每个结点遍历1次，每个结点最多往下沉 2 次，总共就是 $\frac{3N}{8}$ 次操作；<br>……<br>所以时间复杂度为 $T(N) = \frac{N}{2} + \frac{2N}{4} + \frac{3N}{8} + \cdots $<br>故而  $T(N) = 2T(N) -T(N) = N + \frac{N}{2} + \frac{N}{4} + \frac{N}{8} + \cdots - \sigma $ 这是一个等比数列，结果是 $2N$，所以时间复杂度就是 $O(N)$。  </p></blockquote><h4 id="3-1-6-2-堆排序部分"><a href="#3-1-6-2-堆排序部分" class="headerlink" title="3-1-6-2 堆排序部分"></a>3-1-6-2 堆排序部分</h4><p>假设是按照从小到大排序，那么每一次构造一个大根堆后，未排序区域的最大值就到了根结点，那么只要将该数与未排序区域末尾数交换，则该区域的最大数就到了该区域的末尾。同时未排序区域缩小一格，然后恢复未排序区域的大根堆结构，重复操作。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">HeapSort</span>(<span class="params">a</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="comment"># 先构建大根堆</span></span><br><span class="line">    a = buildMaxHeap(a)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(N-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 每一次都将顶点和最后最后一个数进行交换，则最大数就被移动到数组末尾</span></span><br><span class="line">        a[<span class="number">0</span>], a[k] = a[k], a[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 相当于 a[0] 的位置发生了变化，正好用heapify重新调整为大根堆</span></span><br><span class="line">        <span class="comment"># 注意刚刚的最大值已经是有序区域中了，所以heapsize也要每次缩小一次</span></span><br><span class="line">        a = Heapify(a,<span class="number">0</span>,k-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    可以看到，不管最开始采用哪种方法构造大根堆，O(N)或者O(N*logN)都无所谓</span></span><br><span class="line"><span class="string">    后面不断交换位置的操作才是影响时间复杂度的大头，这部分是 O(N*logN)</span></span><br><span class="line"><span class="string">    所以堆排序的总体时间复杂度是 O(N*logN)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="3-1-7-快速排序"><a href="#3-1-7-快速排序" class="headerlink" title="3-1-7 快速排序"></a>3-1-7 快速排序</h3><p>快速排序采用的思想也是分治法，先将数组大致分为有序的几块区域，再对各个区域内分为几个有序的区域，直到区域已经不可再细分，这样整个数组也就有序了。下面只给出快速排序的code，至于其推导过程，见下一章【快速排序深入讨论】。  </p><p>快速排序虽然只用了几个额外的变量，<b><font color="red">但是其空间复杂度是O(logN)</font></b>&lt;/font&gt;!<br>这是因为快速排序使用递归操作，递归操作会调用系统栈，这个系统栈的深度是O(logN)。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">QuickSort</span>(<span class="params">a, L, R</span>):</span><br><span class="line">    <span class="keyword">if</span> L &gt;= R:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="comment"># partition stage:</span></span><br><span class="line">    <span class="comment"># 随机抽取一个基础值</span></span><br><span class="line">    key = random.randint(L, R)</span><br><span class="line">    a[key], a[R] = a[R], a[key]</span><br><span class="line">    <span class="comment"># 将基础值放在最右方便下面写code</span></span><br><span class="line">    key = R</span><br><span class="line">    p1, p2 = L-<span class="number">1</span>, R</span><br><span class="line">    <span class="comment"># 这一段partition已经是经过荷兰国旗问题优化后的partition了，原始的快速排序不是这么写</span></span><br><span class="line">    i = p1+<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; p2:</span><br><span class="line">        <span class="keyword">if</span> a[i] &lt; a[key]:</span><br><span class="line">            <span class="comment"># 如果 i 位置的值更小，i与小于区域的下一位的数交换，小于区域扩张1位</span></span><br><span class="line">            a[i], a[p1+<span class="number">1</span>] = a[p1+<span class="number">1</span>], a[i]</span><br><span class="line">            p1 += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> a[i] == a[key]:</span><br><span class="line">            <span class="comment"># 如果相等，i直接往后过，两个区域都不变化</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果i位置的值更大，i与大于区域的左侧数交换，大于区域扩张(p2减少1)</span></span><br><span class="line">            a[i], a[p2-<span class="number">1</span>] = a[p2-<span class="number">1</span>], a[i]</span><br><span class="line">            p2 -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 同时i不变，因为i位置的数刚从大于区域的左侧被交换过去，还没判断呢</span></span><br><span class="line">    <span class="comment"># 循环结束后 i==p2，i位置的值一定大于等于key位置</span></span><br><span class="line">    <span class="comment"># 将基础值与i位置进行交换</span></span><br><span class="line">    a[i], a[key] = a[key], a[i]</span><br><span class="line">    <span class="comment"># recursion stage</span></span><br><span class="line">    QuickSort(a, L, p1)</span><br><span class="line">    QuickSort(a, p2+<span class="number">1</span>, R)</span><br><span class="line">    <span class="keyword">return</span> a </span><br></pre></td></tr></table></figure><h3 id="3-1-8-计数排序"><a href="#3-1-8-计数排序" class="headerlink" title="3-1-8 计数排序"></a>3-1-8 计数排序</h3><p>要求元素一定是<strong>整数！整数！</strong>且元素值的<strong>范围最好不要太大</strong>，一般来说几万以内应该都还算比较快。<br><b>计数排序不是比较排序，排序的速度快于任何比较排序算法，只不过有上一行提到的先决条件</b>。<br>基本思路如下：<br>① <strong>找出待排序的数组中最大和最小的元素</strong>，因为计数的数组Count的长度取决于待排序数组中数据的范围，<br>② <strong>创建计数数组Count</strong>，长度等于待排序数组的最大值与最小值的差加上1,元素默认值为0.<br>③ <strong>遍历原数组中的元素，以原数组中的元素值作为Count数组的索引</strong>，以原数组中的元素出现次数作为Count数组的元素值。<br>    比如原始数组中有10个66，则Count[10]=66<br>④ <strong>按照count索引从小到大（也就是原始数组元素值从小到大）进行遍历</strong>，排布好新的数组</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">CountSort_1</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;最基础的情况，元素都为非负整数&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 1.获得最大值</span></span><br><span class="line">    <span class="comment"># 如果不想用自带的max函数，那其实也可以遍历一遍数组，时间复杂度也是O(N)</span></span><br><span class="line">    <span class="comment"># 因为计数排序本来就是O(N+K)，时间复杂度是忽略系数的，O(N) + O(N) 还是 O(N)</span></span><br><span class="line">    max_v = <span class="built_in">max</span>(a)</span><br><span class="line">    <span class="comment"># 2.创建辅助数组</span></span><br><span class="line">    count_list = [<span class="number">0</span>]*(max_v+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 3.统计原数组的元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">        count_list[a[k]] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 4.对原始数组的元素按顺序排布</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(count_list)):</span><br><span class="line">        <span class="keyword">while</span> count_list[k] &gt; <span class="number">0</span>:</span><br><span class="line">            a[i] = k</span><br><span class="line">            count_list[k] -= <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 这一段 while 循环体虽然可以改写成如下形式：</span></span><br><span class="line">        <span class="comment"># if count_list[k] &gt; 0:</span></span><br><span class="line">        <span class="comment">#     a[i:i+count_list[k]] = [k]*count_list[k]</span></span><br><span class="line">        <span class="comment">#     i += count_list[k]</span></span><br><span class="line">        <span class="comment"># 但是 python在实际操作中会 在等号右边创建一个临时的数组，然后赋值给左边</span></span><br><span class="line">        <span class="comment"># 这就相当于使用了 额外空间了，所以不建议这么写</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CountSort_2</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;若可能有负数出现，只需要引入一个bias即可&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 1.获得最大值，最小值</span></span><br><span class="line">    min_v, max_v = <span class="built_in">min</span>(a), <span class="built_in">max</span>(a)</span><br><span class="line">    <span class="comment"># bias = 0-min_v if min_v &lt; 0 else 0</span></span><br><span class="line">    bias = - <span class="built_in">min</span>(<span class="number">0</span>, min_v)</span><br><span class="line">    <span class="comment"># 2.创建辅助数组</span></span><br><span class="line">    count_list = [<span class="number">0</span>]*(max_v+<span class="number">1</span>+bias)</span><br><span class="line">    <span class="comment"># 3.统计原数组的元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">        count_list[a[k]+bias] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 4.对原始数组的元素按顺序排布</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(count_list)):</span><br><span class="line">        <span class="keyword">while</span> count_list[k] &gt; <span class="number">0</span>:</span><br><span class="line">            a[i] = k - bias</span><br><span class="line">            count_list[k] -= <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a </span><br><span class="line">    <span class="comment"># 可见这个写法不管有没有负数, 其实都能跑通</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>从代码中可以看出，计数排序的时间复杂度是 O(n+k),  空间复杂度是O(k)<br>其中n是数组规模， k是数组值域范围 max_v - min_v + 1</p><h3 id="3-1-9-基数排序"><a href="#3-1-9-基数排序" class="headerlink" title="3-1-9 基数排序"></a>3-1-9 基数排序</h3><p>所谓的基数，就是指的按照数字的哪一位来排序。<br>比如按照个位来排序，基数就是 10^0;<br>按照十位数进行排序，基数就是 10^1;<br>按照百位数进行排序：基数就是 10^2;<br>基数排序也不用进行比较，因为每一位数字都是 0-9组成的，天然有序，所以只要按照每一位的数字，将数字分到对应的分组去，那么对于当前位数来说，各个组之间就按照0-9排序了。<br>对于每一位都来一次，就能够实现整体有序。  </p><p>基数排序能够实现有序的关键点在于，当按照分组分号之后，从分组中取出来排布时，<b>各个分组的元素要做到先入先出</b>。 因为同一个分组内的元素，当前考察的基数那一位，肯定是相同的，但是其进入分组的顺序，是由上一轮的考察基数位的大小顺序决定的。  </p><p>举个例子：比如 58和51 被分到了一个分组，可以肯定，当前考察的是十位，因为它们的十位都是数字5，这才有可能被分到一个分组。那么上一轮考察的就是个位，个位分别是 1 和 8，那么可以肯定，1这个分组的数字是排在8这个分组的数字之前的。<br>所以在考察十位上的数字进行分组时，一定是 51先遍历到，被分到5号组，然后才是58被遍历到，也分到5号组。所以组内的顺序是: [ 51, 58 ]。那么从分组内取出进行还原时，就要保证先取出 51， 再取出 58。所以各个分组，其实可以从逻辑上视为一个队列。当然不必真的使用队列，只要使用 list 时注意先入先出的顺序就好。  </p><p><b>基数排序通常也是只能处理<font color="red">非负 整数</font>，且要求数目不要过大。</b>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">RadixSort</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;最基础的情况，元素都为非负整数&#x27;&#x27;&#x27;</span></span><br><span class="line">    max_v = <span class="built_in">max</span>(a)</span><br><span class="line">    <span class="comment"># d 这里在统计最高的位数</span></span><br><span class="line">    <span class="comment"># d=0</span></span><br><span class="line">    <span class="comment"># while max_value &gt;0:</span></span><br><span class="line">    <span class="comment">#     d+=1</span></span><br><span class="line">    <span class="comment">#     max_value//=10</span></span><br><span class="line">    d = <span class="built_in">len</span>(<span class="built_in">str</span>(max_v))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">        radix = <span class="number">10</span> ** i <span class="comment"># radix 代表本次循环基于哪一个位</span></span><br><span class="line">        <span class="comment"># 每一轮都是重新初始化 Groups</span></span><br><span class="line">        Groups = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="comment"># 初始化从0到9，共10个分组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> a:</span><br><span class="line">            digit = num // radix % <span class="number">10</span></span><br><span class="line">            <span class="comment"># 按照当前位的数字，将原始数据分别装入不同的group中</span></span><br><span class="line">            Groups[digit].append(num)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 该 print 函数能打印各个阶段 数字装入分组后的状况，</span></span><br><span class="line">        <span class="comment"># 可以取消注释后打印中间结果，帮助理解</span></span><br><span class="line">        <span class="comment"># print(i, Groups)        </span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> Groups:</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> group:</span><br><span class="line">                a[j] = num </span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p><b>稍加改动也能处理出现<font color="red">负整数</font>的情况</b><br>对于负数部分，我们需要在设置一个长度为 10 的分组，用来装 -9 — 0 。<br>这里需要注意的点，<br>① 10 和 -10 与 10% 进行求模运算后，结果都是 0；但是这两个数明显不能都放入 0 号组，<br>     10 是可以放入 0 号分组的，但是 -10 却是一个负数，它的实际位置应该比0还小。<br>      为了方便讨论，我们这里称呼 -10 % 10 为 -0；在负数部分的分组中，排在最大的位置。<br>       即负数的10个分组对应的数字为：[-9], [-8], …, [-1], [-0]<br>② 在求每一位上的数字时，我们之前使用的是 整除号：// 。但是整除号是向下进位，对负数使用整除号时，会往远离 0 的方向进位。 比如 -18 // 10 = -2; 但是我们希望是得到 - 1，这样能照搬非负整数部分的处理，所以就是希望向 0 靠拢。可以使用 int函数。int(-18 / 10 ) = -1.    </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">RadixSort_2</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;要处理的数据中可能出现 负整数&#x27;&#x27;&#x27;</span></span><br><span class="line">    max_v, min_v = <span class="built_in">max</span>(a), <span class="built_in">min</span>(a)</span><br><span class="line">    <span class="comment"># d 这里在统计最高的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果存在负数，str之后会有&#x27;-&#x27;，即比数字本身多了1位，所以需要判断</span></span><br><span class="line">    L_1 = <span class="built_in">len</span>(<span class="built_in">str</span>(max_v)) <span class="keyword">if</span> max_v &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">len</span>(<span class="built_in">str</span>(max_v))-<span class="number">1</span></span><br><span class="line">    L_2 = <span class="built_in">len</span>(<span class="built_in">str</span>(min_v)) <span class="keyword">if</span> min_v &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">len</span>(<span class="built_in">str</span>(min_v))-<span class="number">1</span></span><br><span class="line">    d = <span class="built_in">max</span>(L_1, L_2)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">        radix = <span class="number">10</span> ** i <span class="comment"># radix 代表本次循环基于哪一个位</span></span><br><span class="line">        Groups = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="comment"># 初始化从 0 到9，共10个分组</span></span><br><span class="line">        Groups_neg = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="comment"># 初始化从-9 到-0，共10个分组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> a:</span><br><span class="line">            <span class="comment"># digit = num // radix % 10</span></span><br><span class="line">            digit = <span class="built_in">int</span>(num / radix) % <span class="number">10</span></span><br><span class="line">            <span class="comment"># 注意: -10 和 10 与 10 求模运算后都得 0</span></span><br><span class="line">            <span class="comment"># 但是二者的大小明显不一样</span></span><br><span class="line">            <span class="comment"># 为了便于理解，我们可以假设 10 % 10 = +0； -10 % 10 = -0</span></span><br><span class="line">            <span class="comment"># 按照当前位的数字的正负属性，将原始数据分别装入不同的group中</span></span><br><span class="line">            <span class="keyword">if</span> num &gt;= <span class="number">0</span>:</span><br><span class="line">                Groups[digit].append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 这里需要注意 -9 % 10 =1;...; -1 % 10 = 9; -10 % 10 = -0;</span></span><br><span class="line">                Groups_neg[digit-<span class="number">1</span>].append(num)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 该 print 函数能打印各个阶段 数字装入分组后的状况，</span></span><br><span class="line">        <span class="comment"># 可以取消注释后打印中间结果，帮助理解</span></span><br><span class="line">        <span class="comment"># print(i, Groups_neg, &#x27;---&#x27;, Groups)</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 先取出负数部分</span></span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> Groups_neg:</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> group:</span><br><span class="line">                a[j] = num </span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 再取出正数部分</span></span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> Groups:</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> group:</span><br><span class="line">                a[j] = num </span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p>从代码中可以看出，基数排序的时间复杂度是 O(n*k),  空间复杂度是O(n)<br>其中n是数组规模， k是数组中位数最长的一个数的宽度   </p><h3 id="3-1-10-桶排序"><a href="#3-1-10-桶排序" class="headerlink" title="3-1-10 桶排序"></a>3-1-10 桶排序</h3><p>将数据分到若干个桶（分组）中，每个桶的元素再进行单独排序。<br>通常是按照数值大小进行分组，比如若一个数组最大数为 200，最小数为1，就可以以 20的区间进行分组，分10个桶。但是有一些题目可能也会根据另外一些属性进行分组，总之要看具体情况。<br>对每个桶内的数据进行排序操作，也是看数据的具体情况，可以使用不同的排序方法。<br>最后将各个桶内的元素组合到一起，完成最终排序。 </p><h2 id="3-1-2-二分查找"><a href="#3-1-2-二分查找" class="headerlink" title="3-1-2 二分查找"></a>3-1-2 二分查找</h2><p>二分查找的时间复杂度是O(logN),<a href="https://www.suibibk.com/topic/678695904085016576/">参考链接 </a> </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BinarySearch</span> (arr, L, R, x): </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 基本判断</span></span><br><span class="line">    <span class="keyword">if</span> R &gt;= L: </span><br><span class="line">  </span><br><span class="line">        mid = L + <span class="built_in">int</span>((R - L)/<span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 元素整好的中间位置</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] == x: </span><br><span class="line">            <span class="keyword">return</span> mid </span><br><span class="line">          </span><br><span class="line">        <span class="comment"># 元素小于中间位置的元素，只需要再比较左边的元素</span></span><br><span class="line">        <span class="keyword">elif</span> x &lt; arr[mid]: </span><br><span class="line">            <span class="keyword">return</span> BinarySearch (arr, L, mid-<span class="number">1</span>, x) </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 元素大于中间位置的元素，只需要再比较右边的元素</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> BinarySearch (arr, mid+<span class="number">1</span>, R, x) </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="comment"># 不存在</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2-3 数组双指针</title>
      <link href="/Data-Structure/DS_23_array_double_pointer_exercises.html"/>
      <url>/Data-Structure/DS_23_array_double_pointer_exercises.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1"> <h1 id="2-3-数组双指针"><a href="#2-3-数组双指针" class="headerlink" title="2-3 数组双指针"></a>2-3 数组双指针</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p><b>版权声明：以下题目均来自 <a href="https://leetcode.cn">LeetCode</a>， 仅仅提供跳转到力扣官网的链接，不在本页面出现题目内容，本文章内容禁止商业用途。</b>  </p><p>指针的名字来源于链表，代表的是指向结点地址的位置变量。可以迁移到数组这边来，代表存储数组索引的变量。<br>而双指针的意思就是用两个变量来维护不同的索引，从而实现特定的功能。  </p><h2 id="2-3-1-对撞指针"><a href="#2-3-1-对撞指针" class="headerlink" title="2.3.1 对撞指针"></a>2.3.1 对撞指针</h2><p>所谓对撞指针，就是指的初始状态的两个指针一个在左，一个在右；终止条件为左指针等于右指针。  </p><p><span id="2.3.1"></span>  </p><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">LeetCode 167.两数之和II-输入有序数组</a></td><td><a href="#2.3.1.1">题解2.3.1.1</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/reverse-string/">LeetCode 344.反转字符串</a></td><td><a href="#2.3.1.2">题解2.3.1.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/reverse-vowels-of-a-string/">LeetCode 345.反转字符串中的元音字母</a></td><td><a href="#2.3.1.3">题解2.3.1.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/valid-palindrome/">LeetCode 125.验证回文串</a></td><td><a href="#2.3.1.4">题解2.3.1.4</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21.调整数组顺序使奇数位于偶数前面</a></td><td><a href="#2.3.1.5">题解2.3.1.5</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/boats-to-save-people/">LeetCode 881.救生艇</a></td><td><a href="#2.3.1.6">题解2.3.1.6</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/container-with-most-water/">LeetCode 11.盛最多水的容器</a></td><td><a href="#2.3.1.7">题解2.3.1.7</a></td></tr><tr><td>⑧</td><td><a href="https://leetcode.cn/problems/valid-triangle-number/">LeetCode 611.有效三角形的个数</a></td><td><a href="#2.3.1.8">题解2.3.1.8</a></td></tr><tr><td>⑨</td><td><a href="https://leetcode.cn/problems/3sum/">LeetCode 15.三数之和</a></td><td><a href="#2.3.1.9">题解2.3.1.9</a></td></tr><tr><td>⑩</td><td><a href="https://leetcode.cn/problems/3sum-closest/description/">LeetCode 16.最接近的三数之和</a></td><td><a href="#2.3.1.10">题解2.3.1.10</a></td></tr><tr><td>⑪</td><td><a href="https://leetcode.cn/problems/4sum/">LeetCode 18.四数之和</a></td><td><a href="#2.3.1.11">题解2.3.1.11</a></td></tr><tr><td>⑫</td><td><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">LeetCode 977.有序数组的平方</a></td><td><a href="#2.3.1.12">题解2.3.1.12</a></td></tr><tr><td>⑬</td><td><a href="https://leetcode.cn/problems/sort-colors/">LeetCode 75.颜色分类</a></td><td><a href="#2.3.1.13">题解2.3.1.13</a></td></tr><tr><td>⑭</td><td><a href="https://leetcode.cn/problems/trapping-rain-water/">LeetCode 42.接雨水</a></td><td><a href="#2.3.1.14">题解2.3.1.14</a></td></tr><tr><td>⑮</td><td><a href="https://leetcode.cn/problems/longest-mountain-in-array/">LeetCode 845.数组中的最长山脉</a></td><td><a href="#2.3.1.15">题解2.3.1.15</a></td></tr><tr><td>⑯</td><td><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">LeetCode 978.最长湍流子数组</a></td><td><a href="#2.3.1.16">题解2.3.1.16</a></td></tr></tbody></table></div><p><span id="2.3.1.1"></span>  </p><h3 id="2-3-1-1-两数之和II-输入有序数组"><a href="#2-3-1-1-两数之和II-输入有序数组" class="headerlink" title="2.3.1.1 两数之和II -输入有序数组"></a>2.3.1.1 两数之和II -输入有序数组</h3><p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">LeetCode 167.两数之和II-输入有序数组</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：数组已经有序，那可以从左右两侧向中间靠拢，逼近目标值。</font><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        N = <span class="built_in">len</span>(numbers)</span><br><span class="line">        L, R  =<span class="number">0</span>, N-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            <span class="keyword">while</span> L  &lt;R <span class="keyword">and</span>  numbers[L] +  numbers[R] &lt;target:</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> numbers[L] +  numbers[R] &gt; target:</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> L&lt; R <span class="keyword">and</span> numbers[L] +  numbers[R] == target:</span><br><span class="line">                <span class="keyword">return</span> [L+<span class="number">1</span>, R+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p><span id="2.3.1.2"></span></p><h3 id="2-3-1-2-反转字符串"><a href="#2-3-1-2-反转字符串" class="headerlink" title="2.3.1.2 反转字符串"></a>2.3.1.2 反转字符串</h3><p><a href="https://leetcode.cn/problems/reverse-string/">LeetCode 344.反转字符串</a> |  | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：这个题是对撞双指针的代表题目，也可以用它来进行数组逆序。</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            s[L], s[R] = s[R], s[L]</span><br><span class="line">            L += <span class="number">1</span></span><br><span class="line">            R -=<span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="2.3.1.3"></span>  </p><h3 id="2-3-1-3-反转字符串中的元音字母"><a href="#2-3-1-3-反转字符串中的元音字母" class="headerlink" title="2.3.1.3 反转字符串中的元音字母"></a>2.3.1.3 反转字符串中的元音字母</h3><p><a href="https://leetcode.cn/problems/reverse-vowels-of-a-string/">LeetCode 345.反转字符串中的元音字母</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路 1：先用哈希表记住元音字母原始的索引，然后按照索引逆序改变其对应位置的值。</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;思路1.使用哈希表&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        ll = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="comment"># from collections import defaultdict</span></span><br><span class="line">        <span class="comment"># dict_1 = defaultdict(str)</span></span><br><span class="line">        <span class="comment"># N = len(s)</span></span><br><span class="line">        <span class="comment"># for i in range(N):</span></span><br><span class="line">        <span class="comment">#     if ll[i] in &#x27;aeiouAEIOU&#x27;:</span></span><br><span class="line">        <span class="comment">#         dict_1[i] = ll[i]</span></span><br><span class="line">        <span class="comment"># 注释中的内容一行代码就可以写完</span></span><br><span class="line">        dict_1 = <span class="built_in">dict</span>((i,ch) <span class="keyword">for</span> (i,ch) <span class="keyword">in</span> <span class="built_in">enumerate</span>(ll) <span class="keyword">if</span> ch <span class="keyword">in</span> <span class="string">&#x27;aeiouAEIOU&#x27;</span>)</span><br><span class="line">        list_key = <span class="built_in">sorted</span>(<span class="built_in">list</span>(dict_1.keys()))</span><br><span class="line"></span><br><span class="line">        length = <span class="built_in">len</span>(list_key)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            ll[list_key[i]] =  dict_1[list_key[length-<span class="number">1</span>-i]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ll)</span><br></pre></td></tr></table></figure><font color="#3399FF">思路2：使用双指针，可以借鉴 [反转字符串](#2.3.1.2) 那道题的思路；只不过并不是直接反转，而是先要判断条件。由于我们反转的是元音字符，所以如果不是元音字符，双指针就不用停下来，而是一直向中间靠拢。一旦在相遇之前停下来，说明左右两个指针都遇到了元音字符，我们就将其交换位置（反转）即可；</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;思路2. 使用双指针&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(s)</span><br><span class="line">        ll = <span class="built_in">list</span>(s)</span><br><span class="line">        L, R = <span class="number">0</span>, N-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> ll[L] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;aeiouAEIOU&#x27;</span>:</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> ll[R] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;aeiouAEIOU&#x27;</span>:</span><br><span class="line">                R -=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> L&lt;R:</span><br><span class="line">                ll[L], ll[R] = ll[R], ll[L]</span><br><span class="line">                L +=<span class="number">1</span></span><br><span class="line">                R -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ll)</span><br></pre></td></tr></table></figure><p><span id="2.3.1.4"></span>  </p><h3 id="2-3-1-4-验证回文串"><a href="#2-3-1-4-验证回文串" class="headerlink" title="2.3.1.4 验证回文串"></a>2.3.1.4 验证回文串</h3><p><a href="https://leetcode.cn/problems/valid-palindrome/">LeetCode 125.验证回文串</a> | | <a href="#2.3.1">返回目录2.3.1</a>  </p><font color="#3399FF">思路：回文字符串就是以中心为对称的关系，而且题目中说明了只考虑小写字母和数字两种字符的情况，其他的就该跳过。  也是考虑使用对撞指针.</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 先将所有大写转成小写</span></span><br><span class="line">        s = s.lower()</span><br><span class="line">        <span class="comment"># 初始化双指针</span></span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> <span class="keyword">not</span> s[L].isalnum():</span><br><span class="line">                <span class="comment"># 对于非字母数字字符, 直接不考虑, 直接移动指针</span></span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> <span class="keyword">not</span> s[R].isalnum():</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> L &lt; R:</span><br><span class="line">                <span class="keyword">if</span> s[L] == s[R]:</span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果发现不相等的情况，说明左右不对称</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>   </span><br></pre></td></tr></table></figure><p><span id="2.3.1.5"></span>  </p><h3 id="2-3-1-5-调整数组顺序使奇数位于偶数前面"><a href="#2-3-1-5-调整数组顺序使奇数位于偶数前面" class="headerlink" title="2.3.1.5 调整数组顺序使奇数位于偶数前面"></a>2.3.1.5 调整数组顺序使奇数位于偶数前面</h3><p><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21.调整数组顺序使奇数位于偶数前面</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：该题和上面【 [反转字符串中的元音字母](#2.3.1.3) 】思路是一脉相承的；这里反转的不是元音字符，而是奇数or偶数，只需将判断条件做修改就行；</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exchange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        </span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[L] % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 题目要求奇数在前，所以如果是奇数，左指针就不用反转，直接指针把L指针右移</span></span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[R] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 题目要求偶数在后，所以如果是偶数，右指针就不用反转，直接指针把R指针左移</span></span><br><span class="line">                R -=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 前面两个循环执行完毕后，说明L遇到的是偶数，R遇到的是奇数，</span></span><br><span class="line">            <span class="comment"># 此时交换一下位置即可</span></span><br><span class="line">            <span class="keyword">if</span> L &lt; R:</span><br><span class="line">                nums[L], nums[R] = nums[R], nums[L]</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><span id="2.3.1.6"></span>  </p><h3 id="2-3-1-6-救生艇"><a href="#2-3-1-6-救生艇" class="headerlink" title="2.3.1.6 救生艇"></a>2.3.1.6 救生艇</h3><p><a href="https://leetcode.cn/problems/boats-to-save-people/">LeetCode 881.救生艇</a> || <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：该题说一艘船最多载两人，就容易联想到双指针。一个指针代表一个人，两个指针指向元素的和就是两个人的重量之和。只不过，这里有一个和之前的题目不同的点，那就是我们需要对数组先进行排序。为什么呢？因为如果两个人挤一条船，那么按照生活常识，我们肯定是希望尝试一个最轻的和一个最重的进行搭配，尽可能的利用船的承载能力。所以如果用双指针代表两个人，就需要一个是来自于轻的一组，一个是来自于重的一组，所以按照重量先排序，左侧的就是轻的，右侧的就是重的，就可以利用对撞双指针了。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numRescueBoats</span>(<span class="params">self, people: <span class="type">List</span>[<span class="built_in">int</span>], limit: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        people.sort()</span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(people)-<span class="number">1</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> L &lt;= R: </span><br><span class="line">        <span class="comment"># 注意, 这里的循环控制条件可以L==R, 因为 L==R时表示还剩一个人,这个人单独一艘船 </span></span><br><span class="line">            <span class="keyword">if</span> people[L] + people[R] &lt;= limit:</span><br><span class="line">                <span class="comment"># 如果较轻和较重的能够被一艘船容纳, 就刚好组成一对</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果较轻和较重的加起来比limit还大</span></span><br><span class="line">                <span class="comment"># 就将较重的用一艘船去容纳</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.3.1.7"></span>  </p><h3 id="2-3-1-7-盛水最多的容器"><a href="#2-3-1-7-盛水最多的容器" class="headerlink" title="2.3.1.7 盛水最多的容器"></a>2.3.1.7 盛水最多的容器</h3><p><a href="https://leetcode.cn/problems/container-with-most-water/">LeetCode 11.盛最多水的容器</a> | | <a href="#2.3.1">返回目录2.3.1</a>  </p><font color="#3399FF">思路：双指针代表的是 可以作为容器边界的所有位置的范围。在一开始，双指针指向数组的左右边界，表示 数组中所有的位置都可以作为容器的边界，每次将 <b>对应的数字较小的那个指针</b> 往 另一个指针 的方向移动一个位置，就表示我们认为 这个指针不可能再作为容器的边界了, 然后再比较当前装水容量和之前的装水容量, 看哪个更大即可。  > <b>因为水桶能装多少水，是最矮的那个边界决定的。> 意思是，如果不移动最矮的边界，而移动另一侧较高的边界，无论怎么移动，装水的容量都不可能变多。> 所以我们只好移动最矮的那个边界，看看移动它之后，是否能使得装水量变多。</b></font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">        water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">        <span class="comment"># 两个边界碰到一起之前, 能够装水</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> height[L] &lt;= height[R]:</span><br><span class="line">                water = <span class="built_in">max</span>(water, height[L]*(R-L))</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> height[L] &gt; height[R]:</span><br><span class="line">                water = <span class="built_in">max</span>(water, height[R]*(R-L))</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> water </span><br></pre></td></tr></table></figure><p><span id="2.3.1.8"></span>  </p><h3 id="2-3-1-8-有效三角形的个数"><a href="#2-3-1-8-有效三角形的个数" class="headerlink" title="2.3.1.8 有效三角形的个数"></a>2.3.1.8 有效三角形的个数</h3><p><a href="https://leetcode.cn/problems/valid-triangle-number/">LeetCode 611.有效三角形的个数</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：假设三条边分别为a,b,c;则满足三角形的条件为任意两边之和都大于第三边；如果知道a,b,c的大小关系，比如 a<=b<=c, <b>那么两小边之和大于长边就一定能形成三角形</=b<=c,></font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triangleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N =<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> N &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先从大到小排序</span></span><br><span class="line">        nums.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-<span class="number">2</span>):</span><br><span class="line">            <span class="comment"># 当前 i 位置的数左为最长边 lng； 另外两个小边就在[i+1, N-1]区间找</span></span><br><span class="line">            L, R = i+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;R:</span><br><span class="line">                <span class="comment"># 目标是期望 小边之和 &gt; 长边，即 a+b &gt; c</span></span><br><span class="line">                <span class="comment"># lng, mid, sht = nums[i], nums[L], nums[R]</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果 mid + sht 不够大，说明sht应该增大，即R侧应该往左移一次，找一个更大的sht</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt;= nums[L] + nums[R]:</span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># lng &lt; mid + sht</span></span><br><span class="line">                    <span class="comment"># 如果此时能满足条件, R位置充当最短边sht，则R左侧的更大的数更能成为sht</span></span><br><span class="line">                    <span class="comment"># 即从 L+1 ~ R位置的所有数都可以成为最短边 sht(使得mid + sht更大)</span></span><br><span class="line">                    <span class="comment"># 与mid (L位置的值)一起构造一对小边; sht可取的个数为  =&gt; R - L</span></span><br><span class="line">                    res += R - L</span><br><span class="line">                    <span class="comment"># 计数完之后，再将 L 右移一位，即 mid 减小一点，</span></span><br><span class="line">                    <span class="comment"># 这样会使得 mid + sht变小</span></span><br><span class="line">                    <span class="comment"># 看变小后的和是否还能大于lng</span></span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 使用双指针的核心就在这里, L和R靠拢时, mid+sht 的值是在缩小的</span></span><br><span class="line">                    <span class="comment"># 但只要大于lng, L和R遍历的范围就能够满足条件</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.3.1.9"></span>  </p><h3 id="2-3-1-9-三数之和"><a href="#2-3-1-9-三数之和" class="headerlink" title="2.3.1.9 三数之和"></a>2.3.1.9 三数之和</h3><p><a href="https://leetcode.cn/problems/3sum/">LeetCode 15.三数之和</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：此题和三角形那道题一样，只不过条件变为  nums[i] + nums[j] + nums[k] == 0 难点在于不能出现重复的三元组。如果我们先排序的话，然后遍历数组时，每次都将遍历的值，作为三元组开头的值，如果一旦发现这个开头值和上一次的开头值一样，那就说明重复，应该跳过。</font>  <ul><li><p>第一种代码写法 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-<span class="number">2</span>):</span><br><span class="line">            <span class="comment"># 如果三元组的开头值和上一次的开头值重复, 可能会出现重复三元组, 直接不考虑</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 每一次都在剩余可选范围内，维护左右两个指针</span></span><br><span class="line">            L, R = i+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;R:</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[L] + nums[R] &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 如果三数之和大于0, 就减小最大的数</span></span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[L] + nums[R] &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 如果三数之和小于0, 就增大中间数</span></span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 此时遇到满足条件的三个数</span></span><br><span class="line">                    <span class="keyword">if</span> res <span class="keyword">and</span> nums[i] == res[-<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">and</span> nums[L] == res[-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                        <span class="comment"># 若三个数中的前两个与之前的相同, 说明重复, 不添加进结果</span></span><br><span class="line">                        <span class="comment"># (因nums已经被排序过, 故重复的 L 一定会紧邻, 故可与rse[-1]进行比较)</span></span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res.append([nums[i], nums[L], nums[R]])</span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><p>第二种代码写法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 先从小到大排序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n-<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            L, R = i+<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                <span class="string">&#x27;&#x27;&#x27;这第二种写法就是在遍历L和R时, 直接判断L或R是否是紧邻重复出现</span></span><br><span class="line"><span class="string">                这第二种写法要考虑的条件比较细, 容易出现疏漏&#x27;&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">while</span> L&lt;R <span class="keyword">and</span> L&gt;i+<span class="number">1</span> <span class="keyword">and</span> nums[L-<span class="number">1</span>] == nums[L]:</span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> L&lt;R <span class="keyword">and</span> R &lt; n-<span class="number">1</span> <span class="keyword">and</span> nums[R+<span class="number">1</span>] == nums[R]:</span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> nums[L] + nums[R] + nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                    L +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> L&lt;R <span class="keyword">and</span> nums[L] + nums[R] + nums[i] == <span class="number">0</span>:</span><br><span class="line">                    res.append((nums[L], nums[R], nums[i]))</span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        如果不想这么麻烦的写，也可以在遍历的时候不考虑去重问题。</span></span><br><span class="line"><span class="string">        将结果先转为set，自动就去重了。然后又把set转回list，返回。 </span></span><br><span class="line"><span class="string">        但是调用 set 又转回 list 的话，耗时会剧增。</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p><span id="2.3.1.10"></span>  </p><h3 id="2-3-1-10-最接近的三数之和"><a href="#2-3-1-10-最接近的三数之和" class="headerlink" title="2.3.1.10 最接近的三数之和"></a>2.3.1.10 最接近的三数之和</h3><p><a href="https://leetcode.cn/problems/3sum-closest/description/">LeetCode 16.最接近的三数之和</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><blockquote><p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在恰好一个解.  </p></blockquote><font color="#3399FF">思路：和上面的三数之和思路一样，<b>这里可以不考虑重复问题。因为题目假定每组输入只存在恰好一个解。</b></font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 先将res初始化为一个极值</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-<span class="number">2</span>):</span><br><span class="line">            L, R = i+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;R :</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(nums[i]+nums[L]+nums[R] - target) &lt; <span class="built_in">abs</span>(res-target):</span><br><span class="line">                    res = nums[i]+nums[L]+nums[R]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[L]+nums[R] &lt; target:</span><br><span class="line">                    <span class="comment"># 三数和偏小, 试着增大, 以此靠近 target</span></span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i]+nums[L]+nums[R] &gt; target:</span><br><span class="line">                    <span class="comment"># 三数和偏大, 试着减小, 以此靠近 target</span></span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 如果出现相等的情况</span></span><br><span class="line">                    <span class="comment"># 那就是最接近target, 而且题目说唯一解, 可以直接返回了</span></span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.3.1.11"></span>  </p><h3 id="2-3-1-11-四数之和"><a href="#2-3-1-11-四数之和" class="headerlink" title="2.3.1.11 四数之和"></a>2.3.1.11 四数之和</h3><p><a href="https://leetcode.cn/problems/4sum/">LeetCode 18.四数之和</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：这就是升级版的三数之和问题，可以考虑多搞一层循环来直接套用三数之和的解答方式。</font>   <ul><li><p>第一种代码写法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = [] </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;相较于三数之和问题，多一层循环嵌套而已, 解法本质没有区别&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, N-<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, N-<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> j&gt;i+<span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                L, R = j+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                    <span class="keyword">if</span> nums[i] + nums[j] + nums[L] + nums[R] &gt; target:</span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> nums[i] + nums[j] + nums[L] + nums[R] &lt; target:</span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> res <span class="keyword">and</span> nums[i] == res[-<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">and</span> nums[j] == res[-<span class="number">1</span>][<span class="number">1</span>] <span class="keyword">and</span> nums[L] == res[-<span class="number">1</span>][<span class="number">2</span>]:</span><br><span class="line">                            L += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            res.append([nums[i], nums[j], nums[L], nums[R]])</span><br><span class="line">                            L += <span class="number">1</span></span><br><span class="line">                            R -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><p>第二种代码写法  </p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, N-<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> j&gt;i+<span class="number">1</span> <span class="keyword">and</span> nums[j] ==nums[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                L, R = j+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">while</span> L&lt;R <span class="keyword">and</span> L&gt;j+<span class="number">1</span> <span class="keyword">and</span> nums[L]==nums[L-<span class="number">1</span>]:</span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> R &lt;N-<span class="number">1</span> <span class="keyword">and</span> nums[R] == nums[R+<span class="number">1</span>]:</span><br><span class="line">                        R -=<span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> nums[i] + nums[j] + nums[L] + nums[R] &gt; target:</span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> L&lt;R <span class="keyword">and</span> nums[i] + nums[j] + nums[L] + nums[R] == target:</span><br><span class="line">                        res.append([nums[i], nums[j],nums[L], nums[R]])</span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        L +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.3.1.12"></span>  </p><h3 id="2-3-1-12-有序数组的平方"><a href="#2-3-1-12-有序数组的平方" class="headerlink" title="2.3.1.12 有序数组的平方"></a>2.3.1.12 有序数组的平方</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">LeetCode 977.有序数组的平方</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：要是直接对数组nums内的数进行平方，再排序，这个可能不太符合题目想考察的点。这个题目对于数字的操作其实就是模拟了 $ y=x^2 $ 这个函数，函数开口向上，对称轴为 $x=0$ , 所以对于数组中的数据，谁离0更远，谁平方后就更大。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        暴力解法：</span></span><br><span class="line"><span class="string">        res = [num**2 for num in nums]</span></span><br><span class="line"><span class="string">        return sorted(res)</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        N  = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [<span class="number">0</span>] * N</span><br><span class="line">        L, R, idx  = <span class="number">0</span>, N - <span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt;= R:</span><br><span class="line">            <span class="keyword">while</span> L&lt;=R <span class="keyword">and</span> <span class="built_in">abs</span>(nums[L]) &gt; <span class="built_in">abs</span>(nums[R]):</span><br><span class="line">                <span class="comment"># 如果 L 位置的数更远，就将其平方结果装入 res数组的末尾</span></span><br><span class="line">                res[idx] = nums[L]**<span class="number">2</span></span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                idx -=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;=R <span class="keyword">and</span> <span class="built_in">abs</span>(nums[L]) &lt;= <span class="built_in">abs</span>(nums[R]):</span><br><span class="line">                <span class="comment"># 如果 R 位置的数更远，就将其平方结果装入 res数组的末尾</span></span><br><span class="line">                res[idx] = nums[R]**<span class="number">2</span></span><br><span class="line">                R -=<span class="number">1</span></span><br><span class="line">                idx -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.3.1.13"></span>  </p><h3 id="2-3-1-13-颜色分类"><a href="#2-3-1-13-颜色分类" class="headerlink" title="2.3.1.13 颜色分类"></a>2.3.1.13 颜色分类</h3><p><a href="https://leetcode.cn/problems/sort-colors/">LeetCode 75.颜色分类</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：该题的本质其实是荷兰国旗问题，或者说简化版本的。后面讲排序问题的时候，会专门讨论荷兰国旗问题。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;荷兰国旗问题&#x27;&#x27;&#x27;</span></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        L, R = -<span class="number">1</span>, N</span><br><span class="line">        i = L+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; R:</span><br><span class="line">            <span class="keyword">if</span> L &lt; R <span class="keyword">and</span> nums[i] &lt; <span class="number">1</span>:</span><br><span class="line">                nums[i], nums[L+<span class="number">1</span>] = nums[L+<span class="number">1</span>], nums[i]</span><br><span class="line">                L+=<span class="number">1</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> L &lt; R <span class="keyword">and</span> nums[i] == <span class="number">1</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[i], nums[R-<span class="number">1</span>] = nums[R-<span class="number">1</span>], nums[i]</span><br><span class="line">                R -=<span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="2.3.1.14"></span>  </p><h3 id="2-3-1-14-接雨水"><a href="#2-3-1-14-接雨水" class="headerlink" title="2.3.1.14 接雨水"></a>2.3.1.14 接雨水</h3><p><a href="https://leetcode.cn/problems/trapping-rain-water/">LeetCode 42.接雨水</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路 1：暴力解法，计算每个位置上的最高左右边界，得到每个位置装"水柱"的大小，但是会超出时间限制。</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1.暴力解法</span></span><br><span class="line">        <span class="comment"># 计算每个位置上的&quot;水柱&quot;的大小</span></span><br><span class="line">        <span class="comment"># 注意，该方案超出时间限制，只是作为一个引子</span></span><br><span class="line">        </span><br><span class="line">        L_max, R_max = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        N = <span class="built_in">len</span>(height)</span><br><span class="line">        water = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 对每一个位置，找其左、右两侧最高的边界</span></span><br><span class="line">            <span class="comment"># max 方法的时间复杂度是O(N)</span></span><br><span class="line">            L_max = <span class="built_in">max</span>(height[<span class="number">0</span>:i])</span><br><span class="line">            R_max = <span class="built_in">max</span>(height[i+<span class="number">1</span>:N])</span><br><span class="line">            <span class="comment"># 只有左右两侧存在比当前还要高的边界，才能装水，不然水就流走了</span></span><br><span class="line">            <span class="keyword">if</span> L_max &gt; height[i] <span class="keyword">and</span> R_max &gt; height[i]:</span><br><span class="line">                <span class="comment"># 木桶能装水量是由短板决定的</span></span><br><span class="line">                H = <span class="built_in">min</span>(L_max, R_max)</span><br><span class="line">                water.append(H-height[i])</span><br><span class="line">        <span class="comment"># 整个函数的时间复杂度是O(N^2), 会有测试用例时间超限</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(water)</span><br></pre></td></tr></table></figure><font color="#3399FF">思路 2：在思路1的基础上进行改进。  思路1的想法是没问题的，能够跑通大部分用例，但是对于很长的height数组会超出时间限制。 如果能够将：【对每一个位置寻找其左右最高边界】这个操作的时间复杂度降下来，  那么就能够让整个函数的时间复杂度降低，所以很容易想到 “以空间换时间”。  如果从左往右遍历，要找左侧最高边界，就是在被遍历过的数中找，若能够将左侧遍历过的数中最高的边界，记录下来，那么每一次都只需将原来的左侧最高边界，与新遍历到的数进行对比，即：> 对于 i 位置： L_max = max(L_max, height[i-1]) > 对于右侧的最高边界，就也同理，从右往左遍历，即可得到：> 对于 j 位置， R_max = max(R_max, height[j+1])  这样，就能先遍历一道数组，将这些值记录在辅助数组中，时间复杂度O(N);再遍历一道，计算装水量，还是O(N)的时间复杂度；所以总体的时间复杂度就是O(N)+O(N), 还是 O(N)对于空间复杂度，额外使用了两个数组 L_max，R_max 来存放各个位置的左右边界，勉强也算是 O(2N) -> O(N)</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;思路2 “以空间换时间” &#x27;&#x27;&#x27;</span></span><br><span class="line">        N = <span class="built_in">len</span>(height)</span><br><span class="line">        <span class="comment"># 最左和最右的柱子只能当边界，无法装水</span></span><br><span class="line">        <span class="comment"># 柱子一定要至少有3个才能装水</span></span><br><span class="line">        water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> N &lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> water</span><br><span class="line">        L_max, R_max = height[<span class="number">0</span>], height[N-<span class="number">1</span>]        </span><br><span class="line">        L_boder, R_boder = [L_max]*N, [R_max]*N</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> L <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 将各个位置对应的左右最高边界分别存储到辅助数组中</span></span><br><span class="line">            L_boder[L] = <span class="built_in">max</span>(L_boder[L-<span class="number">1</span>], height[L])</span><br><span class="line">            R = N-<span class="number">1</span>-L</span><br><span class="line">            R_boder[R] = <span class="built_in">max</span>(height[R], R_boder[R+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 水柱高度由较矮边界决定：H = min(L_boder[i], R_boder[i])</span></span><br><span class="line">            <span class="comment"># 同时边界值还要比当前柱子本身要高才行：max(H-height[i], 0)</span></span><br><span class="line">            water += <span class="built_in">max</span>( <span class="built_in">min</span>(L_boder[i], R_boder[i]) - height[i], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> water</span><br><span class="line">        </span><br></pre></td></tr></table></figure><font color="#3399FF">思路 3：思路 2 的改进，能够跑通全部测试用例，但是用到了两个辅助数组，增加了空间复杂度。那么是否还有优化空间呢？  若在寻找左/右最高边界之时，直接计算装水量，岂不是可以不用辅助数组来存储数据了？  但是对于遍历到的数字，我们只能完全肯定其一边的最高边界。> 比如【 <b>从左往右遍历</b>时,考察的是 L 位置】, 可以肯定 L_max 一定是 L 左侧最高边界：> 此时 R_max 是 R 右侧的最高边界，并不一定是 L 右侧的最高边界> 但是 <b> R_max 它是不是 L位置 的右侧最高边界重要吗？</b>来讨论一下    > + <b>情况1</b>. if <font color="Red">R_max > L_max</font>, then H = L_max, 即 H 取值和 R_max 无关，原因如下：        >   如果 L\~R 之间，还有更高的边界可以作为L的右边界，那 L_max 依旧是更矮的，不影响 H 取值是 L_max>   如果 L\~R 之间，不存在更高的边界，那 R_max 就是 L 的最高右边界,哪怕 L~R区间都是更矮的也不影响，反正有 R_max 作为右边界兜底，故 H 取值还是更矮的 L_max>> + <b>情况2</b>.if <font color="gReen">L_max > R_max</font>, 那么确实就不好说了：        >   如果 L\~R 之间 存在更高的边界，那么就应该判断其与 L_max 的大小关系，       >   但是我们暂时无法找到这个值，无法确定更适合 L 位置的右边界          >   如果 L\~R 之间，不存在更高的边界,那 R_max 就是 L 的最高右边界, H=min(L_max, R_max)=R_max          >   主要问题在于，我们暂时无法获取 L~R之间的数字的信息，因为尚未遍历到  > 但是反其道而行之！！！对于当前条件：<font color="gReen">L_max > R_max</font>，无法判断 L 位置的 H 取值。但是却可以判断 R 位置的 H 取值！这正是我们讨论【从左往右遍历时,考察的是 L 位置】 时的情况1如果我们现在 【从 <b>右往左遍历</b> 时,考察的是 R 位置】，那么> + <font color="gReen">L_max > R_max</font> 这个情况>   就是 R 位置的<b>情况1</b>：此时 R 位置的 H = R_max> + 对于 R 位置的<b>情况2</b>：条件是 <font color="Red">R_max > L_max</font>， 同理，无法确定 L~R 之间是否有更适合作为 R 位置左边界的值>   但是，它又转换成了 对于 L 位置的情况1.   对于 R_max == L_max 的情况:  如果考察的是 L 位置，H 仍然能取 L_max如果考察的是 R 位置，H 仍然能取 R_max。仍然按照两个位置情况1的思路去理解在写代码时，只需要将这种情况固定划分到考察 L 或者 R 的一种之中去就行这样整个思路就能串通起来了,由于只需要遍历一次数组，时间复杂度 O(N), 只有有限个辅助变量，空间复杂度O(1)。</font>    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(height)</span><br><span class="line">        <span class="comment"># 最左和最右的柱子只能当边界，无法装水</span></span><br><span class="line">        <span class="comment"># 柱子一定要至少有3个才能装水</span></span><br><span class="line">        water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> N &lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> water</span><br><span class="line"></span><br><span class="line">        L_max, R_max = height[<span class="number">0</span>], height[N-<span class="number">1</span>]</span><br><span class="line">        L, R = <span class="number">1</span>, N-<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> L &lt;= R :</span><br><span class="line">            <span class="keyword">if</span> L_max &lt;= R_max:</span><br><span class="line">                <span class="comment"># 这是 从左往右遍历的 L 位置的情况1:H = L_max</span></span><br><span class="line">                L_max = <span class="built_in">max</span>(L_max, height[L])</span><br><span class="line">                water += L_max - height[L]</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 这是 从右往左遍历的 r 位置的情况1: H = R_max</span></span><br><span class="line">                R_max = <span class="built_in">max</span>(R_max, height[R])</span><br><span class="line">                water += R_max - height[R]</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> water </span><br></pre></td></tr></table></figure><p><span id="2.3.1.15"></span>  </p><h3 id="2-3-1-15-数组中的最长山脉"><a href="#2-3-1-15-数组中的最长山脉" class="headerlink" title="2.3.1.15 数组中的最长山脉"></a>2.3.1.15 数组中的最长山脉</h3><p><a href="https://leetcode.cn/problems/longest-mountain-in-array/">LeetCode 845.数组中的最长山脉</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：这个其实不是对撞指针了，是对每个位置展开一个左右指针，来对每个位置求山脉宽度。其实可以理解为对撞指针的<b>逆过程</b>，从中间开始往两边扩散两个指针。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestMountain</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(arr)</span><br><span class="line">        width = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 注意！根据题目中的要求，是左右侧都要有下降趋势的点才行</span></span><br><span class="line">        <span class="comment"># 所以 最左侧和最右侧元素，arr[0]/arr[N-1]由于只有一边有元素，不合题意</span></span><br><span class="line">        <span class="comment"># 可以不用遍历这两个位置，它俩一定不能作为山顶</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 首先判断是否是符合山顶条件，即左右两侧都有下降趋势</span></span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; arr[i - <span class="number">1</span>] <span class="keyword">and</span> arr[i] &gt; arr[i + <span class="number">1</span>]:</span><br><span class="line">                L = i - <span class="number">1</span></span><br><span class="line">                R = i + <span class="number">1</span></span><br><span class="line">                <span class="comment"># 左侧一直延伸到尽可能左</span></span><br><span class="line">                <span class="keyword">while</span> L &gt; <span class="number">0</span> <span class="keyword">and</span> arr[L - <span class="number">1</span>] &lt; arr[L]:</span><br><span class="line">                    L -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 右侧一直延伸到尽可能右</span></span><br><span class="line">                <span class="keyword">while</span> R &lt; N - <span class="number">1</span> <span class="keyword">and</span> arr[R + <span class="number">1</span>] &lt; arr[R]:</span><br><span class="line">                    R += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                width = <span class="built_in">max</span>(width, R-L+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> width</span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        #$#$#$#$#$#$ 改进后的代码，理论上可以稍微加速一点 #$#$#$#$#$#$#$</span></span><br><span class="line"><span class="string">        # 当然只是理论上, 至于实际是否加速, 得看机器和测试用例的的实际情况</span></span><br><span class="line"><span class="string">        # 改进的位置在while循环中 i 变化的情况</span></span><br><span class="line"><span class="string">        i = 1</span></span><br><span class="line"><span class="string">        while i &lt; N-1:</span></span><br><span class="line"><span class="string">            # 首先判断是否是符合山顶条件，即左右两侧都有下降趋势</span></span><br><span class="line"><span class="string">            if arr[i] &gt; arr[i - 1] and arr[i] &gt; arr[i + 1]:</span></span><br><span class="line"><span class="string">                L = i - 1</span></span><br><span class="line"><span class="string">                R = i + 1</span></span><br><span class="line"><span class="string">                # 左侧一直延伸到尽可能左</span></span><br><span class="line"><span class="string">                while L &gt; 0 and arr[L - 1] &lt; arr[L]:</span></span><br><span class="line"><span class="string">                    L -= 1</span></span><br><span class="line"><span class="string">                # 右侧一直延伸到尽可能右</span></span><br><span class="line"><span class="string">                while R &lt; N - 1 and arr[R] &gt; arr[R + 1]:</span></span><br><span class="line"><span class="string">                    R += 1</span></span><br><span class="line"><span class="string">                </span></span><br><span class="line"><span class="string">                width = max(width, R-L+1)</span></span><br><span class="line"><span class="string">                # 我们可以知道，在当前情况下，是有一个(L,i,R)的山脉</span></span><br><span class="line"><span class="string">                # 所以 在 i~R 区间，必然全是下坡路，不可能存在山顶</span></span><br><span class="line"><span class="string">                # 所以 i 可以直接跳到 R+1的位置去判断</span></span><br><span class="line"><span class="string">                # 省去了右边下山区间这么多元素的判断计算</span></span><br><span class="line"><span class="string">                i = R + 1</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">                i += 1</span></span><br><span class="line"><span class="string">        return width</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>        </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.3.1.16"></span>  </p><h3 id="2-3-1-16-最长湍流子数组"><a href="#2-3-1-16-最长湍流子数组" class="headerlink" title="2.3.1.16 最长湍流子数组"></a>2.3.1.16 最长湍流子数组</h3><p><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">LeetCode 978.最长湍流子数组</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><font color="#3399FF">思路：其实这个题最好的解法不是使用这种扩散指针，但是确实可以参考上面 <b>[数组中的最长山脉](#2.3.1.15)</b> 的思路来做。这里只是提供一种解法，拓展思路，但确实code比较复杂，看起来也不太容易懂，可以看着玩玩。<b>更好的解法还是建议看下面快慢指针部分 [2.3.2.7](#2.3.2.7)题解</b>，该题的code。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxTurbulenceSize</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        首先要搞清楚湍流是什么情况：</span></span><br><span class="line"><span class="string">        ···&lt; arr[M-2] &gt; arr[M-1] &lt; arr[M] &gt; arr[M+1] &lt; arr[M+2] &gt; ···</span></span><br><span class="line"><span class="string">                                    或者</span></span><br><span class="line"><span class="string">        ···&gt; arr[M-2] &lt; arr[M-1] &gt; arr[M] &lt; arr[M+1] &gt; arr[M+2] &lt; ···</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 按照 数组中的最长山脉 的题解思路来做， 特殊情况和边界情况的判断稍显复杂</span></span><br><span class="line">        N = <span class="built_in">len</span>(arr)</span><br><span class="line">        width = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:   </span><br><span class="line">            <span class="keyword">return</span> width</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; N:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> i == N-<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 端点值先特殊讨论</span></span><br><span class="line">                <span class="keyword">if</span> (arr[<span class="number">0</span>] != arr[<span class="number">1</span>]) <span class="keyword">or</span> (arr[N-<span class="number">2</span>] != arr[N-<span class="number">1</span>]): </span><br><span class="line">                    <span class="comment"># 只要端点值的相邻值和它不相等, 就一定是一个宽度为2的湍流</span></span><br><span class="line">                    width = <span class="built_in">max</span>(<span class="number">2</span>, width)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第 1 种 湍流模式, M 点是邻域极大值</span></span><br><span class="line">            <span class="keyword">elif</span> arr[i-<span class="number">1</span>] &lt; arr[i] <span class="keyword">and</span> arr[i] &gt; arr[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 这里的两个 flag是用来控制 &lt; 或 &gt; 符号的, 利用 -1 的不断自乘来实现转向</span></span><br><span class="line">                flag_L, flag_R, left, right = -<span class="number">1</span>, -<span class="number">1</span>, i-<span class="number">1</span>, i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> (arr[left] - arr[left-<span class="number">1</span>])* flag_L &gt; <span class="number">0</span>:</span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                    flag_L *= -<span class="number">1</span>  </span><br><span class="line">                <span class="keyword">while</span> right &lt; N-<span class="number">1</span> <span class="keyword">and</span> (arr[right] - arr[right+<span class="number">1</span>])* flag_R &gt; <span class="number">0</span>:</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">                    flag_R *= -<span class="number">1</span></span><br><span class="line">                width = <span class="built_in">max</span>(width, right-left+<span class="number">1</span>)</span><br><span class="line">                i = right</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 第 2 种 湍流模式, M 点是邻域极小值</span></span><br><span class="line">            <span class="keyword">elif</span> arr[i-<span class="number">1</span>] &gt; arr[i] <span class="keyword">and</span> arr[i] &lt; arr[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 这里的两个 flag是用来控制 &lt; 或 &gt; 符号的, 利用 -1 的不断自乘来实现转向</span></span><br><span class="line">                flag_L, flag_R, left, right = -<span class="number">1</span>, -<span class="number">1</span>, i-<span class="number">1</span>, i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> (arr[left] - arr[left-<span class="number">1</span>])* flag_L &lt; <span class="number">0</span>:</span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                    flag_L *= -<span class="number">1</span>  </span><br><span class="line">                <span class="keyword">while</span> right &lt; N-<span class="number">1</span> <span class="keyword">and</span> (arr[right] - arr[right+<span class="number">1</span>])* flag_R &lt; <span class="number">0</span>:</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">                    flag_R *= -<span class="number">1</span></span><br><span class="line">                width = <span class="built_in">max</span>(width, right-left+<span class="number">1</span>)</span><br><span class="line">                i = right </span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> width</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        这种代码写法的核心思路就是借鉴的 最长山脉那道题，难点在于:</span></span><br><span class="line"><span class="string">        1. 小于/大于符号在不断的交替, 这里是利用 -1 的自乘实现</span></span><br><span class="line"><span class="string">        2. 数组左右端点值的特殊情况容易忽略</span></span><br><span class="line"><span class="string">        总之这种代码写法稍微有点困难，也是因为刚刚才做完 最长山脉的题目，</span></span><br><span class="line"><span class="string">        陷入了 定式思维 的陷阱, 才写出了这种方法。</span></span><br><span class="line"><span class="string">        等下面用快慢指针的思路, 代码就更容易理解</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-2-快慢指针"><a href="#2-3-2-快慢指针" class="headerlink" title="2.3.2 快慢指针"></a>2.3.2 快慢指针</h2><p>所谓快慢指针，就是指的两个指针的移动频率不同，其中快指针因为某个条件，总是跑在慢指针更右侧。<br>通常终止条件就是快指针遍历完了数组。  </p><p><span id="2.3.2"></span>  </p><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">LeetCode 26.删除有序数组中的重复项</a></td><td><a href="#2.3.2.1">题解2.3.2.1</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/string-compression/">LeetCode 443.压缩字符串</a></td><td><a href="#2.3.2.2">题解2.3.2.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">LeetCode 80.删除有序数组中的重复项II</a></td><td><a href="#2.3.2.3">题解2.3.2.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/remove-element/">LeetCode 27.移除元素</a></td><td><a href="#2.3.2.4">题解2.3.2.4</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/move-zeroes//">LeetCode 283.移动零</a></td><td><a href="#2.3.2.5">题解2.3.2.5</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/increasing-triplet-subsequence/">LeetCode 334.递增的三元子序列</a></td><td><a href="#2.3.2.6">题解2.3.2.6</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">LeetCode 978.最长湍流子数组</a></td><td><a href="#2.3.2.7">题解2.3.2.7</a></td></tr></tbody></table></div><p><span id="2.3.2.1"></span>  </p><h3 id="2-3-2-1-删除有序数组中的重复项"><a href="#2-3-2-1-删除有序数组中的重复项" class="headerlink" title="2.3.2.1 删除有序数组中的重复项"></a>2.3.2.1 删除有序数组中的重复项</h3><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">LeetCode 26.删除有序数组中的重复项</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><font color="#3399FF">思路：用快慢指针，快指针先去右侧看是否重复，慢指针用来修改原数组（维护去重部分的边界）</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> N &lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> N</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;方案一. 遍历到的重复的数, 先跳过，将重复区域的最后一个数, 加入唯一元素区域&#x27;&#x27;&#x27;</span></span><br><span class="line">        s, f = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="comment"># 慢指针代表筛选出的【唯一元素区域】的右边界, 一开始这个区域是空的, 所以s=0 </span></span><br><span class="line">        <span class="comment"># 快指针代表后续待比较区域的元素, 因为至少要有2个元素才能比较是否重复, 所以f从第2个元素开始,f=1</span></span><br><span class="line">        <span class="keyword">while</span> f &lt;= N:</span><br><span class="line">            <span class="keyword">if</span> f== N <span class="keyword">or</span> nums[f] != nums[f-<span class="number">1</span>] :</span><br><span class="line">                <span class="comment"># f位置的数与 f-1不相同, 说明：</span></span><br><span class="line">                <span class="comment"># f-1位置是某段重复区域的最后一个数了, f是新区域的第一个数.</span></span><br><span class="line">                <span class="comment"># 把f-1加进唯一元素区域</span></span><br><span class="line">                nums[s] = nums[f-<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 这个if条件里面之所以有 f==N 这个情况, 是因为f=N时, nums取不到值, </span></span><br><span class="line">                <span class="comment"># 且nums的最后一个数N-1位置一定可以加入唯一区域, 因为这个数一定是某段区域的最后一个数(不管这段区域是否重复)</span></span><br><span class="line">                <span class="comment"># 同时不要忘记 右边界s向右扩张1位</span></span><br><span class="line">                s += <span class="number">1</span></span><br><span class="line">            f += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s <span class="comment"># s是右边界, 即唯一元素区域实际是 0 ~ s-1, 共 s 个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        方案二： </span></span><br><span class="line"><span class="string">        上面的方案都是将重复区域的最后一个元素更新到s位置</span></span><br><span class="line"><span class="string">        这里是将重复区域的第一个元素更新到s位置</span></span><br><span class="line"><span class="string">        s, f = -1, 0</span></span><br><span class="line"><span class="string">        while f &lt; N:</span></span><br><span class="line"><span class="string">            # 这里的更新过程非常像在维护一个虚拟的栈</span></span><br><span class="line"><span class="string">            # 当栈为空 s==-1，或者f遇到的数不等于栈顶元素 nums[f] != nums[s]</span></span><br><span class="line"><span class="string">            # 就将栈的区域扩大一个：s+=1， 然后将f对应的元素入栈:nums[s] = nums[f]</span></span><br><span class="line"><span class="string">            if s==-1 or nums[f] != nums[s]:</span></span><br><span class="line"><span class="string">                s += 1</span></span><br><span class="line"><span class="string">                nums[s] = nums[f]</span></span><br><span class="line"><span class="string">            f += 1</span></span><br><span class="line"><span class="string">        # 虚拟栈的范围是 0 ~ s, 共 s+1 个元素       </span></span><br><span class="line"><span class="string">        return s+1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 用虚拟栈的思路会十分容易理解, 代码也很好写, 所以更推荐方案二</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>                 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.3.2.2"></span>  </p><h3 id="2-3-2-2-压缩字符串"><a href="#2-3-2-2-压缩字符串" class="headerlink" title="2.3.2.2 压缩字符串"></a>2.3.2.2 压缩字符串</h3><p><a href="https://leetcode.cn/problems/string-compression/">LeetCode 443.压缩字符串</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><font color="#3399FF">思路：题目中说到只能使用常量额外空间，即空间复杂度要求O(1)，说明没办法用辅助数组。然后这个题其实是上一题 <b>[删除有序数组中的重复项](#2.3.2.1)</b> 的升级版，稍微麻烦了一点而已，思路完全是一样的。同样是要判断连续的重复字符，只不过现在还要追加其数目而已。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compress</span>(<span class="params">self, chars: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(chars)</span><br><span class="line">        <span class="keyword">if</span> N &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> N </span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">rever_list</span>(<span class="params">arr, L, R</span>):</span><br><span class="line">            <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                arr[L], arr[R] = arr[R], arr[L]</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        s, f =  <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="comment"># 重复区域的开头位置begin初始化为0</span></span><br><span class="line">        begin = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> f &lt;= N :</span><br><span class="line">            <span class="keyword">if</span> f == N <span class="keyword">or</span> chars[f] != chars[f-<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 说明 f-1 位置是上一段重复区域的最后一个, f是下一段区域的开头</span></span><br><span class="line">                chars[s] = chars[f-<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 右边界右移一位</span></span><br><span class="line">                s += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 计算上一段重复区域的长度, 就是下一段区域的开头f 减去 上一段的开头位置 begin</span></span><br><span class="line">                cnt = f - begin</span><br><span class="line">                begin = f</span><br><span class="line">                <span class="keyword">if</span> cnt &gt; <span class="number">1</span>:</span><br><span class="line">                    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                    # 这种直接将数字字符串序列化, 每次都会产生一个list</span></span><br><span class="line"><span class="string">                    # 然后接着使用列表切片法进行赋值, 也会在等号右侧产生一个临时list</span></span><br><span class="line"><span class="string">                    # 虽然这种写法确实快, 但是有一点违背【使用常量额外空间】的条件的嫌疑</span></span><br><span class="line"><span class="string">                    # 如果要规避这一点, 可以使用for循环来处理这段逻辑</span></span><br><span class="line"><span class="string">                    # 也就是说题目要求【使用常量额外空间】时, 代码中还是尽量避免产生列表/数组的操作</span></span><br><span class="line"><span class="string">                    num_str = list(str(cnt))</span></span><br><span class="line"><span class="string">                    num_w = len(num_str)</span></span><br><span class="line"><span class="string">                    chars[s:s+num_w] = num_str[:]</span></span><br><span class="line"><span class="string">                    s += num_w</span></span><br><span class="line"><span class="string">                    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">                    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                    虽然这种写法代码比较复杂,而且实际跑出来的效果也许并不是最好的</span></span><br><span class="line"><span class="string">                    但确实在理论上更加严格的遵守了 【使用常量额外空间】 这一条件</span></span><br><span class="line"><span class="string">                    因为算法是要考虑到使用不同的代码时都能产生比较好的效果</span></span><br><span class="line"><span class="string">                    只使用了有限几个变量, 而没有产生列表/数组</span></span><br><span class="line"><span class="string">                    &#x27;&#x27;&#x27;</span></span><br><span class="line">                    <span class="keyword">if</span> cnt &lt; <span class="number">10</span>:</span><br><span class="line">                        <span class="comment"># cnt &lt; 10 时数字只有一个, 简单操作</span></span><br><span class="line">                        chars[s] = <span class="built_in">str</span>(cnt)</span><br><span class="line">                        s += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># cnt &gt;= 10时 数字会至少有2位</span></span><br><span class="line">                        L = s</span><br><span class="line">                        <span class="comment"># 循环产生的结果是先从【个位】开始取出数字填充</span></span><br><span class="line">                        <span class="comment"># 比如 123 产生的结果其实是 &#x27;3&#x27;,&#x27;2&#x27;,&#x27;1&#x27;</span></span><br><span class="line">                        <span class="keyword">while</span> cnt &gt; <span class="number">0</span>:</span><br><span class="line">                            chars[s] = <span class="built_in">str</span>(cnt % <span class="number">10</span>)</span><br><span class="line">                            cnt //= <span class="number">10</span></span><br><span class="line">                            s += <span class="number">1</span></span><br><span class="line">                        R = s-<span class="number">1</span></span><br><span class="line">                        <span class="comment"># 所以填充完之后还需要将该段数字的顺序转回来</span></span><br><span class="line">                        rever_list(chars, L, R)            </span><br><span class="line">            f += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p><span id="2.3.2.3"></span>  </p><h3 id="2-3-2-3-删除有序数组中的重复项II"><a href="#2-3-2-3-删除有序数组中的重复项II" class="headerlink" title="2.3.2.3 删除有序数组中的重复项II"></a>2.3.2.3 删除有序数组中的重复项II</h3><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">LeetCode 80.删除有序数组中的重复项II</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><font color="#3399FF">思路：思路和前面两道题一脉相承，代码稍加改动即可</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># if N &lt;= 2:</span></span><br><span class="line">        <span class="comment">#     return 2</span></span><br><span class="line">        s, f = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        begin = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> f &lt;= N:</span><br><span class="line">            <span class="keyword">if</span> f == N <span class="keyword">or</span> nums[f] != nums[f-<span class="number">1</span>]:</span><br><span class="line">                nums[s] = nums[f-<span class="number">1</span>]</span><br><span class="line">                s += <span class="number">1</span></span><br><span class="line">                cnt = f - begin</span><br><span class="line">                begin = f</span><br><span class="line">                <span class="keyword">if</span> cnt &gt;= <span class="number">2</span>:</span><br><span class="line">                    nums[s] = nums[f-<span class="number">1</span>]</span><br><span class="line">                    s += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            f += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p><span id="2.3.2.4"></span>  </p><h3 id="2-3-2-4-移除元素"><a href="#2-3-2-4-移除元素" class="headerlink" title="2.3.2.4 移除元素"></a>2.3.2.4 移除元素</h3><p><a href="https://leetcode.cn/problems/remove-element/">LeetCode 27.移除元素</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><font color="#3399FF">思路：和上面的题目一脉相承。用虚拟栈的思路会很容易理解。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 慢指针充当虚拟栈栈顶索引, 快指针用来遍历数组</span></span><br><span class="line">        s, f = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> f &lt; N:</span><br><span class="line">            <span class="keyword">if</span> nums[f] != val:</span><br><span class="line">                <span class="comment"># 将虚拟栈扩充一位, 并且将数放入栈顶</span></span><br><span class="line">                s += <span class="number">1</span></span><br><span class="line">                nums[s] = nums[f]</span><br><span class="line">            f += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 虚拟栈数据范围 0~s 共s+1个数字</span></span><br><span class="line">        <span class="keyword">return</span> s+<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.3.2.5"></span>  </p><h3 id="2-3-2-5-移动零"><a href="#2-3-2-5-移动零" class="headerlink" title="2.3.2.5 移动零"></a>2.3.2.5 移动零</h3><p><a href="https://leetcode.cn/problems/move-zeroes//">LeetCode 283.移动零</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><font color="#3399FF">思路: partition 问题，注意，下面的代码是 非稳定的因为不同的0的相对次序其实会变化，只不过题目只要求非0数据相对次序不变，所以还是能保证的。后面的章节讲排序问题的快速排序讨论, 会详细讲 partition 问题;这里还是先用虚拟栈的思考方式来理解更方便一点。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 慢指针充当虚拟栈栈顶索引，快指针用来遍历数组</span></span><br><span class="line">        ps, pf = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pf &lt;N:</span><br><span class="line">            <span class="keyword">if</span> nums[pf] != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 虚拟栈扩充一格</span></span><br><span class="line">                ps += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 栈顶位置的原始数字, 和 pf 位置的数字进行交换, </span></span><br><span class="line">                <span class="comment"># 就把pf位置的数放到栈里来了, 同时将原始数字放到栈外面去了</span></span><br><span class="line">                nums[pf], nums[ps] = nums[ps], nums[pf]</span><br><span class="line">            pf += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="2.3.2.6"></span>  </p><h3 id="2-3-2-6-递增的三元子序列"><a href="#2-3-2-6-递增的三元子序列" class="headerlink" title="2.3.2.6 递增的三元子序列"></a>2.3.2.6 递增的三元子序列</h3><p><a href="https://leetcode.cn/problems/increasing-triplet-subsequence/">LeetCode 334.递增的三元子序列</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><font color="#3399FF">思路：这个题虽然没有显式的使用快慢指针，但是思想是借鉴了快慢指针的。假设我们要找3个数a,b,c满足 a < b < c 的条件，<b>那么a应该尽可能的小，b也应该在大于a的情况下尽可能的小，这样才容易去找到满足条件的c</b>。那么，比方说我们<b><font color="#3333FF">如何找到一个数组中，最小的数呢（不调用min）</font>？？</b>那就是设定一个极大的初始值，遍历一道数组，在遍历过程中发现更小的数，就更新，最终就能找到这个最小的数。借鉴这个思想，我们的代码如下</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increasingTriplet</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        a = b = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &lt;= a:</span><br><span class="line">                <span class="comment"># 这样能够保证在遍历过的数字中，a一定是最小的那个数</span></span><br><span class="line">                a = num </span><br><span class="line">            <span class="keyword">elif</span> num &lt;=b:</span><br><span class="line">                <span class="comment"># elif隐含的条件是不满足上面的条件，即不满足小于等于a</span></span><br><span class="line">                <span class="comment"># 所以b一定能取到在遍历过的数目当中，位于a后面的，比a大的数当中，最小的一个数</span></span><br><span class="line">                b = num </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 在继续变量的过程中，只要遇到一个数不满足上面的条件，即比a和b都大</span></span><br><span class="line">                <span class="comment"># 这个数就能够充当 c 的角色</span></span><br><span class="line">                <span class="comment"># c = num </span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><span id="2.3.2.7"></span>  </p><h3 id="2-3-2-7-最长湍流子数组"><a href="#2-3-2-7-最长湍流子数组" class="headerlink" title="2.3.2.7 最长湍流子数组"></a>2.3.2.7 最长湍流子数组</h3><p><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">LeetCode 978.最长湍流子数组</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><font color="#3399FF">思路：该题在对撞指针中讲过一次，但是更好的解法是使用快慢指针。具体的思路可以看code中的注释，采用快慢指针要快许多</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxTurbulenceSize</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        注意到题目中给的例子，1个元素也算湍流，2个不相等的数也能组成宽度为2的湍流</span></span><br><span class="line"><span class="string">        其实不用像 山脉宽度 那样每次从一个中心点，向着左右扩散</span></span><br><span class="line"><span class="string">        湍流可以选择一个起始点，从左往右的方向一直扩散，比如：</span></span><br><span class="line"><span class="string">        情况1：arr[0] &gt; arr[1] &lt; arr[2] &gt; ··· </span></span><br><span class="line"><span class="string">        或 情况2：arr[0] &lt; arr[1] &gt; arr[2] &lt; ···</span></span><br><span class="line"><span class="string">        考虑用快慢指针，一个维护湍流的起点，另一个维护湍流的终点</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        N, width = <span class="built_in">len</span>(arr), <span class="number">1</span></span><br><span class="line">        L, R = <span class="number">0</span> ,<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> R &lt; N: <span class="comment"># 当湍流的右边界没有超过数组</span></span><br><span class="line">            <span class="comment"># 情况 1</span></span><br><span class="line">            <span class="keyword">if</span> arr[L] &gt; arr[R]:</span><br><span class="line">                flag = -<span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果右边一直能满足湍流的条件，就一直往右扩散</span></span><br><span class="line">                <span class="comment"># 这里是通过乘以 (-1)^k 来变相控制 大于/小于符号, 注意这里用的是 &gt;</span></span><br><span class="line">                <span class="keyword">while</span> R &lt; N-<span class="number">1</span> <span class="keyword">and</span> (arr[R]- arr[R+<span class="number">1</span>]) * flag &gt; <span class="number">0</span>:</span><br><span class="line">                    R += <span class="number">1</span></span><br><span class="line">                    flag *= -<span class="number">1</span></span><br><span class="line">                <span class="comment"># 循环结束后, R 指向该组湍流的最后一个满足条件的元素</span></span><br><span class="line">                width = <span class="built_in">max</span>(width, R-L+<span class="number">1</span>)                </span><br><span class="line">            <span class="comment"># 情况 2</span></span><br><span class="line">            <span class="keyword">elif</span> arr[L] &lt; arr[R]:</span><br><span class="line">                flag = -<span class="number">1</span> </span><br><span class="line">                <span class="comment"># 这里是通过乘以 (-1)^k 来变相控制 大于/小于符号, 注意这里用的是 &lt; </span></span><br><span class="line">                <span class="keyword">while</span> R &lt; N-<span class="number">1</span> <span class="keyword">and</span> (arr[R]- arr[R+<span class="number">1</span>]) * flag &lt; <span class="number">0</span>:</span><br><span class="line">                    R += <span class="number">1</span></span><br><span class="line">                    flag *= -<span class="number">1</span></span><br><span class="line">                width = <span class="built_in">max</span>(width, R-L+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 连续两个数字相等，直接pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="comment"># 更新起点和终点</span></span><br><span class="line">            L = R </span><br><span class="line">            R +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> width</span><br></pre></td></tr></table></figure><!-- <span id="2.3.2.8"></span>  ### 2.3.2.9  [返回目录2.3.2](#2.3.2)>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在恰好一个解.  >示例 1>输入：nums = [-1,2,1,-4], target = 1; &emsp;输出：2  <font color=#3399FF>思路：</font>  ```python```    -->]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2-2 数组相关题目</title>
      <link href="/Data-Structure/DS_22_array_exercises.html"/>
      <url>/Data-Structure/DS_22_array_exercises.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1"> <h1 id="2-2-数组相关题目"><a href="#2-2-数组相关题目" class="headerlink" title="2-2 数组相关题目"></a>2-2 数组相关题目</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p><b>版权声明：以下题目均来自 <a href="https://leetcode.cn">LeetCode</a>， 仅仅提供跳转到力扣官网的链接，不在本页面出现题目内容，本文章内容禁止商业用途。</b></p><p><span id="2.2.1"></span>  </p><h2 id="2-2-1-一维数组的相关题目"><a href="#2-2-1-一维数组的相关题目" class="headerlink" title="2.2.1 一维数组的相关题目"></a>2.2.1 一维数组的相关题目</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/rotate-array/">LeetCode 189.轮转数组</a></td><td><a href="#2.2.1.1">2.2.1.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/find-pivot-index/">LeetCode 724.寻找数组的中心下标</a></td><td><a href="#2.2.1.2">2.2.1.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/max-consecutive-ones/">LeetCode 485.最大连续 1 的个数</a></td><td><a href="#2.2.1.3">2.2.1.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/product-of-array-except-self/">LeetCode 238.除自身以外数组的乘积</a></td><td><a href="#2.2.1.4">2.2.1.4题解</a></td></tr></tbody></table></div><p><span id="2.2.1.1"></span>  </p><h3 id="2-2-1-1-轮转数组"><a href="#2-2-1-1-轮转数组" class="headerlink" title="2.2.1.1 轮转数组"></a>2.2.1.1 轮转数组</h3><p><a href="https://leetcode.cn/problems/rotate-array/">LeetCode 189.轮转数组</a> | |  <a href="#2.2.1">返回2.2.1目录</a>  </p><font color="#3399FF">方案一： 复制一个数组为参照，在原数组上进行修改。 </font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;时间复杂度O(n), 空间复杂度O(n)&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        tmp, n = nums.copy(), <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            nums[(i+k)%n] = tmp[i]</span><br></pre></td></tr></table></figure><font color="#3399FF">方案二： 不另外创建数组。 </font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 题目给的例子中，有k&gt;N的情况，所以先求模运算</span></span><br><span class="line">        k = k % N</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果假设数组首尾相接，是一个循环数组</span></span><br><span class="line">        <span class="comment"># 那么向右轮转k个位置，就相当于后面k个数被挤压到前面去了</span></span><br><span class="line">        <span class="comment"># 前面的 N-k 个数， 被挤压到后面全了</span></span><br><span class="line">        <span class="comment"># 所以就相当于 前 N-k 个数，和后 k个数，整体区域做一下交换</span></span><br><span class="line">        <span class="comment"># 那么如果我们直接从 第 N-k个数字后面的逗号，将数组旋转180度，他们的区域就交换了</span></span><br><span class="line">        nums[:] = nums[::-<span class="number">1</span>] <span class="comment"># 反转数组</span></span><br><span class="line">        <span class="comment"># 注意！如果写成 nums = nums[::-1],原数组num的值是不会被改变的，这种写法相当于创建了一个新的临时数组。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 但是反转数组后，各区域内的顺序也被反转了一遍，我们再将各区域的顺序调回来</span></span><br><span class="line">        <span class="comment"># 将转过来的前k个数字恢复原来的顺序（注意前k个数字序号是 0~k-1）</span></span><br><span class="line">        nums[:k] = nums[k-<span class="number">1</span>::-<span class="number">1</span>] </span><br><span class="line">        <span class="comment"># 将转过来的后的N-K个数字恢复原顺序（注意后N-K个数字序号是 k~N-1）</span></span><br><span class="line">        nums[k:] = nums[N-<span class="number">1</span>:k-<span class="number">1</span>:-<span class="number">1</span>] </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        但是问题是，python在进行切片操作的时候，</span></span><br><span class="line"><span class="string">        实际上是会在等式右边产生一个新的临时list，</span></span><br><span class="line"><span class="string">        然后将值赋给等式左边。也并不见得能省多少空间.</span></span><br><span class="line"><span class="string">        还有的解法是在反转数组的时候，自己写反转函数：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        def reverse_list(nums, start, end):</span></span><br><span class="line"><span class="string">            while start &lt; end:</span></span><br><span class="line"><span class="string">                nums[start], nums[end] = nums[end], nums[start]</span></span><br><span class="line"><span class="string">                start +=1</span></span><br><span class="line"><span class="string">                end -=1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        reverse_list(nums, 0, N-1)</span></span><br><span class="line"><span class="string">        reverse_list(nums, 0, k-1)</span></span><br><span class="line"><span class="string">        reverse_list(nums, k, N-1)     </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        这种的空间复杂度比起直接使用链表切片来说，理论上会少一些吧，反正leetcode的提交结果来看，</span></span><br><span class="line"><span class="string">        使用python2的话，空间消耗确实有减少，但是时间消耗一下就增加了</span></span><br><span class="line"><span class="string">        使用python3的话，空间消耗是真没有多少区别，时间消耗也是增加了。</span></span><br><span class="line"><span class="string">        总得来说，用切片就是快</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><span id="2.2.1.2"></span>  </p><h3 id="2-2-1-2-寻找数组的中心下标"><a href="#2-2-1-2-寻找数组的中心下标" class="headerlink" title="2.2.1.2  寻找数组的中心下标"></a>2.2.1.2  寻找数组的中心下标</h3><p><a href="https://leetcode.cn/problems/find-pivot-index/">LeetCode 724.寻找数组的中心下标</a> | | <a href="#2.2.1">返回2.2.1目录</a>  </p><font color="#3399FF">方案：最直接的思路就是遍历元素的时候，每一次都计算左侧的和 sum(nums[:i]) 和 右侧的和 sum(nums[i+1:])；但是这中间包含了大量重复计算，时间复杂度会很高。所以可以维护两个状态变量，分别记录左和右的累加和，每一次遍历的时候，直接修改状态变量即可。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 把左右结果放入中间变量缓存，就不用每次都调用sum了</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            cur_val = nums[i]</span><br><span class="line">            <span class="keyword">if</span> left == right - cur_val:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += cur_val</span><br><span class="line">                right -= cur_val</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="2.2.1.3"></span>  </p><h3 id="2-2-1-3-最大连续-1-的个数"><a href="#2-2-1-3-最大连续-1-的个数" class="headerlink" title="2.2.1.3 最大连续 1 的个数"></a>2.2.1.3 最大连续 1 的个数</h3><p><a href="https://leetcode.cn/problems/max-consecutive-ones/">LeetCode 485.最大连续 1 的个数</a> | | <a href="#2.2.1">返回2.2.1目录</a></p><font color="#3399FF">方案：这种求连续间隔的题，一般都是用索引相减来做。即右边界的索引，减去左边界的索引，就是这段区间的宽度。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxConsecutiveOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># index_0 用来记录上一次0出现的位置，作为连续1区间的左边界</span></span><br><span class="line">        index_0 = -<span class="number">1</span></span><br><span class="line">        N, gap = <span class="built_in">len</span>(nums), <span class="number">0</span></span><br><span class="line">        <span class="comment"># 在原始数组后面多加一个0，表示区域的最大右边界</span></span><br><span class="line">        nums.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 当遇到为0的时候，取该次i作为右边界，计算两个0之间的间隔</span></span><br><span class="line">                gap = <span class="built_in">max</span>(gap, i-index_0-<span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 更新完gap之后也要把index0更新为当前的0的索引。</span></span><br><span class="line">                index_0 = i</span><br><span class="line">        <span class="keyword">return</span> gap</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        当然也可以使用1来作为计算gap的判断条件，原理是一样的</span></span><br><span class="line"><span class="string">        index_0 = -1</span></span><br><span class="line"><span class="string">        N, gap = len(nums), 0</span></span><br><span class="line"><span class="string">        for i in range(N):</span></span><br><span class="line"><span class="string">            if nums[i] == 1:</span></span><br><span class="line"><span class="string">                gap = max(gap, i-index_0)</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">                index_0 = i</span></span><br><span class="line"><span class="string">        return gap</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><span id="2.2.1.4"></span>  </p><h3 id="2-2-1-4-除自身以外数组的乘积"><a href="#2-2-1-4-除自身以外数组的乘积" class="headerlink" title="2.2.1.4 除自身以外数组的乘积"></a>2.2.1.4 除自身以外数组的乘积</h3><p><a href="https://leetcode.cn/problems/product-of-array-except-self/">LeetCode 238.除自身以外数组的乘积</a> | | <a href="#2.2.1">返回2.2.1目录</a>    </p><font color="#3399FF">方案：最简单的做法就是先求所有元素的积，然后每遍历一个位置就除以该位置的值。但是题目规定不能使用除法！这也是为了避免出现0元素作为除数的情况。那么参考【2.2.2  寻找数组的中心下标】，我们可以维护两个状态，对于每一个位置，存储该数左侧全部元素的积，和右侧全部元素的积。由于不能使用除法，只好将这两个状态分别存入两个数组中，反正题目也没有要求空间复杂度。最终用了2次for循环，2个额外数组。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        l, r = [<span class="number">1</span>]*N, [<span class="number">1</span>]*N</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 原始数据从下表1开始遍历，因为0位置上的左侧积默认是1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N):</span><br><span class="line">            <span class="comment"># 对于i位置的左侧积，就是 i-1位置的左侧积，乘以 i-1 位置的值</span></span><br><span class="line">            l[i] = l[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>]</span><br><span class="line">            i2 = N-i</span><br><span class="line">            <span class="comment"># 同时倒着取索引，计算右侧积</span></span><br><span class="line">            r[i2-<span class="number">1</span>] = r[i2]*nums[i2]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [l[i]*r[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br></pre></td></tr></table></figure><font color="#3399FF">方案二：此题确实有空间复杂度更低的方法。因为输出结果本来就是一个数组，是不占额外空间复杂度的，可以利用该结果数组作为中间辅助数组。> 即第一轮从左往右遍历的时候，先把每个位置的左侧积暂存到结果数组res中；> 第二次从右往左遍历，这个时候只需要用一个变量来缓存右侧积即可，将每个位置的右侧积，乘以已经缓存在res数组中的左侧积，就可得到最终结果了。最终还是只使用了2次for循环，但是没有额外用两个辅助数组，只用了一个额外变量，空间复杂度成了O(1)</font>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#l,r = [1]*N, [1]*N</span></span><br><span class="line">        <span class="comment"># 不使用左右缓存数组，而是直接用结果数组来缓存</span></span><br><span class="line">        res = [<span class="number">1</span>] * N</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N):</span><br><span class="line">            <span class="comment"># 照常计算左侧积</span></span><br><span class="line">            res[i] = res[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第二次从右往左遍历，初始化右侧积 R_mul 为1</span></span><br><span class="line">        R_mul = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N-<span class="number">1</span>,-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># j 位置结果 = 缓存的 j 位置左侧积 * 右侧积</span></span><br><span class="line">            res[j] = res[j]*R_mul</span><br><span class="line">            <span class="comment"># 更新下一位置的右侧积</span></span><br><span class="line">            R_mul *= nums[j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.2.2"></span>  </p><h2 id="2-2-2-二维数组相关题目"><a href="#2-2-2-二维数组相关题目" class="headerlink" title="2.2.2 二维数组相关题目"></a>2.2.2 二维数组相关题目</h2><div class="table-container"><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/rotate-image">LeetCode 48.旋转图像</a></td><td><a href="#2.2.2.1">题解2.2.2.1</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/diagonal-traverse/description/">LeetCode 498.对角线遍历</a></td><td><a href="#2.2.2.2">题解2.2.2.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/spiral-matrix">LeetCode 54. 螺旋矩阵</a></td><td><a href="#2.2.2.3">题解2.2.2.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/spiral-matrix-ii">LeetCode 59. 螺旋矩阵II</a></td><td><a href="#2.2.2.4">题解2.2.2.4</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/set-matrix-zeroes/">LeetCode 73. 矩阵置零</a></td><td><a href="#2.2.2.5">题解2.2.2.5</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/game-of-life">LeetCode 289. 生命游戏</a></td><td><a href="#2.2.2.6">题解2.2.2.6</a></td></tr></tbody></table></div><p><span id="2.2.2.1"></span>  </p><h3 id="2-2-2-1-旋转图像"><a href="#2-2-2-1-旋转图像" class="headerlink" title="2.2.2.1 旋转图像"></a>2.2.2.1 旋转图像</h3><p><a href="https://leetcode.cn/problems/rotate-image">LeetCode 48.旋转图像</a> | | <a href="#2.2.2">返回2.2.2目录</a></p><font face="Times" new roman> <font color="#3399FF">方案：顺时针旋转 90°，行变成了列，列变成了行。原来是第 _i_ 行, 现在就是 倒数 第 _i_ 列 (_N_-1-_i_)；原来是第 _j_ 列, 现在到了第 _j_ 行。对于原有的一个元素 _M[i][j]_, 旋转后出现在 <b>倒数</b> 第 _i_ 列的第 _j_ 行位置：_M[j][N-1-i]_对应四个位置上的元素的变化：  _M[N-1-j][i] --> M[i][j] --> M[j][N-1-i] --> M[N-1-i][N-1-j]_</font> </font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 转换关系 M[N-1-j][i] --&gt; M[i][j] --&gt; M[j][N-1-i] --&gt; M[N-1-i][N-1-j]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 可以发现元素互换都是在自己所在的那个圈层进行交换</span></span><br><span class="line">        <span class="comment"># 每处理完最外一圈，可以视为(待处理)矩阵缩小了一圈</span></span><br><span class="line">        <span class="comment"># 所以我们可以从外到内去处理，一共有 K圈， K = N//2</span></span><br><span class="line">        <span class="comment"># K=0时，圈层左上角是(0,0), K=1时，圈层左上角是(1,1), ...以此类推</span></span><br><span class="line">        N = <span class="built_in">len</span>(matrix)</span><br><span class="line">        K =  N // <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(K):</span><br><span class="line">            <span class="comment"># 对于每一个圈层，如果一次换4个对应位置的元素</span></span><br><span class="line">            <span class="comment"># 那么只要把该圈层的首行的每个元素都进行一次【4位置】交换</span></span><br><span class="line">            <span class="comment"># 该圈层就完成了交换了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 这里一定要注意，对于k圈层的首行，左起列是 k，右侧截止是 N-1-k</span></span><br><span class="line">            <span class="comment"># 但是最右侧那一列可以不用管，因为最后那一列的元素就是首行填充过去的</span></span><br><span class="line">            <span class="comment"># 所以右侧只用取到 N-1-k -1即可</span></span><br><span class="line">            <span class="comment"># 比如k=0时，首行如果是 1,2,3；则只需要移动元素 1及其对应4个位置的，和2及其4个对应位置的；</span></span><br><span class="line">            <span class="comment"># 不用考虑 3及其4个对应位置的数，因为3已经在元素1的4个对应位置当中处理了</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, N-<span class="number">1</span>-i):</span><br><span class="line">                matrix[i][j],     matrix[j][N-<span class="number">1</span>-i], matrix[N-<span class="number">1</span>-i][N-<span class="number">1</span>-j], matrix[N-<span class="number">1</span>-j][i] = \</span><br><span class="line">                matrix[N-<span class="number">1</span>-j][i], matrix[i][j],     matrix[j][N-<span class="number">1</span>-i],     matrix[N-<span class="number">1</span>-i][N-<span class="number">1</span>-j] </span><br><span class="line">            </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.2.2.2"></span>  </p><h3 id="2-2-2-2-对角线遍历"><a href="#2-2-2-2-对角线遍历" class="headerlink" title="2.2.2.2 对角线遍历"></a>2.2.2.2 对角线遍历</h3><p><a href="https://leetcode.cn/problems/diagonal-traverse/description/">LeetCode 498.对角线遍历</a> | | <a href="#2.2.2">返回2.2.2目录</a></p><font color="#3399FF">方案：这种矩阵遍历的问题，最关键的点就在于，如果考虑好边界条件，达到某一个边界条件之后，换方向.</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDiagonalOrder</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        m,n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        left, top, right, bottom = <span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>, m-<span class="number">1</span></span><br><span class="line">        <span class="comment"># i,j表示矩阵的i 行 j 列, k表示矩阵已经遍历了多少个元素</span></span><br><span class="line">        i, j, k = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> k &lt; m*n:</span><br><span class="line">            <span class="comment"># 朝着右上遍历</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= top <span class="keyword">and</span> j &lt;= right <span class="keyword">and</span> k &lt; m*n:</span><br><span class="line">            <span class="comment"># 当 i 未超过上边界, j 未超过右边界, k 未超过元素总数</span></span><br><span class="line">                res.append(mat[i][j])</span><br><span class="line">                i -= <span class="number">1</span> <span class="comment"># 往上移动, 故 i 减小</span></span><br><span class="line">                j += <span class="number">1</span> <span class="comment"># 往右移动, 故 j 增大</span></span><br><span class="line">                k += <span class="number">1</span> <span class="comment"># 已经遍历过一个元素</span></span><br><span class="line">            <span class="comment"># 当跳出了这个while循环时:</span></span><br><span class="line">            <span class="comment"># 1.如果是 k &lt; m*n 不满足, 可以不用管</span></span><br><span class="line">            <span class="comment"># 2.如果是 i &gt;= top 不满足, 说明上方出界, i要往下回来一行才能继续遍历</span></span><br><span class="line">            <span class="comment"># 3.如果是 j &lt;= right 不满足, 说明右侧出界, j要往左侧回来一列才能继续遍历;</span></span><br><span class="line">            <span class="comment">#   同时, 出右界, 说明刚刚那一行已经被遍历完了！！所以i即使没有越上界，依然要向下, 而且是向下两行！</span></span><br><span class="line">            <span class="comment">#   比如如果是 3行2列 的矩阵,（行多列少，j一定先出界） 就会出现这种情况</span></span><br><span class="line">            <span class="comment"># 如果是2.3都出现不满足, 说明刚刚遍历过的位置是右上角, 和情况3一样</span></span><br><span class="line">            <span class="comment"># 总结起来, 伪代码 就为 :</span></span><br><span class="line">            <span class="comment"># i = i + 1 (j没有越右界) or i + 2(j越了右界)</span></span><br><span class="line">            <span class="comment"># j = j (j没有越右界) or j - 1 (j越了右界)</span></span><br><span class="line">            i, j = (i+<span class="number">1</span>, j) <span class="keyword">if</span> (j &lt;=right) <span class="keyword">else</span> (i+<span class="number">2</span>, j-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 朝着左下遍历</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= bottom <span class="keyword">and</span> j &gt;= left <span class="keyword">and</span> k&lt;m*n:</span><br><span class="line">                res.append(mat[i][j])</span><br><span class="line">                i += <span class="number">1</span> <span class="comment"># 往下移动, 故 i 增大</span></span><br><span class="line">                j -= <span class="number">1</span> <span class="comment"># 往左移动, 故 j 减小</span></span><br><span class="line">                k += <span class="number">1</span> <span class="comment"># 已经遍历过一个元素</span></span><br><span class="line">            <span class="comment"># 分析同上（可以用3行4列的矩阵帮助思考，列多行少，i一定先出界）, 此处不赘述, 伪代码 就为 :</span></span><br><span class="line">            <span class="comment"># j = j + 1 (i没有越下界) or j + 2(i越了下界)</span></span><br><span class="line">            <span class="comment"># i = i (i没有越下界) or i - 1 (i越了下界)</span></span><br><span class="line">            j, i = (j+<span class="number">1</span>, i) <span class="keyword">if</span> (i&lt;=bottom) <span class="keyword">else</span> (j+<span class="number">2</span>, i-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.2.2.3"></span>  </p><h3 id="2-2-2-3-螺旋矩阵"><a href="#2-2-2-3-螺旋矩阵" class="headerlink" title="2.2.2.3 螺旋矩阵"></a>2.2.2.3 螺旋矩阵</h3><p><a href="https://leetcode.cn/problems/spiral-matrix">LeetCode 54. 螺旋矩阵</a> | | <a href="#2.2.2">返回2.2.2目录</a>   </p><font color="#3399FF">方案：设立四个边界值，遍历的指针碰到边界值之后，就停下来，换方向，同时更新边界值。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        i, j, k = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        left, up, right, down = <span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>, m-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(left, right+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][j])</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt;= m*n : <span class="keyword">break</span></span><br><span class="line">            up += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(up, down+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][j])</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt;= m*n : <span class="keyword">break</span></span><br><span class="line">            right -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(right, left-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][j])</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt;= m*n : <span class="keyword">break</span></span><br><span class="line">            down -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(down, up-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][j])</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt;= m*n : <span class="keyword">break</span></span><br><span class="line">            left +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.2.2.4"></span>  </p><h3 id="2-2-2-4-螺旋矩阵II"><a href="#2-2-2-4-螺旋矩阵II" class="headerlink" title="2.2.2.4 螺旋矩阵II"></a>2.2.2.4 螺旋矩阵II</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-ii">LeetCode 59. 螺旋矩阵II</a> | | <a href="#2.2.2">返回2.2.2.2目录</a>  </p><font color="#3399FF">方案：上一题中的遍历顺序搞懂了之后，这个题思路很简单，代码也差不多。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 创建一个 N*N的矩阵</span></span><br><span class="line"><span class="string">        # res = n*[n*[0]]</span></span><br><span class="line"><span class="string">        # 注意，这么写是错的，这样写的后果就是里面的每行都是来源于同一行 的copy，</span></span><br><span class="line"><span class="string">        # 会共享存储空间，属于python的浅拷贝！</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 应该这么写：</span></span><br><span class="line"><span class="string">        # res = []</span></span><br><span class="line"><span class="string">        # for i in range(n):</span></span><br><span class="line"><span class="string">        #   res.append([0]*n)</span></span><br><span class="line"><span class="string">        # 即每一行都是新创建一个 [0]*n的行，然后添加进去</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 简化为如下写法：</span></span><br><span class="line">        res = [ [<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        i, j, k = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        left, up, right, down = <span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(left, right+<span class="number">1</span>):</span><br><span class="line">                res[i][j]=k</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n*n: <span class="keyword">break</span></span><br><span class="line">            up +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(up, down+<span class="number">1</span>):</span><br><span class="line">                res[i][j]=k</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n*n: <span class="keyword">break</span></span><br><span class="line">            right -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(right, left-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res[i][j]=k</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n*n: <span class="keyword">break</span></span><br><span class="line">            down -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(down, up-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res[i][j]=k</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n*n: <span class="keyword">break</span></span><br><span class="line">            left +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.2.2.5"></span>  </p><h3 id="2-2-2-5-矩阵置零"><a href="#2-2-2-5-矩阵置零" class="headerlink" title="2.2.2.5 矩阵置零"></a>2.2.2.5 矩阵置零</h3><p><a href="https://leetcode.cn/problems/set-matrix-zeroes/">LeetCode 73. 矩阵置零</a> | | <a href="#2.2.2">返回2.2.2目录</a>   </p><font color="#3399FF">方案：我们需要知道原矩阵中哪些位置为0，如果在遍历的同时修改，那么原来不为0的元素可能会被置为0，会影响后面的元素的判断。比如如果左上角是0，在遍历的时候同时修改原数组，那么第一行和第一列的元素会全部变为0；会导致后面所有元素全部为0. 所以我们只能先遍历矩阵，然后找个地方把为0的位置先记住，然后再第二次遍历的时候进行修改。</font>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setZeroes</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 如果在遍历的时候就修改，那么前面如果出现了0，修改完之后，后面很可能都被改为0</span></span><br><span class="line">        <span class="comment"># 所以先记住这些为0的行/列索引</span></span><br><span class="line">        <span class="comment"># 再改</span></span><br><span class="line">        </span><br><span class="line">        rows, cols = [], []</span><br><span class="line">        M, N = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">in</span> rows:</span><br><span class="line">                        rows.append(i)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> j <span class="keyword">in</span> cols:</span><br><span class="line">                        cols.append(j)</span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;注意，python的二维list不支持以下写法：</span></span><br><span class="line"><span class="string">        for i in rows:</span></span><br><span class="line"><span class="string">            matrix[i][:] =0</span></span><br><span class="line"><span class="string">        for j in cols:</span></span><br><span class="line"><span class="string">            matrix[:][j] = 0</span></span><br><span class="line"><span class="string">        这是 numpy array 才支持的写法</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> rows <span class="keyword">or</span> j <span class="keyword">in</span> cols:</span><br><span class="line">                    matrix[i][j] =<span class="number">0</span> </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;思路2.直接用第一列来记录哪一行出现过0，用第一行来记录哪一列出现过0；</span></span><br><span class="line"><span class="string">后续的元素出现0时，虽然第一行和第一列被修改了，但是第一行第一列对应的位置，按照规则本来也会被改成0. </span></span><br><span class="line"><span class="string">不过要提前记录第一行和第一列是否有0元素，有的话，最后再把他们全部变为0；没有的话就不用管&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setZeroes</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        flag_col0 = <span class="built_in">any</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m))</span><br><span class="line">        flag_row0 = <span class="built_in">any</span>(matrix[<span class="number">0</span>][j] == <span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 先用第一行和第一列来记录出现0的列和行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 根据第一行和第一列的记录，来修改原始矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">or</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 再来处理第一列</span></span><br><span class="line">        <span class="keyword">if</span> flag_col0:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 再来处理第一行</span></span><br><span class="line">        <span class="keyword">if</span> flag_row0:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p><span id="2.2.2.6"></span>  </p><h3 id="2-2-2-6-生命游戏"><a href="#2-2-2-6-生命游戏" class="headerlink" title="2.2.2.6 生命游戏"></a>2.2.2.6 生命游戏</h3><p><a href="https://leetcode.cn/problems/game-of-life">LeetCode 289. 生命游戏</a> | | <a href="#2.2.2">返回2.2.2目录</a>    </p><p><font color="#3399FF">方案：规则看起来很唬人，很多，但是就是对于每一个元素判断，判断其3*3窗口内的值，然后根据该值去改变当前元素的值，的这么一个条件判断语句。<br>另外，由于是同时发生改变，所以不能让变化后的值，影响到后面的元素的判断，所以也要先找一个地方，记录状态，和上题一样，只不过这里直接拷贝一个矩阵，拿他来记录原始状态</font>。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gameOfLife</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 因为是同时发生的，所以我们不能在原有矩阵上直接修改</span></span><br><span class="line">        <span class="comment"># 而是参照原有矩阵的值，对一个新的矩阵的值进行判定</span></span><br><span class="line">        <span class="comment"># 二维数组的 深度拷贝的方式有以下几种，不能直接用 = 号去拷贝，那样是python的浅拷贝，会共享存储区域</span></span><br><span class="line">        <span class="keyword">import</span> copy</span><br><span class="line">        copy_board = copy.deepcopy(board)</span><br><span class="line">        <span class="comment"># copy_board = [copy.deepcopy(row) for row in board]</span></span><br><span class="line">        <span class="comment"># copy_board = [[board[i][j] for j in range(n)] for i in range(m)]</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># left: max(0, j-1), right: min(n, j+1+1), top: max(0, i-1), bottom: min(m, i+1+1)</span></span><br><span class="line">                <span class="keyword">if</span> copy_board[i][j] == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 如果原始状态是1，进入下面的规则</span></span><br><span class="line">                    <span class="comment"># 由于我们要算周围8个格子的和</span></span><br><span class="line">                    <span class="comment"># 先将初始值置为-1，这样就直接考虑9宫格的和（相当于减去当前元素1）</span></span><br><span class="line">                    area_sum = -<span class="number">1</span></span><br><span class="line">                    <span class="comment"># 然后就是如何遍历以当前元素为中心的9宫格的问题了</span></span><br><span class="line">                    <span class="comment"># 理想情况下，i的遍历范围[i-1, i+1 +1), j的遍历范围 [j-1, j+1 +1)</span></span><br><span class="line">                    <span class="comment"># 但是要考虑格子本身就在矩阵边界的情况，所以:</span></span><br><span class="line">                    <span class="comment"># 上边界最小只能到 0: 取max(0, i-1); 左边界最小只能到 0: 取max(0, j-1)</span></span><br><span class="line">                    <span class="comment"># 下边界最大只能到 m: 取min(m, i+1 +1); 右边界最大只能到 n：取min(n, j+1 +1);</span></span><br><span class="line">                    <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(<span class="number">0</span>,i-<span class="number">1</span>), <span class="built_in">min</span>(m,i+<span class="number">1</span> +<span class="number">1</span>)):</span><br><span class="line">                        <span class="keyword">for</span> q <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(<span class="number">0</span>,j-<span class="number">1</span>), <span class="built_in">min</span>(n, j+<span class="number">1</span> +<span class="number">1</span>)):</span><br><span class="line">                            area_sum += copy_board[p][q]</span><br><span class="line">                    <span class="keyword">if</span> area_sum &lt; <span class="number">2</span>:</span><br><span class="line">                        board[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">elif</span> area_sum &gt; <span class="number">3</span>:</span><br><span class="line">                        board[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果原始状态是0，进入下面的规则</span></span><br><span class="line">                    area_sum = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(i-<span class="number">1</span>,<span class="number">0</span>), <span class="built_in">min</span>(m,i+<span class="number">1</span>+<span class="number">1</span>)):</span><br><span class="line">                        <span class="keyword">for</span> q <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(<span class="number">0</span>,j-<span class="number">1</span>), <span class="built_in">min</span>(n, j+<span class="number">1</span>+<span class="number">1</span>)):</span><br><span class="line">                            area_sum += copy_board[p][q]</span><br><span class="line">                    <span class="keyword">if</span> area_sum == <span class="number">3</span>:</span><br><span class="line">                        board[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2-1 顺序表</title>
      <link href="/Data-Structure/DS_21_SeqList.html"/>
      <url>/Data-Structure/DS_21_SeqList.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1"> <h1 id="2-1-顺序表"><a href="#2-1-顺序表" class="headerlink" title="2-1 顺序表"></a>2-1 顺序表</h1><hr style="border:solid; height:1px; color=#000000 size=1">   <p>[toc]</p><h2 id="2-1-1-线性表的概念"><a href="#2-1-1-线性表的概念" class="headerlink" title="2.1.1 线性表的概念"></a>2.1.1 线性表的概念</h2><p>线性表<font face="Times" new roman>（linear list）</font>是数据结构的一种，一个线性表是n个具有相同特性的数据元素构成的有限序列，<b>其中的元素的前驱和后置都最多只有一个</b>。<br>线性表是最基本、最简单、也是最常用的一种数据结构。我们说“线性”和“非线性”，只在逻辑层次上讨论，而不考虑存储层次，所以常见的线性表包括：顺序表、栈和队列、链表。<br>线性表通常都具有：初始化、遍历、求长度和增删改查这些操作。  </p><h2 id="2-1-2-顺序表"><a href="#2-1-2-顺序表" class="headerlink" title="2.1.2 顺序表"></a>2.1.2 顺序表</h2><p>顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储区域，将数据元素顺序地存储在其中，就形成一个顺序表。<br>元素间的顺序关系由它们的存储顺序自然的表示。  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/2_1.webp" width="90%">  </p><p>顺序表的两种形式如图所示；<br>a) 是直接存储元素，这就要求元素的类型相同了，因为不同类型的元素占据的字节数是不一样的；<br>b) 是存储的地址，地址指向的是一些元素，由于地址本身这个类型（比如C++中的指针类型）占据的字节是固定的，所以可以存在顺序表中，这些地址指向的具体的位置，存放的元素又可以是不同的类型。  </p><h2 id="2-1-3-Python中的顺序表"><a href="#2-1-3-Python中的顺序表" class="headerlink" title="2.1.3 Python中的顺序表"></a>2.1.3 Python中的顺序表</h2><p>Python标准类型list（列表，就是一种线性表。但是比较特殊，它是一种元素个数可变的线性表。这种顺序表被称为【<strong>动态顺序表</strong>】，因其容量可以在使用过程中动态变化。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;执行以下code，你会发现list中相同的数:1, 竟然指向的是同一个地址</span></span><br><span class="line"><span class="string">这就跟C/C++的传统印象有区别&#x27;&#x27;&#x27;</span></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(nums[i]))</span><br><span class="line"></span><br><span class="line">nums[<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;#&#x27;</span>*<span class="number">14</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(nums[i]))</span><br><span class="line"><span class="comment">##### output ######</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073360</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073424</span></span><br><span class="line"><span class="string">##############</span></span><br><span class="line"><span class="string">1638490265040</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073360</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073424</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>Python 中的 list 的是一种 <u>采用分离式技术实现的动态顺序表</u> ，在建立空列表的时候，系统分配一块能容纳8个元素的存储区；在执行插入操作时(insert/append)，如果元素存储区满了，就换一块4倍大的存储区。但是如果当list的规模已经较大时，（目前阈值为50000），就换一块2倍大的存储区，避免出现过多的空闲存储位置。<br>Python 中的另一个顺序表，就是 tuple（元组），元组就不可以改变值了。</p><h2 id="2-1-4-Python中list内置操作的时间复杂度"><a href="#2-1-4-Python中list内置操作的时间复杂度" class="headerlink" title="2.1.4 Python中list内置操作的时间复杂度"></a>2.1.4 Python中list内置操作的时间复杂度</h2><div class="table-container"><table><thead><tr><th>操作</th><th>时间复杂度</th><th>举例</th></tr></thead><tbody><tr><td>a[ ]</td><td>O(1)</td><td>a[1]</td></tr><tr><td>pop()</td><td>O(1)</td><td>a.pop()</td></tr><tr><td>pop(i)</td><td>O(N)</td><td>a.pop(0)</td></tr><tr><td>insert(i,item)</td><td>O(N)</td><td>a.insert(3,100)</td></tr><tr><td>del</td><td>O(N)</td><td>del a[3]</td></tr><tr><td>len</td><td>O(N)</td><td>len(a)</td></tr><tr><td>iteration</td><td>O(N)</td><td>for x in a: print x</td></tr><tr><td>contains(in)</td><td>O(N)</td><td>3 in a</td></tr><tr><td>get slice[x:y]</td><td>O(k)</td><td>a[3:7]</td></tr><tr><td>del slice</td><td>O(N)</td><td>del a[3:7]</td></tr><tr><td>set slice</td><td>O(k+N)</td><td>a[3:7]=[3,4,5,6]</td></tr><tr><td>reverse</td><td>O(N)</td><td>a.reverse()</td></tr><tr><td>concatenate</td><td>O(k)</td><td>[1, 2, 3] + [4, 5, 6]</td></tr><tr><td>sort</td><td>O(nlogN)</td><td>a.sort()</td></tr><tr><td>multiply</td><td>O(kN)</td><td>[‘Hi!’] * 4</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1-1 数据结构与算法</title>
      <link href="/Data-Structure/DS_11_data_structure.html"/>
      <url>/Data-Structure/DS_11_data_structure.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1"> <h1 id="1-1-数据结构与算法"><a href="#1-1-数据结构与算法" class="headerlink" title="1-1 数据结构与算法"></a>1-1 数据结构与算法</h1><hr style="border:solid; height:1px; color=#000000 size=1"> <h2 id="1-1-1-数据结构"><a href="#1-1-1-数据结构" class="headerlink" title="1.1.1 数据结构"></a>1.1.1 数据结构</h2><p>数据结构是讨论计算机系统中 <font color="red"> 数据的存储、组织形式 及其 相互关系</font>。  </p><ul><li>数据：客观事物 采用计算机进行识别、存储和加工所进行的描述  </li><li>结构：事物间的相互关系和约束  </li><li>数据结构的基本单元是数据元素  </li></ul><p>数据结构的3个层次：<b>① 数据的逻辑结构；② 数据的存储结构；③ 数据的运算结构(操作集合)。</b>  </p><table border="1" align="center">    <tr>        <td rowspan="3"> ①逻辑结构</td>        <td colspan="2">            反映数据 元素之间 的 逻辑关系 的结构。<br>            逻辑关系是指数据元素之间的<b>前后间关系</b>，而与他们在计算机中的存储位置无关。        </td>    </tr>    <tr>        <td> 线性结构 </td>        <td>             有且仅有一个开始元素和终点元素;<br>            且所有数据元素最多只有一个直接前趋和一个直接后继。<br>             比如 线性表。         </td>    </tr>    <tr>        <td> 非线性结构 </td>        <td>             一个元素可能有多个直接前趋和多个直接后继。<br>            比如 树结构、图结构。        </td>    </tr>    <tr>        <td rowspan="2"> ②存储结构 </td>        <td colspan="2">             数据的逻辑结构在计算机存储空间中的存放形式称为数据的存储结构。<br>            (也称为物理结构)        </td>    </tr>    <tr>        <td colspan="2">            反应数据元素在计算机中的存储方案。<br>            比如：顺序存储、链接存储、索引存储、散列存储。        </td>    </tr>    <tr>        <td rowspan="7"> ③运算结构</td>        <td colspan="2">             数据结构的操作集合        </td>    </tr>    <tr>        <td>  遍历 </td>        <td>  在数据结构的各个元素中移动，或查看所有元素。</td>    </tr>      <tr>        <td>  插入<font color="red">(增)<font> </font></font></td>        <td>  往数据结构中 添加新的元素。</td>    </tr>     <tr>        <td>  删除<font color="red">(删)<font> </font></font></td>        <td>  把指定的数据结构元素移除。</td>    </tr>     <tr>        <td>  更新<font color="red">(改)<font> </font></font></td>        <td>  修改 或 替换数据结构中的 一个或多个元素。</td>    </tr>     <tr>        <td>  查找<font color="red">(查)<font> </font></font></td>        <td>  在数据结构中找寻满足一定条件的数据元素。</td>    </tr>     <tr>        <td>  排序 </td>        <td>  在保持数据结构中元素个数不变的前提条件下，把元素按照指定的顺序重新排列，排序一般是针对线性逻辑结构。</td>    </tr> </table>  <h2 id="1-1-2-算法"><a href="#1-1-2-算法" class="headerlink" title="1.1.2 算法"></a>1.1.2 算法</h2><p>指为解决特定问题 的 有穷的 操作规则 的集合。  </p><table>    <th colspan="2"> 算法的 5 个基本特性 </th>    <tr>        <td> ①有穷性 </td>        <td> 有始有终，不会无限循环，且执行时间可接受。 </td>    </tr>    <tr>        <td> ②确定性 </td>        <td> 算法操作的每一步，其顺序和内容都唯一确定，不会出现二义性。 </td>    </tr>    <tr>        <td> ③数据输入 </td>        <td> 算法具有0个或多个输入。 </td>    </tr>    <tr>        <td> ④数据输出 </td>        <td> 算法至少有一个输出。</td>    </tr>    <tr>        <td> ⑤可行性 </td>        <td> 算法任一步操作都是可以付诸实践的。 </td>    </tr></table>  <p>算法点的效率可分为 时间效率 和 空间效率。  </p><table>    <tr>        <td>             空间复杂度<br>            <font face="Times" new roman> <i>S(n)=O(f(n))</i> </font>        </td>        <td colspan="4">            除开存储数据结构本身外（比如指令、常数、变量 和输入数据），实现算法所需要的额外辅助空间有多少。        </td>    </tr>        <td rowspan="5">             时间复杂度<br>            <font face="Times" new roman> <i>T(n)=O(f(n))</i> </font>        </td>        <td colspan="4">            执行算法所需要的时间以 常数时间操作 的数量级来表示。<br>            相同规模的不同输入，仍可能导致算法的运行时间不同。<br>            <b>一般使用算法最坏情况下的的复杂度来做代表。</b>        </td>    <tr>        <td colspan="4">            常数时间操作是指我们在写代码的时候会涉及到一些指令,这些执令都是固定时间的操作。<br>这些指令是和数据量没有关系的,比如加、减、乘、除、模、位移运算,又或者数组的寻址。        </td>    </tr>    <tr>        <td colspan="4">            不同的机器常数时间操作不一样，比如新一代的机器可能性能更好，常数时间操作更短。<br>但是我们用常数时间操作的数量级（而非具体的数值）来衡量时间复杂度的话，就可以忽略机器的因素，而聚焦到算法本身上来。        </td>    </tr>    <tr>        <td colspan="4">            时间复杂度可以用T(n)的自然特性加以区分，如下：        </td>    </tr>    <tr>        <td> 常量时间 O(1) </td>        <td> 线性时间 O(n) </td>        <td> 对数时间 O(logn) </td>        <td> 指数时间 O(n**2) </td>    </tr></table>  <p>Python 中的 <code>timeit</code> 模块可以来测试代码的执行时间，网上有很多资料,这里不赘述。<br>时间复杂度大致上有以下的大小关系：  </p><p>O(1) &lt; O(logN) &lt; O(logN^2) &lt; O(N) &lt; O(N*logN) &lt; O(N^2) &lt; O(N^3)&lt; …&lt;O(N^k)<br>…  &lt; O( 2^N) &lt; O(3^N)  &lt; … &lt; O(k^N) &lt; O(N!)  </p><p>可以通过数学函数图像来加深理解。  </p><p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/1_1_math_func_img.webp" width="60%">   </p><h2 id="1-1-3-程序"><a href="#1-1-3-程序" class="headerlink" title="1.1.3 程序"></a>1.1.3 程序</h2><p>程序 = 算法 + 数据结构                —— 尼古拉斯·沃斯<br><b> <font color="red">Algorithm + Data Structures = Programs </font>   ——  Niklaus Wirth，1984 图灵奖 <B></B></b></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法_Python</title>
      <link href="/Data-Structure/DS_00_introduction.html"/>
      <url>/Data-Structure/DS_00_introduction.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">  </p><hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p>本系列文章以Python语言为基础，简要介绍基本的数据结构与算法的相关知识。<br>并配合 <a href="https://leetcode.cn/">LeetCode</a> 网站的一些题目来加深相关概念的了解。<br><b><font color="red">注意！由于版权原因，本系列文章在引用LeetCode的题目时，只提供官方页面的跳转链接，而不会直接展示题目信息。</font></b> </p><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><h2 id="1-1-数据结构与算法"><a href="#1-1-数据结构与算法" class="headerlink" title="1-1 数据结构与算法"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_11_data_structure.html">1-1 数据结构与算法</a></h2><h2 id="2-1-顺序表"><a href="#2-1-顺序表" class="headerlink" title="2-1 顺序表"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_21_SeqList.html">2-1 顺序表</a></h2><h2 id="2-2-数组相关题目"><a href="#2-2-数组相关题目" class="headerlink" title="2-2 数组相关题目"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_22_array_exercises.html">2-2 数组相关题目</a></h2><h2 id="2-3-数组双指针"><a href="#2-3-数组双指针" class="headerlink" title="2-3 数组双指针"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_23_array_double_pointer_exercises.html">2-3 数组双指针</a></h2><h2 id="3-1-排序"><a href="#3-1-排序" class="headerlink" title="3-1 排序"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_31_sort_algorithm.html">3-1 排序</a></h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图像分割测试用例</title>
      <link href="/Computer-Vision/Image-Segmentation-By-Deeplearning/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.html"/>
      <url>/Computer-Vision/Image-Segmentation-By-Deeplearning/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.html</url>
      
        <content type="html"><![CDATA[<p>图像分割测试用例</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 深度学习下的图像分割 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习导论</title>
      <link href="/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA.html"/>
      <url>/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA.html</url>
      
        <content type="html"><![CDATA[<p>机器学习导论</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
