<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2-3 数组双指针</title>
      <link href="/Data-Structure/DS_23_array_double_pointer_exercises.html"/>
      <url>/Data-Structure/DS_23_array_double_pointer_exercises.html</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">    <hr style="border:solid; height:1px; color=#000000 size=1"> <h1 id="2-3-数组双指针"><a href="#2-3-数组双指针" class="headerlink" title="2-3 数组双指针"></a>2-3 数组双指针</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p><b>版权声明：以下题目均来自 <a href="https://leetcode.cn/">LeetCode</a>， 仅仅提供跳转到力扣官网的链接，不在本页面出现题目内容，本文章内容禁止商业用途。</b>  </p><p>指针的名字来源于链表，代表的是指向结点地址的位置变量。可以迁移到数组这边来，代表存储数组索引的变量。<br>而双指针的意思就是用两个变量来维护不同的索引，从而实现特定的功能。  </p><h2 id="2-3-1-对撞指针"><a href="#2-3-1-对撞指针" class="headerlink" title="2.3.1 对撞指针"></a>2.3.1 对撞指针</h2><p>所谓对撞指针，就是指的初始状态的两个指针一个在左，一个在右；终止条件为左指针等于右指针。  </p><p><span id="2.3.1"></span>  </p><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">LeetCode 167.两数之和II-输入有序数组</a></td><td><a href="#2.3.1.1">题解2.3.1.1</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/reverse-string/">LeetCode 344.反转字符串</a></td><td><a href="#2.3.1.2">题解2.3.1.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/reverse-vowels-of-a-string/">LeetCode 345.反转字符串中的元音字母</a></td><td><a href="#2.3.1.3">题解2.3.1.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/valid-palindrome/">LeetCode 125.验证回文串</a></td><td><a href="#2.3.1.4">题解2.3.1.4</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21.调整数组顺序使奇数位于偶数前面</a></td><td><a href="#2.3.1.5">题解2.3.1.5</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/boats-to-save-people/">LeetCode 881.救生艇</a></td><td><a href="#2.3.1.6">题解2.3.1.6</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/container-with-most-water/">LeetCode 11.盛最多水的容器</a></td><td><a href="#2.3.1.7">题解2.3.1.7</a></td></tr><tr><td>⑧</td><td><a href="https://leetcode.cn/problems/valid-triangle-number/">LeetCode 611.有效三角形的个数</a></td><td><a href="#2.3.1.8">题解2.3.1.8</a></td></tr><tr><td>⑨</td><td><a href="https://leetcode.cn/problems/3sum/">LeetCode 15.三数之和</a></td><td><a href="#2.3.1.9">题解2.3.1.9</a></td></tr><tr><td>⑩</td><td><a href="https://leetcode.cn/problems/3sum-closest/description/">LeetCode 16.最接近的三数之和</a></td><td><a href="#2.3.1.10">题解2.3.1.10</a></td></tr><tr><td>⑪</td><td><a href="https://leetcode.cn/problems/4sum/">LeetCode 18.四数之和</a></td><td><a href="#2.3.1.11">题解2.3.1.11</a></td></tr><tr><td>⑫</td><td><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">LeetCode 977.有序数组的平方</a></td><td><a href="#2.3.1.12">题解2.3.1.12</a></td></tr><tr><td>⑬</td><td><a href="https://leetcode.cn/problems/sort-colors/">LeetCode 75.颜色分类</a></td><td><a href="#2.3.1.13">题解2.3.1.13</a></td></tr><tr><td>⑭</td><td><a href="https://leetcode.cn/problems/trapping-rain-water/">LeetCode 42.接雨水</a></td><td><a href="#2.3.1.14">题解2.3.1.14</a></td></tr><tr><td>⑮</td><td><a href="https://leetcode.cn/problems/longest-mountain-in-array/">LeetCode 845.数组中的最长山脉</a></td><td><a href="#2.3.1.15">题解2.3.1.15</a></td></tr><tr><td>⑯</td><td><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">LeetCode 978.最长湍流子数组</a></td><td><a href="#2.3.1.16">题解2.3.1.16</a></td></tr></tbody></table><p><span id="2.3.1.1"></span>  </p><h3 id="2-3-1-1-两数之和II-输入有序数组"><a href="#2-3-1-1-两数之和II-输入有序数组" class="headerlink" title="2.3.1.1 两数之和II -输入有序数组"></a>2.3.1.1 两数之和II -输入有序数组</h3><p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">LeetCode 167.两数之和II-输入有序数组</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p><font color="#3399FF">思路：数组已经有序，那可以从左右两侧向中间靠拢，逼近目标值。</font></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        N = <span class="built_in">len</span>(numbers)</span><br><span class="line">        L, R  =<span class="number">0</span>, N-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            <span class="keyword">while</span> L  &lt;R <span class="keyword">and</span>  numbers[L] +  numbers[R] &lt;target:</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> numbers[L] +  numbers[R] &gt; target:</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> L&lt; R <span class="keyword">and</span> numbers[L] +  numbers[R] == target:</span><br><span class="line">                <span class="keyword">return</span> [L+<span class="number">1</span>, R+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p><span id="2.3.1.2"></span></p><h3 id="2-3-1-2-反转字符串"><a href="#2-3-1-2-反转字符串" class="headerlink" title="2.3.1.2 反转字符串"></a>2.3.1.2 反转字符串</h3><p><a href="https://leetcode.cn/problems/reverse-string/">LeetCode 344.反转字符串</a> |  | <a href="#2.3.1">返回目录2.3.1</a></p><p><font color="#3399FF">思路：这个题是对撞双指针的代表题目，也可以用它来进行数组逆序。</font>   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            s[L], s[R] = s[R], s[L]</span><br><span class="line">            L += <span class="number">1</span></span><br><span class="line">            R -=<span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="2.3.1.3"></span>  </p><h3 id="2-3-1-3-反转字符串中的元音字母"><a href="#2-3-1-3-反转字符串中的元音字母" class="headerlink" title="2.3.1.3 反转字符串中的元音字母"></a>2.3.1.3 反转字符串中的元音字母</h3><p><a href="https://leetcode.cn/problems/reverse-vowels-of-a-string/">LeetCode 345.反转字符串中的元音字母</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p><font color="#3399FF">思路 1：先用哈希表记住元音字母原始的索引，然后按照索引逆序改变其对应位置的值。</font>   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;思路1.使用哈希表&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        ll = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="comment"># from collections import defaultdict</span></span><br><span class="line">        <span class="comment"># dict_1 = defaultdict(str)</span></span><br><span class="line">        <span class="comment"># N = len(s)</span></span><br><span class="line">        <span class="comment"># for i in range(N):</span></span><br><span class="line">        <span class="comment">#     if ll[i] in &#x27;aeiouAEIOU&#x27;:</span></span><br><span class="line">        <span class="comment">#         dict_1[i] = ll[i]</span></span><br><span class="line">        <span class="comment"># 注释中的内容一行代码就可以写完</span></span><br><span class="line">        dict_1 = <span class="built_in">dict</span>((i,ch) <span class="keyword">for</span> (i,ch) <span class="keyword">in</span> <span class="built_in">enumerate</span>(ll) <span class="keyword">if</span> ch <span class="keyword">in</span> <span class="string">&#x27;aeiouAEIOU&#x27;</span>)</span><br><span class="line">        list_key = <span class="built_in">sorted</span>(<span class="built_in">list</span>(dict_1.keys()))</span><br><span class="line"></span><br><span class="line">        length = <span class="built_in">len</span>(list_key)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            ll[list_key[i]] =  dict_1[list_key[length-<span class="number">1</span>-i]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ll)</span><br></pre></td></tr></table></figure><p><font color="#3399FF">思路2：使用双指针，可以借鉴 <a href="#2.3.1.2">反转字符串</a> 那道题的思路；<br>只不过并不是直接反转，而是先要判断条件。<br>由于我们反转的是元音字符，所以如果不是元音字符，双指针就不用停下来，而是一直向中间靠拢。<br>一旦在相遇之前停下来，说明左右两个指针都遇到了元音字符，我们就将其交换位置（反转）即可；</font>   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;思路2. 使用双指针&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(s)</span><br><span class="line">        ll = <span class="built_in">list</span>(s)</span><br><span class="line">        L, R = <span class="number">0</span>, N-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> ll[L] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;aeiouAEIOU&#x27;</span>:</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> ll[R] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;aeiouAEIOU&#x27;</span>:</span><br><span class="line">                R -=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> L&lt;R:</span><br><span class="line">                ll[L], ll[R] = ll[R], ll[L]</span><br><span class="line">                L +=<span class="number">1</span></span><br><span class="line">                R -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ll)</span><br></pre></td></tr></table></figure><p><span id="2.3.1.4"></span>  </p><h3 id="2-3-1-4-验证回文串"><a href="#2-3-1-4-验证回文串" class="headerlink" title="2.3.1.4 验证回文串"></a>2.3.1.4 验证回文串</h3><p><a href="https://leetcode.cn/problems/valid-palindrome/">LeetCode 125.验证回文串</a> | | <a href="#2.3.1">返回目录2.3.1</a>  </p><p><font color="#3399FF">思路：回文字符串就是以中心为对称的关系，而且题目中说明了只考虑小写字母和数字两种字符的情况，其他的就该跳过。<br>也是考虑使用对撞指针.</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 先将所有大写转成小写</span></span><br><span class="line">        s = s.lower()</span><br><span class="line">        <span class="comment"># 初始化双指针</span></span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> <span class="keyword">not</span> s[L].isalnum():</span><br><span class="line">                <span class="comment"># 对于非字母数字字符, 直接不考虑, 直接移动指针</span></span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> <span class="keyword">not</span> s[R].isalnum():</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> L &lt; R:</span><br><span class="line">                <span class="keyword">if</span> s[L] == s[R]:</span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果发现不相等的情况，说明左右不对称</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>   </span><br></pre></td></tr></table></figure><p><span id="2.3.1.5"></span>  </p><h3 id="2-3-1-5-调整数组顺序使奇数位于偶数前面"><a href="#2-3-1-5-调整数组顺序使奇数位于偶数前面" class="headerlink" title="2.3.1.5 调整数组顺序使奇数位于偶数前面"></a>2.3.1.5 调整数组顺序使奇数位于偶数前面</h3><p><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21.调整数组顺序使奇数位于偶数前面</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p><font color="#3399FF">思路：该题和上面【 <a href="#2.3.1.3">反转字符串中的元音字母</a> 】思路是一脉相承的；<br>这里反转的不是元音字符，而是奇数or偶数，只需将判断条件做修改就行；</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exchange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        </span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[L] % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 题目要求奇数在前，所以如果是奇数，左指针就不用反转，直接指针把L指针右移</span></span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[R] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 题目要求偶数在后，所以如果是偶数，右指针就不用反转，直接指针把R指针左移</span></span><br><span class="line">                R -=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 前面两个循环执行完毕后，说明L遇到的是偶数，R遇到的是奇数，</span></span><br><span class="line">            <span class="comment"># 此时交换一下位置即可</span></span><br><span class="line">            <span class="keyword">if</span> L &lt; R:</span><br><span class="line">                nums[L], nums[R] = nums[R], nums[L]</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><span id="2.3.1.6"></span>  </p><h3 id="2-3-1-6-救生艇"><a href="#2-3-1-6-救生艇" class="headerlink" title="2.3.1.6 救生艇"></a>2.3.1.6 救生艇</h3><p><a href="https://leetcode.cn/problems/boats-to-save-people/">LeetCode 881.救生艇</a> || <a href="#2.3.1">返回目录2.3.1</a></p><p><font color="#3399FF">思路：该题说一艘船最多载两人，就容易联想到双指针。一个指针代表一个人，两个指针指向元素的和就是两个人的重量之和。<br>只不过，这里有一个和之前的题目不同的点，那就是我们需要对数组先进行排序。<br>为什么呢？因为如果两个人挤一条船，那么按照生活常识，我们肯定是希望尝试一个最轻的和一个最重的进行搭配，尽可能的利用船的承载能力。<br>所以如果用双指针代表两个人，就需要一个是来自于轻的一组，一个是来自于重的一组，所以按照重量先排序，左侧的就是轻的，右侧的就是重的，就可以利用对撞双指针了。</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numRescueBoats</span>(<span class="params">self, people: <span class="type">List</span>[<span class="built_in">int</span>], limit: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        people.sort()</span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(people)-<span class="number">1</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> L &lt;= R: </span><br><span class="line">        <span class="comment"># 注意, 这里的循环控制条件可以L==R, 因为 L==R时表示还剩一个人,这个人单独一艘船 </span></span><br><span class="line">            <span class="keyword">if</span> people[L] + people[R] &lt;= limit:</span><br><span class="line">                <span class="comment"># 如果较轻和较重的能够被一艘船容纳, 就刚好组成一对</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果较轻和较重的加起来比limit还大</span></span><br><span class="line">                <span class="comment"># 就将较重的用一艘船去容纳</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.3.1.7"></span>  </p><h3 id="2-3-1-7-盛水最多的容器"><a href="#2-3-1-7-盛水最多的容器" class="headerlink" title="2.3.1.7 盛水最多的容器"></a>2.3.1.7 盛水最多的容器</h3><p><a href="https://leetcode.cn/problems/container-with-most-water/">LeetCode 11.盛最多水的容器</a> | | <a href="#2.3.1">返回目录2.3.1</a>  </p><p><font color="#3399FF">思路：双指针代表的是 可以作为容器边界的所有位置的范围。在一开始，双指针指向数组的左右边界，表示 数组中所有的位置都可以作为容器的边界，每次将 <b>对应的数字较小的那个指针</b> 往 另一个指针 的方向移动一个位置，就表示我们认为 这个指针不可能再作为容器的边界了, 然后再比较当前装水容量和之前的装水容量, 看哪个更大即可。  </font></p><blockquote><p><b>因为水桶能装多少水，是最矮的那个边界决定的。<br>意思是，如果不移动最矮的边界，而移动另一侧较高的边界，无论怎么移动，装水的容量都不可能变多。<br>所以我们只好移动最矮的那个边界，看看移动它之后，是否能使得装水量变多。</b>  </p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        L, R = <span class="number">0</span>, <span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">        water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> L &lt; R:</span><br><span class="line">        <span class="comment"># 两个边界碰到一起之前, 能够装水</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> height[L] &lt;= height[R]:</span><br><span class="line">                water = <span class="built_in">max</span>(water, height[L]*(R-L))</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> height[L] &gt; height[R]:</span><br><span class="line">                water = <span class="built_in">max</span>(water, height[R]*(R-L))</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> water </span><br></pre></td></tr></table></figure><p><span id="2.3.1.8"></span>  </p><h3 id="2-3-1-8-有效三角形的个数"><a href="#2-3-1-8-有效三角形的个数" class="headerlink" title="2.3.1.8 有效三角形的个数"></a>2.3.1.8 有效三角形的个数</h3><p><a href="https://leetcode.cn/problems/valid-triangle-number/">LeetCode 611.有效三角形的个数</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p><font color="#3399FF">思路：假设三条边分别为a,b,c;则满足三角形的条件为任意两边之和都大于第三边；<br>如果知道a,b,c的大小关系，比如 a&lt;&#x3D;b&lt;&#x3D;c, <b>那么两小边之和大于长边就一定能形成三角形</b></font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triangleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N =<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> N &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先从大到小排序</span></span><br><span class="line">        nums.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-<span class="number">2</span>):</span><br><span class="line">            <span class="comment"># 当前 i 位置的数左为最长边 lng； 另外两个小边就在[i+1, N-1]区间找</span></span><br><span class="line">            L, R = i+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;R:</span><br><span class="line">                <span class="comment"># 目标是期望 小边之和 &gt; 长边，即 a+b &gt; c</span></span><br><span class="line">                <span class="comment"># lng, mid, sht = nums[i], nums[L], nums[R]</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果 mid + sht 不够大，说明sht应该增大，即R侧应该往左移一次，找一个更大的sht</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt;= nums[L] + nums[R]:</span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># lng &lt; mid + sht</span></span><br><span class="line">                    <span class="comment"># 如果此时能满足条件, R位置充当最短边sht，则R左侧的更大的数更能成为sht</span></span><br><span class="line">                    <span class="comment"># 即从 L+1 ~ R位置的所有数都可以成为最短边 sht(使得mid + sht更大)</span></span><br><span class="line">                    <span class="comment"># 与mid (L位置的值)一起构造一对小边; sht可取的个数为  =&gt; R - L</span></span><br><span class="line">                    res += R - L</span><br><span class="line">                    <span class="comment"># 计数完之后，再将 L 右移一位，即 mid 减小一点，</span></span><br><span class="line">                    <span class="comment"># 这样会使得 mid + sht变小</span></span><br><span class="line">                    <span class="comment"># 看变小后的和是否还能大于lng</span></span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 使用双指针的核心就在这里, L和R靠拢时, mid+sht 的值是在缩小的</span></span><br><span class="line">                    <span class="comment"># 但只要大于lng, L和R遍历的范围就能够满足条件</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.3.1.9"></span>  </p><h3 id="2-3-1-9-三数之和"><a href="#2-3-1-9-三数之和" class="headerlink" title="2.3.1.9 三数之和"></a>2.3.1.9 三数之和</h3><p><a href="https://leetcode.cn/problems/3sum/">LeetCode 15.三数之和</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p><font color="#3399FF">思路：此题和三角形那道题一样，只不过条件变为  nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0<br>难点在于不能出现重复的三元组。如果我们先排序的话，然后遍历数组时，每次都将遍历的值，作为三元组开头的值，如果一旦发现这个开头值和上一次的开头值一样，那就说明重复，应该跳过。</font>  </p><ul><li><p>第一种代码写法 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-<span class="number">2</span>):</span><br><span class="line">            <span class="comment"># 如果三元组的开头值和上一次的开头值重复, 可能会出现重复三元组, 直接不考虑</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 每一次都在剩余可选范围内，维护左右两个指针</span></span><br><span class="line">            L, R = i+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;R:</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[L] + nums[R] &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 如果三数之和大于0, 就减小最大的数</span></span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[L] + nums[R] &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 如果三数之和小于0, 就增大中间数</span></span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 此时遇到满足条件的三个数</span></span><br><span class="line">                    <span class="keyword">if</span> res <span class="keyword">and</span> nums[i] == res[-<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">and</span> nums[L] == res[-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                        <span class="comment"># 若三个数中的前两个与之前的相同, 说明重复, 不添加进结果</span></span><br><span class="line">                        <span class="comment"># (因nums已经被排序过, 故重复的 L 一定会紧邻, 故可与rse[-1]进行比较)</span></span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res.append([nums[i], nums[L], nums[R]])</span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><p>第二种代码写法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 先从小到大排序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n-<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            L, R = i+<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                <span class="string">&#x27;&#x27;&#x27;这第二种写法就是在遍历L和R时, 直接判断L或R是否是紧邻重复出现</span></span><br><span class="line"><span class="string">                这第二种写法要考虑的条件比较细, 容易出现疏漏&#x27;&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">while</span> L&lt;R <span class="keyword">and</span> L&gt;i+<span class="number">1</span> <span class="keyword">and</span> nums[L-<span class="number">1</span>] == nums[L]:</span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> L&lt;R <span class="keyword">and</span> R &lt; n-<span class="number">1</span> <span class="keyword">and</span> nums[R+<span class="number">1</span>] == nums[R]:</span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> nums[L] + nums[R] + nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                    L +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> L&lt;R <span class="keyword">and</span> nums[L] + nums[R] + nums[i] == <span class="number">0</span>:</span><br><span class="line">                    res.append((nums[L], nums[R], nums[i]))</span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        如果不想这么麻烦的写，也可以在遍历的时候不考虑去重问题。</span></span><br><span class="line"><span class="string">        将结果先转为set，自动就去重了。然后又把set转回list，返回。 </span></span><br><span class="line"><span class="string">        但是调用 set 又转回 list 的话，耗时会剧增。</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p><span id="2.3.1.10"></span>  </p><h3 id="2-3-1-10-最接近的三数之和"><a href="#2-3-1-10-最接近的三数之和" class="headerlink" title="2.3.1.10 最接近的三数之和"></a>2.3.1.10 最接近的三数之和</h3><p><a href="https://leetcode.cn/problems/3sum-closest/description/">LeetCode 16.最接近的三数之和</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><blockquote><p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在恰好一个解.  </p></blockquote><p><font color="#3399FF">思路：和上面的三数之和思路一样，<b>这里可以不考虑重复问题。因为题目假定每组输入只存在恰好一个解。</b></font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 先将res初始化为一个极值</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-<span class="number">2</span>):</span><br><span class="line">            L, R = i+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;R :</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(nums[i]+nums[L]+nums[R] - target) &lt; <span class="built_in">abs</span>(res-target):</span><br><span class="line">                    res = nums[i]+nums[L]+nums[R]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[L]+nums[R] &lt; target:</span><br><span class="line">                    <span class="comment"># 三数和偏小, 试着增大, 以此靠近 target</span></span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i]+nums[L]+nums[R] &gt; target:</span><br><span class="line">                    <span class="comment"># 三数和偏大, 试着减小, 以此靠近 target</span></span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 如果出现相等的情况</span></span><br><span class="line">                    <span class="comment"># 那就是最接近target, 而且题目说唯一解, 可以直接返回了</span></span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.3.1.11"></span>  </p><h3 id="2-3-1-11-四数之和"><a href="#2-3-1-11-四数之和" class="headerlink" title="2.3.1.11 四数之和"></a>2.3.1.11 四数之和</h3><p><a href="https://leetcode.cn/problems/4sum/">LeetCode 18.四数之和</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p><font color="#3399FF">思路：这就是升级版的三数之和问题，可以考虑多搞一层循环来直接套用三数之和的解答方式。</font>   </p><ul><li><p>第一种代码写法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = [] </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;相较于三数之和问题，多一层循环嵌套而已, 解法本质没有区别&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, N-<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, N-<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> j&gt;i+<span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                L, R = j+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                    <span class="keyword">if</span> nums[i] + nums[j] + nums[L] + nums[R] &gt; target:</span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> nums[i] + nums[j] + nums[L] + nums[R] &lt; target:</span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> res <span class="keyword">and</span> nums[i] == res[-<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">and</span> nums[j] == res[-<span class="number">1</span>][<span class="number">1</span>] <span class="keyword">and</span> nums[L] == res[-<span class="number">1</span>][<span class="number">2</span>]:</span><br><span class="line">                            L += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            res.append([nums[i], nums[j], nums[L], nums[R]])</span><br><span class="line">                            L += <span class="number">1</span></span><br><span class="line">                            R -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><p>第二种代码写法</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, N-<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> j&gt;i+<span class="number">1</span> <span class="keyword">and</span> nums[j] ==nums[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                L, R = j+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">while</span> L&lt;R <span class="keyword">and</span> L&gt;j+<span class="number">1</span> <span class="keyword">and</span> nums[L]==nums[L-<span class="number">1</span>]:</span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> R &lt;N-<span class="number">1</span> <span class="keyword">and</span> nums[R] == nums[R+<span class="number">1</span>]:</span><br><span class="line">                        R -=<span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> nums[i] + nums[j] + nums[L] + nums[R] &gt; target:</span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> L&lt;R <span class="keyword">and</span> nums[i] + nums[j] + nums[L] + nums[R] == target:</span><br><span class="line">                        res.append([nums[i], nums[j],nums[L], nums[R]])</span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        L +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.3.1.12"></span>  </p><h3 id="2-3-1-12-有序数组的平方"><a href="#2-3-1-12-有序数组的平方" class="headerlink" title="2.3.1.12 有序数组的平方"></a>2.3.1.12 有序数组的平方</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">LeetCode 977.有序数组的平方</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p><font color="#3399FF">思路：要是直接对数组nums内的数进行平方，再排序，这个可能不太符合题目想考察的点。这个题目对于数字的操作其实就是模拟了 $ y&#x3D;x^2 $ 这个函数，函数开口向上，对称轴为 $x&#x3D;0$ , 所以对于数组中的数据，谁离0更远，谁平方后就更大。</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        暴力解法：</span></span><br><span class="line"><span class="string">        res = [num**2 for num in nums]</span></span><br><span class="line"><span class="string">        return sorted(res)</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        N  = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [<span class="number">0</span>] * N</span><br><span class="line">        L, R, idx  = <span class="number">0</span>, N - <span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt;= R:</span><br><span class="line">            <span class="keyword">while</span> L&lt;=R <span class="keyword">and</span> <span class="built_in">abs</span>(nums[L]) &gt; <span class="built_in">abs</span>(nums[R]):</span><br><span class="line">                <span class="comment"># 如果 L 位置的数更远，就将其平方结果装入 res数组的末尾</span></span><br><span class="line">                res[idx] = nums[L]**<span class="number">2</span></span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                idx -=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;=R <span class="keyword">and</span> <span class="built_in">abs</span>(nums[L]) &lt;= <span class="built_in">abs</span>(nums[R]):</span><br><span class="line">                <span class="comment"># 如果 R 位置的数更远，就将其平方结果装入 res数组的末尾</span></span><br><span class="line">                res[idx] = nums[R]**<span class="number">2</span></span><br><span class="line">                R -=<span class="number">1</span></span><br><span class="line">                idx -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.3.1.13"></span>  </p><h3 id="2-3-1-13-颜色分类"><a href="#2-3-1-13-颜色分类" class="headerlink" title="2.3.1.13 颜色分类"></a>2.3.1.13 颜色分类</h3><p><a href="https://leetcode.cn/problems/sort-colors/">LeetCode 75.颜色分类</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p><font color="#3399FF">思路：该题的本质其实是荷兰国旗问题，或者说简化版本的。后面讲排序问题的时候，会专门讨论荷兰国旗问题。</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;荷兰国旗问题&#x27;&#x27;&#x27;</span></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        L, R = -<span class="number">1</span>, N</span><br><span class="line">        i = L+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; R:</span><br><span class="line">            <span class="keyword">if</span> L &lt; R <span class="keyword">and</span> nums[i] &lt; <span class="number">1</span>:</span><br><span class="line">                nums[i], nums[L+<span class="number">1</span>] = nums[L+<span class="number">1</span>], nums[i]</span><br><span class="line">                L+=<span class="number">1</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> L &lt; R <span class="keyword">and</span> nums[i] == <span class="number">1</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[i], nums[R-<span class="number">1</span>] = nums[R-<span class="number">1</span>], nums[i]</span><br><span class="line">                R -=<span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="2.3.1.14"></span>  </p><h3 id="2-3-1-14-接雨水"><a href="#2-3-1-14-接雨水" class="headerlink" title="2.3.1.14 接雨水"></a>2.3.1.14 接雨水</h3><p><a href="https://leetcode.cn/problems/trapping-rain-water/">LeetCode 42.接雨水</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p><font color="#3399FF">思路 1：暴力解法，计算每个位置上的最高左右边界，得到每个位置装”水柱”的大小，但是会超出时间限制。</font>   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1.暴力解法</span></span><br><span class="line">        <span class="comment"># 计算每个位置上的&quot;水柱&quot;的大小</span></span><br><span class="line">        <span class="comment"># 注意，该方案超出时间限制，只是作为一个引子</span></span><br><span class="line">        </span><br><span class="line">        L_max, R_max = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        N = <span class="built_in">len</span>(height)</span><br><span class="line">        water = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 对每一个位置，找其左、右两侧最高的边界</span></span><br><span class="line">            <span class="comment"># max 方法的时间复杂度是O(N)</span></span><br><span class="line">            L_max = <span class="built_in">max</span>(height[<span class="number">0</span>:i])</span><br><span class="line">            R_max = <span class="built_in">max</span>(height[i+<span class="number">1</span>:N])</span><br><span class="line">            <span class="comment"># 只有左右两侧存在比当前还要高的边界，才能装水，不然水就流走了</span></span><br><span class="line">            <span class="keyword">if</span> L_max &gt; height[i] <span class="keyword">and</span> R_max &gt; height[i]:</span><br><span class="line">                <span class="comment"># 木桶能装水量是由短板决定的</span></span><br><span class="line">                H = <span class="built_in">min</span>(L_max, R_max)</span><br><span class="line">                water.append(H-height[i])</span><br><span class="line">        <span class="comment"># 整个函数的时间复杂度是O(N^2), 会有测试用例时间超限</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(water)</span><br></pre></td></tr></table></figure><p><font color="#3399FF">思路 2：在思路1的基础上进行改进。<br>思路1的想法是没问题的，能够跑通大部分用例，但是对于很长的height数组会超出时间限制。<br>如果能够将：【对每一个位置寻找其左右最高边界】这个操作的时间复杂度降下来，<br>那么就能够让整个函数的时间复杂度降低，所以很容易想到 “以空间换时间”。  </font></p><p>如果从左往右遍历，要找左侧最高边界，就是在被遍历过的数中找，若能够将左侧遍历过的数中最高的边界，记录下来，那么每一次都只需将原来的左侧最高边界，与新遍历到的数进行对比，即：</p><blockquote><p>对于 i 位置： L_max &#x3D; max(L_max, height[i-1]) </p></blockquote><p>对于右侧的最高边界，就也同理，从右往左遍历，即可得到：</p><blockquote><p>对于 j 位置， R_max &#x3D; max(R_max, height[j+1])  </p></blockquote><p>这样，就能先遍历一道数组，将这些值记录在辅助数组中，时间复杂度O(N);<br>再遍历一道，计算装水量，还是O(N)的时间复杂度；所以总体的时间复杂度就是O(N)+O(N), 还是 O(N)<br>对于空间复杂度，额外使用了两个数组 L_max，R_max 来存放各个位置的左右边界，勉强也算是 O(2N) -&gt; O(N)<br>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;思路2 “以空间换时间” &#x27;&#x27;&#x27;</span></span><br><span class="line">        N = <span class="built_in">len</span>(height)</span><br><span class="line">        <span class="comment"># 最左和最右的柱子只能当边界，无法装水</span></span><br><span class="line">        <span class="comment"># 柱子一定要至少有3个才能装水</span></span><br><span class="line">        water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> N &lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> water</span><br><span class="line">        L_max, R_max = height[<span class="number">0</span>], height[N-<span class="number">1</span>]        </span><br><span class="line">        L_boder, R_boder = [L_max]*N, [R_max]*N</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> L <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 将各个位置对应的左右最高边界分别存储到辅助数组中</span></span><br><span class="line">            L_boder[L] = <span class="built_in">max</span>(L_boder[L-<span class="number">1</span>], height[L])</span><br><span class="line">            R = N-<span class="number">1</span>-L</span><br><span class="line">            R_boder[R] = <span class="built_in">max</span>(height[R], R_boder[R+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 水柱高度由较矮边界决定：H = min(L_boder[i], R_boder[i])</span></span><br><span class="line">            <span class="comment"># 同时边界值还要比当前柱子本身要高才行：max(H-height[i], 0)</span></span><br><span class="line">            water += <span class="built_in">max</span>( <span class="built_in">min</span>(L_boder[i], R_boder[i]) - height[i], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> water</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p><font color="#3399FF">思路 3：思路 2 的改进，能够跑通全部测试用例，但是用到了两个辅助数组，增加了空间复杂度。那么是否还有优化空间呢？  </font></p><p>若在寻找左&#x2F;右最高边界之时，直接计算装水量，岂不是可以不用辅助数组来存储数据了？<br>但是对于遍历到的数字，我们只能完全肯定其一边的最高边界。</p><blockquote><p>比如【 <b>从左往右遍历</b>时,考察的是 L 位置】, 可以肯定 L_max 一定是 L 左侧最高边界：<br>此时 R_max 是 R 右侧的最高边界，并不一定是 L 右侧的最高边界<br>但是 <b> R_max 它是不是 L位置 的右侧最高边界重要吗？</b>来讨论一下    </p><ul><li><p><b>情况1</b>. if <font color="Red">R_max &gt; L_max</font>, then H &#x3D; L_max, 即 H 取值和 R_max 无关，原因如下：<br>如果 L~R 之间，还有更高的边界可以作为L的右边界，那 L_max 依旧是更矮的，不影响 H 取值是 L_max<br>如果 L~R 之间，不存在更高的边界，那 R_max 就是 L 的最高右边界,哪怕 L~R区间都是更矮的也不影响，反正有 R_max 作为右边界兜底，故 H 取值还是更矮的 L_max</p></li><li><p><b>情况2</b>.if <font color="gReen">L_max &gt; R_max</font>, 那么确实就不好说了：<br>如果 L~R 之间 存在更高的边界，那么就应该判断其与 L_max 的大小关系，<br>但是我们暂时无法找到这个值，无法确定更适合 L 位置的右边界<br>如果 L~R 之间，不存在更高的边界,那 R_max 就是 L 的最高右边界, H&#x3D;min(L_max, R_max)&#x3D;R_max<br>主要问题在于，我们暂时无法获取 L~R之间的数字的信息，因为尚未遍历到</p></li></ul></blockquote><blockquote><p>但是反其道而行之！！！对于当前条件：<font color="gReen">L_max &gt; R_max</font>，无法判断 L 位置的 H 取值。但是却可以判断 R 位置的 H 取值！这正是我们讨论【从左往右遍历时,考察的是 L 位置】 时的情况1<br>如果我们现在 【从 <b>右往左遍历</b> 时,考察的是 R 位置】，那么</p><ul><li><font color="gReen">L_max &gt; R_max</font> 这个情况<br>就是 R 位置的<b>情况1</b>：此时 R 位置的 H &#x3D; R_max</li><li>对于 R 位置的<b>情况2</b>：条件是 <font color="Red">R_max &gt; L_max</font>， 同理，无法确定 L~R 之间是否有更适合作为 R 位置左边界的值<br>但是，它又转换成了 对于 L 位置的情况1.</li></ul></blockquote><p>对于 R_max &#x3D;&#x3D; L_max 的情况:<br>如果考察的是 L 位置，H 仍然能取 L_max<br>如果考察的是 R 位置，H 仍然能取 R_max。<br>仍然按照两个位置情况1的思路去理解<br>在写代码时，只需要将这种情况固定划分到考察 L 或者 R 的一种之中去就行<br>这样整个思路就能串通起来了,<br>由于只需要遍历一次数组，时间复杂度 O(N),<br>只有有限个辅助变量，空间复杂度O(1)。    </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(height)</span><br><span class="line">        <span class="comment"># 最左和最右的柱子只能当边界，无法装水</span></span><br><span class="line">        <span class="comment"># 柱子一定要至少有3个才能装水</span></span><br><span class="line">        water = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> N &lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> water</span><br><span class="line"></span><br><span class="line">        L_max, R_max = height[<span class="number">0</span>], height[N-<span class="number">1</span>]</span><br><span class="line">        L, R = <span class="number">1</span>, N-<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> L &lt;= R :</span><br><span class="line">            <span class="keyword">if</span> L_max &lt;= R_max:</span><br><span class="line">                <span class="comment"># 这是 从左往右遍历的 L 位置的情况1:H = L_max</span></span><br><span class="line">                L_max = <span class="built_in">max</span>(L_max, height[L])</span><br><span class="line">                water += L_max - height[L]</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 这是 从右往左遍历的 r 位置的情况1: H = R_max</span></span><br><span class="line">                R_max = <span class="built_in">max</span>(R_max, height[R])</span><br><span class="line">                water += R_max - height[R]</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> water </span><br></pre></td></tr></table></figure><p><span id="2.3.1.15"></span>  </p><h3 id="2-3-1-15-数组中的最长山脉"><a href="#2-3-1-15-数组中的最长山脉" class="headerlink" title="2.3.1.15 数组中的最长山脉"></a>2.3.1.15 数组中的最长山脉</h3><p><a href="https://leetcode.cn/problems/longest-mountain-in-array/">LeetCode 845.数组中的最长山脉</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p><font color="#3399FF">思路：这个其实不是对撞指针了，是对每个位置展开一个左右指针，来对每个位置求山脉宽度。<br>其实可以理解为对撞指针的<b>逆过程</b>，从中间开始往两边扩散两个指针。</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestMountain</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(arr)</span><br><span class="line">        width = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 注意！根据题目中的要求，是左右侧都要有下降趋势的点才行</span></span><br><span class="line">        <span class="comment"># 所以 最左侧和最右侧元素，arr[0]/arr[N-1]由于只有一边有元素，不合题意</span></span><br><span class="line">        <span class="comment"># 可以不用遍历这两个位置，它俩一定不能作为山顶</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 首先判断是否是符合山顶条件，即左右两侧都有下降趋势</span></span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; arr[i - <span class="number">1</span>] <span class="keyword">and</span> arr[i] &gt; arr[i + <span class="number">1</span>]:</span><br><span class="line">                L = i - <span class="number">1</span></span><br><span class="line">                R = i + <span class="number">1</span></span><br><span class="line">                <span class="comment"># 左侧一直延伸到尽可能左</span></span><br><span class="line">                <span class="keyword">while</span> L &gt; <span class="number">0</span> <span class="keyword">and</span> arr[L - <span class="number">1</span>] &lt; arr[L]:</span><br><span class="line">                    L -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 右侧一直延伸到尽可能右</span></span><br><span class="line">                <span class="keyword">while</span> R &lt; N - <span class="number">1</span> <span class="keyword">and</span> arr[R + <span class="number">1</span>] &lt; arr[R]:</span><br><span class="line">                    R += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                width = <span class="built_in">max</span>(width, R-L+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> width</span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        #$#$#$#$#$#$ 改进后的代码，理论上可以稍微加速一点 #$#$#$#$#$#$#$</span></span><br><span class="line"><span class="string">        # 当然只是理论上, 至于实际是否加速, 得看机器和测试用例的的实际情况</span></span><br><span class="line"><span class="string">        # 改进的位置在while循环中 i 变化的情况</span></span><br><span class="line"><span class="string">        i = 1</span></span><br><span class="line"><span class="string">        while i &lt; N-1:</span></span><br><span class="line"><span class="string">            # 首先判断是否是符合山顶条件，即左右两侧都有下降趋势</span></span><br><span class="line"><span class="string">            if arr[i] &gt; arr[i - 1] and arr[i] &gt; arr[i + 1]:</span></span><br><span class="line"><span class="string">                L = i - 1</span></span><br><span class="line"><span class="string">                R = i + 1</span></span><br><span class="line"><span class="string">                # 左侧一直延伸到尽可能左</span></span><br><span class="line"><span class="string">                while L &gt; 0 and arr[L - 1] &lt; arr[L]:</span></span><br><span class="line"><span class="string">                    L -= 1</span></span><br><span class="line"><span class="string">                # 右侧一直延伸到尽可能右</span></span><br><span class="line"><span class="string">                while R &lt; N - 1 and arr[R] &gt; arr[R + 1]:</span></span><br><span class="line"><span class="string">                    R += 1</span></span><br><span class="line"><span class="string">                </span></span><br><span class="line"><span class="string">                width = max(width, R-L+1)</span></span><br><span class="line"><span class="string">                # 我们可以知道，在当前情况下，是有一个(L,i,R)的山脉</span></span><br><span class="line"><span class="string">                # 所以 在 i~R 区间，必然全是下坡路，不可能存在山顶</span></span><br><span class="line"><span class="string">                # 所以 i 可以直接跳到 R+1的位置去判断</span></span><br><span class="line"><span class="string">                # 省去了右边下山区间这么多元素的判断计算</span></span><br><span class="line"><span class="string">                i = R + 1</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">                i += 1</span></span><br><span class="line"><span class="string">        return width</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>        </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.3.1.16"></span>  </p><h3 id="2-3-1-16-最长湍流子数组"><a href="#2-3-1-16-最长湍流子数组" class="headerlink" title="2.3.1.16 最长湍流子数组"></a>2.3.1.16 最长湍流子数组</h3><p><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">LeetCode 978.最长湍流子数组</a> | | <a href="#2.3.1">返回目录2.3.1</a></p><p><font color="#3399FF">思路：其实这个题最好的解法不是使用这种扩散指针，但是确实可以参考上面 <b><a href="#2.3.1.15">数组中的最长山脉</a></b> 的思路来做。<br>这里只是提供一种解法，拓展思路，但确实code比较复杂，看起来也不太容易懂，可以看着玩玩。<br><b>更好的解法还是建议看下面快慢指针部分 <a href="#2.3.2.7">2.3.2.7</a>题解</b>，该题的code。</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxTurbulenceSize</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        首先要搞清楚湍流是什么情况：</span></span><br><span class="line"><span class="string">        ···&lt; arr[M-2] &gt; arr[M-1] &lt; arr[M] &gt; arr[M+1] &lt; arr[M+2] &gt; ···</span></span><br><span class="line"><span class="string">                                    或者</span></span><br><span class="line"><span class="string">        ···&gt; arr[M-2] &lt; arr[M-1] &gt; arr[M] &lt; arr[M+1] &gt; arr[M+2] &lt; ···</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 按照 数组中的最长山脉 的题解思路来做， 特殊情况和边界情况的判断稍显复杂</span></span><br><span class="line">        N = <span class="built_in">len</span>(arr)</span><br><span class="line">        width = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:   </span><br><span class="line">            <span class="keyword">return</span> width</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; N:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> i == N-<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 端点值先特殊讨论</span></span><br><span class="line">                <span class="keyword">if</span> (arr[<span class="number">0</span>] != arr[<span class="number">1</span>]) <span class="keyword">or</span> (arr[N-<span class="number">2</span>] != arr[N-<span class="number">1</span>]): </span><br><span class="line">                    <span class="comment"># 只要端点值的相邻值和它不相等, 就一定是一个宽度为2的湍流</span></span><br><span class="line">                    width = <span class="built_in">max</span>(<span class="number">2</span>, width)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第 1 种 湍流模式, M 点是邻域极大值</span></span><br><span class="line">            <span class="keyword">elif</span> arr[i-<span class="number">1</span>] &lt; arr[i] <span class="keyword">and</span> arr[i] &gt; arr[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 这里的两个 flag是用来控制 &lt; 或 &gt; 符号的, 利用 -1 的不断自乘来实现转向</span></span><br><span class="line">                flag_L, flag_R, left, right = -<span class="number">1</span>, -<span class="number">1</span>, i-<span class="number">1</span>, i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> (arr[left] - arr[left-<span class="number">1</span>])* flag_L &gt; <span class="number">0</span>:</span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                    flag_L *= -<span class="number">1</span>  </span><br><span class="line">                <span class="keyword">while</span> right &lt; N-<span class="number">1</span> <span class="keyword">and</span> (arr[right] - arr[right+<span class="number">1</span>])* flag_R &gt; <span class="number">0</span>:</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">                    flag_R *= -<span class="number">1</span></span><br><span class="line">                width = <span class="built_in">max</span>(width, right-left+<span class="number">1</span>)</span><br><span class="line">                i = right</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 第 2 种 湍流模式, M 点是邻域极小值</span></span><br><span class="line">            <span class="keyword">elif</span> arr[i-<span class="number">1</span>] &gt; arr[i] <span class="keyword">and</span> arr[i] &lt; arr[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 这里的两个 flag是用来控制 &lt; 或 &gt; 符号的, 利用 -1 的不断自乘来实现转向</span></span><br><span class="line">                flag_L, flag_R, left, right = -<span class="number">1</span>, -<span class="number">1</span>, i-<span class="number">1</span>, i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> (arr[left] - arr[left-<span class="number">1</span>])* flag_L &lt; <span class="number">0</span>:</span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                    flag_L *= -<span class="number">1</span>  </span><br><span class="line">                <span class="keyword">while</span> right &lt; N-<span class="number">1</span> <span class="keyword">and</span> (arr[right] - arr[right+<span class="number">1</span>])* flag_R &lt; <span class="number">0</span>:</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">                    flag_R *= -<span class="number">1</span></span><br><span class="line">                width = <span class="built_in">max</span>(width, right-left+<span class="number">1</span>)</span><br><span class="line">                i = right </span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> width</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        这种代码写法的核心思路就是借鉴的 最长山脉那道题，难点在于:</span></span><br><span class="line"><span class="string">        1. 小于/大于符号在不断的交替, 这里是利用 -1 的自乘实现</span></span><br><span class="line"><span class="string">        2. 数组左右端点值的特殊情况容易忽略</span></span><br><span class="line"><span class="string">        总之这种代码写法稍微有点困难，也是因为刚刚才做完 最长山脉的题目，</span></span><br><span class="line"><span class="string">        陷入了 定式思维 的陷阱, 才写出了这种方法。</span></span><br><span class="line"><span class="string">        等下面用快慢指针的思路, 代码就更容易理解</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-2-快慢指针"><a href="#2-3-2-快慢指针" class="headerlink" title="2.3.2 快慢指针"></a>2.3.2 快慢指针</h2><p>所谓快慢指针，就是指的两个指针的移动频率不同，其中快指针因为某个条件，总是跑在慢指针更右侧。<br>通常终止条件就是快指针遍历完了数组。  </p><p><span id="2.3.2"></span>  </p><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">LeetCode 26.删除有序数组中的重复项</a></td><td><a href="#2.3.2.1">题解2.3.2.1</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/string-compression/">LeetCode 443.压缩字符串</a></td><td><a href="#2.3.2.2">题解2.3.2.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">LeetCode 80.删除有序数组中的重复项II</a></td><td><a href="#2.3.2.3">题解2.3.2.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/remove-element/">LeetCode 27.移除元素</a></td><td><a href="#2.3.2.4">题解2.3.2.4</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/move-zeroes//">LeetCode 283.移动零</a></td><td><a href="#2.3.2.5">题解2.3.2.5</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/increasing-triplet-subsequence/">LeetCode 334.递增的三元子序列</a></td><td><a href="#2.3.2.6">题解2.3.2.6</a></td></tr><tr><td>⑦</td><td><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">LeetCode 978.最长湍流子数组</a></td><td><a href="#2.3.2.7">题解2.3.2.7</a></td></tr></tbody></table><p><span id="2.3.2.1"></span>  </p><h3 id="2-3-2-1-删除有序数组中的重复项"><a href="#2-3-2-1-删除有序数组中的重复项" class="headerlink" title="2.3.2.1 删除有序数组中的重复项"></a>2.3.2.1 删除有序数组中的重复项</h3><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">LeetCode 26.删除有序数组中的重复项</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><p><font color="#3399FF">思路：用快慢指针，快指针先去右侧看是否重复，慢指针用来修改原数组（维护去重部分的边界）</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> N &lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> N</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;方案一. 遍历到的重复的数, 先跳过，将重复区域的最后一个数, 加入唯一元素区域&#x27;&#x27;&#x27;</span></span><br><span class="line">        s, f = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="comment"># 慢指针代表筛选出的【唯一元素区域】的右边界, 一开始这个区域是空的, 所以s=0 </span></span><br><span class="line">        <span class="comment"># 快指针代表后续待比较区域的元素, 因为至少要有2个元素才能比较是否重复, 所以f从第2个元素开始,f=1</span></span><br><span class="line">        <span class="keyword">while</span> f &lt;= N:</span><br><span class="line">            <span class="keyword">if</span> f== N <span class="keyword">or</span> nums[f] != nums[f-<span class="number">1</span>] :</span><br><span class="line">                <span class="comment"># f位置的数与 f-1不相同, 说明：</span></span><br><span class="line">                <span class="comment"># f-1位置是某段重复区域的最后一个数了, f是新区域的第一个数.</span></span><br><span class="line">                <span class="comment"># 把f-1加进唯一元素区域</span></span><br><span class="line">                nums[s] = nums[f-<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 这个if条件里面之所以有 f==N 这个情况, 是因为f=N时, nums取不到值, </span></span><br><span class="line">                <span class="comment"># 且nums的最后一个数N-1位置一定可以加入唯一区域, 因为这个数一定是某段区域的最后一个数(不管这段区域是否重复)</span></span><br><span class="line">                <span class="comment"># 同时不要忘记 右边界s向右扩张1位</span></span><br><span class="line">                s += <span class="number">1</span></span><br><span class="line">            f += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s <span class="comment"># s是右边界, 即唯一元素区域实际是 0 ~ s-1, 共 s 个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        方案二： </span></span><br><span class="line"><span class="string">        上面的方案都是将重复区域的最后一个元素更新到s位置</span></span><br><span class="line"><span class="string">        这里是将重复区域的第一个元素更新到s位置</span></span><br><span class="line"><span class="string">        s, f = -1, 0</span></span><br><span class="line"><span class="string">        while f &lt; N:</span></span><br><span class="line"><span class="string">            # 这里的更新过程非常像在维护一个虚拟的栈</span></span><br><span class="line"><span class="string">            # 当栈为空 s==-1，或者f遇到的数不等于栈顶元素 nums[f] != nums[s]</span></span><br><span class="line"><span class="string">            # 就将栈的区域扩大一个：s+=1， 然后将f对应的元素入栈:nums[s] = nums[f]</span></span><br><span class="line"><span class="string">            if s==-1 or nums[f] != nums[s]:</span></span><br><span class="line"><span class="string">                s += 1</span></span><br><span class="line"><span class="string">                nums[s] = nums[f]</span></span><br><span class="line"><span class="string">            f += 1</span></span><br><span class="line"><span class="string">        # 虚拟栈的范围是 0 ~ s, 共 s+1 个元素       </span></span><br><span class="line"><span class="string">        return s+1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 用虚拟栈的思路会十分容易理解, 代码页很好写, 所以更推荐方案二</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>                 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.3.2.2"></span>  </p><h3 id="2-3-2-2-压缩字符串"><a href="#2-3-2-2-压缩字符串" class="headerlink" title="2.3.2.2 压缩字符串"></a>2.3.2.2 压缩字符串</h3><p><a href="https://leetcode.cn/problems/string-compression/">LeetCode 443.压缩字符串</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><p><font color="#3399FF">思路：题目中说到只能使用常量额外空间，即空间复杂度要求O(1)，说明没办法用辅助数组。<br>然后这个题其实是上一题 <b><a href="#2.3.2.1">删除有序数组中的重复项</a></b> 的升级版，稍微麻烦了一点而已，思路完全是一样的。<br>同样是要判断连续的重复字符，只不过现在还要追加其数目而已。</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compress</span>(<span class="params">self, chars: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;这里的code 采用上一题中 update 1 的写法</span></span><br><span class="line"><span class="string">           即把 f == N 的情况纳入while 循环中&#x27;&#x27;&#x27;</span></span><br><span class="line">        cnt, N = <span class="number">0</span>, <span class="built_in">len</span>(chars)</span><br><span class="line">        <span class="comment"># 该题中，s部分不光有去重后的字符，还有其数目部分</span></span><br><span class="line">        <span class="comment"># 所以再新增一个 old_left 指针，用来记录上一个重复区域的末尾</span></span><br><span class="line">        <span class="comment"># 以便于计算最近重复区域的长度</span></span><br><span class="line">        <span class="comment"># s 维护的是去重部分新内容的右边界</span></span><br><span class="line">        old_left, s, f = -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> f &lt;= N:</span><br><span class="line">            <span class="keyword">if</span> f==N <span class="keyword">or</span> chars[f] != chars[f-<span class="number">1</span>]:</span><br><span class="line">                chars[s] = chars[f-<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># f-1是最近重复区域的末尾索引，old_left是上个重复区域末尾的索引</span></span><br><span class="line">                cnt = f-<span class="number">1</span> - old_left</span><br><span class="line">                s += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 根据题意，数目大于1的时候，才要追加数目</span></span><br><span class="line">                <span class="keyword">if</span> cnt &gt; <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 将数字进行字符串序列化</span></span><br><span class="line">                    cnt_list =  <span class="built_in">list</span>(<span class="built_in">str</span>(cnt))</span><br><span class="line">                    <span class="comment"># 将数字部分追加进去</span></span><br><span class="line">                    chars[s:s+<span class="built_in">len</span>(cnt_list)] = cnt_list[:]</span><br><span class="line">                    <span class="comment"># 记得更新 s 索引</span></span><br><span class="line">                    s += <span class="built_in">len</span>(cnt_list)</span><br><span class="line">                <span class="comment"># 处理完最近的重复区域之后，将f-1赋值给old_left</span></span><br><span class="line">                old_left = f-<span class="number">1</span></span><br><span class="line">            f += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p><span id="2.3.2.3"></span>  </p><h3 id="2-3-2-3-删除有序数组中的重复项II"><a href="#2-3-2-3-删除有序数组中的重复项II" class="headerlink" title="2.3.2.3 删除有序数组中的重复项II"></a>2.3.2.3 删除有序数组中的重复项II</h3><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">LeetCode 80.删除有序数组中的重复项II</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><p><font color="#3399FF">思路：思路和前面两道题一脉相承，代码稍加改动即可</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 和上一题一样，old_left维护上一个重复区域的末尾索引</span></span><br><span class="line">        <span class="comment"># ps 指向待填充区域的起始位置（或者说已处理部分的右边界）</span></span><br><span class="line">        old_left, ps, pf = -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> pf &lt;= N:</span><br><span class="line">            <span class="keyword">if</span> pf == N <span class="keyword">or</span> nums[pf] != nums[pf-<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># pf-1 是最近的重复区域末尾索引</span></span><br><span class="line">                cnt = <span class="built_in">min</span>(pf-<span class="number">1</span> - old_left, <span class="number">2</span>)</span><br><span class="line">                nums[ps:ps+cnt] = nums[pf-<span class="number">1</span>:pf]*cnt</span><br><span class="line">                ps += cnt</span><br><span class="line">                old_left = pf -<span class="number">1</span></span><br><span class="line">            pf += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ps</span><br></pre></td></tr></table></figure><p><span id="2.3.2.4"></span>  </p><h3 id="2-3-2-4-移除元素"><a href="#2-3-2-4-移除元素" class="headerlink" title="2.3.2.4 移除元素"></a>2.3.2.4 移除元素</h3><p><a href="https://leetcode.cn/problems/remove-element/">LeetCode 27.移除元素</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><p><font color="#3399FF">思路：和上面的题目一脉相承。用虚拟栈的思路会很容易理解。</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 慢指针充当虚拟栈栈顶索引, 快指针用来遍历数组</span></span><br><span class="line">        s, f = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> f &lt; N:</span><br><span class="line">            <span class="keyword">if</span> nums[f] != val:</span><br><span class="line">                <span class="comment"># 将虚拟栈扩充一位, 并且将数放入栈顶</span></span><br><span class="line">                s += <span class="number">1</span></span><br><span class="line">                nums[s] = nums[f]</span><br><span class="line">            f += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 虚拟栈数据范围 0~s 共s+1个数字</span></span><br><span class="line">        <span class="keyword">return</span> s+<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.3.2.5"></span>  </p><h3 id="2-3-2-5-移动零"><a href="#2-3-2-5-移动零" class="headerlink" title="2.3.2.5 移动零"></a>2.3.2.5 移动零</h3><p><a href="https://leetcode.cn/problems/move-zeroes//">LeetCode 283.移动零</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><p><font color="#3399FF">思路: partition 问题，注意，下面的代码是 非稳定的<br>因为不同的0的相对次序其实会变化，只不过题目只要求非0数据相对次序不变，所以还是能保证的。<br>后面的章节讲排序问题的快速排序讨论, 会详细讲 partition 问题;<br>这里还是先用虚拟栈的思考方式来理解更方便一点。</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 慢指针充当虚拟栈栈顶索引，快指针用来遍历数组</span></span><br><span class="line">        ps, pf = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pf &lt;N:</span><br><span class="line">            <span class="keyword">if</span> nums[pf] != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 虚拟栈扩充一格</span></span><br><span class="line">                ps += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 栈顶位置的原始数字, 和 pf 位置的数字进行交换, </span></span><br><span class="line">                <span class="comment"># 就把pf位置的数放到栈里来了, 同时将原始数字放到栈外面去了</span></span><br><span class="line">                nums[pf], nums[ps] = nums[ps], nums[pf]</span><br><span class="line">            pf += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="2.3.2.6"></span>  </p><h3 id="2-3-2-6-递增的三元子序列"><a href="#2-3-2-6-递增的三元子序列" class="headerlink" title="2.3.2.6 递增的三元子序列"></a>2.3.2.6 递增的三元子序列</h3><p><a href="https://leetcode.cn/problems/increasing-triplet-subsequence/">LeetCode 334.递增的三元子序列</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><p><font color="#3399FF">思路：这个题虽然没有显式的使用快慢指针，但是思想是借鉴了快慢指针的。<br>假设我们要找3个数a,b,c满足 a &lt; b &lt; c 的条件，<b>那么a应该尽可能的小，b也应该在大于a的情况下尽可能的小，这样才容易去找到满足条件的c</b>。<br>那么，比方说我们<b><font color="#3333FF">如何找到一个数组中，最小的数呢（不调用min）</font>？？</b>那就是设定一个极大的初始值，遍历一道数组，在遍历过程中发现更小的数，就更新，最终就能找到这个最小的数。<br>借鉴这个思想，我们的代码如下</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increasingTriplet</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        a = b = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &lt;= a:</span><br><span class="line">                <span class="comment"># 这样能够保证在遍历过的数字中，a一定是最小的那个数</span></span><br><span class="line">                a = num </span><br><span class="line">            <span class="keyword">elif</span> num &lt;=b:</span><br><span class="line">                <span class="comment"># elif隐含的条件是不满足上面的条件，即不满足小于等于a</span></span><br><span class="line">                <span class="comment"># 所以b一定能取到在遍历过的数目当中，位于a后面的，比a大的数当中，最小的一个数</span></span><br><span class="line">                b = num </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 在继续变量的过程中，只要遇到一个数不满足上面的条件，即比a和b都大</span></span><br><span class="line">                <span class="comment"># 这个数就能够充当 c 的角色</span></span><br><span class="line">                <span class="comment"># c = num </span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><span id="2.3.2.7"></span>  </p><h3 id="2-3-2-7-最长湍流子数组"><a href="#2-3-2-7-最长湍流子数组" class="headerlink" title="2.3.2.7 最长湍流子数组"></a>2.3.2.7 最长湍流子数组</h3><p><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">LeetCode 978.最长湍流子数组</a> | | <a href="#2.3.2">返回目录2.3.2</a></p><p><font color="#3399FF">思路：该题在对撞指针中讲过一次，但是更好的解法是使用快慢指针。<br>具体的思路可以看code中的注释，采用快慢指针要快许多</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxTurbulenceSize</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        注意到题目中给的例子，1个元素也算湍流，2个不相等的数也能组成宽度为2的湍流</span></span><br><span class="line"><span class="string">        其实不用像 山脉宽度 那样每次从一个中心点，向着左右扩散</span></span><br><span class="line"><span class="string">        湍流可以选择一个起始点，从左往右的方向一直扩散，比如：</span></span><br><span class="line"><span class="string">        情况1：arr[0] &gt; arr[1] &lt; arr[2] &gt; ··· </span></span><br><span class="line"><span class="string">        或 情况2：arr[0] &lt; arr[1] &gt; arr[2] &lt; ···</span></span><br><span class="line"><span class="string">        考虑用快慢指针，一个维护湍流的起点，另一个维护湍流的终点</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        N, width = <span class="built_in">len</span>(arr), <span class="number">1</span></span><br><span class="line">        L, R = <span class="number">0</span> ,<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> R &lt; N: <span class="comment"># 当湍流的右边界没有超过数组</span></span><br><span class="line">            <span class="comment"># 情况 1</span></span><br><span class="line">            <span class="keyword">if</span> arr[L] &gt; arr[R]:</span><br><span class="line">                flag = -<span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果右边一直能满足湍流的条件，就一直往右扩散</span></span><br><span class="line">                <span class="comment"># 这里是通过乘以 (-1)^k 来变相控制 大于/小于符号, 注意这里用的是 &gt;</span></span><br><span class="line">                <span class="keyword">while</span> R &lt; N-<span class="number">1</span> <span class="keyword">and</span> (arr[R]- arr[R+<span class="number">1</span>]) * flag &gt; <span class="number">0</span>:</span><br><span class="line">                    R += <span class="number">1</span></span><br><span class="line">                    flag *= -<span class="number">1</span></span><br><span class="line">                <span class="comment"># 循环结束后, R 指向该组湍流的最后一个满足条件的元素</span></span><br><span class="line">                width = <span class="built_in">max</span>(width, R-L+<span class="number">1</span>)                </span><br><span class="line">            <span class="comment"># 情况 2</span></span><br><span class="line">            <span class="keyword">elif</span> arr[L] &lt; arr[R]:</span><br><span class="line">                flag = -<span class="number">1</span> </span><br><span class="line">                <span class="comment"># 这里是通过乘以 (-1)^k 来变相控制 大于/小于符号, 注意这里用的是 &lt; </span></span><br><span class="line">                <span class="keyword">while</span> R &lt; N-<span class="number">1</span> <span class="keyword">and</span> (arr[R]- arr[R+<span class="number">1</span>]) * flag &lt; <span class="number">0</span>:</span><br><span class="line">                    R += <span class="number">1</span></span><br><span class="line">                    flag *= -<span class="number">1</span></span><br><span class="line">                width = <span class="built_in">max</span>(width, R-L+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 连续两个数字相等，直接pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="comment"># 更新起点和终点</span></span><br><span class="line">            L = R </span><br><span class="line">            R +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> width</span><br></pre></td></tr></table></figure><!-- <span id="2.3.2.8"></span>  ### 2.3.2.9  [返回目录2.3.2](#2.3.2)>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在恰好一个解.  >示例 1>输入：nums = [-1,2,1,-4], target = 1; &emsp;输出：2  <font color=#3399FF>思路：</font>  ```python```    -->]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2-2 数组相关题目</title>
      <link href="/Data-Structure/DS_22_array_exercises.html"/>
      <url>/Data-Structure/DS_22_array_exercises.html</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">    <hr style="border:solid; height:1px; color=#000000 size=1"> <h1 id="2-2-数组相关题目"><a href="#2-2-数组相关题目" class="headerlink" title="2-2 数组相关题目"></a>2-2 数组相关题目</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p><b>版权声明：以下题目均来自 <a href="https://leetcode.cn/">LeetCode</a>， 仅仅提供跳转到力扣官网的链接，不在本页面出现题目内容，本文章内容禁止商业用途。</b></p><p><span id="2.2.1"></span>  </p><h2 id="2-2-1-一维数组的相关题目"><a href="#2-2-1-一维数组的相关题目" class="headerlink" title="2.2.1 一维数组的相关题目"></a>2.2.1 一维数组的相关题目</h2><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/rotate-array/">LeetCode 189.轮转数组</a></td><td><a href="#2.2.1.1">2.2.1.1题解</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/find-pivot-index/">LeetCode 724.寻找数组的中心下标</a></td><td><a href="#2.2.1.2">2.2.1.2题解</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/max-consecutive-ones/">LeetCode 485.最大连续 1 的个数</a></td><td><a href="#2.2.1.3">2.2.1.3题解</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/product-of-array-except-self/">LeetCode 238.除自身以外数组的乘积</a></td><td><a href="#2.2.1.4">2.2.1.4题解</a></td></tr></tbody></table><p><span id="2.2.1.1"></span>  </p><h3 id="2-2-1-1-轮转数组"><a href="#2-2-1-1-轮转数组" class="headerlink" title="2.2.1.1 轮转数组"></a>2.2.1.1 轮转数组</h3><p><a href="https://leetcode.cn/problems/rotate-array/">LeetCode 189.轮转数组</a> | |  <a href="#2.2.1">返回2.2.1目录</a>  </p><p><font color="#3399FF">方案一： 复制一个数组为参照，在原数组上进行修改。 </font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;时间复杂度O(n), 空间复杂度O(n)&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        tmp, n = nums.copy(), <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            nums[(i+k)%n] = tmp[i]</span><br></pre></td></tr></table></figure><p><font color="#3399FF">方案二： 不另外创建数组。 </font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 题目给的例子中，有k&gt;N的情况，所以先求模运算</span></span><br><span class="line">        k = k % N</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果假设数组首尾相接，是一个循环数组</span></span><br><span class="line">        <span class="comment"># 那么向右轮转k个位置，就相当于后面k个数被挤压到前面去了</span></span><br><span class="line">        <span class="comment"># 前面的 N-k 个数， 被挤压到后面全了</span></span><br><span class="line">        <span class="comment"># 所以就相当于 前 N-k 个数，和后 k个数，整体区域做一下交换</span></span><br><span class="line">        <span class="comment"># 那么如果我们直接从 第 N-k个数字后面的逗号，将数组旋转180度，他们的区域就交换了</span></span><br><span class="line">        nums[:] = nums[::-<span class="number">1</span>] <span class="comment"># 反转数组</span></span><br><span class="line">        <span class="comment"># 注意！如果写成 nums = nums[::-1],原数组num的值是不会被改变的，这种写法相当于创建了一个新的临时数组。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 但是反转数组后，各区域内的顺序也被反转了一遍，我们再将各区域的顺序调回来</span></span><br><span class="line">        <span class="comment"># 将转过来的前k个数字恢复原来的顺序（注意前k个数字序号是 0~k-1）</span></span><br><span class="line">        nums[:k] = nums[k-<span class="number">1</span>::-<span class="number">1</span>] </span><br><span class="line">        <span class="comment"># 将转过来的后的N-K个数字恢复原顺序（注意后N-K个数字序号是 k~N-1）</span></span><br><span class="line">        nums[k:] = nums[N-<span class="number">1</span>:k-<span class="number">1</span>:-<span class="number">1</span>] </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        但是问题是，python在进行切片操作的时候，</span></span><br><span class="line"><span class="string">        实际上是会在等式右边产生一个新的临时list，</span></span><br><span class="line"><span class="string">        然后将值赋给等式左边。也并不见得能省多少空间.</span></span><br><span class="line"><span class="string">        还有的解法是在反转数组的时候，自己写反转函数：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        def reverse_list(nums, start, end):</span></span><br><span class="line"><span class="string">            while start &lt; end:</span></span><br><span class="line"><span class="string">                nums[start], nums[end] = nums[end], nums[start]</span></span><br><span class="line"><span class="string">                start +=1</span></span><br><span class="line"><span class="string">                end -=1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        reverse_list(nums, 0, N-1)</span></span><br><span class="line"><span class="string">        reverse_list(nums, 0, k-1)</span></span><br><span class="line"><span class="string">        reverse_list(nums, k, N-1)     </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        这种的空间复杂度比起直接使用链表切片来说，理论上会少一些吧，反正leetcode的提交结果来看，</span></span><br><span class="line"><span class="string">        使用python2的话，空间消耗确实有减少，但是时间消耗一下就增加了</span></span><br><span class="line"><span class="string">        使用python3的话，空间消耗是真没有多少区别，时间消耗也是增加了。</span></span><br><span class="line"><span class="string">        总得来说，用切片就是快</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><span id="2.2.1.2"></span>  </p><h3 id="2-2-1-2-寻找数组的中心下标"><a href="#2-2-1-2-寻找数组的中心下标" class="headerlink" title="2.2.1.2  寻找数组的中心下标"></a>2.2.1.2  寻找数组的中心下标</h3><p><a href="https://leetcode.cn/problems/find-pivot-index/">LeetCode 724.寻找数组的中心下标</a> | | <a href="#2.2.1">返回2.2.1目录</a>  </p><p><font color="#3399FF">方案：最直接的思路就是遍历元素的时候，每一次都计算左侧的和 sum(nums[:i]) 和 右侧的和 sum(nums[i+1:])；但是这中间包含了大量重复计算，时间复杂度会很高。所以可以维护两个状态变量，分别记录左和右的累加和，每一次遍历的时候，直接修改状态变量即可。</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 把左右结果放入中间变量缓存，就不用每次都调用sum了</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            cur_val = nums[i]</span><br><span class="line">            <span class="keyword">if</span> left == right - cur_val:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += cur_val</span><br><span class="line">                right -= cur_val</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><span id="2.2.1.3"></span>  </p><h3 id="2-2-1-3-最大连续-1-的个数"><a href="#2-2-1-3-最大连续-1-的个数" class="headerlink" title="2.2.1.3 最大连续 1 的个数"></a>2.2.1.3 最大连续 1 的个数</h3><p><a href="https://leetcode.cn/problems/max-consecutive-ones/">LeetCode 485.最大连续 1 的个数</a> | | <a href="#2.2.1">返回2.2.1目录</a></p><p><font color="#3399FF">方案：这种求连续间隔的题，一般都是用索引相减来做。即右边界的索引，减去左边界的索引，就是这段区间的宽度。</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxConsecutiveOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># index_0 用来记录上一次0出现的位置，作为连续1区间的左边界</span></span><br><span class="line">        index_0 = -<span class="number">1</span></span><br><span class="line">        N, gap = <span class="built_in">len</span>(nums), <span class="number">0</span></span><br><span class="line">        <span class="comment"># 在原始数组后面多加一个0，表示区域的最大右边界</span></span><br><span class="line">        nums.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 当遇到为0的时候，取该次i作为右边界，计算两个0之间的间隔</span></span><br><span class="line">                gap = <span class="built_in">max</span>(gap, i-index_0-<span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 更新完gap之后也要把index0更新为当前的0的索引。</span></span><br><span class="line">                index_0 = i</span><br><span class="line">        <span class="keyword">return</span> gap</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        当然也可以使用1来作为计算gap的判断条件，原理是一样的</span></span><br><span class="line"><span class="string">        index_0 = -1</span></span><br><span class="line"><span class="string">        N, gap = len(nums), 0</span></span><br><span class="line"><span class="string">        for i in range(N):</span></span><br><span class="line"><span class="string">            if nums[i] == 1:</span></span><br><span class="line"><span class="string">                gap = max(gap, i-index_0)</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">                index_0 = i</span></span><br><span class="line"><span class="string">        return gap</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><span id="2.2.1.4"></span>  </p><h3 id="2-2-1-4-除自身以外数组的乘积"><a href="#2-2-1-4-除自身以外数组的乘积" class="headerlink" title="2.2.1.4 除自身以外数组的乘积"></a>2.2.1.4 除自身以外数组的乘积</h3><p><a href="https://leetcode.cn/problems/product-of-array-except-self/">LeetCode 238.除自身以外数组的乘积</a> | | <a href="#2.2.1">返回2.2.1目录</a>    </p><p><font color="#3399FF">方案：最简单的做法就是先求所有元素的积，然后每遍历一个位置就除以该位置的值。但是题目规定不能使用除法！这也是为了避免出现0元素作为除数的情况。那么参考【2.2.2  寻找数组的中心下标】，我们可以维护两个状态，对于每一个位置，存储该数左侧全部元素的积，和右侧全部元素的积。由于不能使用除法，只好将这两个状态分别存入两个数组中，反正题目也没有要求空间复杂度。<br>最终用了2次for循环，2个额外数组。</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        l, r = [<span class="number">1</span>]*N, [<span class="number">1</span>]*N</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 原始数据从下表1开始遍历，因为0位置上的左侧积默认是1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N):</span><br><span class="line">            <span class="comment"># 对于i位置的左侧积，就是 i-1位置的左侧积，乘以 i-1 位置的值</span></span><br><span class="line">            l[i] = l[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>]</span><br><span class="line">            i2 = N-i</span><br><span class="line">            <span class="comment"># 同时倒着取索引，计算右侧积</span></span><br><span class="line">            r[i2-<span class="number">1</span>] = r[i2]*nums[i2]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [l[i]*r[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br></pre></td></tr></table></figure><p><font color="#3399FF">方案二：此题确实有空间复杂度更低的方法。因为输出结果本来就是一个数组，是不占额外空间复杂度的，可以利用该结果数组作为中间辅助数组。</font></p><blockquote><p>即第一轮从左往右遍历的时候，先把每个位置的左侧积暂存到结果数组res中；<br>第二次从右往左遍历，这个时候只需要用一个变量来缓存右侧积即可，将每个位置的右侧积，乘以已经缓存在res数组中的左侧积，就可得到最终结果了。</p></blockquote><p>最终还是只使用了2次for循环，但是没有额外用两个辅助数组，只用了一个额外变量，空间复杂度成了O(1)   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#l,r = [1]*N, [1]*N</span></span><br><span class="line">        <span class="comment"># 不使用左右缓存数组，而是直接用结果数组来缓存</span></span><br><span class="line">        res = [<span class="number">1</span>] * N</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N):</span><br><span class="line">            <span class="comment"># 照常计算左侧积</span></span><br><span class="line">            res[i] = res[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第二次从右往左遍历，初始化右侧积 R_mul 为1</span></span><br><span class="line">        R_mul = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N-<span class="number">1</span>,-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># j 位置结果 = 缓存的 j 位置左侧积 * 右侧积</span></span><br><span class="line">            res[j] = res[j]*R_mul</span><br><span class="line">            <span class="comment"># 更新下一位置的右侧积</span></span><br><span class="line">            R_mul *= nums[j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.2.2"></span>  </p><h2 id="2-2-2-二维数组相关题目"><a href="#2-2-2-二维数组相关题目" class="headerlink" title="2.2.2 二维数组相关题目"></a>2.2.2 二维数组相关题目</h2><table><thead><tr><th>序号</th><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>①</td><td><a href="https://leetcode.cn/problems/rotate-image">LeetCode 48.旋转图像</a></td><td><a href="#2.2.2.1">题解2.2.2.1</a></td></tr><tr><td>②</td><td><a href="https://leetcode.cn/problems/diagonal-traverse/description/">LeetCode 498.对角线遍历</a></td><td><a href="#2.2.2.2">题解2.2.2.2</a></td></tr><tr><td>③</td><td><a href="https://leetcode.cn/problems/spiral-matrix">LeetCode 54. 螺旋矩阵</a></td><td><a href="#2.2.2.3">题解2.2.2.3</a></td></tr><tr><td>④</td><td><a href="https://leetcode.cn/problems/spiral-matrix-ii">LeetCode 59. 螺旋矩阵II</a></td><td><a href="#2.2.2.4">题解2.2.2.4</a></td></tr><tr><td>⑤</td><td><a href="https://leetcode.cn/problems/set-matrix-zeroes/">LeetCode 73. 矩阵置零</a></td><td><a href="#2.2.2.5">题解2.2.2.5</a></td></tr><tr><td>⑥</td><td><a href="https://leetcode.cn/problems/game-of-life">LeetCode 289. 生命游戏</a></td><td><a href="#2.2.2.6">题解2.2.2.6</a></td></tr></tbody></table><p><span id="2.2.2.1"></span>  </p><h3 id="2-2-2-1-旋转图像"><a href="#2-2-2-1-旋转图像" class="headerlink" title="2.2.2.1 旋转图像"></a>2.2.2.1 旋转图像</h3><p><a href="https://leetcode.cn/problems/rotate-image">LeetCode 48.旋转图像</a> | | <a href="#2.2.2">返回2.2.2目录</a></p><p><font face="Times" new roman> <font color="#3399FF">方案：顺时针旋转 90°，行变成了列，列变成了行。<br>原来是第 <em>i</em> 行, 现在就是 倒数 第 <em>i</em> 列 (<em>N</em>-1-<em>i</em>)；原来是第 <em>j</em> 列, 现在到了第 <em>j</em> 行。<br>对于原有的一个元素 <em>M[i][j]</em>, 旋转后出现在 <b>倒数</b> 第 <em>i</em> 列的第 <em>j</em> 行位置：<em>M[j][N-1-i]</em><br>对应四个位置上的元素的变化：<br> <em>M[N-1-j][i] –&gt; M[i][j] –&gt; M[j][N-1-i] –&gt; M[N-1-i][N-1-j]</em><br></font> </font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 转换关系 M[N-1-j][i] --&gt; M[i][j] --&gt; M[j][N-1-i] --&gt; M[N-1-i][N-1-j]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 可以发现元素互换都是在自己所在的那个圈层进行交换</span></span><br><span class="line">        <span class="comment"># 每处理完最外一圈，可以视为(待处理)矩阵缩小了一圈</span></span><br><span class="line">        <span class="comment"># 所以我们可以从外到内去处理，一共有 K圈， K = N//2</span></span><br><span class="line">        <span class="comment"># K=0时，圈层左上角是(0,0), K=1时，圈层左上角是(1,1), ...以此类推</span></span><br><span class="line">        N = <span class="built_in">len</span>(matrix)</span><br><span class="line">        K =  N // <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(K):</span><br><span class="line">            <span class="comment"># 对于每一个圈层，如果一次换4个对应位置的元素</span></span><br><span class="line">            <span class="comment"># 那么只要把该圈层的首行的每个元素都进行一次【4位置】交换</span></span><br><span class="line">            <span class="comment"># 该圈层就完成了交换了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 这里一定要注意，对于k圈层的首行，左起列是 k，右侧截止是 N-1-k</span></span><br><span class="line">            <span class="comment"># 但是最右侧那一列可以不用管，因为最后那一列的元素就是首行填充过去的</span></span><br><span class="line">            <span class="comment"># 所以右侧只用取到 N-1-k -1即可</span></span><br><span class="line">            <span class="comment"># 比如k=0时，首行如果是 1,2,3；则只需要移动元素 1及其对应4个位置的，和2及其4个对应位置的；</span></span><br><span class="line">            <span class="comment"># 不用考虑 3及其4个对应位置的数，因为3已经在元素1的4个对应位置当中处理了</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, N-<span class="number">1</span>-i):</span><br><span class="line">                matrix[i][j],     matrix[j][N-<span class="number">1</span>-i], matrix[N-<span class="number">1</span>-i][N-<span class="number">1</span>-j], matrix[N-<span class="number">1</span>-j][i] = \</span><br><span class="line">                matrix[N-<span class="number">1</span>-j][i], matrix[i][j],     matrix[j][N-<span class="number">1</span>-i],     matrix[N-<span class="number">1</span>-i][N-<span class="number">1</span>-j] </span><br><span class="line">            </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="2.2.2.2"></span>  </p><h3 id="2-2-2-2-对角线遍历"><a href="#2-2-2-2-对角线遍历" class="headerlink" title="2.2.2.2 对角线遍历"></a>2.2.2.2 对角线遍历</h3><p><a href="https://leetcode.cn/problems/diagonal-traverse/description/">LeetCode 498.对角线遍历</a> | | <a href="#2.2.2">返回2.2.2目录</a></p><p><font color="#3399FF">方案：这种矩阵遍历的问题，最关键的点就在于，如果考虑好边界条件，达到某一个边界条件之后，换方向.</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDiagonalOrder</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        m,n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        left, top, right, bottom = <span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>, m-<span class="number">1</span></span><br><span class="line">        <span class="comment"># i,j表示矩阵的i 行 j 列, k表示矩阵已经遍历了多少个元素</span></span><br><span class="line">        i, j, k = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> k &lt; m*n:</span><br><span class="line">            <span class="comment"># 朝着右上遍历</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= top <span class="keyword">and</span> j &lt;= right <span class="keyword">and</span> k &lt; m*n:</span><br><span class="line">            <span class="comment"># 当 i 未超过上边界, j 未超过右边界, k 未超过元素总数</span></span><br><span class="line">                res.append(mat[i][j])</span><br><span class="line">                i -= <span class="number">1</span> <span class="comment"># 往上移动, 故 i 减小</span></span><br><span class="line">                j += <span class="number">1</span> <span class="comment"># 往右移动, 故 j 增大</span></span><br><span class="line">                k += <span class="number">1</span> <span class="comment"># 已经遍历过一个元素</span></span><br><span class="line">            <span class="comment"># 当跳出了这个while循环时:</span></span><br><span class="line">            <span class="comment"># 1.如果是 k &lt; m*n 不满足, 可以不用管</span></span><br><span class="line">            <span class="comment"># 2.如果是 i &gt;= top 不满足, 说明上方出界, i要往下回来一行才能继续遍历</span></span><br><span class="line">            <span class="comment"># 3.如果是 j &lt;= right 不满足, 说明右侧出界, j要往左侧回来一列才能继续遍历;</span></span><br><span class="line">            <span class="comment">#   同时, 出右界, 说明刚刚那一行已经被遍历完了！！所以i即使没有越上界，依然要向下, 而且是向下两行！</span></span><br><span class="line">            <span class="comment">#   比如如果是 3行2列 的矩阵,（行多列少，j一定先出界） 就会出现这种情况</span></span><br><span class="line">            <span class="comment"># 如果是2.3都出现不满足, 说明刚刚遍历过的位置是右上角, 和情况3一样</span></span><br><span class="line">            <span class="comment"># 总结起来, 伪代码 就为 :</span></span><br><span class="line">            <span class="comment"># i = i + 1 (j没有越右界) or i + 2(j越了右界)</span></span><br><span class="line">            <span class="comment"># j = j (j没有越右界) or j - 1 (j越了右界)</span></span><br><span class="line">            i, j = (i+<span class="number">1</span>, j) <span class="keyword">if</span> (j &lt;=right) <span class="keyword">else</span> (i+<span class="number">2</span>, j-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 朝着左下遍历</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= bottom <span class="keyword">and</span> j &gt;= left <span class="keyword">and</span> k&lt;m*n:</span><br><span class="line">                res.append(mat[i][j])</span><br><span class="line">                i += <span class="number">1</span> <span class="comment"># 往下移动, 故 i 增大</span></span><br><span class="line">                j -= <span class="number">1</span> <span class="comment"># 往左移动, 故 j 减小</span></span><br><span class="line">                k += <span class="number">1</span> <span class="comment"># 已经遍历过一个元素</span></span><br><span class="line">            <span class="comment"># 分析同上（可以用3行4列的矩阵帮助思考，列多行少，i一定先出界）, 此处不赘述, 伪代码 就为 :</span></span><br><span class="line">            <span class="comment"># j = j + 1 (i没有越下界) or j + 2(i越了下界)</span></span><br><span class="line">            <span class="comment"># i = i (i没有越下界) or i - 1 (i越了下界)</span></span><br><span class="line">            j, i = (j+<span class="number">1</span>, i) <span class="keyword">if</span> (i&lt;=bottom) <span class="keyword">else</span> (j+<span class="number">2</span>, i-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.2.2.3"></span>  </p><h3 id="2-2-2-3-螺旋矩阵"><a href="#2-2-2-3-螺旋矩阵" class="headerlink" title="2.2.2.3 螺旋矩阵"></a>2.2.2.3 螺旋矩阵</h3><p><a href="https://leetcode.cn/problems/spiral-matrix">LeetCode 54. 螺旋矩阵</a> | | <a href="#2.2.2">返回2.2.2目录</a>   </p><p><font color="#3399FF">方案：设立四个边界值，遍历的指针碰到边界值之后，就停下来，换方向，同时更新边界值。</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        i, j, k = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        left, up, right, down = <span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>, m-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(left, right+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][j])</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt;= m*n : <span class="keyword">break</span></span><br><span class="line">            up += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(up, down+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][j])</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt;= m*n : <span class="keyword">break</span></span><br><span class="line">            right -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(right, left-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][j])</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt;= m*n : <span class="keyword">break</span></span><br><span class="line">            down -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(down, up-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][j])</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt;= m*n : <span class="keyword">break</span></span><br><span class="line">            left +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.2.2.4"></span>  </p><h3 id="2-2-2-4-螺旋矩阵II"><a href="#2-2-2-4-螺旋矩阵II" class="headerlink" title="2.2.2.4 螺旋矩阵II"></a>2.2.2.4 螺旋矩阵II</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-ii">LeetCode 59. 螺旋矩阵II</a> | | <a href="#2.2.2">返回2.2.2.2目录</a>  </p><p><font color="#3399FF">方案：上一题中的遍历顺序搞懂了之后，这个题思路很简单，代码也差不多。</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 创建一个 N*N的矩阵</span></span><br><span class="line"><span class="string">        # res = n*[n*[0]]</span></span><br><span class="line"><span class="string">        # 注意，这么写是错的，这样写的后果就是里面的每行都是来源于同一行 的copy，</span></span><br><span class="line"><span class="string">        # 会共享存储空间，属于python的浅拷贝！</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 应该这么写：</span></span><br><span class="line"><span class="string">        # res = []</span></span><br><span class="line"><span class="string">        # for i in range(n):</span></span><br><span class="line"><span class="string">        #   res.append([0]*n)</span></span><br><span class="line"><span class="string">        # 即每一行都是新创建一个 [0]*n的行，然后添加进去</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 简化为如下写法：</span></span><br><span class="line">        res = [ [<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        i, j, k = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        left, up, right, down = <span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(left, right+<span class="number">1</span>):</span><br><span class="line">                res[i][j]=k</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n*n: <span class="keyword">break</span></span><br><span class="line">            up +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(up, down+<span class="number">1</span>):</span><br><span class="line">                res[i][j]=k</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n*n: <span class="keyword">break</span></span><br><span class="line">            right -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(right, left-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res[i][j]=k</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n*n: <span class="keyword">break</span></span><br><span class="line">            down -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(down, up-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res[i][j]=k</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n*n: <span class="keyword">break</span></span><br><span class="line">            left +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><span id="2.2.2.5"></span>  </p><h3 id="2-2-2-5-矩阵置零"><a href="#2-2-2-5-矩阵置零" class="headerlink" title="2.2.2.5 矩阵置零"></a>2.2.2.5 矩阵置零</h3><p><a href="https://leetcode.cn/problems/set-matrix-zeroes/">LeetCode 73. 矩阵置零</a> | | <a href="#2.2.2">返回2.2.2目录</a>   </p><p><font color="#3399FF">方案：我们需要知道原矩阵中哪些位置为0，如果在遍历的同时修改，那么原来不为0的元素可能会被置为0，会影响后面的元素的判断。比如如果左上角是0，在遍历的时候同时修改原数组，那么第一行和第一列的元素会全部变为0；会导致后面所有元素全部为0. 所以我们只能先遍历矩阵，然后找个地方把为0的位置先记住，然后再第二次遍历的时候进行修改。</font>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setZeroes</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 如果在遍历的时候就修改，那么前面如果出现了0，修改完之后，后面很可能都被改为0</span></span><br><span class="line">        <span class="comment"># 所以先记住这些为0的行/列索引</span></span><br><span class="line">        <span class="comment"># 再改</span></span><br><span class="line">        </span><br><span class="line">        rows, cols = [], []</span><br><span class="line">        M, N = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">in</span> rows:</span><br><span class="line">                        rows.append(i)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> j <span class="keyword">in</span> cols:</span><br><span class="line">                        cols.append(j)</span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;注意，python的二维list不支持以下写法：</span></span><br><span class="line"><span class="string">        for i in rows:</span></span><br><span class="line"><span class="string">            matrix[i][:] =0</span></span><br><span class="line"><span class="string">        for j in cols:</span></span><br><span class="line"><span class="string">            matrix[:][j] = 0</span></span><br><span class="line"><span class="string">        这是 numpy array 才支持的写法</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> rows <span class="keyword">or</span> j <span class="keyword">in</span> cols:</span><br><span class="line">                    matrix[i][j] =<span class="number">0</span> </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;思路2.直接用第一列来记录哪一行出现过0，用第一行来记录哪一列出现过0；</span></span><br><span class="line"><span class="string">后续的元素出现0时，虽然第一行和第一列被修改了，但是第一行第一列对应的位置，按照规则本来也会被改成0. </span></span><br><span class="line"><span class="string">不过要提前记录第一行和第一列是否有0元素，有的话，最后再把他们全部变为0；没有的话就不用管&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setZeroes</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        flag_col0 = <span class="built_in">any</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m))</span><br><span class="line">        flag_row0 = <span class="built_in">any</span>(matrix[<span class="number">0</span>][j] == <span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 先用第一行和第一列来记录出现0的列和行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 根据第一行和第一列的记录，来修改原始矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">or</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 再来处理第一列</span></span><br><span class="line">        <span class="keyword">if</span> flag_col0:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 再来处理第一行</span></span><br><span class="line">        <span class="keyword">if</span> flag_row0:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p><span id="2.2.2.6"></span>  </p><h3 id="2-2-2-6-生命游戏"><a href="#2-2-2-6-生命游戏" class="headerlink" title="2.2.2.6 生命游戏"></a>2.2.2.6 生命游戏</h3><p><a href="https://leetcode.cn/problems/game-of-life">LeetCode 289. 生命游戏</a> | | <a href="#2.2.2">返回2.2.2目录</a>    </p><p><font color="#3399FF">方案：规则看起来很唬人，很多，但是就是对于每一个元素判断，判断其3*3窗口内的值，然后根据该值去改变当前元素的值，的这么一个条件判断语句。<br>另外，由于是同时发生改变，所以不能让变化后的值，影响到后面的元素的判断，所以也要先找一个地方，记录状态，和上题一样，只不过这里直接拷贝一个矩阵，拿他来记录原始状态</font>。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gameOfLife</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 因为是同时发生的，所以我们不能在原有矩阵上直接修改</span></span><br><span class="line">        <span class="comment"># 而是参照原有矩阵的值，对一个新的矩阵的值进行判定</span></span><br><span class="line">        <span class="comment"># 二维数组的 深度拷贝的方式有以下几种，不能直接用 = 号去拷贝，那样是python的浅拷贝，会共享存储区域</span></span><br><span class="line">        <span class="keyword">import</span> copy</span><br><span class="line">        copy_board = copy.deepcopy(board)</span><br><span class="line">        <span class="comment"># copy_board = [copy.deepcopy(row) for row in board]</span></span><br><span class="line">        <span class="comment"># copy_board = [[board[i][j] for j in range(n)] for i in range(m)]</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># left: max(0, j-1), right: min(n, j+1+1), top: max(0, i-1), bottom: min(m, i+1+1)</span></span><br><span class="line">                <span class="keyword">if</span> copy_board[i][j] == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 如果原始状态是1，进入下面的规则</span></span><br><span class="line">                    <span class="comment"># 由于我们要算周围8个格子的和</span></span><br><span class="line">                    <span class="comment"># 先将初始值置为-1，这样就直接考虑9宫格的和（相当于减去当前元素1）</span></span><br><span class="line">                    area_sum = -<span class="number">1</span></span><br><span class="line">                    <span class="comment"># 然后就是如何遍历以当前元素为中心的9宫格的问题了</span></span><br><span class="line">                    <span class="comment"># 理想情况下，i的遍历范围[i-1, i+1 +1), j的遍历范围 [j-1, j+1 +1)</span></span><br><span class="line">                    <span class="comment"># 但是要考虑格子本身就在矩阵边界的情况，所以:</span></span><br><span class="line">                    <span class="comment"># 上边界最小只能到 0: 取max(0, i-1); 左边界最小只能到 0: 取max(0, j-1)</span></span><br><span class="line">                    <span class="comment"># 下边界最大只能到 m: 取min(m, i+1 +1); 右边界最大只能到 n：取min(n, j+1 +1);</span></span><br><span class="line">                    <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(<span class="number">0</span>,i-<span class="number">1</span>), <span class="built_in">min</span>(m,i+<span class="number">1</span> +<span class="number">1</span>)):</span><br><span class="line">                        <span class="keyword">for</span> q <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(<span class="number">0</span>,j-<span class="number">1</span>), <span class="built_in">min</span>(n, j+<span class="number">1</span> +<span class="number">1</span>)):</span><br><span class="line">                            area_sum += copy_board[p][q]</span><br><span class="line">                    <span class="keyword">if</span> area_sum &lt; <span class="number">2</span>:</span><br><span class="line">                        board[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">elif</span> area_sum &gt; <span class="number">3</span>:</span><br><span class="line">                        board[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果原始状态是0，进入下面的规则</span></span><br><span class="line">                    area_sum = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(i-<span class="number">1</span>,<span class="number">0</span>), <span class="built_in">min</span>(m,i+<span class="number">1</span>+<span class="number">1</span>)):</span><br><span class="line">                        <span class="keyword">for</span> q <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(<span class="number">0</span>,j-<span class="number">1</span>), <span class="built_in">min</span>(n, j+<span class="number">1</span>+<span class="number">1</span>)):</span><br><span class="line">                            area_sum += copy_board[p][q]</span><br><span class="line">                    <span class="keyword">if</span> area_sum == <span class="number">3</span>:</span><br><span class="line">                        board[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2-1 顺序表</title>
      <link href="/Data-Structure/DS_21_SeqList.html"/>
      <url>/Data-Structure/DS_21_SeqList.html</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">    <hr style="border:solid; height:1px; color=#000000 size=1"> <h1 id="2-1-顺序表"><a href="#2-1-顺序表" class="headerlink" title="2-1 顺序表"></a>2-1 顺序表</h1><hr style="border:solid; height:1px; color=#000000 size=1">   <p>[toc]</p><h2 id="2-1-1-线性表的概念"><a href="#2-1-1-线性表的概念" class="headerlink" title="2.1.1 线性表的概念"></a>2.1.1 线性表的概念</h2><p>线性表<font face="Times" new roman>（linear list）</font>是数据结构的一种，一个线性表是n个具有相同特性的数据元素构成的有限序列，<b>其中的元素的前驱和后置都最多只有一个</b>。<br>线性表是最基本、最简单、也是最常用的一种数据结构。我们说“线性”和“非线性”，只在逻辑层次上讨论，而不考虑存储层次，所以常见的线性表包括：顺序表、栈和队列、链表。<br>线性表通常都具有：初始化、遍历、求长度和增删改查这些操作。  </p><h2 id="2-1-2-顺序表"><a href="#2-1-2-顺序表" class="headerlink" title="2.1.2 顺序表"></a>2.1.2 顺序表</h2><p>顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储区域，将数据元素顺序地存储在其中，就形成一个顺序表。<br>元素间的顺序关系由它们的存储顺序自然的表示。  </p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/2_1.webp" width="90%">  <p>顺序表的两种形式如图所示；<br>a) 是直接存储元素，这就要求元素的类型相同了，因为不同类型的元素占据的字节数是不一样的；<br>b) 是存储的地址，地址指向的是一些元素，由于地址本身这个类型（比如C++中的指针类型）占据的字节是固定的，所以可以存在顺序表中，这些地址指向的具体的位置，存放的元素又可以是不同的类型。  </p><h2 id="2-1-3-Python中的顺序表"><a href="#2-1-3-Python中的顺序表" class="headerlink" title="2.1.3 Python中的顺序表"></a>2.1.3 Python中的顺序表</h2><p>Python标准类型list（列表，就是一种线性表。但是比较特殊，它是一种元素个数可变的线性表。这种顺序表被称为【<strong>动态顺序表</strong>】，因其容量可以在使用过程中动态变化。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;执行以下code，你会发现list中相同的数:1, 竟然指向的是同一个地址</span></span><br><span class="line"><span class="string">这就跟C/C++的传统印象有区别&#x27;&#x27;&#x27;</span></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(nums[i]))</span><br><span class="line"></span><br><span class="line">nums[<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;#&#x27;</span>*<span class="number">14</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(nums[i]))</span><br><span class="line"><span class="comment">##### output ######</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073360</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073424</span></span><br><span class="line"><span class="string">##############</span></span><br><span class="line"><span class="string">1638490265040</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073360</span></span><br><span class="line"><span class="string">1638490073392</span></span><br><span class="line"><span class="string">1638490073424</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>Python 中的 list 的是一种 <u>采用分离式技术实现的动态顺序表</u> ，在建立空列表的时候，系统分配一块能容纳8个元素的存储区；在执行插入操作时(insert&#x2F;append)，如果元素存储区满了，就换一块4倍大的存储区。但是如果当list的规模已经较大时，（目前阈值为50000），就换一块2倍大的存储区，避免出现过多的空闲存储位置。<br>Python 中的另一个顺序表，就是 tuple（元组），元组就不可以改变值了。</p><h2 id="2-1-4-Python中list内置操作的时间复杂度"><a href="#2-1-4-Python中list内置操作的时间复杂度" class="headerlink" title="2.1.4 Python中list内置操作的时间复杂度"></a>2.1.4 Python中list内置操作的时间复杂度</h2><table><thead><tr><th>操作</th><th>时间复杂度</th><th>举例</th></tr></thead><tbody><tr><td>a[ ]</td><td>O(1)</td><td>a[1]</td></tr><tr><td>pop()</td><td>O(1)</td><td>a.pop()</td></tr><tr><td>pop(i)</td><td>O(N)</td><td>a.pop(0)</td></tr><tr><td>insert(i,item)</td><td>O(N)</td><td>a.insert(3,100)</td></tr><tr><td>del</td><td>O(N)</td><td>del a[3]</td></tr><tr><td>len</td><td>O(N)</td><td>len(a)</td></tr><tr><td>iteration</td><td>O(N)</td><td>for x in a: print x</td></tr><tr><td>contains(in)</td><td>O(N)</td><td>3 in a</td></tr><tr><td>get slice[x:y]</td><td>O(k)</td><td>a[3:7]</td></tr><tr><td>del slice</td><td>O(N)</td><td>del a[3:7]</td></tr><tr><td>set slice</td><td>O(k+N)</td><td>a[3:7]&#x3D;[3,4,5,6]</td></tr><tr><td>reverse</td><td>O(N)</td><td>a.reverse()</td></tr><tr><td>concatenate</td><td>O(k)</td><td>[1, 2, 3] + [4, 5, 6]</td></tr><tr><td>sort</td><td>O(nlogN)</td><td>a.sort()</td></tr><tr><td>multiply</td><td>O(kN)</td><td>[‘Hi!’] * 4</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1-1 数据结构与算法</title>
      <link href="/Data-Structure/DS_11_data_structure.html"/>
      <url>/Data-Structure/DS_11_data_structure.html</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">    <hr style="border:solid; height:1px; color=#000000 size=1"> <h1 id="1-1-数据结构与算法"><a href="#1-1-数据结构与算法" class="headerlink" title="1-1 数据结构与算法"></a>1-1 数据结构与算法</h1><hr style="border:solid; height:1px; color=#000000 size=1"> <h2 id="1-1-1-数据结构"><a href="#1-1-1-数据结构" class="headerlink" title="1.1.1 数据结构"></a>1.1.1 数据结构</h2><p>数据结构是讨论计算机系统中 <font color="red"> 数据的存储、组织形式 及其 相互关系</font>。  </p><ul><li>数据：客观事物 采用计算机进行识别、存储和加工所进行的描述  </li><li>结构：事物间的相互关系和约束  </li><li>数据结构的基本单元是数据元素</li></ul><p>数据结构的3个层次：<b>① 数据的逻辑结构；② 数据的存储结构；③ 数据的运算结构(操作集合)。</b>  </p><table border="1" align="center">    <tr>        <td rowspan="3"> ①逻辑结构</td>        <td colspan="2">            反映数据 元素之间 的 逻辑关系 的结构。<br>            逻辑关系是指数据元素之间的<b>前后间关系</b>，而与他们在计算机中的存储位置无关。        </td>    </tr>    <tr>        <td> 线性结构 </td>        <td>             有且仅有一个开始元素和终点元素;<br>            且所有数据元素最多只有一个直接前趋和一个直接后继。<br>             比如 线性表。         </td>    </tr>    <tr>        <td> 非线性结构 </td>        <td>             一个元素可能有多个直接前趋和多个直接后继。<br>            比如 树结构、图结构。        </td>    </tr>    <tr>        <td rowspan="2"> ②存储结构 </td>        <td colspan="2">             数据的逻辑结构在计算机存储空间中的存放形式称为数据的存储结构。<br>            (也称为物理结构)        </td>    </tr>    <tr>        <td colspan="2">            反应数据元素在计算机中的存储方案。<br>            比如：顺序存储、链接存储、索引存储、散列存储。        </td>    </tr>    <tr>        <td rowspan="7"> ③运算结构</td>        <td colspan="2">             数据结构的操作集合        </td>    </tr>    <tr>        <td>  遍历 </td>        <td>  在数据结构的各个元素中移动，或查看所有元素。</td>    </tr>      <tr>        <td>  插入<font color="red">(增)<font> </font></font></td>        <td>  往数据结构中 添加新的元素。</td>    </tr>     <tr>        <td>  删除<font color="red">(删)<font> </font></font></td>        <td>  把指定的数据结构元素移除。</td>    </tr>     <tr>        <td>  更新<font color="red">(改)<font> </font></font></td>        <td>  修改 或 替换数据结构中的 一个或多个元素。</td>    </tr>     <tr>        <td>  查找<font color="red">(查)<font> </font></font></td>        <td>  在数据结构中找寻满足一定条件的数据元素。</td>    </tr>     <tr>        <td>  排序 </td>        <td>  在保持数据结构中元素个数不变的前提条件下，把元素按照指定的顺序重新排列，排序一般是针对线性逻辑结构。</td>    </tr> </table>  <h2 id="1-1-2-算法"><a href="#1-1-2-算法" class="headerlink" title="1.1.2 算法"></a>1.1.2 算法</h2><p>指为解决特定问题 的 有穷的 操作规则 的集合。  </p><table>    <th colspan="2"> 算法的 5 个基本特性 </th>    <tr>        <td> ①有穷性 </td>        <td> 有始有终，不会无限循环，且执行时间可接受。 </td>    </tr>    <tr>        <td> ②确定性 </td>        <td> 算法操作的每一步，其顺序和内容都唯一确定，不会出现二义性。 </td>    </tr>    <tr>        <td> ③数据输入 </td>        <td> 算法具有0个或多个输入。 </td>    </tr>    <tr>        <td> ④数据输出 </td>        <td> 算法至少有一个输出。</td>    </tr>    <tr>        <td> ⑤可行性 </td>        <td> 算法任一步操作都是可以付诸实践的。 </td>    </tr></table>  <p>算法点的效率可分为 时间效率 和 空间效率。  </p><table>    <tr>        <td>             空间复杂度<br>            <font face="Times" new roman> <i>S(n)=O(f(n))</i> </font>        </td>        <td colspan="4">            除开存储数据结构本身外（比如指令、常数、变量 和输入数据），实现算法所需要的额外辅助空间有多少。        </td>    </tr>        <td rowspan="5">             时间复杂度<br>            <font face="Times" new roman> <i>T(n)=O(f(n))</i> </font>        </td>        <td colspan="4">            执行算法所需要的时间以 常数时间操作 的数量级来表示。<br>            相同规模的不同输入，仍可能导致算法的运行时间不同。<br>            <b>一般使用算法最坏情况下的的复杂度来做代表。</b>        </td>    <tr>        <td colspan="4">            常数时间操作是指我们在写代码的时候会涉及到一些指令,这些执令都是固定时间的操作。<br>这些指令是和数据量没有关系的,比如加、减、乘、除、模、位移运算,又或者数组的寻址。        </td>    </tr>    <tr>        <td colspan="4">            不同的机器常数时间操作不一样，比如新一代的机器可能性能更好，常数时间操作更短。<br>但是我们用常数时间操作的数量级（而非具体的数值）来衡量时间复杂度的话，就可以忽略机器的因素，而聚焦到算法本身上来。        </td>    </tr>    <tr>        <td colspan="4">            时间复杂度可以用T(n)的自然特性加以区分，如下：        </td>    </tr>    <tr>        <td> 常量时间 O(1) </td>        <td> 线性时间 O(n) </td>        <td> 对数时间 O(logn) </td>        <td> 指数时间 O(n**2) </td>    </tr></table>  <p>Python 中的 <code>timeit</code> 模块可以来测试代码的执行时间，网上有很多资料,这里不赘述。<br>时间复杂度大致上有以下的大小关系：  </p><p>O(1) &lt; O(logN) &lt; O(logN^2) &lt; O(N) &lt; O(N*logN) &lt; O(N^2) &lt; O(N^3)&lt; …&lt;O(N^k)<br>…  &lt; O( 2^N) &lt; O(3^N)  &lt; … &lt; O(k^N) &lt; O(N!)  </p><p>可以通过数学函数图像来加深理解。  </p><img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/Data_Structure/1_1_math_func_img.webp" width="60%">   <h2 id="1-1-3-程序"><a href="#1-1-3-程序" class="headerlink" title="1.1.3 程序"></a>1.1.3 程序</h2><p>程序 &#x3D; 算法 + 数据结构                —- 尼古拉斯·沃斯<br><b> <font color="red">Algorithm + Data Structures &#x3D; Programs </font>   —-  Niklaus Wirth，1984 图灵奖 <B></B></b></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法_Python</title>
      <link href="/Data-Structure/DS_00_introduction.html"/>
      <url>/Data-Structure/DS_00_introduction.html</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.staticaly.com/gh/teeyohuang/pic_bed@main/img/csdn_head_webp.webp" width="70%">    <hr style="border:solid; height:1px; color=#000000 size=1">  <h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><hr style="border:solid; height:1px; color=#000000 size=1">  <p>本系列文章以Python语言为基础，简要介绍基本的数据结构与算法的相关知识。<br>并配合 <a href="https://leetcode.cn/">LeetCode</a> 网站的一些题目来加深相关概念的了解。<br><b><font color="red">注意！由于版权原因，本系列文章在引用LeetCode的题目时，只提供官方页面的跳转链接，而不会直接展示题目信息。</font></b> </p><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><h2 id="1-1-数据结构与算法"><a href="#1-1-数据结构与算法" class="headerlink" title="1-1 数据结构与算法"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_11_data_structure.html">1-1 数据结构与算法</a></h2><h2 id="2-1-顺序表"><a href="#2-1-顺序表" class="headerlink" title="2-1 顺序表"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_21_SeqList.html">2-1 顺序表</a></h2><h2 id="2-2-数组相关题目"><a href="#2-2-数组相关题目" class="headerlink" title="2-2 数组相关题目"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_22_array_exercises.html">2-2 数组相关题目</a></h2><h2 id="2-3-数组双指针"><a href="#2-3-数组双指针" class="headerlink" title="2-3 数组双指针"></a><a href="https://teeyohuang.github.io/Data-Structure/DS_23_array_double_pointer_exercises.html">2-3 数组双指针</a></h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度学习导论</title>
      <link href="/Deep-Learning/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA.html"/>
      <url>/Deep-Learning/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA.html</url>
      
        <content type="html"><![CDATA[<p>深度学习导论</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习导论</title>
      <link href="/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA.html"/>
      <url>/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA.html</url>
      
        <content type="html"><![CDATA[<p>机器学习导论</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图像分割测试用例</title>
      <link href="/Computer-Vision/Image-Segmentation-By-Deeplearning/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.html"/>
      <url>/Computer-Vision/Image-Segmentation-By-Deeplearning/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.html</url>
      
        <content type="html"><![CDATA[<p>图像分割测试用例</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 深度学习下的图像分割 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
