<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>7-2 树相关的题目 | 朝花夕拾</title><meta name="author" content="TeeyoHuang"><meta name="copyright" content="TeeyoHuang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="树相关的题目">
<meta property="og:type" content="article">
<meta property="og:title" content="7-2 树相关的题目">
<meta property="og:url" content="https://teeyohuang.github.io/Data-Structure/DS_72_tree_exercises.html">
<meta property="og:site_name" content="朝花夕拾">
<meta property="og:description" content="树相关的题目">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://teeyohuang.github.io/pic_bed/Data_Structure/7_2_0.webp">
<meta property="article:published_time" content="2023-04-28T16:15:00.000Z">
<meta property="article:modified_time" content="2023-12-16T16:57:17.809Z">
<meta property="article:author" content="TeeyoHuang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://teeyohuang.github.io/pic_bed/Data_Structure/7_2_0.webp"><link rel="shortcut icon" href="/img/favicon_T.png"><link rel="canonical" href="https://teeyohuang.github.io/Data-Structure/DS_72_tree_exercises.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":40,"languages":{"author":"作者: TeeyoHuang","link":"链接: ","source":"来源: 朝花夕拾","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '7-2 树相关的题目',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-17 00:57:17'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 7 || hour >= 22
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="/css/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/teeyo_comic.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://teeyohuang.github.io/pic_bed/Data_Structure/7_2_0.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="朝花夕拾"><span class="site-name">朝花夕拾</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">7-2 树相关的题目</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-28T16:15:00.000Z" title="发表于 2023-04-29 00:15:00">2023-04-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-16T16:57:17.809Z" title="更新于 2023-12-17 00:57:17">2023-12-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Data-Structure/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>73分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="7-2 树相关的题目"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="https://teeyohuang.github.io/pic_bed/img/csdn_head_webp.webp" width="70%">   </p>
<hr style="border:solid; height:1px; color=#000000 size=1">   

<h1 id="7-2-树相关的题目"><a href="#7-2-树相关的题目" class="headerlink" title="7-2 树相关的题目"></a>7-2 树相关的题目</h1><hr style="border:solid; height:1px; color=#000000 size=1">  

<p><b>版权声明：以下题目均来自 <a target="_blank" rel="noopener" href="https://leetcode.cn">LeetCode</a>， 仅仅提供跳转到力扣官网的链接，不在本页面出现题目内容，本文章内容禁止商业用途。</b></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container">
<table>
<thead>
<tr>
<th>小节</th>
<th>位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>7.2.1</td>
<td><a href="#7.2.1">二叉树的遍历</a></td>
</tr>
<tr>
<td>7.2.2</td>
<td><a href="#7.2.2">二叉树反序列化（还原）</a></td>
</tr>
<tr>
<td>7.2.3</td>
<td><a href="#7.2.3">路径问题</a></td>
</tr>
<tr>
<td>7.2.4</td>
<td><a href="#7.2.4">验证各种树</a></td>
</tr>
<tr>
<td>7.2.5</td>
<td><a href="#7.2.5">二叉查找树</a></td>
</tr>
<tr>
<td>7.2.6</td>
<td><a href="#7.2.6">前缀树</a></td>
</tr>
</tbody>
</table>
</div>
<p><span id="7.2.1"></span></p>
<h2 id="7-2-1-二叉树的遍历"><a href="#7-2-1-二叉树的遍历" class="headerlink" title="7.2.1 二叉树的遍历"></a>7.2.1 二叉树的遍历</h2><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>题目</th>
<th>题解</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">LeetCode 144.二叉树的前序遍历</a></td>
<td><a href="#7.2.1.1.1">题解7.2.1.1.1</a></td>
</tr>
<tr>
<td>②</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">LeetCode 94.二叉树的中序遍历</a></td>
<td><a href="#7.2.1.1.2">题解7.2.1.1.2</a></td>
</tr>
<tr>
<td>③</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">LeetCode 145.二叉树的后序遍历</a></td>
<td><a href="#7.2.1.1.3">题解7.2.1.1.3</a></td>
</tr>
<tr>
<td>④</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">LeetCode 102.二叉树的层序遍历</a></td>
<td><a href="#7.2.1.2.1">题解7.2.1.2.1</a></td>
</tr>
<tr>
<td>⑤</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">LeetCode 107.二叉树的层序遍历 II</a></td>
<td><a href="#7.2.1.2.2">题解7.2.1.2.2</a></td>
</tr>
<tr>
<td>⑥</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">LeetCode 103.二叉树的锯齿形层序遍历</a></td>
<td><a href="#7.2.1.2.3">题解7.2.1.2.3</a></td>
</tr>
<tr>
<td>⑦</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">LeetCode 104.二叉树的最大深度</a></td>
<td><a href="#7.2.1.3">题解7.2.1.3</a></td>
</tr>
<tr>
<td>⑧</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">LeetCode 111.二叉树的最小深度</a></td>
<td><a href="#7.2.1.4">题解7.2.1.4</a></td>
</tr>
<tr>
<td>⑨</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">LeetCode 662.二叉树最大宽度</a></td>
<td><a href="#7.2.1.5">题解7.2.1.5</a></td>
</tr>
<tr>
<td>⑩</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">LeetCode 199.二叉树的右视图</a></td>
<td><a href="#7.2.1.6">题解7.2.1.6</a></td>
</tr>
<tr>
<td>⑪</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">LeetCode 101.对称二叉树</a></td>
<td><a href="#7.2.1.7">题解7.2.1.7</a></td>
</tr>
<tr>
<td>⑫</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">LeetCode 226.翻转二叉树</a></td>
<td><a href="#7.2.1.8">题解7.2.1.8</a></td>
</tr>
<tr>
<td>⑬</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">LeetCode 116.填充每个节点的下一个右侧节点指针</a></td>
<td><a href="#7.2.1.9">题解7.2.1.9</a></td>
</tr>
<tr>
<td>⑭</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">LeetCode 117.填充每个节点的下一个右侧节点指针 II</a></td>
<td><a href="#7.2.1.10">题解7.2.1.10</a></td>
</tr>
<tr>
<td>⑮</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">LeetCode 100.相同的树</a></td>
<td><a href="#7.2.1.11">题解7.2.1.11</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="7-2-1-1-深度优先遍历-DFS"><a href="#7-2-1-1-深度优先遍历-DFS" class="headerlink" title="7.2.1.1 深度优先遍历-DFS"></a>7.2.1.1 深度优先遍历-DFS</h3><p><span id="7.2.1.1.1"></span>  </p>
<h4 id="7-2-1-1-1-二叉树的前序遍历"><a href="#7-2-1-1-1-二叉树的前序遍历" class="headerlink" title="7.2.1.1.1 二叉树的前序遍历"></a>7.2.1.1.1 二叉树的前序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">LeetCode 144.二叉树的前序遍历</a> | |<a href="#7.2.1">返回目录7.2.1</a></p>
<p>思路：前序遍历就是根结点要先遍历到。中-左-右 的顺序    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.递归方法&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 根结点在最开始处理</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            preorder(root.left)</span><br><span class="line">            preorder(root.right)</span><br><span class="line"></span><br><span class="line">        res =[]</span><br><span class="line">        preorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归方法之一&#x27;&#x27;&#x27;</span></span><br><span class="line">        cur = root</span><br><span class="line">        s, res = [], []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> <span class="built_in">len</span>(s)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 先遍历根结点及其左子树上的每一个子树的根结点</span></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="comment"># 左子树部分遍历完之后就可以遍历右边的子树部分了</span></span><br><span class="line">            cur = s.pop()</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归方法之二&#x27;&#x27;&#x27;</span></span><br><span class="line">        s, res = [], []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            s.append(root)</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span>:</span><br><span class="line">                cur = s.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                <span class="comment"># 注意这里是先将右子结点入栈，再将左子结点入栈</span></span><br><span class="line">                <span class="comment"># 这样出栈的时候，就是左子结点先出栈，右子结点后出栈</span></span><br><span class="line">                <span class="keyword">if</span> cur.right :</span><br><span class="line">                    s.append(cur.right)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    s.append(cur.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><span id="7.2.1.1.2"></span>  </p>
<h4 id="7-2-1-1-2-二叉树的中序遍历"><a href="#7-2-1-1-2-二叉树的中序遍历" class="headerlink" title="7.2.1.1.2 二叉树的中序遍历"></a>7.2.1.1.2 二叉树的中序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">LeetCode 94.二叉树的中序遍历</a>| | <a href="#7.2.1">返回目录7.2.1</a></p>
<p>思路：前序遍历就是左子结点要先遍历到。左-中-右 的顺序    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.递归方法&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            inorder(root.left)</span><br><span class="line">            <span class="comment"># 根结点在中间处理</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            inorder(root.right)</span><br><span class="line"></span><br><span class="line">        res =[]</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归方法&#x27;&#x27;&#x27;</span></span><br><span class="line">        cur = root</span><br><span class="line">        s, res = [], []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> <span class="built_in">len</span>(s)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="comment"># 先将结点入栈而不是读取值</span></span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.left </span><br><span class="line">            </span><br><span class="line">            cur = s.pop()</span><br><span class="line">            <span class="comment"># 弹出的结点再读取值</span></span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><span id="7.2.1.1.3"></span>  </p>
<h4 id="7-2-1-1-3-二叉树的后序遍历"><a href="#7-2-1-1-3-二叉树的后序遍历" class="headerlink" title="7.2.1.1.3 二叉树的后序遍历"></a>7.2.1.1.3 二叉树的后序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">LeetCode 145.二叉树的后序遍历</a> | |<a href="#7.2.1">返回目录7.2.1</a></p>
<p>思路：后序就是按照 左-右-中 的顺序  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.递归法&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">posorder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            posorder(root.left)</span><br><span class="line">            posorder(root.right)</span><br><span class="line">            <span class="comment"># 根结点排在最后处理</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        posorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归方法之一&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;按照先序遍历，只不过是右结点先于左结点，构造成：中-右-左，最后逆序：</span></span><br><span class="line"><span class="string">        得到 左-右-中 的顺序&#x27;&#x27;&#x27;</span></span><br><span class="line">        cur = root</span><br><span class="line">        s, res = [], []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> <span class="built_in">len</span>(s)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                s.append(cur)</span><br><span class="line">                <span class="comment"># 这里就是先处理左右当中的右子结点</span></span><br><span class="line">                cur = cur.right</span><br><span class="line">            cur = s.pop()</span><br><span class="line">            <span class="comment"># 后处理左结点</span></span><br><span class="line">            cur = cur.left</span><br><span class="line">        <span class="comment"># 此时res是 中-右-左 的顺序，再逆序即可</span></span><br><span class="line">        res.reverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归方法之二&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;按照先序遍历，只不过是右结点先于左结点，构造成：中-右-左，最后逆序：</span></span><br><span class="line"><span class="string">        得到 左-右-中 的顺序&#x27;&#x27;&#x27;</span></span><br><span class="line">        s, res = [], []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            s.append(root)</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span>:</span><br><span class="line">                cur = s.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                <span class="comment"># 注意这里是先将左子结点入栈，再将右子结点入栈</span></span><br><span class="line">                <span class="comment"># 这样出栈的时候，就是右子结点先出栈，左子结点后出栈</span></span><br><span class="line">                <span class="keyword">if</span> cur.left :</span><br><span class="line">                    s.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    s.append(cur.right)</span><br><span class="line">        res.reverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.非递归方法之三&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;不采用逆序的手段，直接按照需要的顺序求结果&#x27;&#x27;&#x27;</span></span><br><span class="line">        pre, cur = <span class="literal">None</span>, root</span><br><span class="line">        s, res = [], []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> <span class="built_in">len</span>(s)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            </span><br><span class="line">            cur = s.pop()</span><br><span class="line">            <span class="comment"># 如果当前结点没有右子结点，或者其右子结点上一轮已经处理过</span></span><br><span class="line">            <span class="comment"># 就说明应该处理当前结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.right <span class="keyword">or</span> cur.right == pre:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 如果不是，说明存在右子结点，且尚未处理过右子结点</span></span><br><span class="line">            <span class="comment"># 就先将当前结点放回栈，先处理其右子结点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="7-2-1-2-广度优先遍历-BFS"><a href="#7-2-1-2-广度优先遍历-BFS" class="headerlink" title="7.2.1.2 广度优先遍历-BFS"></a>7.2.1.2 广度优先遍历-BFS</h3><p><span id="7.2.1.2.1"></span>  </p>
<h4 id="7-2-1-2-1-二叉树的层序遍历"><a href="#7-2-1-2-1-二叉树的层序遍历" class="headerlink" title="7.2.1.2.1 二叉树的层序遍历"></a>7.2.1.2.1 二叉树的层序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">LeetCode 102.二叉树的层序遍历</a> | | <a href="#7.2.1">返回目录7.2.1</a></p>
<p>思路：一层一层的遍历。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># q作为临时队列</span></span><br><span class="line">        q = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            layer = []</span><br><span class="line">            <span class="comment"># N 实际是当前要遍历的层的结点个数</span></span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="comment"># 模拟队列的处理方法，即先进的先出，</span></span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                layer.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">            res.append(layer)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><span id="7.2.1.2.2"></span>  </p>
<h4 id="7-2-1-2-2-二叉树的层序遍历-II"><a href="#7-2-1-2-2-二叉树的层序遍历-II" class="headerlink" title="7.2.1.2.2 二叉树的层序遍历 II"></a>7.2.1.2.2 二叉树的层序遍历 II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">LeetCode 107.二叉树的层序遍历 II</a>| | <a href="#7.2.1">返回目录7.2.1</a></p>
<p>思路：普通的层序遍历再逆序。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrderBottom</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># q作为临时队列</span></span><br><span class="line">        q = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            layer = []</span><br><span class="line">            <span class="comment"># N 实际是当前要遍历的层的结点个数</span></span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="comment"># 模拟队列的处理方法，即先进的先出，</span></span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                layer.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">            res.append(layer)</span><br><span class="line">        res.reverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><span id="7.2.1.2.3"></span>  </p>
<h4 id="7-2-1-2-3-二叉树的锯齿形层序遍历"><a href="#7-2-1-2-3-二叉树的锯齿形层序遍历" class="headerlink" title="7.2.1.2.3 二叉树的锯齿形层序遍历"></a>7.2.1.2.3 二叉树的锯齿形层序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">LeetCode 103.二叉树的锯齿形层序遍历</a> | | <a href="#7.2.1">返回目录7.2.1</a></p>
<p>思路：普通的层序遍历,对于特定的层进行逆序。这个逆序操作可以在遍历完一层之后再做，也可以在遍历的时候就调整方向，手法是多种的。题解中选择遍历完一层之后再对整层做逆序，操作起来简单一些。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">zigzagLevelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># q作为临时队列</span></span><br><span class="line">        q = [root]</span><br><span class="line">        res = []</span><br><span class="line">        L = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            layer = []</span><br><span class="line">            <span class="comment"># N 实际是当前要遍历的层的结点个数</span></span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="comment"># 模拟队列的处理方法，即先进的先出，</span></span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                layer.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> L % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                res.append(layer)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(layer[::-<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 处理完当前层之后，层索引加一</span></span><br><span class="line">            L += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><span id="7.2.1.3"></span>  </p>
<h3 id="7-2-1-3-二叉树的最大深度"><a href="#7-2-1-3-二叉树的最大深度" class="headerlink" title="7.2.1.3 二叉树的最大深度"></a>7.2.1.3 二叉树的最大深度</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">LeetCode 104.二叉树的最大深度</a> | | <a href="#7.2.1">返回目录7.2.1</a></p>
<p>思路1：说白了就是求多少层，就可以考虑使用层序遍历的解法。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        q = [root]</span><br><span class="line">        h = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            n = <span class="built_in">len</span>(q)</span><br><span class="line">            h+=<span class="number">1</span> <span class="comment"># 思路很简单，每有一层，就给深度加上1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure>
<p>思路2：如果按照有多深这个角度来理解，使用深度优先遍历也是可以的。采用递归的方法，写起来也简单。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            left_height = self.maxDepth(root.left) </span><br><span class="line">            right_height = self.maxDepth(root.right) </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left_height, right_height) + <span class="number">1</span> </span><br></pre></td></tr></table></figure>
<p><span id="7.2.1.4"></span>  </p>
<h3 id="7-2-1-4-二叉树的最小深度"><a href="#7-2-1-4-二叉树的最小深度" class="headerlink" title="7.2.1.4 二叉树的最小深度"></a>7.2.1.4 二叉树的最小深度</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">LeetCode 111.二叉树的最小深度</a>| | <a href="#7.2.1">返回目录7.2.1</a></p>
<p>思路1：说白了还是在求层数，就可以考虑使用层序遍历的解法，只不过不一定要遍历到最后一层才停止。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        q, h = [root], <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q :</span><br><span class="line">            n = <span class="built_in">len</span>(q)</span><br><span class="line">            h+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 知道终点条件就行，达到此条件，直接可以返回了，不用继续遍历下一层了</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">not</span> cur.left) <span class="keyword">and</span> (<span class="keyword">not</span> cur.right):</span><br><span class="line">                    <span class="keyword">return</span> h</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure>
<p>思路2：依然可以使用深度优先遍历的方法。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 递归的结束条件依然是判断当前结点是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        min_depth =  <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> root.left: <span class="comment"># 如果左子结点存在, 才去算其深度</span></span><br><span class="line">            min_depth = <span class="built_in">min</span>(self.minDepth(root.left), min_depth)</span><br><span class="line">        <span class="keyword">if</span> root.right: <span class="comment"># 如果右子结点存在, 才去算其深度</span></span><br><span class="line">            min_depth = <span class="built_in">min</span>(self.minDepth(root.right), min_depth)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><span id="7.2.1.5"></span>  </p>
<h3 id="7-2-1-5-二叉树最大宽度"><a href="#7-2-1-5-二叉树最大宽度" class="headerlink" title="7.2.1.5 二叉树最大宽度"></a>7.2.1.5 二叉树最大宽度</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">LeetCode 662.二叉树最大宽度</a> | | <a href="#7.2.1">返回目录7.2.1</a></p>
<p>思路1：比较直观的方法是求出每一层的宽度，然后求出最大值，这就可以考虑层次优先遍历。<br>求每一层的宽度时，因其实就是求最右侧的点到最左侧的点，的宽度是多少，<br>然而，此时要求将中间的null结点也算作有效的点，干脆就对结点进行编号。<br>编号方式为，假设其在对应的一个满二叉树中的位置索引编号！   </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">widthOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        width = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> width </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化根节点和其序号      </span></span><br><span class="line">        q = [(root,<span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="comment"># 计算该层的最大宽度</span></span><br><span class="line">            width_of_layer = q[-<span class="number">1</span>][<span class="number">1</span>] - q[<span class="number">0</span>][<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 然后更新width</span></span><br><span class="line">            width = <span class="built_in">max</span>(width, width_of_layer)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur, index = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 对比原始的层序遍历，只是将入队的元素改为了(node, index)而已</span></span><br><span class="line">                <span class="comment"># index是对应满二叉树的位置索引</span></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append((cur.left, <span class="number">2</span>*index+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append((cur.right, <span class="number">2</span>*index+<span class="number">2</span>))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> width</span><br></pre></td></tr></table></figure>
<p>思路2：也可以使用递归方法采取深度优先的思路，直观上没有层次遍历方法那么容易理解。<br>说白了也是利用递归的时候，每次深入结点，就改变index，同时对每层设置了一个起始节点的index，固定在那里，便于计算宽度。直观上不太好理解   </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">widthOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 这个是存储每一层的最左侧结点的index的哈希表</span></span><br><span class="line">        layerMin = &#123;&#125;</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode], depth: <span class="built_in">int</span>, index: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="comment"># 递归结束条件为当前结点为空</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> depth <span class="keyword">not</span> <span class="keyword">in</span> layerMin:</span><br><span class="line">                layerMin[depth] = index  <span class="comment"># 每一层最先访问到的节点会是最左边的节点，即每一层编号的最小值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(index - layerMin[depth] + <span class="number">1</span>,</span><br><span class="line">                       dfs(node.left, depth + <span class="number">1</span>, index * <span class="number">2</span> + <span class="number">1</span>),</span><br><span class="line">                       dfs(node.right, depth + <span class="number">1</span>, index * <span class="number">2</span> + <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><span id="7.2.1.6"></span>  </p>
<h3 id="7-2-1-6-二叉树的右视图"><a href="#7-2-1-6-二叉树的右视图" class="headerlink" title="7.2.1.6 二叉树的右视图"></a>7.2.1.6 二叉树的右视图</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">LeetCode 199.二叉树的右视图</a> | | <a href="#7.2.1">返回目录7.2.1</a></p>
<p>思路1：采用层序遍历，每一层只取最右的结点。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.广度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        q=[root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(q) &gt; <span class="number">0</span>:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> i == N-<span class="number">1</span>:</span><br><span class="line">                    res.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>思路2：采用深度优先遍历，按照先序遍历的基础code进行修改，但是要先遍历右子树上的结点；<br>并且，我们记住已经遍历过的深度，对于每一深度（层）而言，遍历到这一深度时的第一个结点一定是最右侧的结点。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.深度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每一个元素由[结点, 深度]这样的二元数组构成</span></span><br><span class="line">        cur = [root,<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 用一个哈希表存储已经遍历过的层的序号</span></span><br><span class="line">        hash_d = &#123;&#125;</span><br><span class="line">        s, res = [], []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur[<span class="number">0</span>] <span class="keyword">or</span> s:</span><br><span class="line">            <span class="keyword">while</span> cur[<span class="number">0</span>]:</span><br><span class="line">                cur_node, cur_d = cur[<span class="number">0</span>], cur[<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 如果当前深度还没有遍历，那么该层遇到的第一个结点就一定是最右侧的结点</span></span><br><span class="line">                <span class="keyword">if</span> cur_d <span class="keyword">not</span> <span class="keyword">in</span> hash_d:</span><br><span class="line">                    res.append(cur_node.val)</span><br><span class="line">                    hash_d[cur_d] = cur_node</span><br><span class="line"></span><br><span class="line">                s.append(cur)</span><br><span class="line">                <span class="comment"># 记得往右子树的方向更新cur</span></span><br><span class="line">                cur = [cur_node.right, cur_d+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            cur = s.pop()</span><br><span class="line">            cur = [cur[<span class="number">0</span>].left, cur[<span class="number">1</span>]+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><span id="7.2.1.7"></span>  </p>
<h3 id="7-2-1-7-对称二叉树"><a href="#7-2-1-7-对称二叉树" class="headerlink" title="7.2.1.7 对称二叉树"></a>7.2.1.7 对称二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">LeetCode 101.对称二叉树</a> | | <a href="#7.2.1">返回目录7.2.1</a>  </p>
<p>思路1：采用广度优先(层序)遍历，判断各层是否符合对称条件。<br>注意，这里对称不光是要值相等，还要让位置符合对称的条件   </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.采用广度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line"></span><br><span class="line">        h = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 同时将结点，和其对应满二叉树的位置索引保存</span></span><br><span class="line">        q = [(root,<span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            h += <span class="number">1</span></span><br><span class="line">            layer = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                node, idx = cur</span><br><span class="line">                layer.append(cur)</span><br><span class="line">                <span class="comment"># 同时将结点，和其对应满二叉树的位置索引保存</span></span><br><span class="line">                <span class="keyword">if</span> node.left:   </span><br><span class="line">                    q.append((node.left, <span class="number">2</span>*idx+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    q.append((node.right, <span class="number">2</span>*idx+<span class="number">2</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 判断当前layer是否符合对称条件</span></span><br><span class="line">            L, R = <span class="number">0</span>, N-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt;= R:</span><br><span class="line">                left, right = layer[L], layer[R]</span><br><span class="line">                <span class="comment"># 要同时判断值是否相等，以及位置是否满足对称关系</span></span><br><span class="line">                <span class="comment"># 这里先求前几层的结点总数</span></span><br><span class="line">                front_node_cnts = <span class="number">2</span>**(h-<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> left[<span class="number">0</span>].val == right[<span class="number">0</span>].val <span class="keyword">and</span> \</span><br><span class="line">                    left[<span class="number">1</span>]-front_node_cnts  +  right[<span class="number">1</span>]-front_node_cnts == <span class="number">2</span>**(h-<span class="number">1</span>)-<span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 其中 left[1]-front_node_cnts 和 right[1]-front_node_cnts 代表的是当前结点索引，减去前几层的结点数</span></span><br><span class="line">                    <span class="comment"># 2**(h-1) 是假设当前层是满的情况时，应该有多少个结点</span></span><br><span class="line">                    L+=<span class="number">1</span></span><br><span class="line">                    R-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># print(left[0].val,right[0].val,left[1],right[1], front_node_cnts, N-1)</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>思路2：采用深度优先遍历。<br>注意，这里要注意，判断左右两个结点的值是否相等时，一定要保证这两个结点来自对称的位置，而未必是同一个结点的左右子结点。    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.采用深度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 根结点本身为空，返回True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line"></span><br><span class="line">         <span class="comment"># 结点不为空，再来讨论其子树</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">left, right</span>):</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;注意: </span></span><br><span class="line"><span class="string">            DFS传入的两个结点，是对称位置的两个结点，而不一定是同一个结点的左右子结点 </span></span><br><span class="line"><span class="string">            只有对树的根结点而言，对称位置的两个结点，刚好是其左右子结点，再往下就不是左右子结点了！</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="comment"># 如果对称位置的结点都为空，满足对称</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">            <span class="keyword">elif</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="comment"># 如果左侧结点不为空，右侧结点为空，显然不对称</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> left <span class="keyword">and</span> right:</span><br><span class="line">                <span class="comment"># 如果左侧结点为空，右侧结点不为空，显然不对称</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果对称左右位置的结点都不为空，就要讨论两个条件：</span></span><br><span class="line">                <span class="comment"># 1.左右两个结点的值是否相等：</span></span><br><span class="line">                <span class="comment"># 2.左右两个结点下的子树本身是否满足对称条件</span></span><br><span class="line">                <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">                    <span class="comment"># 左右结点（即对称位置）的值不相等，显然不对称</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 一定要注意DFS传入的两个结点，是对称位置的两个结点，而非同一个结点的左右子结点</span></span><br><span class="line">                    <span class="keyword">return</span> DFS(left.left, right.right) <span class="keyword">and</span> DFS(left.right, right.left)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> DFS(root.left, root.right)</span><br></pre></td></tr></table></figure>
<p><span id="7.2.1.8"></span>  </p>
<h3 id="7-2-1-8-翻转二叉树"><a href="#7-2-1-8-翻转二叉树" class="headerlink" title="7.2.1.8 翻转二叉树"></a>7.2.1.8 翻转二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">LeetCode 226.翻转二叉树</a> | | <a href="#7.2.1">返回目录7.2.1</a>  </p>
<p>思路1：采用深度优先遍历，递归地反转子树。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先递归处理该结点的左右子树，使其左右子树已经完成反转</span></span><br><span class="line">        new_left = self.invertTree(root.left)</span><br><span class="line">        new_right = self.invertTree(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 再将其左右子树交换即可</span></span><br><span class="line">        root.left, root.right = new_right, new_left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p><span id="7.2.1.9"></span>  </p>
<h3 id="7-2-1-9-填充每个节点的下一个右侧节点指针"><a href="#7-2-1-9-填充每个节点的下一个右侧节点指针" class="headerlink" title="7.2.1.9 填充每个节点的下一个右侧节点指针"></a>7.2.1.9 填充每个节点的下一个右侧节点指针</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">LeetCode 116.填充每个节点的下一个右侧节点指针</a> | | <a href="#7.2.1">返回目录7.2.1</a>  </p>
<p>思路1：最直接的思路就是采用广度优先遍历，对每一层进行连接即可。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="string">&#x27;Optional[Node]&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root </span><br><span class="line">        </span><br><span class="line">        q = [root]</span><br><span class="line">        cur = root </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N =<span class="built_in">len</span>(q)</span><br><span class="line">            pre = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 层内链接</span></span><br><span class="line">                <span class="keyword">if</span> pre:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur </span><br><span class="line">                pre = cur </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> root </span><br></pre></td></tr></table></figure>
<p>思路2：由于题目中说了这是满二叉树，所以每一层都是满的，每个父节点都有两个子节点。所以也可以利用这一特点来做，即对已经建立起来的next链接做横向移动。   </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># 从根节点开始</span></span><br><span class="line">        leftmost = root</span><br><span class="line">        <span class="keyword">while</span> leftmost.left:</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 遍历这一层节点组织成的横向链表，为下一层的节点更新 next 指针</span></span><br><span class="line">            head = leftmost</span><br><span class="line">            <span class="keyword">while</span> head:</span><br><span class="line">                <span class="comment"># 1.同一个父节点内的左右子结点链接</span></span><br><span class="line">                head.left.<span class="built_in">next</span> = head.right</span><br><span class="line">                <span class="comment"># 2.将不同父节点之间的下一层右左子结点链接起来</span></span><br><span class="line">                <span class="keyword">if</span> head.<span class="built_in">next</span>:</span><br><span class="line">                    head.right.<span class="built_in">next</span> = head.<span class="built_in">next</span>.left</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 在本层内指针向后移动</span></span><br><span class="line">                head = head.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 去下一层的最左的节点</span></span><br><span class="line">            leftmost = leftmost.left</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root </span><br></pre></td></tr></table></figure>
<p><span id="7.2.1.10"></span>  </p>
<h3 id="7-2-1-10-填充每个节点的下一个右侧节点指针II"><a href="#7-2-1-10-填充每个节点的下一个右侧节点指针II" class="headerlink" title="7.2.1.10 填充每个节点的下一个右侧节点指针II"></a>7.2.1.10 填充每个节点的下一个右侧节点指针II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">LeetCode 117.填充每个节点的下一个右侧节点指针 II</a> | | <a href="#7.2.1">返回目录7.2.1</a>   </p>
<p>思路1：这个题和上一题的唯一区别就是，该题没有明确说明树是【完全二叉树】，但是依然能够用上一题的层次遍历的方法来做。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root </span><br><span class="line">        </span><br><span class="line">        q = [root]</span><br><span class="line">        cur = root </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N =<span class="built_in">len</span>(q)</span><br><span class="line">            pre = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> pre:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur </span><br><span class="line">                pre = cur </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> root </span><br></pre></td></tr></table></figure>
<p><span id="7.2.1.11"></span>  </p>
<h3 id="7-2-1-11-相同的树"><a href="#7-2-1-11-相同的树" class="headerlink" title="7.2.1.11 相同的树"></a>7.2.1.11 相同的树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">LeetCode 100.相同的树</a> | | <a href="#7.2.1">返回目录7.2.1</a>   </p>
<p>思路：如果采用深度优先遍历的思路，其实和【<a href="#7.2.1.7">对称二叉树</a>】那道题的思路几乎一致。都是对比对应位置的结点的值是否相等，只不过一个是在树的左右两侧寻找，一个是在两棵树之间寻找。<br>code的基本写法也是很相似的。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSameTree</span>(<span class="params">self, p: <span class="type">Optional</span>[TreeNode], q: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;注意：传入的两个结点，是对两个树对应位置的两个结点&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 如果两个结点都是空结点，满足相等</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">        <span class="comment"># 如果一个为空一个不为空，显然不相等</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> p <span class="keyword">and</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        <span class="comment"># 如果一个为空一个不为空，显然不相等</span></span><br><span class="line">        <span class="keyword">elif</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果两个结点都不为空，对比值的大小</span></span><br><span class="line">            <span class="keyword">if</span> p.val != q.val:</span><br><span class="line">                <span class="comment"># 值不想等，显然不符合</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 值相等的话，再看其左右子树是否满足</span></span><br><span class="line">                <span class="comment"># 传入的两个结点，是对两个树对应位置的两个结点</span></span><br><span class="line">                <span class="keyword">return</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br></pre></td></tr></table></figure>
<p><span id="7.2.2"></span></p>
<h2 id="7-2-2-二叉树反序列化（还原）"><a href="#7-2-2-二叉树反序列化（还原）" class="headerlink" title="7.2.2 二叉树反序列化（还原）"></a>7.2.2 二叉树反序列化（还原）</h2><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>题目</th>
<th>题解</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LeetCode 105.从前序与中序遍历序列构造二叉树</a></td>
<td><a href="#7.2.2.1">题解7.2.2.1</a></td>
</tr>
<tr>
<td>②</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">LeetCode 106.从中序与后序遍历序列构造二叉树</a></td>
<td><a href="#7.2.2.2">题解7.2.2.2</a></td>
</tr>
<tr>
<td>③</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">LeetCode 889.根据前序和后序遍历构造二叉树</a></td>
<td><a href="#7.2.2.3">题解7.2.2.3</a></td>
</tr>
</tbody>
</table>
</div>
<p><span id="7.2.2.1"></span>  </p>
<h3 id="7-2-2-1-从前序与中序遍历序列构造二叉树"><a href="#7-2-2-1-从前序与中序遍历序列构造二叉树" class="headerlink" title="7.2.2.1 从前序与中序遍历序列构造二叉树"></a>7.2.2.1 从前序与中序遍历序列构造二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LeetCode 105.从前序与中序遍历序列构造二叉树</a> | | <a href="#7.2.2">返回目录7.2.2</a></p>
<p>思路：核心在于，对于每一棵子树范围的结点，它的先序遍历的第一个元素，一定是该子树的根结点，即[ 根结点-[左子树结点]-[右子树结点] ]。而对于中序遍历,根结点能够将左右子树的结点分开，即[ [左子树结点]-根结点-[右子树结点] ] 。<br>而且该题强调了无重复元素，所以能够根据这两个遍历方式还原出原始二叉树。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:       </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getNode</span>(<span class="params">preorder_start, preorder_end, inorder_start, inorder_end</span>):</span><br><span class="line">            <span class="comment"># 如果传入的先序序列的开始索引已经大于了结束索引，就可以停止了</span></span><br><span class="line">            <span class="keyword">if</span> preorder_start &gt; preorder_end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当前考察的先序序列的第一个元素一定是根结点</span></span><br><span class="line">            root_val = preorder[preorder_start]</span><br><span class="line">            root_node = TreeNode(root_val)</span><br><span class="line">            <span class="comment"># 求出该元素在中序序列中的索引（题目中已经说了没有重复元素，所以可以直接在哈希表中找）</span></span><br><span class="line">            root_inorder_idx = inorder_index[root_val]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 根据中序遍历根结点的位置，我们可以将【中序】遍历分成左右两半，分别代表左右两个子树的【中序】序列</span></span><br><span class="line">            <span class="comment"># 注意，这里只是写了两个区域的端点索引</span></span><br><span class="line">            left_tree_inorder = [inorder_start, root_inorder_idx-<span class="number">1</span>]</span><br><span class="line">            right_tree_inorder = [root_inorder_idx+<span class="number">1</span>, inorder_end]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 还可以得到左子树的结点个数：</span></span><br><span class="line">            left_tree_node_cnts = root_inorder_idx - inorder_start</span><br><span class="line">            <span class="comment"># 根据这个数目，来求左右子树的【先序】序列的端点索引</span></span><br><span class="line">            left_tree_preorder = [preorder_start+<span class="number">1</span>, preorder_start + left_tree_node_cnts]</span><br><span class="line">            right_tree_preorder = [preorder_start + left_tree_node_cnts + <span class="number">1</span>, preorder_end]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 已经知道左右两个子树的，先序和中序的端点索引了，可以调用递归了</span></span><br><span class="line">            root_node.left = getNode(left_tree_preorder[<span class="number">0</span>], left_tree_preorder[<span class="number">1</span>], left_tree_inorder[<span class="number">0</span>], left_tree_inorder[<span class="number">1</span>])</span><br><span class="line">            root_node.right = getNode(right_tree_preorder[<span class="number">0</span>], right_tree_preorder[<span class="number">1</span>], right_tree_inorder[<span class="number">0</span>], right_tree_inorder[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root_node</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 用哈希表暂时将中序遍历的索引存储</span></span><br><span class="line">        inorder_index = &#123;val:i <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder)&#125;</span><br><span class="line">        N = <span class="built_in">len</span>(preorder)        </span><br><span class="line">        root = getNode(<span class="number">0</span>,N-<span class="number">1</span>, <span class="number">0</span>, N-<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>简化版代码：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:       </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment"># inorder 元素的序号先存起来</span></span><br><span class="line">        inorder_index = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder):</span><br><span class="line">            inorder_index[num] = i </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">buildNode</span>(<span class="params">L1, R1, L2, R2</span>):</span><br><span class="line">            <span class="comment"># 递归终止条件</span></span><br><span class="line">            <span class="keyword">if</span> L1&gt;R1 <span class="keyword">or</span> L2&gt;R2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line"></span><br><span class="line">            root_val = preorder[L1]</span><br><span class="line">            root = TreeNode(val=root_val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> L1==R1: <span class="comment"># 只够组成一个子结点</span></span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">            <span class="comment"># 划分 inorder 列表</span></span><br><span class="line">            root_index_in = inorder_index[preorder[L1]]</span><br><span class="line">            left_inorder = (L2, root_index_in-<span class="number">1</span>)</span><br><span class="line">            right_inorder = (root_index_in+<span class="number">1</span>,  R2)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 划分 preorder 列表</span></span><br><span class="line">            left_w = left_inorder[<span class="number">1</span>]-left_inorder[<span class="number">0</span>]+<span class="number">1</span></span><br><span class="line">            left_preorder = (L1+<span class="number">1</span>, L1+left_w)</span><br><span class="line">            right_preorder = (L1+left_w+<span class="number">1</span>, R1)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归调用函数构造左子结点 、右子结点</span></span><br><span class="line">            root.left = buildNode(left_preorder[<span class="number">0</span>], left_preorder[<span class="number">1</span>], left_inorder[<span class="number">0</span>], left_inorder[<span class="number">1</span>])</span><br><span class="line">            root.right = buildNode(right_preorder[<span class="number">0</span>], right_preorder[<span class="number">1</span>], right_inorder[<span class="number">0</span>], right_inorder[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buildNode(<span class="number">0</span>, <span class="built_in">len</span>(preorder)-<span class="number">1</span>, <span class="number">0</span>, <span class="built_in">len</span>(inorder)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><span id="7.2.2.2"></span>  </p>
<h3 id="7-2-2-2-从中序与后序遍历序列构造二叉树"><a href="#7-2-2-2-从中序与后序遍历序列构造二叉树" class="headerlink" title="7.2.2.2 从中序与后序遍历序列构造二叉树"></a>7.2.2.2 从中序与后序遍历序列构造二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">LeetCode 106.从中序与后序遍历序列构造二叉树</a>| | <a href="#7.2.2">返回目录7.2.2</a></p>
<p>思路：和上一题的思路是一样的，甚至code都只需要改一点点。改动点是：后序遍历的顺序是根结点在最后一个位置，即[ [左子树结点]-[右子树结点]-根结点 ]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getNode</span>(<span class="params">postorder_start, postorder_end, inorder_start, inorder_end</span>):</span><br><span class="line">            <span class="comment"># 如果传入的后序序列的开始索引已经大于了结束索引，就可以停止了</span></span><br><span class="line">            <span class="keyword">if</span> postorder_start &gt; postorder_end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当前考察的后序序列的【最后一个】元素一定是根结点</span></span><br><span class="line">            root_val = postorder[postorder_end]</span><br><span class="line">            root_node = TreeNode(root_val)</span><br><span class="line">            <span class="comment"># 求出该元素在中序序列中的索引（题目中已经说了没有重复元素，所以可以直接在哈希表中找）</span></span><br><span class="line">            root_inorder_idx = inorder_index[root_val]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 根据中序遍历根结点的位置，我们可以将【中序】遍历分成左右两半，分别代表左右两个子树的【中序】序列</span></span><br><span class="line">            <span class="comment"># 注意，这里只是写了两个区域的端点索引</span></span><br><span class="line">            left_tree_inorder = [inorder_start, root_inorder_idx-<span class="number">1</span>]</span><br><span class="line">            right_tree_inorder = [root_inorder_idx+<span class="number">1</span>, inorder_end]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 还可以得到左子树的结点个数：</span></span><br><span class="line">            left_tree_node_cnts = root_inorder_idx - inorder_start</span><br><span class="line">            <span class="comment"># 根据这个数目，来求左右子树的【后序】序列的端点索引</span></span><br><span class="line">            left_tree_postorder = [postorder_start, postorder_start + left_tree_node_cnts-<span class="number">1</span>]</span><br><span class="line">            right_tree_postorder = [postorder_start + left_tree_node_cnts, postorder_end-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 已经知道左右两个子树的，后序和中序的端点索引了，可以调用递归了</span></span><br><span class="line">            root_node.left = getNode(left_tree_postorder[<span class="number">0</span>], left_tree_postorder[<span class="number">1</span>], left_tree_inorder[<span class="number">0</span>], left_tree_inorder[<span class="number">1</span>])</span><br><span class="line">            root_node.right = getNode(right_tree_postorder[<span class="number">0</span>], right_tree_postorder[<span class="number">1</span>], right_tree_inorder[<span class="number">0</span>], right_tree_inorder[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root_node</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 用哈希表暂时将中序遍历的索引存储</span></span><br><span class="line">        inorder_index = &#123;val:i <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder)&#125;</span><br><span class="line">        N = <span class="built_in">len</span>(postorder)        </span><br><span class="line">        root = getNode(<span class="number">0</span>,N-<span class="number">1</span>, <span class="number">0</span>, N-<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>简化版代码：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(inorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># inorder 元素的序号先存起来</span></span><br><span class="line">        inorder_index = &#123;val:i <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder)&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">buildNode</span>(<span class="params">L1, R1, L2, R2</span>):</span><br><span class="line">            <span class="comment"># 递归终止条件</span></span><br><span class="line">            <span class="keyword">if</span> L1&gt;R1 <span class="keyword">or</span> L2&gt;R2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">            </span><br><span class="line">            root_val = postorder[R2]</span><br><span class="line">            root_node = TreeNode(root_val)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> L1==R1: <span class="comment"># 只够组成一个子结点</span></span><br><span class="line">                <span class="keyword">return</span> root_node</span><br><span class="line"></span><br><span class="line">            <span class="comment"># inorder subset</span></span><br><span class="line">            root_index_in = inorder_index[root_val]</span><br><span class="line">            left_inorder = (L1, root_index_in-<span class="number">1</span>)</span><br><span class="line">            right_inorder = (root_index_in+<span class="number">1</span>, R1)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># postorder subset </span></span><br><span class="line">            left_w = root_index_in - L1</span><br><span class="line">            left_postorder = (L2, L2+left_w-<span class="number">1</span>)</span><br><span class="line">            right_postorder = (L2+left_w, R2-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归调用函数构造左子结点 、右子结点</span></span><br><span class="line">            root_node.left = buildNode(left_inorder[<span class="number">0</span>], left_inorder[<span class="number">1</span>], left_postorder[<span class="number">0</span>], left_postorder[<span class="number">1</span>])</span><br><span class="line">            root_node.right = buildNode(right_inorder[<span class="number">0</span>], right_inorder[<span class="number">1</span>], right_postorder[<span class="number">0</span>], right_postorder[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root_node </span><br><span class="line"></span><br><span class="line">        N = <span class="built_in">len</span>(postorder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buildNode(<span class="number">0</span>, N-<span class="number">1</span>, <span class="number">0</span>,N-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><span id="7.2.2.3"></span>  </p>
<h3 id="7-2-2-3-根据前序和后序遍历构造二叉树"><a href="#7-2-2-3-根据前序和后序遍历构造二叉树" class="headerlink" title="7.2.2.3 根据前序和后序遍历构造二叉树"></a>7.2.2.3 根据前序和后序遍历构造二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">LeetCode 889.根据前序和后序遍历构造二叉树</a> | | <a href="#7.2.2">返回目录7.2.2</a></p>
<p>思路：实际上，只靠先序遍历和后序遍历的结果，并不能唯一确定地还原二叉树的结构。<br>但是由于题目中说如果存在多个答案，可以返回任何一个，这样该题才能做。<br>同样是利用上面二题的思路进行code改写即可。    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">constructFromPrePost</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getNode</span>(<span class="params">preorder_start, preorder_end, postorder_start, postorder_end</span>):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> preorder_start &gt; preorder_end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当前考察的先序序列的第一个元素一定是根结点</span></span><br><span class="line">            root_val = preorder[preorder_start]</span><br><span class="line">            root_node = TreeNode(root_val)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 说明没有子树了，只需要返回一个结点即可</span></span><br><span class="line">            <span class="keyword">if</span> preorder_start == preorder_end:</span><br><span class="line">                <span class="keyword">return</span> root_node</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果该条件成立，说明至少存在一个子树</span></span><br><span class="line">            <span class="keyword">if</span> preorder_start + <span class="number">1</span> &lt;= preorder_end:</span><br><span class="line">                <span class="comment"># 如果先序序列的第二个结点，等于后序遍历的倒数第二个结点，又由于结点的值不存在重复的情况</span></span><br><span class="line">                <span class="comment"># 说明只有一棵子树，题目中说如果有多个答案，可以返回其中任何一个，那么就直接将这种情况当作左子树来处理</span></span><br><span class="line">                <span class="keyword">if</span> preorder[preorder_start + <span class="number">1</span>] == postorder[postorder_end-<span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># 求出前序遍历的 左子树的 区间端点索引</span></span><br><span class="line">                    left_tree_preorder = [preorder_start + <span class="number">1</span>, preorder_end]</span><br><span class="line">                    <span class="comment"># 求出后序遍历的 左子树的 区间端点索引</span></span><br><span class="line">                    left_tree_postorder = [postorder_start, postorder_end-<span class="number">1</span>]</span><br><span class="line">                    <span class="comment"># 将端点值传入递归函数</span></span><br><span class="line">                    root_node.left = getNode(left_tree_preorder[<span class="number">0</span>], left_tree_preorder[<span class="number">1</span>], left_tree_postorder[<span class="number">0</span>], left_tree_postorder[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 上面的if如果不成立，说明一定同时存在左右两棵子树</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 左子树的根结点，就是先序遍历序列的第二个元素</span></span><br><span class="line">                    left_root = preorder[preorder_start + <span class="number">1</span>]</span><br><span class="line">                    <span class="comment"># 右子树的根结点，就是后序遍历序列的倒数第二个元素</span></span><br><span class="line">                    right_root = postorder[postorder_end-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                     <span class="comment"># 求出前序遍历的 左子树和右子树的 区间端点索引</span></span><br><span class="line">                    left_tree_preorder = [preorder_start + <span class="number">1</span>, preorder_index[right_root]-<span class="number">1</span>]</span><br><span class="line">                    right_tree_preorder = [preorder_index[right_root], preorder_end]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 求出后序遍历的 左子树和右子树的 区间端点索引</span></span><br><span class="line">                    left_tree_postorder = [postorder_start, postorder_index[left_root]]</span><br><span class="line">                    right_tree_postorder = [postorder_index[left_root]+<span class="number">1</span>, postorder_end-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 将区间端点索引传入递归函数</span></span><br><span class="line">                    root_node.left = getNode(left_tree_preorder[<span class="number">0</span>], left_tree_preorder[<span class="number">1</span>], left_tree_postorder[<span class="number">0</span>], left_tree_postorder[<span class="number">1</span>])</span><br><span class="line">                    root_node.right = getNode(right_tree_preorder[<span class="number">0</span>], right_tree_preorder[<span class="number">1</span>], right_tree_postorder[<span class="number">0</span>], right_tree_postorder[<span class="number">1</span>])</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> root_node</span><br><span class="line"></span><br><span class="line">        preorder_index = &#123;val:i <span class="keyword">for</span> (i,val) <span class="keyword">in</span> <span class="built_in">enumerate</span>(preorder)&#125;</span><br><span class="line">        postorder_index = &#123;val:i <span class="keyword">for</span> (i,val) <span class="keyword">in</span> <span class="built_in">enumerate</span>(postorder)&#125;</span><br><span class="line">        N = <span class="built_in">len</span>(preorder)</span><br><span class="line">        root = getNode(<span class="number">0</span>,N-<span class="number">1</span>, <span class="number">0</span>, N-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>简化版代码如下：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">constructFromPrePost</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 需要将两个数组的值和索引都存入哈希表</span></span><br><span class="line">        preorder_index = &#123;val:i <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">enumerate</span>(preorder)&#125;</span><br><span class="line">        postorder_index = &#123;val:i <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">enumerate</span>(postorder)&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">buildNode</span>(<span class="params">L1, R1, L2, R2</span>):</span><br><span class="line">            <span class="keyword">if</span> L1&gt;R1 <span class="keyword">or</span> L2&gt;R2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 以先序列表的最前的数作为根结点</span></span><br><span class="line">            root_val = preorder[L1]</span><br><span class="line">            root_node = TreeNode(val=root_val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> L1==R1: <span class="comment"># 只够组成一个结点</span></span><br><span class="line">                <span class="keyword">return</span> root_node</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 说明至少有一颗子树</span></span><br><span class="line">                <span class="keyword">if</span> preorder[L1+<span class="number">1</span>] == postorder[R2-<span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># 理论上左子树的根结点==理论上右子树的根结点，说明只有一棵树，就把它当做左子树即可</span></span><br><span class="line">                    left_preorder = (L1+<span class="number">1</span>, R1)</span><br><span class="line">                    left_postorder = (L2, R2-<span class="number">1</span>)</span><br><span class="line">                    root_node.left = buildNode(left_preorder[<span class="number">0</span>], left_preorder[<span class="number">1</span>], left_postorder[<span class="number">0</span>], left_postorder[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 不满足以上的条件说明有两棵树</span></span><br><span class="line"></span><br><span class="line">                    left_root_val = preorder[L1+<span class="number">1</span>]   <span class="comment"># 左子树根结点用先序部分剩下的最左侧点</span></span><br><span class="line">                    right_root_val = postorder[R2-<span class="number">1</span>] <span class="comment"># 右子树的根结点用后续部分倒数第二个</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 划分 preorder 列表</span></span><br><span class="line">                    <span class="comment"># 这里就会需要用到右子树根结点在 先序中的位置, 才能将先序的左右区分开</span></span><br><span class="line">                    left_preorder = (L1+<span class="number">1</span>, preorder_index[right_root_val]-<span class="number">1</span>)</span><br><span class="line">                    right_preorder = (preorder_index[right_root_val], R1)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 划分 postorder 列表</span></span><br><span class="line">                    <span class="comment"># 这里就会需要用到左子树的根结点 在后续中的部分, 才能将后序的左右区分开</span></span><br><span class="line">                    left_postorder = (L2, postorder_index[left_root_val])</span><br><span class="line">                    right_postorder = (postorder_index[left_root_val]+<span class="number">1</span>, R2-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 递归调用函数</span></span><br><span class="line">                    root_node.left = buildNode(left_preorder[<span class="number">0</span>], left_preorder[<span class="number">1</span>], left_postorder[<span class="number">0</span>], left_postorder[<span class="number">1</span>])</span><br><span class="line">                    root_node.right = buildNode(right_preorder[<span class="number">0</span>], right_preorder[<span class="number">1</span>], right_postorder[<span class="number">0</span>], right_postorder[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> root_node </span><br><span class="line">            </span><br><span class="line">        N = <span class="built_in">len</span>(preorder)</span><br><span class="line">        root = buildNode(<span class="number">0</span>,N-<span class="number">1</span>, <span class="number">0</span>, N-<span class="number">1</span>)  </span><br><span class="line">        <span class="keyword">return</span> root   </span><br></pre></td></tr></table></figure>
<p><span id="7.2.3"> </span></p>
<h2 id="7-2-3-路径问题"><a href="#7-2-3-路径问题" class="headerlink" title="7.2.3 路径问题"></a>7.2.3 路径问题</h2><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>题目</th>
<th>题解</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">LeetCode 112.路径总和</a></td>
<td><a href="#7.2.3.1">题解7.2.3.1</a></td>
</tr>
<tr>
<td>①</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">LeetCode 113.路径总和 II</a></td>
<td><a href="#7.2.3.2">题解7.2.3.2</a></td>
</tr>
<tr>
<td>③</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">LeetCode 124.二叉树中的最大路径和</a></td>
<td><a href="#7.2.3.3">题解7.2.3.3</a></td>
</tr>
<tr>
<td>④</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">LeetCode 236.二叉树的最近公共祖先</a></td>
<td><a href="#7.2.3.4">题解7.2.3.4</a></td>
</tr>
<tr>
<td>⑤</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">LeetCode 257.二叉树的所有路径</a></td>
<td><a href="#7.2.3.5">题解7.2.3.5</a></td>
</tr>
<tr>
<td>⑥</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-in-zigzag-labelled-binary-tree/">LeetCode 1104.二叉树寻路</a></td>
<td><a href="#7.2.3.6">题解7.2.3.6</a></td>
</tr>
</tbody>
</table>
</div>
<p><span id="7.2.3.1"></span>  </p>
<h3 id="7-2-3-1-路径总和"><a href="#7-2-3-1-路径总和" class="headerlink" title="7.2.3.1 路径总和"></a>7.2.3.1 路径总和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">LeetCode 112.路径总和</a> | | <a href="#7.2.3">返回目录7.2.3</a></p>
<p>思路 1：广度优先遍历。每一层的每个结点都计算其累积的路径和，直到计算完最后一层的结点的路径和。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.广度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#每一个元素是由 (结点, 之前路径上的路径和)</span></span><br><span class="line">        q = [(root, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                node, pathSum = q.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果当前结点已经是叶子结点了，就需要判断一下刚刚它计算得到的路径和</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> pathSum + node.val == targetSum:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果不是叶子结点，就继续添加下一层</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    q.append((node.left, pathSum + node.val))</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    q.append((node.right, pathSum + node.val))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>思路 2：深度优先遍历。每深入一个结点，就减去上面已经遍历过的路径上的结点值的和，相当于值看剩下的结点能否满足剩下的和。     </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;2.深度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node, restSum</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果本身就是叶子结点,就看剩下的 restSum 是不是等于结点值</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">        <span class="keyword">return</span> restSum == node.val</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果本身不是叶子结点，就继续向下深入</span></span><br><span class="line">    <span class="comment"># 只要左右子结点中有一条路能满足即可</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> DFS(node.left, restSum - node.val) <span class="keyword">or</span> DFS(node.right, restSum - node.val) </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> DFS(root, targetSum)</span><br></pre></td></tr></table></figure>
<p><span id="7.2.3.2"></span>  </p>
<h3 id="7-2-3-2-路径总和II"><a href="#7-2-3-2-路径总和II" class="headerlink" title="7.2.3.2 路径总和II"></a>7.2.3.2 路径总和II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">LeetCode 113.路径总和 II</a> | | <a href="#7.2.3">返回目录7.2.3</a></p>
<p>思路 1：和上一题很类似，只不过上一题只是判断是否存在这样的路径，而该题还要确定出这样的路径，难度稍微提升了一点。<br>如果我们仍使用广度优先搜索，该如何才能在确定这样的路径存在时，知道前面路径上的所有结点是什么呢？<br>可以考虑用一个哈希表来记住所有结点的父结点。这样的话就能沿着路径反方向遍历完整条路径。<br>仅需在上一题的code的基础上做一些修改即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.广度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用一个哈希表来存储各个结点的父结点</span></span><br><span class="line">        hash_father = &#123;root:<span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getPath</span>(<span class="params">node</span>):</span><br><span class="line">            path = []</span><br><span class="line">            <span class="comment"># 按照哈希表记录的父结点，一直往上找，并将值添加到path中</span></span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                path.append(node.val)</span><br><span class="line">                node = hash_father[node]</span><br><span class="line">            <span class="comment"># 记得要反转一下path才是从上到下的顺序</span></span><br><span class="line">            path.reverse()</span><br><span class="line">            <span class="keyword">return</span> path</span><br><span class="line"></span><br><span class="line">        <span class="comment">#每一个元素是 (结点, 之前路径上的路径和)</span></span><br><span class="line">        q = [(root, <span class="number">0</span>)]</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            layer = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                node, pathSum = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 如果当前结点已经是叶子结点了，就需要判断一下刚刚它计算得到的路径和</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> pathSum + node.val == targetSum:</span><br><span class="line">                    <span class="comment">#return True</span></span><br><span class="line">                    <span class="comment"># 调用getPath向上寻找路径，并添加到结果res中</span></span><br><span class="line">                    res.append(getPath(node))</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果不是叶子结点，就继续添加下一层</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    q.append((node.left, pathSum + node.val))</span><br><span class="line">                    <span class="comment"># 记得更新左子结点的父结点关系</span></span><br><span class="line">                    hash_father[node.left] = node</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    q.append((node.right, pathSum + node.val))</span><br><span class="line">                    <span class="comment"># 记得更新右子结点的父结点关系</span></span><br><span class="line">                    hash_father[node.right] = node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>思路 2：也可以使用深度优先遍历，在深度优先遍历的过程中，用一个临时数组记住每个结点之前的路径，然后看加上当前结点后是否满足条件。   </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.深度优先遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        res, path = [], []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node, resSum</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="comment"># 当前结点不为空，就先将该结点值放入path中</span></span><br><span class="line">            path.append(node.val)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 然后判断当前结点是否是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="comment"># 如果是叶子结点，且当前结点的值刚好等于剩余的sum值，说明该路径满足条件</span></span><br><span class="line">                <span class="keyword">if</span> node.val == resSum:</span><br><span class="line">                    <span class="comment"># 满足条件的路径, 就往 res 中添加一次</span></span><br><span class="line">                    res.append(path[:]) <span class="comment"># 这里注意要用 path[:]来进行赋值操作，不然的话会进行浅拷贝</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果当前结点不是叶子结点，就继续向它的子结点进行延伸</span></span><br><span class="line">                DFS(node.left, resSum-node.val)</span><br><span class="line">                DFS(node.right,  resSum-node.val)</span><br><span class="line">            <span class="comment"># 当前结点处理完之后，要记得将当前结点从 path中移除，因为已经要跳出处理该结点的范围了</span></span><br><span class="line">            path.pop()</span><br><span class="line">                 </span><br><span class="line">        DFS(root, targetSum)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><span id="7.2.3.3"></span>  </p>
<h3 id="7-2-3-3-二叉树中的最大路径和"><a href="#7-2-3-3-二叉树中的最大路径和" class="headerlink" title="7.2.3.3 二叉树中的最大路径和"></a>7.2.3.3 二叉树中的最大路径和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">LeetCode 124.二叉树中的最大路径和</a>| | <a href="#7.2.3">返回目录7.2.3</a></p>
<p>思路：这里的路径并不一定是指的从根结点出发到叶子结点的路径，而是从一个结点到另一个结点的任意路径。<br>考察二叉树最小的结构，即1个父结点连着两个子结点的情况：<br>&ensp;father<br>&ensp;/ &emsp;&emsp;\<br>left &emsp;right<br>如果我们的路径要经过father结点，那么路径一共就只有以下几种情况：<br>1.这一部分作为更大路径的子路径：<br>a. father;  b. father-left;  c. father-right<br>2.自己这一部分构成一个路径：<br>left-father-right  </p>
<p>而至于我们要不要经过 father 结点，那就是看上面这4种情况，能否产生更大的路径和，即：经过father点是否对更大的路径的总和有正向增益？  </p>
<p>将这个最小结构放入树当中，这里的左右子结点，可以视为左右子树的总贡献；而father结点的贡献，就视为father结点作为某个子结点时的贡献。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">maxGain</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 递归计算左右子节点的最大贡献值</span></span><br><span class="line">            <span class="comment"># 只有在最大贡献值大于 0 时，才会选取对应子节点</span></span><br><span class="line">            leftGain = <span class="built_in">max</span>(maxGain(node.left), <span class="number">0</span>)</span><br><span class="line">            rightGain = <span class="built_in">max</span>(maxGain(node.right), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 因为结点只能在路径序列中至多出现一次</span></span><br><span class="line">            <span class="comment"># 所以对于任一父结点与其左右子结点能够组成的一个子路径分别为：</span></span><br><span class="line">            <span class="comment"># 1.只取父结点入路径; 2.父结点-左子结点; 3.父结点-右子结点</span></span><br><span class="line">            local_path_gain = <span class="built_in">max</span>(node.val, node.val+leftGain, node.val+rightGain)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 另有一种情况就是 父结点和两个子结点自己组成大路径，不再作为其它大路径的子部分</span></span><br><span class="line">            global_path_gain = node.val + leftGain + rightGain</span><br><span class="line">            <span class="comment"># 如果是这种情况，我们直接将该路径和与总的结果比较，取较大者</span></span><br><span class="line">            res[<span class="number">0</span>] = <span class="built_in">max</span>(res[<span class="number">0</span>], global_path_gain)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果希望将父结点和任一子结点作为一个子路径参与大更大的路径中</span></span><br><span class="line">            <span class="comment"># 我们就把这个子路径的最大路径和返回出去即可</span></span><br><span class="line">            <span class="keyword">return</span> local_path_gain</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 题目中给的条件是 -1000 &lt;= Node.val &lt;= 1000</span></span><br><span class="line">        <span class="comment"># 借用列表来作为全局变量</span></span><br><span class="line">        res =[-<span class="number">1001</span>]</span><br><span class="line">        maxGain(root)</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p><span id="7.2.3.4"></span>  </p>
<h3 id="7-2-3-4-二叉树的最近公共祖先"><a href="#7-2-3-4-二叉树的最近公共祖先" class="headerlink" title="7.2.3.4 二叉树的最近公共祖先"></a>7.2.3.4 二叉树的最近公共祖先</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">LeetCode 236.二叉树的最近公共祖先</a> | | <a href="#7.2.3">返回目录7.2.3</a></p>
<p>思路1： 既然是找公共祖先，比较容易想到的是，上面的题目中 <a href="#7.2.3.2">题解7.2.3.2</a> 为了获取路径，将父结点都存入哈希表中的方法。这里确实可以用。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q: </span><br><span class="line">            <span class="keyword">return</span> root </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置一个哈希表来存储结点的父结点</span></span><br><span class="line">        hash_father = &#123;root:<span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 利用DFS先将各个结点和其父结点都存入hash_father</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node :</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                hash_father[node.left] = node </span><br><span class="line">                DFS(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                hash_father[node.right] = node </span><br><span class="line">                DFS(node.right)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        DFS(root)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这样对于 p, q 两个node，都能够一直往上追溯回树的根结点root</span></span><br><span class="line">        <span class="comment"># 这个问题就可以看成两个无环链表的相交问题了</span></span><br><span class="line">        <span class="comment"># 为了code简便起见，这里又用哈希表方法来解决相交问题</span></span><br><span class="line">        hash_p = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            hash_p[p] = <span class="number">1</span></span><br><span class="line">            p = hash_father[p]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="keyword">if</span> q <span class="keyword">in</span> hash_p:</span><br><span class="line">                <span class="keyword">return</span> q</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q = hash_father[q]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span> </span><br></pre></td></tr></table></figure>
<p>思路2：也可以用深度优先遍历，递归的方法找。<br>注意到题目中提示了，p和q互不相等，且一定位于树中，说明一定有公共祖先！<br>如果最近祖先是根结点，那么说明p和q一个位于左子树，一个位于右子树；<br>如果最近公共祖先不是根结点，那么要么位于左子树（说明p和q都位于左子树），要么位于右子树（说明p和q都位于右子树）。<br>这个概念可以递归推导于任一一个范围的子树。   </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="comment"># 这个条件很关键, 意思是顺着根结点往下的路径探索, 如果这条路径上 出现p or q, 那么就会返回p or q</span></span><br><span class="line">        <span class="comment"># 如果该条路径上不存在p或者q, 则会返回 None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q: </span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># left的返回值，要么是None（即p和q都不在左子树中），要么是 p 或者q 或其最近公共祖先</span></span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="comment"># right的返回值，要么是None（即p和q都不在右子树中），要么是 p 或者q 或其最近公共祖先</span></span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left: </span><br><span class="line">            <span class="comment"># 如果left是None，则p和q都不在左子树中，则p和q都在右子树中，答案就是right返回值</span></span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right: </span><br><span class="line">            <span class="comment"># 如果right是None，则p和q都不在右子树中，则p和q都在左子树中，答案就是left 返回值</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 如果上面两个return都没有返回，说明left和right都不为空</span></span><br><span class="line">        <span class="comment"># 那么p和q分别位于 左、右子树中，最近公共祖先就应该是root</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p><span id="7.2.3.5"></span>  </p>
<h3 id="7-2-3-5-二叉树的所有路径"><a href="#7-2-3-5-二叉树的所有路径" class="headerlink" title="7.2.3.5 二叉树的所有路径"></a>7.2.3.5 二叉树的所有路径</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">LeetCode 257.二叉树的所有路径</a> | | <a href="#7.2.3">返回目录7.2.3</a></p>
<p>思路：采用深度优先遍历，这里的code的写法，也应用到上面的【<a href="#7.2.3.2">7.2.3.2 路径总和II</a>】同理，该题也可以用上面的那种拿哈希表存储父结点的思路。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node, path</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="comment"># 进入到该结点的处理环节，就先将该结点放入path中</span></span><br><span class="line">            path.append(<span class="built_in">str</span>(node.val))</span><br><span class="line">            <span class="comment"># 是叶子结点,说明已经找到一条路径</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="comment"># 往结果中形成一条路径</span></span><br><span class="line">                res.append(<span class="string">&#x27;-&gt;&#x27;</span>.join(path))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                DFS(node.left, path)</span><br><span class="line">                DFS(node.right, path)</span><br><span class="line">            <span class="comment"># 这一层处理完之后，需要将该结点弹出，不然会继续停留在path中</span></span><br><span class="line">            path.pop()</span><br><span class="line">        </span><br><span class="line">        res, path = [], []</span><br><span class="line">        DFS(root, path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><span id="7.2.3.6"></span>  </p>
<h3 id="7-2-3-6-二叉树寻路"><a href="#7-2-3-6-二叉树寻路" class="headerlink" title="7.2.3.6 二叉树寻路"></a>7.2.3.6 二叉树寻路</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-in-zigzag-labelled-binary-tree/">LeetCode 1104.二叉树寻路</a>| | <a href="#7.2.3">返回目录7.2.3</a></p>
<p>思路：只有偶数层的顺序逆序了，所以对于路径中位于偶数层的数字, 它的位置其实并不是对应原始完全二叉树的位置, 对其进行处理即可。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathInZigZagTree</span>(<span class="params">self, label: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_reverse_location</span>(<span class="params">label, H</span>):</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;该函数就是对于偶数层的label, 计算其位置对应原始满二叉树的位置的label&#x27;&#x27;&#x27;</span></span><br><span class="line">            start = <span class="number">2</span>**(H-<span class="number">1</span>) <span class="comment"># 第H层的起始结点</span></span><br><span class="line">            end = <span class="number">2</span>**H -<span class="number">1</span>  <span class="comment"># 第H层的结束结点:</span></span><br><span class="line">            new_label = end - label + start </span><br><span class="line">            <span class="keyword">return</span> new_label</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为后面会使用到label, 所以label的值可能发生变化, 这里先将其原始值保存</span></span><br><span class="line">        origin_label = label</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;因为如果当前label是偶数层, 则需要对其进行处理, 处理之后才能得到原始完全二叉树的位置的label&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 计算当前的label是第几层</span></span><br><span class="line">        H = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> label &gt; <span class="number">1</span>:</span><br><span class="line">            label = label // <span class="number">2</span></span><br><span class="line">            H += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> H % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            label = get_reverse_location(origin_label, H)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            label = origin_label</span><br><span class="line">        <span class="comment"># 此时label已经得到校正, 是对应的完全二叉树位置的label</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># label修正之后, 我们就先假设在原始完全二叉树中, 去回溯路径。</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 这个循环是从label开始, 依次向上回溯, 直到根结点1</span></span><br><span class="line">        <span class="keyword">while</span> label &gt;= <span class="number">1</span>:</span><br><span class="line">            res.append(label)</span><br><span class="line">            label = label // <span class="number">2</span></span><br><span class="line">        res.reverse() <span class="comment"># 逆序之后得到从1到label的路径</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="comment"># 此时的res路径是假设按照原始满二叉树来向下寻得的路径</span></span><br><span class="line">        <span class="comment"># 再对其中偶数层的数字进行转换即可</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res)):</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 偶数层</span></span><br><span class="line">                res[i] = get_reverse_location(res[i], i+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res       </span><br></pre></td></tr></table></figure>
<p><span id="7.2.4"></span>  </p>
<h2 id="7-2-4-验证各种树"><a href="#7-2-4-验证各种树" class="headerlink" title="7.2.4 验证各种树"></a>7.2.4 验证各种树</h2><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>题目</th>
<th>题解</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-tree-nodes/">LeetCode 1361.验证二叉树</a></td>
<td><a href="#7.2.4.1">题解7.2.4.1</a></td>
</tr>
<tr>
<td>①</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">LeetCode 98.验证二叉搜索树</a></td>
<td><a href="#7.2.4.2">题解7.2.4.2</a></td>
</tr>
<tr>
<td>③</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">LeetCode 958.二叉树的完全性检验</a></td>
<td><a href="#7.2.4.3">题解7.2.4.3</a></td>
</tr>
<tr>
<td>④</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">LeetCode 110.平衡二叉树</a></td>
<td><a href="#7.2.4.4">题解7.2.4.4</a></td>
</tr>
</tbody>
</table>
</div>
<p><span id="7.2.4.1"></span>  </p>
<h3 id="7-2-4-1-验证二叉树"><a href="#7-2-4-1-验证二叉树" class="headerlink" title="7.2.4.1 验证二叉树"></a>7.2.4.1 验证二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-tree-nodes/">LeetCode 1361.验证二叉树</a> | | <a href="#7.2.4">返回目录7.2.4</a></p>
<p>思路：这个题乍一看可能不知道在说什么，其实给出的两个列表 leftChild 和 rightChild 的元素指的就是 第 i 个结点的左右指向。<br>示例1中，i=0的结点，左子结点是leftChild[0]-&gt;1，右子结点是rightChild[0]-&gt;2;<br>i=1的结点，左子结点是leftChild[1]-&gt;-1,表示没有，右子结点是rightChild[1]-&gt;-1,表示没有;<br>i=2的结点，左子结点是leftChild[2]-&gt;3，右子结点是rightChild[2]-&gt;-1,表示没有;<br>i=3的结点，左子结点是leftChild[3]-&gt;-1,表示没有，右子结点是rightChild[3]-&gt;-1,表示没有;<br><b>说白了，就是看每个结点的入度（指入的箭头）是否不超过1，且有且只有1个结点入度为0（即根结点），<br>以及出度（指出的箭头）是否不超过2，（但是此题每个点只会有left和right两个指向，所以这个条件是自然满足的，可以不用考虑）<br>以及箭头是否为单向的，比如如果 0指向1，但是1也指向0，那明显是不符合的。</b><br>比如示例2中，1和2都指向3，导致3的入度为2，就不符合条件了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validateBinaryTreeNodes</span>(<span class="params">self, n: <span class="built_in">int</span>, leftChild: <span class="type">List</span>[<span class="built_in">int</span>], rightChild: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 先建立一个入度的统计列表</span></span><br><span class="line">        indegree = [<span class="number">0</span>]*n</span><br><span class="line">        <span class="comment"># 将每个结点的入度数目进行统计</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> leftChild[i] != -<span class="number">1</span>: indegree[leftChild[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> rightChild[i] != -<span class="number">1</span>: indegree[rightChild[i]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先判断是否有且只有一个根结点</span></span><br><span class="line">        root = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 统计入度为0的结点的数目</span></span><br><span class="line">            <span class="keyword">if</span> indegree[i] == <span class="number">0</span>: </span><br><span class="line">                root.append(i)</span><br><span class="line">            <span class="comment"># 如果有发现入度超过 1 的结点，直接返回False</span></span><br><span class="line">            <span class="keyword">elif</span> indegree[i] &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 要求有且只有一个根结点，否则就不能满足树的条件！</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(root) != <span class="number">1</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确定存在根结点之后，来判断</span></span><br><span class="line">        <span class="comment"># 这里采用层次遍历的方法</span></span><br><span class="line">        res = []</span><br><span class="line">        q = [root[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            layer = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur_idx = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 检查cur_idx是否已经存在了，</span></span><br><span class="line">                <span class="comment"># 即判断这里cur_idx作为上一层的子结点，是否还指向了上面的层</span></span><br><span class="line">                <span class="keyword">if</span> cur_idx <span class="keyword">in</span> res:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    layer.append(cur_idx)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> leftChild[cur_idx] != -<span class="number">1</span>:</span><br><span class="line">                    q.append(leftChild[cur_idx])</span><br><span class="line">                <span class="keyword">if</span> rightChild[cur_idx] != -<span class="number">1</span>:</span><br><span class="line">                    q.append(rightChild[cur_idx])</span><br><span class="line"></span><br><span class="line">            res.extend(layer)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里的判断是检查连通性，即所有结点都被包含在树中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(res) == n</span><br></pre></td></tr></table></figure>
<p><span id="7.2.4.2"></span>  </p>
<h3 id="7-2-4-2-验证二叉搜索树"><a href="#7-2-4-2-验证二叉搜索树" class="headerlink" title="7.2.4.2 验证二叉搜索树"></a>7.2.4.2 验证二叉搜索树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">LeetCode 98.验证二叉搜索树</a> | | <a href="#7.2.4">返回目录7.2.4</a></p>
<p>思路1 ：二叉搜索树的重要特性，就是如果按中序遍历的话，其结果是一个递增数组！<br>利用这一点，稍微改动中序遍历的code，就能够实现二叉搜索树的判定  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        cur = root</span><br><span class="line">        res, s = [], []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> <span class="built_in">len</span>(s)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                s.append(cur) </span><br><span class="line">                cur = cur.left</span><br><span class="line">            cur = s.pop()</span><br><span class="line">            <span class="comment"># 在原始的中序遍历读值之前，先判断当前值，是否比前一个值大</span></span><br><span class="line">            <span class="comment"># 就多了这么个步骤</span></span><br><span class="line">            <span class="keyword">if</span> res:</span><br><span class="line">                <span class="keyword">if</span> cur.val &lt;= res[-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>思路2 ：二叉搜索树当中的每个子树，也都是二叉搜索树。<br>利用这一点，采用深度优先遍历，递归地判定每个子树都满足二叉搜索的条件，<br>并将子树部分的最大、最小值往上级传递，就能够实现二叉搜索树的判定  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node</span>)-&gt; (<span class="built_in">bool</span>, <span class="built_in">int</span>, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="comment"># 如果是空树，直接就满足条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>, <span class="literal">None</span>, <span class="literal">None</span>            </span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                <span class="comment"># 如果左子结点不为空，才往下递归</span></span><br><span class="line">                left_tree, left_min, left_max = DFS(node.left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 否则左子树直接就满足二叉搜索的条件,</span></span><br><span class="line">                <span class="comment"># 手动设置为 left_min = node.val，（这样该结点值能作为左部分的最小值向上传递，）</span></span><br><span class="line">                <span class="comment"># left_max = 无穷小，保证该结点值一定满足二叉搜索条件 </span></span><br><span class="line">                left_tree, left_min, left_max = <span class="literal">True</span>, node.val, -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                <span class="comment"># 如果右子结点不为空，才往下递归</span></span><br><span class="line">                right_tree, right_min, right_max = DFS(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 否则右子树直接就满足二叉搜索的条件,</span></span><br><span class="line">                <span class="comment"># 手动设置为 right_max = node.val（这样该结点值能作为右部分的最大值向上传递，）</span></span><br><span class="line">                <span class="comment"># right_min = 无穷大，保证该结点值一定满足二叉搜索条件 </span></span><br><span class="line">                right_tree, right_min, right_max = <span class="literal">True</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), node.val</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断左右子树是否满足二叉搜索条件，以及当前结点是否满足</span></span><br><span class="line">            <span class="keyword">if</span> left_tree <span class="keyword">and</span> right_tree <span class="keyword">and</span> left_max &lt; node.val  <span class="keyword">and</span> node.val &lt; right_min:</span><br><span class="line">                <span class="comment"># 左侧最小数，作为该部分子树最小数的代表：min = left_min</span></span><br><span class="line">                <span class="comment"># 右侧最大数，作为该部分子树最大数的代表：max = right_max</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>, left_min, right_max</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 当返回False的时候，后面两个min max值已经没有意义了，可以随便写</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span>, <span class="literal">None</span>, <span class="literal">None</span> </span><br><span class="line">        <span class="keyword">return</span> DFS(root)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p><span id="7.2.4.3"></span>  </p>
<h3 id="7-2-4-3-二叉树的完全性检验"><a href="#7-2-4-3-二叉树的完全性检验" class="headerlink" title="7.2.4.3 二叉树的完全性检验"></a>7.2.4.3 二叉树的完全性检验</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">LeetCode 958.二叉树的完全性检验</a> | | <a href="#7.2.4">返回目录7.2.4</a></p>
<p>思路：完全二叉树的一个性质就是，对于每一个结点，其序号应当与对应的满二叉树的结点序号对应一致，毕竟满二叉树就是一颗特殊的完全二叉树。<br>求最大宽度的那个例子里，遍历元素的时候，将其序号取到，而且这个序号，恰巧就是按照满二叉树的排列来取的。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isCompleteTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 将根节点的序号初始化为0</span></span><br><span class="line">        q = [(root,<span class="number">0</span>)]</span><br><span class="line">        i = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            N = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                cur, index = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 每遍历一个结点，就将其数组排列顺序 i 加上1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 比较两个序号是否相等</span></span><br><span class="line">                <span class="keyword">if</span> i != index:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 在队列入队时，同时搭上其在满二叉树中对应位置的序号</span></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append((cur.left, <span class="number">2</span>*index+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append((cur.right, <span class="number">2</span>*index+<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><span id="7.2.4.4"></span>  </p>
<h3 id="7-2-4-4-平衡二叉树"><a href="#7-2-4-4-平衡二叉树" class="headerlink" title="7.2.4.4 平衡二叉树"></a>7.2.4.4 平衡二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">LeetCode 110.平衡二叉树</a> | | <a href="#7.2.4">返回目录7.2.4</a></p>
<p>思路1：对于每个结点，其左右子树的高度差不大于1。<br>所以可以用深度优先遍历，递归的检查每个子树是否平衡。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 第一个递归函数是用来求解结点的height</span></span><br><span class="line">    <span class="comment"># 这其实就是【7.2.1.3 二叉树的最大深度】的递归解法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.height(node.left), self.height(node.right)) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 要判断左右两个子树的高度差是否超过1, 以及左右子树是否都平衡</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(self.height(root.left) - self.height(root.right)) &lt;= <span class="number">1</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br></pre></td></tr></table></figure>
<p>思路2：上面的方案1思路是对的，但是在递归使用 isBalanced 函数的时候，对于每一个结点，都要调用一次 height 来求一次该结点的深度，实际上浪费了很多重复计算。<br>如果在递归的时候，能够不断的把结点的深度往上传递，就不用每次都用height函数去计算了。<br>因为父结点的深度 就是 子结点的最大深度+1    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>, <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 分别获取左右子结点的最大深度 和 回传状态</span></span><br><span class="line">                left, left_status = DFS(node.left)</span><br><span class="line">                right, right_status = DFS(node.right)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 回传当前结点的最大深度 和 当前子树是否平衡的状态</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>, left_status <span class="keyword">and</span> right_status <span class="keyword">and</span> <span class="built_in">abs</span>(left-right) &lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> DFS(root)[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    其实这中code写法，和上一题7.2.4.3的思路2的解法是一致的，</span></span><br><span class="line"><span class="string">    都是在递归的时候，回传一个需要对比的值</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><span id="7.2.5"></span></p>
<h2 id="7-2-5-二叉查找树"><a href="#7-2-5-二叉查找树" class="headerlink" title="7.2.5 二叉查找树"></a>7.2.5 二叉查找树</h2><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>题目</th>
<th>题解</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">LeetCode 700.二叉搜索树中的搜索</a></td>
<td><a href="#7.2.5.1">题解7.2.5.1</a></td>
</tr>
<tr>
<td>①</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">LeetCode 701.二叉搜索树中的插入操作</a></td>
<td><a href="#7.2.5.2">题解7.2.5.2</a></td>
</tr>
<tr>
<td>③</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">LeetCode 450.删除二叉搜索树中的节点</a></td>
<td><a href="#7.2.5.3">题解7.2.5.3</a></td>
</tr>
<tr>
<td>④</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">LeetCode 230.二叉搜索树中第K小的元素</a></td>
<td><a href="#7.2.5.4">题解7.2.5.4</a></td>
</tr>
<tr>
<td>⑤</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指Offer 54.二叉搜索树的第k大节点</a></td>
<td><a href="#7.2.5.5">题解7.2.5.5</a></td>
</tr>
<tr>
<td>⑥</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">LeetCode 235.二叉搜索树的最近公共祖先</a></td>
<td><a href="#7.2.5.6">题解7.2.5.6</a></td>
</tr>
<tr>
<td>⑦</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">LeetCode 108.将有序数组转换为二叉搜索树</a></td>
<td><a href="#7.2.5.7">题解7.2.5.7</a></td>
</tr>
</tbody>
</table>
</div>
<p><span id="7.2.5.1"></span>  </p>
<h3 id="7-2-5-1-二叉搜索树中的搜索"><a href="#7-2-5-1-二叉搜索树中的搜索" class="headerlink" title="7.2.5.1 二叉搜索树中的搜索"></a>7.2.5.1 二叉搜索树中的搜索</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">LeetCode 700.二叉搜索树中的搜索</a> | | <a href="#7.2.5">返回目录7.2.5</a></p>
<p>思路：较为简单，按照二叉树的性质：<br>如果当前结点比val大，就往去左子树找；如果当前结点比val小，就去右子树找。<br>本身就是一种二分查找。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># &#x27;&#x27;&#x27;递归&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># if not root or root.val == val:</span></span><br><span class="line">        <span class="comment">#     return root</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># if val &lt; root.val:</span></span><br><span class="line">        <span class="comment">#     # 在左子树里递归</span></span><br><span class="line">        <span class="comment">#     return self.searchBST(root.left, val)</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     # 在右子树里递归</span></span><br><span class="line">        <span class="comment">#     return self.searchBST(root.right, val) </span></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;迭代&#x27;&#x27;&#x27;</span></span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="keyword">if</span> val == node.val:</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">            <span class="keyword">elif</span>  val &lt; node.val:</span><br><span class="line">                node = node.left </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = node.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p><span id="7.2.5.2"></span>  </p>
<h3 id="7-2-5-2-二叉搜索树中的插入操作"><a href="#7-2-5-2-二叉搜索树中的插入操作" class="headerlink" title="7.2.5.2 二叉搜索树中的插入操作"></a>7.2.5.2 二叉搜索树中的插入操作</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">LeetCode 701.二叉搜索树中的插入操作</a> | | <a href="#7.2.5">返回目录7.2.5</a></p>
<p>思路：示例中给了两个满足条件的解决结果，会发现第二个解决方式，是对原有的树的根结点做了修改，这样操作起来可能会有点复杂；<br><b>其实可以尽量保持原来的树不动</b>，将新结点尽可能地插入到树的最后一层或者倒数第二层去。这样能保证上面的结点的关系是不变的。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertIntoBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 如果是空树，直接添加</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        </span><br><span class="line">        pos = root</span><br><span class="line">        <span class="comment"># 从根结点开始遍历</span></span><br><span class="line">        <span class="keyword">while</span> pos:</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;因为题目保证输入数据一定与原始二叉树中任一结点的值不同</span></span><br><span class="line"><span class="string">            所以只存在 大于 和 小于 两种情况， 不存在 等于 的情况</span></span><br><span class="line"><span class="string">            这里直接考虑新结点安排在某个叶子结点之后&#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> val &lt; pos.val:</span><br><span class="line">            <span class="comment"># 如果待插入的val, 小于当前结点的val, 就应该往左树上安排</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pos.left:</span><br><span class="line">                <span class="comment"># 如果左子结点为空, 刚好就放在左子结点</span></span><br><span class="line">                    pos.left = TreeNode(val)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果当前结点的左子结点不为空, 就继续向下遍历</span></span><br><span class="line">                    pos = pos.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pos.right:</span><br><span class="line">                    pos.right = TreeNode(val)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pos = pos.right</span><br><span class="line">        <span class="comment"># 可以看到code中一定是要找到某个点的 左/ 右子结点为空才插入，</span></span><br><span class="line">        <span class="comment"># 即不改变原来的结点的关系</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p><span id="7.2.5.3"></span>  </p>
<h3 id="7-2-5-3-删除二叉搜索树中的节点"><a href="#7-2-5-3-删除二叉搜索树中的节点" class="headerlink" title="7.2.5.3 删除二叉搜索树中的节点"></a>7.2.5.3 删除二叉搜索树中的节点</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">LeetCode 450.删除二叉搜索树中的节点</a>| | <a href="#7.2.5">返回目录7.2.5</a></p>
<p>思路：该题的每一个输入都会对应好几种不同的合理的输出，这主要取决于如何处理被删除的结点的子树。<br>这里选用一种比较简单的思路，即用右子树代替原来的子树部分，然后将原来的左子树整体搬迁的右子树的下面去；。<br>那么哪个位置合适呢？原来右子树的左下角的那个结点，将原来的左子树作为左下角结点的左子树，一定是合适的；<br>这是由BST 左 &lt; 中 &lt; 右 的性质决定的，可以在草稿上画一画。    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root    </span><br><span class="line">        <span class="comment">######### 先查找值为 key 的结点 ##############        </span></span><br><span class="line">        node, father, tag = root, <span class="literal">None</span>, <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 在遍历的时候, 同时记录node的父结点, 以便等会儿进行新的链接操作, 如同删除链表结点那般</span></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="keyword">if</span> key == node.val:</span><br><span class="line">                <span class="comment"># 找到该结点, 退出循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span>  key &lt; node.val:</span><br><span class="line">                father = node </span><br><span class="line">                tag = <span class="string">&#x27;left&#x27;</span>    <span class="comment"># tag=left表示node是父结点的左子结点</span></span><br><span class="line">                node = node.left </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                father = node </span><br><span class="line">                tag = <span class="string">&#x27;right&#x27;</span>   <span class="comment"># tag=left表示node是父结点的右子结点</span></span><br><span class="line">                node = node.right</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="comment"># 没找到key相同的结点, 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="comment">######### 找到了值为 key 的结点 ##############</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;这里需要注意，若tag=&#x27;&#x27;，说明一上来就找到了该结点，即要删除的是root结点&#x27;&#x27;&#x27;</span>          </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="comment"># 当前结点没有子结点, 直接将该结点置空</span></span><br><span class="line">            <span class="keyword">if</span> tag == <span class="string">&#x27;&#x27;</span>:        root = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">elif</span> tag == <span class="string">&#x27;left&#x27;</span> : father.left = <span class="literal">None</span> </span><br><span class="line">            <span class="keyword">else</span>:                father.right = <span class="literal">None</span> </span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> node.left:</span><br><span class="line">            <span class="comment"># 当前结点无左子结点, 但有右子结点, 用右子结点替代当前结点即可</span></span><br><span class="line">            <span class="keyword">if</span> tag == <span class="string">&#x27;&#x27;</span>:        root = root.right</span><br><span class="line">            <span class="keyword">elif</span> tag == <span class="string">&#x27;left&#x27;</span> : father.left = node.right </span><br><span class="line">            <span class="keyword">else</span>:                father.right = node.right </span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="comment">#  当前结点无右子结点, 但有左子结点, 用左子结点替代当前结点即可</span></span><br><span class="line">            <span class="keyword">if</span> tag == <span class="string">&#x27;&#x27;</span>:        root = root.left</span><br><span class="line">            <span class="keyword">elif</span> tag == <span class="string">&#x27;left&#x27;</span> : father.left = node.left </span><br><span class="line">            <span class="keyword">else</span>:                father.right = node.left </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="comment"># 当前结点左右子结点都不为空, 就要来细节处理一下了</span></span><br><span class="line">            <span class="comment"># 本次code选择将该结点的左子树部分全部移动到右子树最下方</span></span><br><span class="line">            </span><br><span class="line">            left, right = node.left, node.right</span><br><span class="line">            <span class="comment"># 在右子树里进行遍历, 直到找到右子树里最下层的左侧结点</span></span><br><span class="line">            <span class="keyword">while</span> right.left:</span><br><span class="line">                right = right.left </span><br><span class="line">            <span class="comment"># 根据二叉搜索树的性质, 右子树部分的点的值, 一定是大于左子树部分的点的值</span></span><br><span class="line">            <span class="comment"># 所以这里直接将原来左子树, 接在右侧最下层的左边, 是一定能满足二叉搜索树的性质的</span></span><br><span class="line">            right.left = left </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 用右子树部分替代原有结点</span></span><br><span class="line">            <span class="keyword">if</span> tag == <span class="string">&#x27;&#x27;</span>:        root = root.right</span><br><span class="line">            <span class="keyword">elif</span> tag == <span class="string">&#x27;left&#x27;</span> : father.left = node.right </span><br><span class="line">            <span class="keyword">else</span>:                father.right = node.right </span><br><span class="line">        <span class="keyword">return</span> root </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>精简版代码  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root </span><br><span class="line">        </span><br><span class="line">        tag, father, node = <span class="string">&#x27;&#x27;</span>, <span class="literal">None</span>, root</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="keyword">if</span> key == node.val:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> key &lt; node.val:</span><br><span class="line">                father = node </span><br><span class="line">                tag = <span class="string">&#x27;L&#x27;</span></span><br><span class="line">                node = node.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                father = node </span><br><span class="line">                tag = <span class="string">&#x27;R&#x27;</span></span><br><span class="line">                node = node.right </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="comment"># 没有找到key对应的点</span></span><br><span class="line">            <span class="keyword">return</span> root </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">del_node</span>(<span class="params">tag, father, root, new_node</span>):</span><br><span class="line">            <span class="keyword">if</span> tag == <span class="string">&#x27;&#x27;</span>: </span><br><span class="line">                <span class="comment"># 说明是根结点要删除, 直接对根结点, 即node进行修改</span></span><br><span class="line">                root = new_node </span><br><span class="line">            <span class="keyword">elif</span> tag == <span class="string">&#x27;L&#x27;</span>: </span><br><span class="line">                <span class="comment"># node 是其父结点的左子结点</span></span><br><span class="line">                father.left = new_node</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># node 是其父结点的右子结点</span></span><br><span class="line">                father.right = new_node</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            new_node = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> node.right:</span><br><span class="line">            new_node = node.right</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">elif</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            new_node = node.left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left, right = node.left, node.right </span><br><span class="line">            <span class="keyword">while</span> right.left:</span><br><span class="line">                right = right.left  </span><br><span class="line">            right.left = left </span><br><span class="line"></span><br><span class="line">            new_node = node.right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> del_node(tag, father, root,  new_node)  </span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p><span id="7.2.5.4"></span>  </p>
<h3 id="7-2-5-4-二叉搜索树中第K小的元素"><a href="#7-2-5-4-二叉搜索树中第K小的元素" class="headerlink" title="7.2.5.4 二叉搜索树中第K小的元素"></a>7.2.5.4 二叉搜索树中第K小的元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指Offer 54.二叉搜索树的第k大节点</a>| | <a href="#7.2.5">返回目录7.2.5</a><br>思路：核心思想是 BST 的中序遍历是升序数列。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallest</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.最简单的思路：先求中序遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 1.1 递归</span></span><br><span class="line"><span class="string">        def inorder(node):</span></span><br><span class="line"><span class="string">            if not node:</span></span><br><span class="line"><span class="string">                return</span></span><br><span class="line"><span class="string">            inorder(node.left)</span></span><br><span class="line"><span class="string">            res.append(node.val)</span></span><br><span class="line"><span class="string">            inorder(node.right)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        res = []</span></span><br><span class="line"><span class="string">        inorder(root)</span></span><br><span class="line"><span class="string">        return res[k-1]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 1.2 迭代</span></span><br><span class="line"><span class="string">        s, res = [], [] </span></span><br><span class="line"><span class="string">        cur = root</span></span><br><span class="line"><span class="string">        while cur or s:</span></span><br><span class="line"><span class="string">            while cur:</span></span><br><span class="line"><span class="string">                s.append(cur)</span></span><br><span class="line"><span class="string">                cur = cur.left </span></span><br><span class="line"><span class="string">            cur = s.pop()</span></span><br><span class="line"><span class="string">            res.append(cur.val)</span></span><br><span class="line"><span class="string">            cur = cur.right </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return  res[k-1]</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.不用完成全部中序遍历，而在遍历的过程中计数&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 2.1 递归方案</span></span><br><span class="line"><span class="string">        def inorder(node):</span></span><br><span class="line"><span class="string">            if not node:</span></span><br><span class="line"><span class="string">                return </span></span><br><span class="line"><span class="string">            inorder(node.left)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            res[0] +=1</span></span><br><span class="line"><span class="string">            if res[0] == res[1]:</span></span><br><span class="line"><span class="string">                res.append(node.val)</span></span><br><span class="line"><span class="string">                return </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            inorder(node.right) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 用res[0]存放计数器, 用res[1]存放目标值k</span></span><br><span class="line"><span class="string">        res=[0,k]</span></span><br><span class="line"><span class="string">        inorder(root)</span></span><br><span class="line"><span class="string">        return res[-1]</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 2.2 迭代方案</span></span><br><span class="line">        s, i = [],<span class="number">0</span></span><br><span class="line">        cur = root </span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> s:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.left </span><br><span class="line">            cur= s.pop()</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == k:</span><br><span class="line">                <span class="keyword">return</span> cur.val </span><br><span class="line">            cur = cur.right </span><br></pre></td></tr></table></figure>
<p><span id="7.2.5.5"></span>  </p>
<h3 id="7-2-5-5-二叉搜索树的第k大节点"><a href="#7-2-5-5-二叉搜索树的第k大节点" class="headerlink" title="7.2.5.5 二叉搜索树的第k大节点"></a>7.2.5.5 二叉搜索树的第k大节点</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指Offer 54.二叉搜索树的第k大节点</a>| | <a href="#7.2.5">返回目录7.2.5</a></p>
<p>思路：上一题是求第k小，这一题是求第k大，核心原理是一样的：利用BST的中序遍历。<br>只不过这里要求第k大的话，稍微改一下中序遍历的code， 即改成 右-中-左 的形式。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthLargest</span>(<span class="params">self, root: TreeNode, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;1.递归方案&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># def DFS(node):</span></span><br><span class="line">        <span class="comment">#     if not node:</span></span><br><span class="line">        <span class="comment">#         return </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#     DFS(node.right)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#     res[0]+=1</span></span><br><span class="line">        <span class="comment">#     if res[0] == res[1]:</span></span><br><span class="line">        <span class="comment">#         res.append(node.val)</span></span><br><span class="line">        <span class="comment">#         return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#     DFS(node.left)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># res = [0, k]</span></span><br><span class="line">        <span class="comment"># DFS(root)</span></span><br><span class="line">        <span class="comment"># return res[-1]</span></span><br><span class="line">            </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;2.迭代方案&#x27;&#x27;&#x27;</span></span><br><span class="line">        s, i = [], <span class="number">0</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> s:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                s.append(cur)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            cur = s.pop()</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == k:</span><br><span class="line">                <span class="keyword">return</span> cur.val </span><br><span class="line">            cur = cur.left </span><br></pre></td></tr></table></figure>
<p><span id="7.2.5.6"></span>  </p>
<h3 id="7-2-5-6-二叉搜索树的最近公共祖先"><a href="#7-2-5-6-二叉搜索树的最近公共祖先" class="headerlink" title="7.2.5.6  二叉搜索树的最近公共祖先"></a>7.2.5.6  二叉搜索树的最近公共祖先</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">LeetCode 235.二叉搜索树的最近公共祖先</a>| | <a href="#7.2.5">返回目录7.2.5</a></p>
<p>思路：该题和 【<a href="#7.2.3.4">7.2.3.4 二叉树的最近公共祖先</a>】其实一样，所以可以直接用那道题的code；<br>但是一棵树是二叉搜索树BST时，有其特殊性，所以也有更快一点的方案。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        # 1.直接使用普通二叉树 最近公共祖先的code [236题]</span></span><br><span class="line"><span class="string">        if not root or root == p or root == q: </span></span><br><span class="line"><span class="string">            return root</span></span><br><span class="line"><span class="string">        # left的返回值，要么是None（即p和q都不在左子树中），要么是 p 或者q 或其最近公共祖先</span></span><br><span class="line"><span class="string">        left = self.lowestCommonAncestor(root.left, p, q)</span></span><br><span class="line"><span class="string">        # right的返回值，要么是None（即p和q都不在右子树中），要么是 p 或者q 或其最近公共祖先</span></span><br><span class="line"><span class="string">        right = self.lowestCommonAncestor(root.right, p, q)</span></span><br><span class="line"><span class="string">        if not left: </span></span><br><span class="line"><span class="string">            # 如果left是None，则p和q都不在左子树中，则p和q都在右子树中，答案就是right返回值</span></span><br><span class="line"><span class="string">            return right</span></span><br><span class="line"><span class="string">        if not right: </span></span><br><span class="line"><span class="string">            # 如果right是None，则p和q都不在右子树中，则p和q都在左子树中，答案就是left 返回值</span></span><br><span class="line"><span class="string">            return left</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">        # 如果上面两个return都没有返回，说明left和right都不为空</span></span><br><span class="line"><span class="string">        # 那么p和q分别位于 左、右子树中，最近公共祖先就应该是root</span></span><br><span class="line"><span class="string">        return root</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 依据BST自身的特性来做</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q: </span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># 如果两个点的值, 都比当前结点的值小, 那就去当前结点的左子树中寻找</span></span><br><span class="line">        <span class="keyword">if</span> p.val &lt; root.val <span class="keyword">and</span> q.val &lt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="comment"># 如果两个点的值, 都比当前结点的值大, 那就去当前结点的右子树中寻找</span></span><br><span class="line">        <span class="keyword">elif</span> p.val &gt; root.val <span class="keyword">and</span> q.val &gt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="comment"># 如果当前结点的值在p和q的值的中间, 那说明当前结点就是最近公共祖先</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p><span id="7.2.5.7"></span>  </p>
<h3 id="7-2-5-7-将有序数组转换为二叉搜索树"><a href="#7-2-5-7-将有序数组转换为二叉搜索树" class="headerlink" title="7.2.5.7 将有序数组转换为二叉搜索树"></a>7.2.5.7 将有序数组转换为二叉搜索树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">LeetCode 108.将有序数组转换为二叉搜索树</a>| | <a href="#7.2.5">返回目录7.2.5</a></p>
<p>思路：BST本身就是利用二分查找思想来构建的树，所以这里直接用二分法。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;二分法的步骤&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">Bi</span>(<span class="params">L, R</span>):</span><br><span class="line">            <span class="keyword">if</span> L &gt; R:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            M = L + (R-L)//<span class="number">2</span></span><br><span class="line">            <span class="comment"># 每一次将区间 中间的数 作为当前子树的根结点</span></span><br><span class="line">            node = TreeNode(nums[M])</span><br><span class="line">            <span class="comment"># 中点左侧的数放在左子树处理</span></span><br><span class="line">            node.left = Bi(L,M-<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 中点右侧的数放在右子树处理</span></span><br><span class="line">            node.right = Bi(M+<span class="number">1</span>, R)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Bi(<span class="number">0</span>, N-<span class="number">1</span>) </span><br></pre></td></tr></table></figure>
<p><span id="7.2.6"></span></p>
<h2 id="7-2-6-前缀树"><a href="#7-2-6-前缀树" class="headerlink" title="7.2.6 前缀树"></a>7.2.6 前缀树</h2><p>前缀树即<code>Trie</code>树（发音类似 “try”），也被称为字典树，是一种树形结构。广泛应用于统计和排序大量的字符串（但不仅限于字符串）。它是根据树的路径来得到字符串，能节省存储空间，减少字符串比较，尽快地查询到需要的字符串，所以经常被用于文本词频统计。  </p>
<p>距离说明，现有 await, awake, award, awful, awfully 共5个单词（字符串），据此生成的前缀树如下图所示：  </p>
<blockquote>
<p><img src="https://teeyohuang.github.io/pic_bed/Data_Structure/7_2_6.webp" width="50%"> </p>
</blockquote>
<p>可以观察到，对于重叠部分的子串，是可以公用树中的路径的，这样就减少了存储字符串的空间。<br>对于每一个字符串的结尾字母形成的结点，用绿色高亮表示，意味着从根结点出发的这条路径存在一个对应的字符串的，这样也就能提高查询效率。比如最右侧的路径中，第一个L和最后的Y都是高亮表示，说明该条路径存在以第一个L结尾，和Y结尾的单词。  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>题目</th>
<th>题解</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/">LeetCode 208.实现 Trie (前缀树)</a></td>
<td><a href="#7.2.6.1">题解7.2.6.1</a></td>
</tr>
<tr>
<td>①</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-prefix/">LeetCode 14.最长公共前缀</a></td>
<td><a href="#7.2.6.2">题解7.2.6.2</a></td>
</tr>
<tr>
<td>③</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">LeetCode 211.添加与搜索单词 - 数据结构设计</a></td>
<td><a href="#7.2.6.3">题解7.2.6.3</a></td>
</tr>
<tr>
<td>④</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/prefix-and-suffix-search/">LeetCode 745.前缀和后缀搜索</a></td>
<td><a href="#7.2.6.4">题解7.2.6.4</a></td>
</tr>
</tbody>
</table>
</div>
<p><span id="7.2.6.1"></span>  </p>
<h3 id="7-2-6-1-实现-Trie-前缀树"><a href="#7-2-6-1-实现-Trie-前缀树" class="headerlink" title="7.2.6.1 实现 Trie (前缀树)"></a>7.2.6.1 实现 Trie (前缀树)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/">LeetCode 208.实现 Trie (前缀树)</a> | | <a href="#7.2.6">返回目录7.2.6</a>  </p>
<p>思路 1：利用链表结构来实现树，单独设计出存储字符的结点的结构：TrieNode。<br>这个结点包含两个基本属性，一个是它的子结点，另一个是它是否是结尾结点；<br>甚至还可以根据需要，增加结点的属性，比如路径权重，作为结尾的次数等等。<br>所以这个方法，从直观上来说，容易理解和接受。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 对于每个结点，一定要有子结点</span></span><br><span class="line">        <span class="comment"># 而子结点往往不像二叉树那样一般有左右两个，</span></span><br><span class="line">        <span class="comment"># 所以用一个字典来存储所有子结点</span></span><br><span class="line">        self.children = defaultdict(TrieNode)</span><br><span class="line">        <span class="comment"># 标记当且结点是否是某个字符串的结尾</span></span><br><span class="line">        self.word_tail = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 有多少个子串经过当前结点的路径</span></span><br><span class="line">        <span class="comment"># self.weight = 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 从根结点开始遍历</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="comment"># 按照子结点继续向下延伸路径</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="comment"># 因为children是用的 defaultdict 来构造</span></span><br><span class="line">            <span class="comment"># 所以不用判断cur.children中是否已存在c，如果不存在会默认构造一个TrieNode对象；详细可以参考defaultdict的用法</span></span><br><span class="line">            cur = cur.children[c]</span><br><span class="line">        <span class="comment"># 字符串最后的结点，要记得标记一下结尾</span></span><br><span class="line">        cur.is_word = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 从根结点开始遍历</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="comment"># 从子结点中尝试取得当前字符</span></span><br><span class="line">            cur = cur.children.get(c)</span><br><span class="line">            <span class="comment"># 如果子结点中没有该字符，说明不存在这样的字符串</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 如果前面的路径都存在，就要看最后的字符是否是一个结尾字符</span></span><br><span class="line">        <span class="comment"># 因为该函数是查找是否存在某个单词，而非查找前缀</span></span><br><span class="line">        <span class="comment"># 所以直接返回最后结点的“结尾状态”</span></span><br><span class="line">        <span class="keyword">return</span> cur.is_word</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 从根结点开始遍历</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="comment"># 注意这里是查找前缀，而非查找某个单词</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> prefix:</span><br><span class="line">            cur = cur.children.get(c)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 所以最后不用判断是否存在这样的单词，</span></span><br><span class="line">        <span class="comment"># 而是只要有这样的路径（前缀）即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>思路 2：利用哈希表来实现。<br>它是通过字典的嵌套来实现，即一个字符作为字典的key，而字典的value是一个新的子字典，里面包含后续的字符作为key的子字典。就是不断地在字典里面新建更深层的字典。<br>这种方法理解起来没有使用链表那么直观，但是更省内存，速度也更快。   </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 初始化就是建立一个空的哈希表/字典</span></span><br><span class="line">        self.root = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word:<span class="built_in">str</span></span>)-&gt;<span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 依然是从根结点开始</span></span><br><span class="line">        <span class="comment"># 这里可以理解为从最外层往里进行深入</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">        <span class="comment"># 对于每一个来自word的字符，查看它是否已经是当前层的字典的一个key</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">            <span class="comment"># 如果当前层还没有ch这个key，那么就需要先建立一个以ch为key的子字典</span></span><br><span class="line">                cur[ch] = &#123;&#125;</span><br><span class="line">            <span class="comment"># 进入ch为key的子字典那一层</span></span><br><span class="line">            cur = cur[ch]</span><br><span class="line">        <span class="comment"># 对于最后一层字典的 &#x27;nd&#x27; 这个key，设置其value为 1，表示是一个word的结尾。</span></span><br><span class="line">        cur[<span class="string">&#x27;end&#x27;</span>] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word:<span class="built_in">str</span></span>)-&gt;<span class="built_in">bool</span>:</span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            cur = cur[ch]</span><br><span class="line">        <span class="comment"># 因为该函数是查找是否有一个word，所以要判断符合条件的路径的最后一层字典</span></span><br><span class="line">        <span class="comment"># 是否包含 end 这个key</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;end&#x27;</span> <span class="keyword">in</span> cur</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            cur  = cur[ch]</span><br><span class="line">        <span class="comment"># 因为该函数只需要判断是否存在这样的路径（前缀），所以只要中途不跳出，就一定存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><span id="7.2.6.2"></span>  </p>
<h3 id="7-2-6-2-最长公共前缀"><a href="#7-2-6-2-最长公共前缀" class="headerlink" title="7.2.6.2 最长公共前缀"></a>7.2.6.2 最长公共前缀</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-prefix/">LeetCode 14.最长公共前缀</a> | | <a href="#7.2.6">返回目录7.2.6</a><br>思路：找公共前缀，这里比较自然的就想到了前缀树的思路。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;使用前缀树的思路&#x27;&#x27;&#x27;</span></span><br><span class="line">        N = <span class="built_in">len</span>(strs)</span><br><span class="line">        <span class="comment"># 如果只有一个单词，那它本身就是自己的公共前缀</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        Trie = &#123;<span class="string">&quot;root&quot;</span>:&#123;&#125;&#125;</span><br><span class="line">        <span class="comment"># end_flag = &quot;#end&quot; # 该题只是判断前缀，不用查找单词，所以可以不设置结尾标识</span></span><br><span class="line">        </span><br><span class="line">        common_prefix = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> strs:</span><br><span class="line">            cur = Trie[<span class="string">&quot;root&quot;</span>]</span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="comment"># 如果原来没有这样的路径，就需要新建一个</span></span><br><span class="line">                    cur[ch] = &#123;&#125;</span><br><span class="line">                <span class="comment"># 进入ch为key的那一层</span></span><br><span class="line">                cur = cur[ch]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;weight&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="comment"># 如果当前层还没有设置过weight参数，说明是第一次到该层，初始化一下weight参数</span></span><br><span class="line">                    cur[<span class="string">&#x27;weight&#x27;</span>] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果当前层已经设置过weight参数，将ch这一层的路径权重加 1</span></span><br><span class="line">                    cur[<span class="string">&#x27;weight&#x27;</span>] += <span class="number">1</span></span><br><span class="line">                <span class="comment"># print(ch, cur[&#x27;weight&#x27;])</span></span><br><span class="line">                <span class="comment">#然后判断, 路径权重是否等于word的数目，等于的话才一定是所有word的公共路径</span></span><br><span class="line">                <span class="keyword">if</span> cur[<span class="string">&#x27;weight&#x27;</span>] == N:</span><br><span class="line">                    common_prefix += ch</span><br><span class="line">                </span><br><span class="line">            <span class="comment"># cur[end_flag] = True</span></span><br><span class="line">        <span class="keyword">return</span> common_prefix</span><br></pre></td></tr></table></figure>
<p><span id="7.2.6.3"></span>  </p>
<h3 id="7-2-6-1-添加与搜索单词-数据结构设计"><a href="#7-2-6-1-添加与搜索单词-数据结构设计" class="headerlink" title="7.2.6.1 添加与搜索单词 - 数据结构设计"></a>7.2.6.1 添加与搜索单词 - 数据结构设计</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">LeetCode 211.添加与搜索单词 - 数据结构设计</a> | | <a href="#7.2.6">返回目录7.2.6</a></p>
<p>思路：利用前缀树的思路来解决。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = &#123;&#125;</span><br><span class="line">        self.end = <span class="string">&#x27;end&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addWord</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">                cur[ch] = &#123;&#125;</span><br><span class="line">            cur = cur[ch]</span><br><span class="line">        cur[self.end] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="comment"># 因为&#x27;.&#x27;相当于万能符号，所以当&#x27;.&#x27;存在的时候，要对该层的所有key进行向下的查找</span></span><br><span class="line">        <span class="comment"># 所以不是一个单路径的查找过程，故这里写成递归函数的形式，当某一条路径没有找到的时候，还能跳回上级的出发点</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">cur, w, index</span>):</span><br><span class="line">            <span class="comment"># 递归结束的条件</span></span><br><span class="line">            <span class="comment"># 因为索引是从0开始的，即待查找的的字符索引是从 0 ~ N-1,（N表示word长度）</span></span><br><span class="line">            <span class="comment"># index 为 N 的时候表示遍历完了整个待查找的的字符串</span></span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(w):</span><br><span class="line">                <span class="comment"># 如果要求匹配的是前缀, 到这里可以直接返回 True</span></span><br><span class="line">                <span class="comment"># return True</span></span><br><span class="line">                <span class="comment"># 但是由于匹配的是word，即完成的单词，就涉及到要判断当前路径是否是结尾的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> self.end <span class="keyword">not</span> <span class="keyword">in</span> cur <span class="keyword">else</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">            ch = w[index]</span><br><span class="line">            <span class="comment"># 如果不是万能字符，就按照正常处理</span></span><br><span class="line">            <span class="keyword">if</span> ch != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> cur:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">return</span> recursive(cur[ch], w, index+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果当前是万能字符，就需要对该层的每一个key向下进行搜索</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> key <span class="keyword">in</span> cur:</span><br><span class="line">                    <span class="comment"># 这个条件往往容易忽略, 如果 key ==self.end, 说明该条路线上已经没有元素了</span></span><br><span class="line">                    <span class="comment"># 就不用再顺着这条路往里面递归了</span></span><br><span class="line">                    <span class="keyword">if</span> key == self.end:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> recursive(cur[key], w, index+<span class="number">1</span>):</span><br><span class="line">                        <span class="comment"># 如果向下递归的返回值是True, 这里也就返回True</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="comment"># 遍历了当前层的所有key都没有返回True的话，最后就只好返回False了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recursive(cur, word, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><span id="7.2.6.4"></span>  </p>
<h3 id="7-2-6-1-前缀和后缀搜索"><a href="#7-2-6-1-前缀和后缀搜索" class="headerlink" title="7.2.6.1 前缀和后缀搜索"></a>7.2.6.1 前缀和后缀搜索</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/prefix-and-suffix-search/">LeetCode 745.前缀和后缀搜索</a> | | <a href="#7.2.6">返回目录7.2.6</a></p>
<p>思路：前缀搜索可以用前缀树的思路，那么后缀搜索就是逆序的前缀搜索；<br>所以可以考虑使用两个前缀树，一个进行前缀存储，另一个逆序前缀（即后缀）存储、  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordFilter</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>):</span><br><span class="line">        self.trie_prefix = &#123;&#125;</span><br><span class="line">        self.trie_suff = &#123;&#125;</span><br><span class="line">        self.end = <span class="string">&#x27;end&#x27;</span></span><br><span class="line">        <span class="comment"># 调用 insert_list 函数来从words列表构建前缀树和后缀树</span></span><br><span class="line">        self.insert_list(words)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为该题的测试输入时，会出现那种反复查找重复的 前缀 prefix, 后缀 suff 的情况</span></span><br><span class="line">        <span class="comment"># 所以我这里为了提速，将查找过的结果，以 “prefix#suff” 为key, 索引值index为value，存入record字典中，</span></span><br><span class="line">        <span class="comment"># 这样之后出现重复的测试输入，就不用再去计算了</span></span><br><span class="line">        self.record = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_word</span>(<span class="params">self, root, word, index</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;具体的如何插入每个单词&#x27;&#x27;&#x27;</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="comment"># 对于路径上的每一层，要保存其出现在 words列表 中的index</span></span><br><span class="line">                cur[ch] = &#123;<span class="string">&#x27;index&#x27;</span>:[], &#125;</span><br><span class="line">            cur = cur[ch]</span><br><span class="line">            cur[<span class="string">&#x27;index&#x27;</span>].append(index)</span><br><span class="line">        cur[self.end] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_index</span>(<span class="params">self, root, substr</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;查找具有子串：substr 的单词的索引&#x27;&#x27;&#x27;</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> substr:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            cur = cur[ch]</span><br><span class="line">        <span class="keyword">return</span> cur[<span class="string">&#x27;index&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_list</span>(<span class="params">self, words</span>):        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(words)):</span><br><span class="line">            self.insert_word(self.trie_prefix, words[i], i)</span><br><span class="line">            self.insert_word(self.trie_suff, words[i][::-<span class="number">1</span>], i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self, pref: <span class="built_in">str</span>, suff: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果当前的 prefix 和 suff 的组合，在之前没有查询过，就进行以下的查询</span></span><br><span class="line">        <span class="keyword">if</span> pref + <span class="string">&#x27;#&#x27;</span> + suff <span class="keyword">not</span> <span class="keyword">in</span> self.record:</span><br><span class="line">            <span class="comment"># 在前缀树中查找该前缀的index</span></span><br><span class="line">            prefix_index = self.find_index(self.trie_prefix, pref)</span><br><span class="line">            <span class="comment"># 在后缀树中查找该后缀的index</span></span><br><span class="line">            suff_index = self.find_index(self.trie_suff, suff[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果二者其一没有找到，那就说明该样例不存在</span></span><br><span class="line">            <span class="keyword">if</span> prefix_index == -<span class="number">1</span> <span class="keyword">or</span> suff_index== -<span class="number">1</span>:</span><br><span class="line">                self.record[pref + <span class="string">&#x27;#&#x27;</span> + suff] = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果前后缀都找到各自的 index，那就求它们的交集</span></span><br><span class="line">                join_index = <span class="built_in">set</span>(prefix_index) &amp; <span class="built_in">set</span>(suff_index)</span><br><span class="line">                <span class="comment"># 如果交集大于0， 就存下最大的那个 index</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(join_index) &gt; <span class="number">0</span>:</span><br><span class="line">                    self.record[pref + <span class="string">&#x27;#&#x27;</span> + suff] = <span class="built_in">max</span>(join_index)</span><br><span class="line">                <span class="comment"># 如果不存在交集，说明该样例也不存在，存储 -1 </span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.record[pref + <span class="string">&#x27;#&#x27;</span> + suff] = -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.record[pref + <span class="string">&#x27;#&#x27;</span> + suff]</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Teeyohuang.github.io">TeeyoHuang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://teeyohuang.github.io/Data-Structure/DS_72_tree_exercises.html">https://teeyohuang.github.io/Data-Structure/DS_72_tree_exercises.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Teeyohuang.github.io" target="_blank">朝花夕拾</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://teeyohuang.github.io/pic_bed/Data_Structure/7_2_0.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Data-Structure/DS_71_tree.html" title="7-1 树"><img class="cover" src="https://teeyohuang.github.io/pic_bed/Data_Structure/7_1_0.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">7-1 树</div></div></a></div><div class="next-post pull-right"><a href="/Data-Structure/DS_81_graph.html" title="8-1 图"><img class="cover" src="https://teeyohuang.github.io/pic_bed/Data_Structure/8_1_0.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">8-1 图</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/teeyo_comic.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">TeeyoHuang</div><div class="author-info__description">『Stay Hungry. Stay Foolish.』</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/teeyohuang" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/teeyohuang@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog, just for recording and sharing.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#7-2-%E6%A0%91%E7%9B%B8%E5%85%B3%E7%9A%84%E9%A2%98%E7%9B%AE"><span class="toc-text">7-2 树相关的题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-text">目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">7.2.1 二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-DFS"><span class="toc-text">7.2.1.1 深度优先遍历-DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-1-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">7.2.1.1.1 二叉树的前序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-1-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">7.2.1.1.2 二叉树的中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-1-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">7.2.1.1.3 二叉树的后序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-BFS"><span class="toc-text">7.2.1.2 广度优先遍历-BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-2-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">7.2.1.2.1 二叉树的层序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-2-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-II"><span class="toc-text">7.2.1.2.2 二叉树的层序遍历 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-2-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">7.2.1.2.3 二叉树的锯齿形层序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-text">7.2.1.3 二叉树的最大深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-text">7.2.1.4 二叉树的最小深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-5-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6"><span class="toc-text">7.2.1.5 二叉树最大宽度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-6-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-text">7.2.1.6 二叉树的右视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-7-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">7.2.1.7 对称二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-8-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">7.2.1.8 翻转二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-9-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-text">7.2.1.9 填充每个节点的下一个右侧节点指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-10-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II"><span class="toc-text">7.2.1.10 填充每个节点的下一个右侧节点指针II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-11-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="toc-text">7.2.1.11 相同的树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E8%BF%98%E5%8E%9F%EF%BC%89"><span class="toc-text">7.2.2 二叉树反序列化（还原）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-1-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">7.2.2.1 从前序与中序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-2-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">7.2.2.2 从中序与后序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-3-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">7.2.2.3 根据前序和后序遍历构造二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-3-%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-text">7.2.3 路径问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3-1-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-text">7.2.3.1 路径总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3-2-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII"><span class="toc-text">7.2.3.2 路径总和II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-text">7.2.3.3 二叉树中的最大路径和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3-4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">7.2.3.4 二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3-5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-text">7.2.3.5 二叉树的所有路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3-6-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%BB%E8%B7%AF"><span class="toc-text">7.2.3.6 二叉树寻路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-4-%E9%AA%8C%E8%AF%81%E5%90%84%E7%A7%8D%E6%A0%91"><span class="toc-text">7.2.4 验证各种树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-4-1-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">7.2.4.1 验证二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-4-2-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">7.2.4.2 验证二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-4-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%8C%E5%85%A8%E6%80%A7%E6%A3%80%E9%AA%8C"><span class="toc-text">7.2.4.3 二叉树的完全性检验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-4-4-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">7.2.4.4 平衡二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-5-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-text">7.2.5 二叉查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-5-1-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-text">7.2.5.1 二叉搜索树中的搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-5-2-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">7.2.5.2 二叉搜索树中的插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-5-3-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">7.2.5.3 删除二叉搜索树中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-5-4-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">7.2.5.4 二叉搜索树中第K小的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-5-5-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="toc-text">7.2.5.5 二叉搜索树的第k大节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-5-6-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">7.2.5.6  二叉搜索树的最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-5-7-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">7.2.5.7 将有序数组转换为二叉搜索树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-6-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-text">7.2.6 前缀树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-6-1-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-text">7.2.6.1 实现 Trie (前缀树)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-6-2-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="toc-text">7.2.6.2 最长公共前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-6-1-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">7.2.6.1 添加与搜索单词 - 数据结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-6-1-%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E6%90%9C%E7%B4%A2"><span class="toc-text">7.2.6.1 前缀和后缀搜索</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/Pandas-Base/PD_07_Pandas_Senior_Data_Operations.html" title="7-pandas数据分组聚合合并"><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/7_0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="7-pandas数据分组聚合合并"/></a><div class="content"><a class="title" href="/Pandas-Base/PD_07_Pandas_Senior_Data_Operations.html" title="7-pandas数据分组聚合合并">7-pandas数据分组聚合合并</a><time datetime="2023-10-31T16:06:00.000Z" title="发表于 2023-11-01 00:06:00">2023-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Pandas-Base/PD_06_Pandas_Medior_Data_Operations.html" title="6-pandas数据进阶操作"><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/6_0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="6-pandas数据进阶操作"/></a><div class="content"><a class="title" href="/Pandas-Base/PD_06_Pandas_Medior_Data_Operations.html" title="6-pandas数据进阶操作">6-pandas数据进阶操作</a><time datetime="2023-10-31T16:05:00.000Z" title="发表于 2023-11-01 00:05:00">2023-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Pandas-Base/PD_05_Pandas_Junior_Data_Operations.html" title="5-pandas数据基础操作"><img src="https://teeyohuang.github.io/pic_bed/Pandas_Base/5_0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="5-pandas数据基础操作"/></a><div class="content"><a class="title" href="/Pandas-Base/PD_05_Pandas_Junior_Data_Operations.html" title="5-pandas数据基础操作">5-pandas数据基础操作</a><time datetime="2023-10-31T16:04:00.000Z" title="发表于 2023-11-01 00:04:00">2023-11-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By TeeyoHuang</div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'HgAn8i4mE43FcGFWsenlAi1P-gzGzoHsz',
      appKey: 'KUQAsQXyj2wWidCEzHg4ds1i',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://Teeyohuang.github.io/categories/Data-Structure/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 数据结构与算法 (17)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Teeyohuang.github.io/categories/Machine-Learning/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 机器学习 (9)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Teeyohuang.github.io/categories/Deep-Learning/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 深度学习 (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Teeyohuang.github.io/categories/Computer-Vision/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 计算机视觉 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://Teeyohuang.github.io/categories/Pandas-Base/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 Pandas基础入门 (7)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://Teeyohuang.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #cad6d9}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="Machine-Learning/ML_00_Introduction.html" alt=""><img width="48" height="48" src="https://teeyohuang.github.io/pic_bed/Machine_Learning/0_0.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-06-01</span><a class="blog-slider__title" href="Machine-Learning/ML_00_Introduction.html" alt="">机器学习系列</a><div class="blog-slider__text">机器学习系列文章简介</div><a class="blog-slider__button" href="Machine-Learning/ML_00_Introduction.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="Data-Structure/DS_00_introduction.html" alt=""><img width="48" height="48" src="https://teeyohuang.github.io/pic_bed/Data_Structure/Data_Structure_and_Algorithm_webp.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-04-29</span><a class="blog-slider__title" href="Data-Structure/DS_00_introduction.html" alt="">数据结构与算法_Python</a><div class="blog-slider__text">数据结构与算法_Python 系列专栏简要说明</div><a class="blog-slider__button" href="Data-Structure/DS_00_introduction.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="Pandas-Base/PD_01_Introduction.html" alt=""><img width="48" height="48" src="https://teeyohuang.github.io/pic_bed/Pandas_Base/1_0.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-11-01</span><a class="blog-slider__title" href="Pandas-Base/PD_01_Introduction.html" alt="">1-Pandas教程简介</a><div class="blog-slider__text">Pandas基础入门系列文章简介</div><a class="blog-slider__button" href="Pandas-Base/PD_01_Introduction.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="Deep-Learning/DL_00_introduction.html" alt=""><img width="48" height="48" src="https://teeyohuang.github.io/pic_bed/Deep_Learning/DL.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-05-01</span><a class="blog-slider__title" href="Deep-Learning/DL_00_introduction.html" alt="">深度学习导论</a><div class="blog-slider__text">深度学习 系列专栏简要说明</div><a class="blog-slider__button" href="Deep-Learning/DL_00_introduction.html" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('pagination');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>